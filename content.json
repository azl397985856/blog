{"meta":{"title":"lucifer的网络博客","subtitle":"LeetCode 前端","description":"lucifer的个人博客，用来记录LeeCode刷题过程和心得，以及构建大前端知识体系","author":"lucifer","url":"https://lucifer.ren/blog","root":"/blog/"},"pages":[{"title":"404 Not Found","date":"2019-12-11T04:35:19.039Z","updated":"2019-12-11T04:35:19.039Z","comments":true,"path":"404.html","permalink":"https://lucifer.ren/blog/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于我","date":"2020-04-13T06:39:19.119Z","updated":"2020-04-13T06:39:19.119Z","comments":true,"path":"about/index.html","permalink":"https://lucifer.ren/blog/about/index.html","excerpt":"","text":"我是一个对技术充满兴趣的程序员, 擅长前端工程化，前端性能优化，前端标准化等。 做过.net， 搞过 Java，现在是一名前端工程师。 除了我的本职工作外，我会在开源社区进行一些输出和分享，比较受欢迎的有宇宙最强的前端面试指南和我的第一本小书 目前本人正在写一本关于《leetcode 题解》的实体书，因此可能更新会比较慢，如果有人想要做些贡献或者合作的也可以直接用下面的邮箱联系我。 另外如果大家需要内推的可以找我，我这里有包括阿里，腾讯，头条，网易等很多公司的朋友。有需要可以直接群里联系我，或者发送到我的个人邮箱 [azl397985856@gmail.com]。 我重新整理了下自己的公众号，并且我还给它换了一个名字脑洞前端，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。 在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。 之后我的文章会同步到微信公众号 脑洞前端 ，你可以关注获取最新的文章，并和我进行交流。 另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。"},{"title":"所有分类","date":"2019-12-11T04:35:19.047Z","updated":"2019-12-11T04:35:19.047Z","comments":true,"path":"categories/index.html","permalink":"https://lucifer.ren/blog/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-12-11T04:35:19.047Z","updated":"2019-12-11T04:35:19.047Z","comments":true,"path":"mylist/index.html","permalink":"https://lucifer.ren/blog/mylist/index.html","excerpt":"","text":""},{"title":"技术大佬和他们的博客","date":"2020-05-22T05:19:27.197Z","updated":"2020-05-22T05:19:27.197Z","comments":true,"path":"friends/index.html","permalink":"https://lucifer.ren/blog/friends/index.html","excerpt":"","text":"我的友链卡片博客名称：lucifer 的网络博客博客网址：https://lucifer.ren/blog/博客头像：https://tva1.sinaimg.cn/large/006tNbRwly1ga7ognflh9j30b40b4q3w.jpg博客介绍：一个脑洞很大的程序员，Github 30K LeetCode 项目，公众号《脑洞前端》。 加入我如需添加友链，请添加微信（DevelopeEngineer）备注“友链交换”，格式如上。 除了提供上面必须的基本信息之外，你还可以提供： PV 和 UV 数据 feedly 订阅地址 以上数据是为了计算你的排名，为了你的排名更加靠前，鼓励大家提供。"},{"title":"所有标签","date":"2019-12-11T04:35:19.048Z","updated":"2019-12-11T04:35:19.048Z","comments":true,"path":"tags/index.html","permalink":"https://lucifer.ren/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"你不知道的前端异常处理（万字长文，建议收藏）","slug":"error-catch","date":"2020-06-14T07:54:17.496Z","updated":"2020-06-15T15:36:32.817Z","comments":true,"path":"2020/06/14/error-catch/","link":"","permalink":"https://lucifer.ren/blog/2020/06/14/error-catch/","excerpt":"除了调试，处理异常或许是程序员编程时间占比最高的了。我们天天和各种异常打交道，就好像我们天天和 Bug 打交道一样。因此正确认识异常，并作出合适的异常处理就显得很重要了。 我们先尝试抛开前端这个限定条件，来看下更广泛意义上程序的报错以及异常处理。不管是什么语言，都会有异常的发生。而我们程序员要做的就是正确识别程序中的各种异常，并针对其做相应的异常处理。 然而，很多人对异常的处理方式是事后修补，即某个异常发生的时候，增加对应的条件判断，这真的是一种非常低效的开发方式，非常不推荐大家这么做。那么究竟如何正确处理异常呢？由于不同语言有不同的特性，因此异常处理方式也不尽相同。但是异常处理的思维框架一定是一致的。本文就前端异常进行详细阐述，但是读者也可以稍加修改延伸到其他各个领域。 本文讨论的异常指的是软件异常，而非硬件异常。","text":"除了调试，处理异常或许是程序员编程时间占比最高的了。我们天天和各种异常打交道，就好像我们天天和 Bug 打交道一样。因此正确认识异常，并作出合适的异常处理就显得很重要了。 我们先尝试抛开前端这个限定条件，来看下更广泛意义上程序的报错以及异常处理。不管是什么语言，都会有异常的发生。而我们程序员要做的就是正确识别程序中的各种异常，并针对其做相应的异常处理。 然而，很多人对异常的处理方式是事后修补，即某个异常发生的时候，增加对应的条件判断，这真的是一种非常低效的开发方式，非常不推荐大家这么做。那么究竟如何正确处理异常呢？由于不同语言有不同的特性，因此异常处理方式也不尽相同。但是异常处理的思维框架一定是一致的。本文就前端异常进行详细阐述，但是读者也可以稍加修改延伸到其他各个领域。 本文讨论的异常指的是软件异常，而非硬件异常。 什么是异常用直白的话来解释异常的话，就是程序发生了意想不到的情况，这种情况影响到了程序的正确运行。 从根本上来说，异常就是一个数据结构，其保存了异常发生的相关信息，比如错误码，错误信息等。以 JS 中的标准内置对象 Error 为例，其标准属性有 name 和 message。然而不同的浏览器厂商有自己的自定义属性，这些属性并不通用。比如 Mozilla 浏览器就增加了 filename 和 stack 等属性。 值得注意的是错误只有被抛出，才会产生异常，不被抛出的错误不会产生异常。比如： 123456function t() &#123; console.log(\"start\"); new Error(); console.log(\"end\");&#125;t(); （动画演示） 这段代码不会产生任何的异常，控制台也不会有任何错误输出。 异常的分类按照产生异常时程序是否正在运行，我们可以将错误分为编译时异常和运行时异常。 编译时异常指的是源代码在编译成可执行代码之前产生的异常。而运行时异常指的是可执行代码被装载到内存中执行之后产生的异常。 编译时异常我们知道 TS 最终会被编译成 JS，从而在 JS Runtime中执行。既然存在编译，就有可能编译失败，就会有编译时异常。 比如我使用 TS 写出了如下代码： 1const s: string = 123; 这很明显是错误的代码， 我给 s 声明了 string 类型，但是却给它赋值 number。 当我使用 tsc（typescript 编译工具，全称是 typescript compiler）尝试编译这个文件的时候会有异常抛出： 12345678tsc a.tsa.ts:1:7 - error TS2322: Type '123' is not assignable to type 'string'.1 const s: string = 123; ~Found 1 error. 这个异常就是编译时异常，因为我的代码还没有执行。 然而并不是你用了 TS 才存在编译时异常，JS 同样有编译时异常。有的人可能会问 JS 不是解释性语言么？是边解释边执行，没有编译环节，怎么会有编译时异常？ 别急，我举个例子你就明白了。如下代码： 123456function t() &#123; console.log('start') await sa console.log('end')&#125;t() 上面的代码由于存在语法错误，不会编译通过，因此并不会打印start，侧面证明了这是一个编译时异常。尽管 JS 是解释语言，也依然存在编译阶段，这是必然的，因此自然也会有编译异常。 总的来说，编译异常可以在代码被编译成最终代码前被发现，因此对我们的伤害更小。接下来，看一下令人心生畏惧的运行时异常。 运行时异常相信大家对运行时异常非常熟悉。这恐怕是广大前端碰到最多的异常类型了。众所周知的 NPE（Null Pointer Exception） 就是运行时异常。 将上面的例子稍加改造，得到下面代码： 123456function t() &#123; console.log(\"start\"); throw 1; console.log(\"end\");&#125;t(); （动画演示） 注意 end 没有打印，并且 t 没有弹出栈。实际上 t 最终还是会被弹出的，只不过和普通的返回不一样。 如上，则会打印出start。由于异常是在代码运行过程中抛出的，因此这个异常属于运行时异常。相对于编译时异常，这种异常更加难以发现。上面的例子可能比较简单，但是如果我的异常是隐藏在某一个流程控制语句（比如 if else）里面呢？程序就可能在客户的电脑走入那个抛出异常的 if 语句，而在你的电脑走入另一条。这就是著名的 《在我电脑上好好的》 事件。 异常的传播异常的传播和我之前写的浏览器事件模型有很大的相似性。只不过那个是作用在 DOM 这样的数据结构，这个则是作用在函数调用栈这种数据结构，并且事件传播存在捕获阶段，异常传播是没有的。不同 C 语言，JS 中异常传播是自动的，不需要程序员手动地一层层传递。如果一个异常没有被 catch，它会沿着函数调用栈一层层传播直到栈空。 异常处理中有两个关键词，它们是throw（抛出异常） 和 catch（处理异常）。 当一个异常被抛出的时候，异常的传播就开始了。异常会不断传播直到遇到第一个 catch。 如果程序员没有手动 catch，那么一般而言程序会抛出类似unCaughtError，表示发生了一个异常，并且这个异常没有被程序中的任何 catch 语言处理。未被捕获的异常通常会被打印在控制台上，里面有详细的堆栈信息，从而帮助程序员快速排查问题。实际上我们的程序的目标是避免 unCaughtError这种异常，而不是一般性的异常。 一点小前提由于 JS 的 Error 对象没有 code 属性，只能根据 message 来呈现，不是很方便。我这里进行了简单的扩展，后面很多地方我用的都是自己扩展的 Error ，而不是原生 JS Error ，不再赘述。 123456oldError = Error;Error = function (&#123; code, message, fileName, lineNumber &#125;) &#123; error = new oldError(message, fileName, lineNumber); error.code = code; return error;&#125;; 手动抛出 or 自动抛出异常既可以由程序员自己手动抛出，也可以由程序自动抛出。 1throw new Error(`I'm Exception`); （手动抛出的例子） 12a = null;a.toString(); // Thrown: TypeError: Cannot read property 'toString' of null （程序自动抛出的例子） 自动抛出异常很好理解，毕竟我们哪个程序员没有看到过程序自动抛出的异常呢？ “这个异常突然就跳出来！吓我一跳！”，某不知名程序员如是说。 那什么时候应该手动抛出异常呢？ 一个指导原则就是你已经预知到程序不能正确进行下去了。比如我们要实现除法，首先我们要考虑的是被除数为 0 的情况。当被除数为 0 的时候，我们应该怎么办呢？是抛出异常，还是 return 一个特殊值？答案是都可以，你自己能区分就行，这没有一个严格的参考标准。 我们先来看下抛出异常，告诉调用者你的输入，我处理不了这种情况。 12345678910111213141516171819function divide(a, b) &#123; a = +a; b = +b; // 转化成数字 if (!b) &#123; // 匹配 +0, -0, NaN throw new Error(&#123; code: 1, message: \"Invalid dividend \" + b, &#125;); &#125; if (Number.isNaN(a)) &#123; // 匹配 NaN throw new Error(&#123; code: 2, message: \"Invalid divisor \" + a, &#125;); &#125; return a / b;&#125; 上面代码会在两种情况下抛出异常，告诉调用者你的输入我处理不了。由于这两个异常都是程序员自动手动抛出的，因此是可预知的异常。 刚才说了，我们也可以通过返回值来区分异常输入。我们来看下返回值输入是什么，以及和异常有什么关系。 异常 or 返回如果是基于异常形式（遇到不能处理的输入就抛出异常）。当别的代码调用divide的时候，需要自己 catch。 12345678910111213function t() &#123; try &#123; divide(\"foo\", \"bar\"); &#125; catch (err) &#123; if (err.code === 1) &#123; return console.log(\"被除数必须是除0之外的数\"); &#125; if (err.code === 2) &#123; return console.log(\"除数必须是数字\"); &#125; throw new Error(\"不可预知的错误\"); &#125;&#125; 然而就像上面我说的那样，divide 函数设计的时候，也完全可以不用异常，而是使用返回值来区分。 12345678910111213141516171819function divide(a, b) &#123; a = +a; b = +b; // 转化成数字 if (!b) &#123; // 匹配 +0, -0, NaN return new Error(&#123; code: 1, message: \"Invalid dividend \" + b, &#125;); &#125; if (Number.isNaN(a)) &#123; // 匹配 NaN return new Error(&#123; code: 2, message: \"Invalid divisor \" + a, &#125;); &#125; return a / b;&#125; 当然，我们使用方式也要作出相应改变。 1234567891011function t() &#123; const res = divide(\"foo\", \"bar\"); if (res.code === 1) &#123; return console.log(\"被除数必须是除0之外的数\"); &#125; if (res.code === 2) &#123; return console.log(\"除数必须是数字\"); &#125; return new Error(\"不可预知的错误\");&#125; 这种函数设计方式和抛出异常的设计方式从功能上说都是一样的，只是告诉调用方的方式不同。如果你选择第二种方式，而不是抛出异常，那么实际上需要调用方书写额外的代码，用来区分正常情况和异常情况，这并不是一种良好的编程习惯。 然而在 Go 等返回值可以为复数的语言中，我们无需使用上面蹩脚的方式，而是可以： 1234res, err := divide(\"foo\", \"bar\");if err != nil &#123; log.Fatal(err)&#125; 这是和 Java 和 JS 等语言使用的 try catch 不一样的的地方，Go 是通过 panic recover defer 机制来进行异常处理的。感兴趣的可以去看看 Go 源码关于错误测试部分 可能大家对 Go 不太熟悉。没关系，我们来继续看下 shell。实际上 shell 也是通过返回值来处理异常的，我们可以通过 $? 拿到上一个命令的返回值，这本质上也是一种调用栈的传播行为，而且是通过返回值而不是捕获来处理异常的。 作为函数返回值处理和 try catch 一样，这是语言的设计者和开发者共同决定的一件事情。 上面提到了异常传播是作用在函数调用栈上的。当一个异常发生的时候，其会沿着函数调用栈逐层返回，直到第一个 catch 语句。当然 catch 语句内部仍然可以触发异常（自动或者手动）。如果 catch 语句内部发生了异常，也一样会沿着其函数调用栈继续执行上述逻辑，专业术语是 stack unwinding。 实际上并不是所有的语言都会进行 stack unwinding，这个我们会在接下来的《运行时异常可以恢复么？》部分讲解。 伪代码来描述一下： 12345678function bubble(error, fn) &#123; if (fn.hasCatchBlock()) &#123; runCatchCode(error); &#125; if (callstack.isNotEmpty()) &#123; bubble(error, callstack.pop()); &#125;&#125; 从我的伪代码可以看出所谓的 stack unwinding 其实就是 callstack.pop() 这就是异常传播的一切！仅此而已。 异常的处理我们已经了解来异常的传播方式了。那么接下来的问题是，我们应该如何在这个传播过程中处理异常呢？ 我们来看一个简单的例子： 12345678910function a() &#123; b();&#125;function b() &#123; c();&#125;function c() &#123; throw new Error(\"an error occured\");&#125;a(); 我们将上面的代码放到 chrome 中执行， 会在控制台显示如下输出： 我们可以清楚地看出函数的调用关系。即错误是在 c 中发生的，而 c 是 b 调用的，b 是 a 调用的。这个函数调用栈是为了方便开发者定位问题而存在的。 上面的代码，我们并没有 catch 错误，因此上面才会有uncaught Error。 那么如果我们 catch ，会发生什么样的变化呢？catch 的位置会对结果产生什么样的影响？在 a ，b，c 中 catch 的效果是一样的么？ 我们来分别看下： 1234567891011121314function a() &#123; b();&#125;function b() &#123; c();&#125;function c() &#123; try &#123; throw new Error(\"an error occured\"); &#125; catch (err) &#123; console.log(err); &#125;&#125;a(); (在 c 中 catch) 我们将上面的代码放到 chrome 中执行， 会在控制台显示如下输出： 可以看出，此时已经没有uncaught Error啦，仅仅在控制台显示了标准输出，而非错误输出（因为我用的是 console.log，而不是 console.error）。然而更重要是的是，如果我们没有 catch，那么后面的同步代码将不会执行。 比如在 c 的 throw 下面增加一行代码，这行代码是无法被执行的，无论这个错误有没有被捕获。 12345678function c() &#123; try &#123; throw new Error(\"an error occured\"); console.log(\"will never run\"); &#125; catch (err) &#123; console.log(err); &#125;&#125; 我们将 catch 移动到 b 中试试看。 123456789101112131415function a() &#123; b();&#125;function b() &#123; try &#123; c(); &#125; catch (err) &#123; console.log(err); &#125;&#125;function c() &#123; throw new Error(\"an error occured\");&#125;a(); (在 b 中 catch) 在这个例子中，和上面在 c 中捕获没有什么本质不同。其实放到 a 中捕获也是一样，这里不再贴代码了，感兴趣的自己试下。 既然处于函数调用栈顶部的函数报错， 其函数调用栈下方的任意函数都可以进行捕获，并且效果没有本质不同。那么问题来了，我到底应该在哪里进行错误处理呢？ 答案是责任链模式。我们先来简单介绍一下责任链模式，不过细节不会在这里展开。 假如 lucifer 要请假。 如果请假天数小于等于 1 天，则主管同意即可 如果请假大于 1 天，但是小于等于三天，则需要 CTO 同意。 如果请假天数大于三天，则需要老板同意。 这就是一个典型的责任链模式。谁有责任干什么事情是确定的，不要做自己能力范围之外的事情。比如主管不要去同意大于 1 天的审批。 举个例子，假设我们的应用有三个异常处理类，它们分别是：用户输入错误，网络错误 和 类型错误。如下代码，当代码执行的时候会报错一个用户输入异常。这个异常没有被 C 捕获，会 unwind stack 到 b，而 b 中 catch 到这个错误之后，通过查看 code 值判断其可以被处理，于是打印I can handle this。 123456789101112131415161718192021222324252627282930function a() &#123; try &#123; b(); &#125; catch (err) &#123; if (err.code === \"NETWORK_ERROR\") &#123; return console.log(\"I can handle this\"); &#125; // can't handle, pass it down throw err; &#125;&#125;function b() &#123; try &#123; c(); &#125; catch (err) &#123; if (err.code === \"INPUT_ERROR\") &#123; return console.log(\"I can handle this\"); &#125; // can't handle, pass it down throw err; &#125;&#125;function c() &#123; throw new Error(&#123; code: \"INPUT_ERROR\", message: \"an error occured\", &#125;);&#125;a(); 而如果 c 中抛出的是别的异常，比如网络异常，那么 b 是无法处理的，虽然 b catch 住了，但是由于你无法处理，因此一个好的做法是继续抛出异常，而不是吞没异常。不要畏惧错误，抛出它。只有没有被捕获的异常才是可怕的，如果一个错误可以被捕获并得到正确处理，它就不可怕。 举个例子： 12345678910111213141516171819202122232425262728function a() &#123; try &#123; b(); &#125; catch (err) &#123; if (err.code === \"NETWORK_ERROR\") &#123; return console.log(\"I can handle this\"); &#125; // can't handle, pass it down throw err; &#125;&#125;function b() &#123; try &#123; c(); &#125; catch (err) &#123; if (err.code === \"INPUT_ERROR\") &#123; return console.log(\"I can handle this\"); &#125; &#125;&#125;function c() &#123; throw new Error(&#123; code: \"NETWORK_ERROR\", message: \"an error occured\", &#125;);&#125;a(); 如上代码不会有任何异常被抛出，它被完全吞没了，这对我们调试问题简直是灾难。因此切记不要吞没你不能处理的异常。正确的做法应该是上面讲的那种只 catch 你可以处理的异常，而将你不能处理的异常 throw 出来，这就是责任链模式的典型应用。 这只是一个简单的例子，就足以绕半天。实际业务肯定比这个复杂多得多。因此异常处理绝对不是一件容易的事情。 如果说谁来处理是一件困难的事情，那么在异步中决定谁来处理异常就是难上加难，我们来看下。 同步与异步同步异步一直是前端难以跨越的坎，对于异常处理也是一样。以 NodeJS 中用的比较多的读取文件 API 为例。它有两个版本，一个是异步，一个是同步。同步读取仅仅应该被用在没了这个文件无法进行下去的时候。比如读取一个配置文件。而不应该在比如浏览器中读取用户磁盘上的一个图片等，这样会造成主线程阻塞，导致浏览器卡死。 1234// 异步读取文件fs.readFileSync();// 同步读取文件fs.readFile(); 当我们试图同步读取一个不存在的文件的时候，会抛出以下异常： 1234567891011fs.readFileSync('something-not-exist.lucifer');console.log('脑洞前端');Thrown:Error: ENOENT: no such file or directory, open 'something-not-exist.lucifer' at Object.openSync (fs.js:446:3) at Object.readFileSync (fs.js:348:35) &#123; errno: -2, syscall: 'open', code: 'ENOENT', path: 'something-not-exist.lucifer'&#125; 并且脑洞前端是不会被打印出来的。这个比较好理解，我们上面已经解释过了。 而如果以异步方式的话： 123456789101112fs.readFile('something-not-exist.lucifer', (err, data) =&gt; &#123;if(err) &#123;throw err&#125;&#125;);console.log('lucifer')luciferundefinedThrown:[Error: ENOENT: no such file or directory, open 'something-not-exist.lucifer'] &#123; errno: -2, code: 'ENOENT', syscall: 'open', path: 'something-not-exist.lucifer'&#125;&gt; 脑洞前端是会被打印出来的。 其本质在于 fs.readFile 的函数调用已经成功，并从调用栈返回并执行到下一行的console.log(&#39;lucifer&#39;)。因此错误发生的时候，调用栈是空的，这一点可以从上面的错误堆栈信息中看出来。 不明白为什么调用栈是空的同学可以看下我之前写的《一文看懂浏览器事件循环》 而 try catch 的作用仅仅是捕获当前调用栈的错误（上面异常传播部分已经讲过了）。因此异步的错误是无法捕获的，比如； 123456789try &#123; fs.readFile(\"something-not-exist.lucifer\", (err, data) =&gt; &#123; if (err) &#123; throw err; &#125; &#125;);&#125; catch (err) &#123; console.log(\"catching an error\");&#125; 上面的 catching an error 不会被打印。因为错误抛出的时候， 调用栈中不包含这个 catch 语句，而仅仅在执行fs.readFile的时候才会。 如果我们换成同步读取文件的例子看看： 12345try &#123; fs.readFileSync(\"something-not-exist.lucifer\");&#125; catch (err) &#123; console.log(\"catching an error\");&#125; 上面的代码会打印 catching an error。因为读取文件被同步发起，文件返回之前线程会被挂起，当线程恢复执行的时候， fs.readFileSync 仍然在函数调用栈中，因此 fs.readFileSync 产生的异常会冒泡到 catch 语句。 简单来说就是异步产生的错误不能用 try catch 捕获，而要使用回调捕获。 可能有人会问了，我见过用 try catch 捕获异步异常啊。 比如： 123456789101112131415rejectIn = (ms) =&gt; new Promise((_, r) =&gt; &#123; setTimeout(() =&gt; &#123; r(1); &#125;, ms); &#125;);async function t() &#123; try &#123; await rejectIn(0); &#125; catch (err) &#123; console.log(\"catching an error\", err); &#125;&#125;t(); 本质上这只是一个语法糖，是 Promise.prototype.catch 的一个语法糖而已。而这一语法糖能够成立的原因在于其用了 Promise 这种包装类型。如果你不用包装类型，比如上面的 fs.readFile 不用 Promise 等包装类型包装，打死都不能用 try catch 捕获。 而如果我们使用 babel 转义下，会发现 try catch 不见了，变成了 switch case 语句。这就是 try catch “可以捕获异步异常”的原因，仅此而已，没有更多。 （babel 转义结果） 我使用的 babel 转义环境都记录在这里，大家可以直接点开链接查看. 虽然浏览器并不像 babel 转义这般实现，但是至少我们明白了一点。目前的 try catch 的作用机制是无法捕获异步异常的。 异步的错误处理推荐使用容器包装，比如 Promise。然后使用 catch 进行处理。实际上 Promise 的 catch 和 try catch 的 catch 有很多相似的地方，大家可以类比过去。 和同步处理一样，很多原则都是通用的。比如异步也不要去吞没异常。下面的代码是不好的，因为它吞没了它不能处理的异常。 12p = Promise.reject(1);p.catch(() =&gt; &#123;&#125;); 更合适的做法的应该是类似这种： 1234567p = Promise.reject(1);p.catch((err) =&gt; &#123; if (err == 1) &#123; return console.log(\"I can handle this\"); &#125; throw err;&#125;); 彻底消除运行时异常可能么？我个人对目前前端现状最为头疼的一点是：大家过分依赖运行时，而严重忽略编译时。我见过很多程序，你如果不运行，根本不知道程序是怎么走的，每个变量的 shape 是什么。怪不得处处都可以看到 console.log。我相信你一定对此感同身受。也许你就是那个写出这种代码的人，也许你是给别人擦屁股的人。为什么会这样？ 就是因为大家太依赖运行时。TS 的出现很大程度上改善了这一点，前提是你用的是 typescript，而不是 anyscript。其实 eslint 以及 stylint 对此也有贡献，毕竟它们都是静态分析工具。 我强烈建议将异常保留在编译时，而不是运行时。不妨极端一点来看：假如所有的异常都在编译时发生，而一定不会在运行时发生。那么我们是不是就可以信心满满地对应用进行重构啦? 幸运的是，我们能够做到。只不过如果当前语言做不到的话，则需要对现有的语言体系进行改造。这种改造成本真的很大。不仅仅是 API，编程模型也发生了翻天覆地的变化，不然函数式也不会这么多年没有得到普及了。 不熟悉函数编程的可以看看我之前写的函数式编程入门篇。 如果才能彻底消除异常呢？在回答这个问题之前，我们先来看下一门号称没有运行时异常的语言 elm。elm 是一门可以编译为 JS 的函数式编程语言，其封装了诸如网络 IO 等副作用，是一种声明式可推导的语言。 有趣的是，elm 也有异常处理。 elm 中关于异常处理（Error Handling）部分有两个小节的内容，分别是：Maybe 和 Result。elm 之所以没有运行时异常的一个原因就是它们。 一句话概括“为什么 elm 没有异常”的话，那就是elm 把异常看作数据（data）。 举个简单的例子： 12345678maybeResolveOrNot = (ms) =&gt; setTimeout(() =&gt; &#123; if (Math.random() &gt; 0.5) &#123; console.log(\"ok\"); &#125; else &#123; throw new Error(\"error\"); &#125; &#125;); 上面的代码有一半的可能报错。那么在 elm 中就不允许这样的情况发生。所有的可能发生异常的代码都会被强制包装一层容器，这个容器在这里是 Maybe。 在其他函数式编程语言名字可能有所不同，但是意义相同。实际上，不仅仅是异常，正常的数据也会被包装到容器中，你需要通过容器的接口来获取数据。如果难以理解的话，你可以将其简单理解为 Promsie（但并不完全等价）。 Maybe 可能返回正常的数据 data，也可能会生成一个错误 error。某一个时刻只能是其中一个，并且只有运行的时候，我们才真正知道它是什么。从这一点来看，有点像薛定谔的猫。 不过 Maybe 已经完全考虑到异常的存在，一切都在它的掌握之中。所有的异常都能够在编译时推导出来。当然要想推导出这些东西，你需要对整个编程模型做一定的封装会抽象，比如 DOM 就不能直接用了，而是需要一个中间层。 再来看下一个更普遍的例子 NPE： 1null.toString(); elm 也不会发生。原因也很简单，因为 null 也会被包装起来，当你通过这个包装类型就行访问的时候，容器有能力避免这种情况，因此就可以不会发生异常。当然这里有一个很重要的前提就是可推导，而这正是函数式编程语言的特性。这部分内容超出了本文的讨论范围，不再这里说了。 运行时异常可以恢复么？最后要讨论的一个主题是运行时异常是否可以恢复。先来解释一下，什么是运行时异常的恢复。 还是用上面的例子： 123456function t() &#123; console.log(\"start\"); throw 1; console.log(\"end\");&#125;t(); 这个我们已经知道了， end 是不会打印的。 尽管你这么写也是无济于事： 12345678910function t() &#123; try &#123; console.log(\"start\"); throw 1; console.log(\"end\"); &#125; catch (err) &#123; console.log(\"relax, I can handle this\"); &#125;&#125;t(); 如果我想让它打印呢？我想让程序面对异常可以自己 recover 怎么办？我已经捕获这个错误， 并且我确信我可以处理，让流程继续走下去吧！如果有能力做到这个，这个就是运行时异常恢复。 遗憾地告诉你，据我所知，目前没有任何一个引擎能够做到这一点。 这个例子过于简单， 只能帮助我们理解什么是运行时异常恢复，但是不足以让我们看出这有什么用？ 我们来看一个更加复杂的例子，我们这里直接使用上面实现过的函数divide。 1234567891011121314function t() &#123; try &#123; const res = divide(\"foo\", \"bar\"); alert(`you got $&#123;res&#125;`); &#125; catch (err) &#123; if (err.code === 1) &#123; return console.log(\"被除数必须是除0之外的数\"); &#125; if (err.code === 2) &#123; return console.log(\"除数必须是数字\"); &#125; throw new Error(\"不可预知的错误\"); &#125;&#125; 如上代码，会进入 catch ，而不会 alert。因此对于用户来说， 应用程序是没有任何响应的。这是不可接受的。 要吐槽一点的是这种事情真的是挺常见的，只不过大家用的不是 alert 罢了。 如果我们的代码在进入 catch 之后还能够继续返回出错位置继续执行就好了。 如何实现异常中断的恢复呢？我刚刚说了：据我所知，目前没有任何一个引擎能够做到异常恢复。那么我就来发明一个新的语法解决这个问题。 12345678910function t() &#123; try &#123; const res = divide(\"foo\", \"bar\"); alert(`you got $&#123;res&#125;`); &#125; catch (err) &#123; console.log(\"releax, I can handle this\"); resume - 1; &#125;&#125;t(); 上面的 resume 是我定义的一个关键字，功能是如果遇到异常，则返回到异常发生的地方，然后给当前发生异常的函数一个返回值 -1，并使得后续代码能够正常运行，不受影响。这其实是一种 fallback。 这绝对是一个超前的理念。当然挑战也非常大，对现有的体系冲击很大，很多东西都要改。我希望社区可以考虑把这个东西加到标准。 最佳实践通过前面的学习，你已经知道了异常是什么，异常是怎么产生的，以及如何正确处理异常（同步和异步）。接下来，我们谈一下异常处理的最佳实践。 我们平时开发一个应用。 如果站在生产者和消费者的角度来看的话。当我们使用别人封装的框架，库，模块，甚至是函数的时候，我们就是消费者。而当我们写的东西被他人使用的时候，我们就是生产者。 实际上，就算是生产者内部也会有多个模块构成，多个模块之间也会有生产者和消费者的再次身份转化。不过为了简单起见，本文不考虑这种关系。这里的生产者指的就是给他人使用的功能，是纯粹的生产者。 从这个角度出发，来看下异常处理的最佳实践。 作为消费者当作为消费者的时候，我们关心的是使用的功能是否会抛出异常，如果是，他们有哪些异常。比如： 123456import foo from \"lucifer\";try &#123; foo.bar();&#125; catch (err) &#123; // 有哪些异常？&#125; 当然，理论上 foo.bar 可能产生任何异常，而不管它的 API 是这么写的。但是我们关心的是可预期的异常。因此你一定希望这个时候有一个 API 文档，详细列举了这个 API 可能产生的异常有哪些。 比如这个 foo.bar 4 种可能的异常 分别是 A，B，C 和 D。其中 A 和 B 是我可以处理的，而 C 和 D 是我不能处理的。那么我应该： 123456789101112import foo from \"lucifer\";try &#123; foo.bar();&#125; catch (err) &#123; if (err.code === \"A\") &#123; return console.log(\"A happened\"); &#125; if (err.code === \"B\") &#123; return console.log(\"B happened\"); &#125; throw err;&#125; 可以看出，不管是 C 和 D，还是 API 中没有列举的各种可能异常，我们的做法都是直接抛出。 作为生产者如果你作为生产者，你要做的就是提供上面提到的详细的 API，告诉消费者你的可能错误有哪些。这样消费者就可以在 catch 中进行相应判断，处理异常情况。 你可以提供类似上图的错误表，让大家可以很快知道可能存在的可预知异常有哪些。不得不吐槽一句，在这一方面很多框架，库做的都很差。希望大家可以重视起来，努力维护良好的前端开发大环境。 总结本文很长，如果你能耐心看完，你真得给可以给自己鼓个掌 👏👏👏。 我从什么是异常，以及异常的分类，让大家正确认识异常，简单来说异常就是一种数据结构而已。 接着，我又讲到了异常的传播和处理。这两个部分是紧密联系的。异常的传播和事件传播没有本质不同，主要不同是数据结构不同，思想是类似的。具体来说异常会从发生错误的调用处，沿着调用栈回退，直到第一个 catch 语句或者栈为空。如果栈为空都没有碰到一个 catch，则会抛出uncaught Error。 需要特别注意的是异步的异常处理，不过你如果对我讲的原理了解了，这都不是事。 然后，我提出了两个脑洞问题： 彻底消除运行时异常可能么？ 运行时异常可以恢复么？ 这两个问题非常值得研究，但由于篇幅原因，我这里只是给你讲个轮廓而已。如果你对这两个话题感兴趣，可以和我交流。 最后，我提到了前端异常处理的最佳实践。大家通过两种角色（生产者和消费者）的转换，认识一下不同决定关注点以及承担责任的不同。具体来说提到了 明确声明可能的异常以及 处理你应该处理的，不要吞没你不能处理的异常。当然这个最佳实践仍然是轮廓性的。如果大家想要一份 前端最佳实践 checklist，可以给我留言。留言人数较多的话，我考虑专门写一个前端最佳实践 checklist 类型的文章。","categories":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/tags/前端/"},{"name":"异常处理","slug":"异常处理","permalink":"https://lucifer.ren/blog/tags/异常处理/"}]},{"title":"一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～","slug":"删除问题","date":"2020-06-13T13:12:04.222Z","updated":"2020-06-14T07:46:06.467Z","comments":true,"path":"2020/06/13/删除问题/","link":"","permalink":"https://lucifer.ren/blog/2020/06/13/删除问题/","excerpt":"我花了几天时间，从力扣中精选了四道相同思想的题目，来帮助大家解套，如果觉得文章对你有用，记得点赞分享，让我看到你的认可，有动力继续做下去。 这就是接下来要给大家讲的四个题，其中 1081 和 316 题只是换了说法而已。 316. 去除重复字母(困难) 321. 拼接最大数(困难) 402. 移掉 K 位数字(中等) 1081. 不同字符的最小子序列（中等）","text":"我花了几天时间，从力扣中精选了四道相同思想的题目，来帮助大家解套，如果觉得文章对你有用，记得点赞分享，让我看到你的认可，有动力继续做下去。 这就是接下来要给大家讲的四个题，其中 1081 和 316 题只是换了说法而已。 316. 去除重复字母(困难) 321. 拼接最大数(困难) 402. 移掉 K 位数字(中等) 1081. 不同字符的最小子序列（中等） 402. 移掉 K 位数字（中等）我们从一个简单的问题入手，识别一下这种题的基本形式和套路，为之后的三道题打基础。 题目描述1234567891011121314151617181920212223给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。注意:num 的长度小于 10002 且 ≥ k。num 不会包含任何前导零。示例 1 :输入: num = &quot;1432219&quot;, k = 3输出: &quot;1219&quot;解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。示例 2 :输入: num = &quot;10200&quot;, k = 1输出: &quot;200&quot;解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。示例 3 :输入: num = &quot;10&quot;, k = 2输出: &quot;0&quot;解释: 从原数字移除所有的数字，剩余为空就是 0。 前置知识 数学 思路这道题让我们从一个字符串数字中删除 k 个数字，使得剩下的数最小。也就说，我们要保持原来的数字的相对位置不变。 以题目中的 num = 1432219， k = 3 为例，我们需要返回一个长度为 4 的字符串，问题在于： 我们怎么才能求出这四个位置依次是什么呢？ （图 1） 暴力法的话，我们需要枚举C_n^(n - k) 种序列（其中 n 为数字长度），并逐个比较最大。这个时间复杂度是指数级别的，必须进行优化。 一个思路是： 从左到右遍历 对于每一个遍历到的元素，我们决定是丢弃还是保留 问题的关键是：我们怎么知道，一个元素是应该保留还是丢弃呢？ 这里有一个前置知识：对于两个数 123a456 和 123b456，如果 a &gt; b， 那么数字 123a456 大于 数字 123b456，否则数字 123a456 小于等于数字 123b456。也就说，两个相同位数的数字大小关系取决于第一个不同的数的大小。 因此我们的思路就是： 从左到右遍历 对于遍历到的元素，我们选择保留。 但是我们可以选择性丢弃前面相邻的元素。 丢弃与否的依据如上面的前置知识中阐述中的方法。 以题目中的 num = 1432219， k = 3 为例的图解过程如下： （图 2） 由于没有左侧相邻元素，因此没办法丢弃。 （图 3） 由于 4 比左侧相邻的 1 大。如果选择丢弃左侧的 1，那么会使得剩下的数字更大（开头的数从 1 变成了 4）。因此我们仍然选择不丢弃。 （图 4） 由于 3 比左侧相邻的 4 小。 如果选择丢弃左侧的 4，那么会使得剩下的数字更小（开头的数从 4 变成了 3）。因此我们选择丢弃。 。。。 后面的思路类似，我就不继续分析啦。 然而需要注意的是，如果给定的数字是一个单调递增的数字，那么我们的算法会永远选择不丢弃。这个题目中要求的，我们要永远确保丢弃 k 个矛盾。 一个简单的思路就是： 每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。 而当遍历完成，如果 k 仍然大于 0。不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素。 上面的思路可行，但是稍显复杂。 （图 5） 我们需要把思路逆转过来。刚才我的关注点一直是丢弃，题目要求我们丢弃 k 个。反过来说，不就是让我们保留 $n - k$ 个元素么？其中 n 为数字长度。 那么我们只需要按照上面的方法遍历完成之后，再截取前n - k个元素即可。 按照上面的思路，我们来选择数据结构。由于我们需要保留和丢弃相邻的元素，因此使用栈这种在一端进行添加和删除的数据结构是再合适不过了，我们来看下代码实现。 代码（Python）12345678910class Solution(object): def removeKdigits(self, num, k): stack = [] remain = len(num) - k for digit in num: while k and stack and stack[-1] &gt; digit: stack.pop() k -= 1 stack.append(digit) return ''.join(stack[:remain]).lstrip('0') or '0' 复杂度分析 时间复杂度：虽然内层还有一个 while 循环，但是由于每个数字最多仅会入栈出栈一次，因此时间复杂度仍然为 $O(N)$，其中 $N$ 为数字长度。 空间复杂度：我们使用了额外的栈来存储数字，因此空间复杂度为 $O(N)$，其中 $N$ 为数字长度。 提示： 如果题目改成求删除 k 个字符之后的最大数，我们只需要将 stack[-1] &gt; digit 中的大于号改成小于号即可。 316. 去除重复字母（困难）题目描述12345678910给你一个仅包含小写字母的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。示例 1:输入: &quot;bcabc&quot;输出: &quot;abc&quot;示例 2:输入: &quot;cbacdcbc&quot;输出: &quot;acdb&quot; 前置知识 字典序 数学 思路与上面题目不同，这道题没有一个全局的删除次数 k。而是对于每一个在字符串 s 中出现的字母 c 都有一个 k 值。这个 k 是 c 出现次数 - 1。 沿用上面的知识的话，我们首先要做的就是计算每一个字符的 k，可以用一个字典来描述这种关系，其中 key 为 字符 c，value 为其出现的次数。 具体算法： 建立一个字典。其中 key 为 字符 c，value 为其出现的剩余次数。 从左往右遍历字符串，每次遍历到一个字符，其剩余出现次数 - 1. 对于每一个字符，如果其对应的剩余出现次数大于 1，我们可以选择丢弃（也可以选择不丢弃），否则不可以丢弃。 是否丢弃的标准和上面题目类似。如果栈中相邻的元素字典序更大，那么我们选择丢弃相邻的栈中的元素。 还记得上面题目的边界条件么？如果栈中剩下的元素大于 $n - k$，我们选择截取前 $n - k$ 个数字。然而本题中的 k 是分散在各个字符中的，因此这种思路不可行的。 不过不必担心。由于题目是要求只出现一次。我们可以在遍历的时候简单地判断其是否在栈上即可。 代码： 123456789101112class Solution: def removeDuplicateLetters(self, s) -&gt; int: stack = [] remain_counter = collections.Counter(s) for c in s: if c not in stack: while stack and c &lt; stack[-1] and remain_counter[stack[-1]] &gt; 0: stack.pop() stack.append(c) remain_counter[c] -= 1 return ''.join(stack) 复杂度分析 时间复杂度：由于判断当前字符是否在栈上存在需要 $O(N)$ 的时间，因此总的时间复杂度就是 $O(N ^ 2)$，其中 $N$ 为字符串长度。 空间复杂度：我们使用了额外的栈来存储数字，因此空间复杂度为 $O(N)$，其中 $N$ 为字符串长度。 查询给定字符是否在一个序列中存在的方法。根本上来说，有两种可能： 有序序列： 可以二分法，时间复杂度大致是 $O(N)$。 无序序列： 可以使用遍历的方式，最坏的情况下时间复杂度为 $O(N)$。我们也可以使用空间换时间的方式，使用 $N$的空间 换取 $O(1)$的时间复杂度。 由于本题中的 stack 并不是有序的，因此我们的优化点考虑空间换时间。而由于每种字符仅可以出现一次，这里使用 hashset 即可。 代码（Python）1234567891011121314class Solution: def removeDuplicateLetters(self, s) -&gt; int: stack = [] seen = set() remain_counter = collections.Counter(s) for c in s: if c not in seen: while stack and c &lt; stack[-1] and remain_counter[stack[-1]] &gt; 0: seen.discard(stack.pop()) seen.add(c) stack.append(c) remain_counter[c] -= 1 return ''.join(stack) 复杂度分析 时间复杂度：$O(N)$，其中 $N$ 为字符串长度。 空间复杂度：我们使用了额外的栈和 hashset，因此空间复杂度为 $O(N)$，其中 $N$ 为字符串长度。 LeetCode 《1081. 不同字符的最小子序列》 和本题一样，不再赘述。 321. 拼接最大数（困难）题目描述123456789101112131415161718192021222324252627282930给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。说明: 请尽可能地优化你算法的时间和空间复杂度。示例 1:输入:nums1 = [3, 4, 6, 5]nums2 = [9, 1, 2, 5, 8, 3]k = 5输出:[9, 8, 6, 5, 3]示例 2:输入:nums1 = [6, 7]nums2 = [6, 0, 4]k = 5输出:[6, 7, 6, 0, 4]示例 3:输入:nums1 = [3, 9]nums2 = [8, 9]k = 3输出:[9, 8, 9] 前置知识 分治 数学 思路和第一道题类似，只不不过这一次是两个数组，而不是一个，并且是求最大数。 最大最小是无关紧要的，关键在于是两个数组，并且要求从两个数组选取的元素个数加起来一共是 k。 然而在一个数组中取 k 个数字，并保持其最小（或者最大），我们已经会了。但是如果问题扩展到两个，会有什么变化呢？ 实际上，问题本质并没有发生变化。 假设我们从 nums1 中取了 k1 个，从 num2 中取了 k2 个，其中 k1 + k2 = k。而 k1 和 k2 这 两个子问题我们是会解决的。由于这两个子问题是相互独立的，因此我们只需要分别求解，然后将结果合并即可。 假如 k1 和 k2 个数字，已经取出来了。那么剩下要做的就是将这个长度分别为 k1 和 k2 的数字，合并成一个长度为 k 的数组合并成一个最大的数组。 以题目的 nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5 为例。 假如我们从 num1 中取出 1 个数字，那么就要从 nums2 中取出 4 个数字。 运用第一题的方法，我们计算出应该取 nums1 的 [6]，并取 nums2 的 [9,5,8,3]。 如何将 [6] 和 [9,5,8,3]，使得数字尽可能大，并且保持相对位置不变呢？ 实际上这个过程有点类似归并排序中的治，而上面我们分别计算 num1 和 num2 的最大数的过程类似归并排序中的分。 （图 6） 代码： 我们将从 num1 中挑选的 k1 个数组成的数组称之为 A，将从 num2 中挑选的 k2 个数组成的数组称之为 B， 1234567def merge(A, B): ans = [] while A or B: bigger = A if A &gt; B else B ans.append(bigger[0]) bigger.pop(0) return ans 这里需要说明一下。 在很多编程语言中：如果 A 和 B 是两个数组，当前仅当 A 的首个元素字典序大于 B 的首个元素，A &gt; B 返回 true，否则返回 false。 比如： 1234567A = [1,2]B = [2]A &lt; B # TrueA = [1,2]B = [1,2,3]A &lt; B # False 以合并 [6] 和 [9,5,8,3] 为例，图解过程如下： （图 7） 具体算法： 从 nums1 中 取 $min(i, len(nums1))$ 个数形成新的数组 A（取的逻辑同第一题），其中 i 等于 0,1,2, … k。 从 nums2 中 对应取 $min(j, len(nums2))$ 个数形成新的数组 B（取的逻辑同第一题），其中 j 等于 k - i。 将 A 和 B 按照上面的 merge 方法合并 上面我们暴力了 k 种组合情况，我们只需要将 k 种情况取出最大值即可。 代码（Python）12345678910111213141516171819202122class Solution: def maxNumber(self, nums1, nums2, k): def pick_max(nums, k): stack = [] drop = len(nums) - k for num in nums: while drop and stack and stack[-1] &lt; num: stack.pop() drop -= 1 stack.append(num) return stack[:k] def merge(A, B): ans = [] while A or B: bigger = A if A &gt; B else B ans.append(bigger[0]) bigger.pop(0) return ans return max(merge(pick_max(nums1, i), pick_max(nums2, k-i)) for i in range(k+1) if i &lt;= len(nums1) and k-i &lt;= len(nums2)) 复杂度分析 时间复杂度：pick_max 的时间复杂度为 $O(M + N)$ ，其中 $M$ 为 nums1 的长度，$N$ 为 nums2 的长度。 merge 的时间复杂度为 $O(k)$，再加上外层遍历所有的 k 中可能性。因此总的时间复杂度为 $O(k^2 * (M + N))$。 空间复杂度：我们使用了额外的 stack 和 ans 数组，因此空间复杂度为 $O(max(M, N, k))$，其中 $M$ 为 nums1 的长度，$N$ 为 nums2 的长度。 总结这四道题都是删除或者保留若干个字符，使得剩下的数字最小（或最大）或者字典序最小（或最大）。而解决问题的前提是要有一定数学前提。而基于这个数学前提，我们贪心地删除栈中相邻的字符。如果你会了这个套路，那么这四个题目应该都可以轻松解决。 316. 去除重复字母（困难），我们使用 hashmap 代替了数组的遍历查找，属于典型的空间换时间方式，可以认识到数据结构的灵活使用是多么的重要。背后的思路是怎么样的？为什么想到空间换时间的方式，我在文中也进行了详细的说明，这都是值得大家思考的问题。然而实际上，这些题目中使用的栈也都是空间换时间的思想。大家下次碰到需要空间换取时间的场景，是否能够想到本文给大家介绍的栈和哈希表呢？ 321. 拼接最大数（困难）则需要我们能够对问题进行分解，这绝对不是一件简单的事情。但是对难以解决的问题进行分解是一种很重要的技能，希望大家能够通过这道题加深这种分治思想的理解。 大家可以结合我之前写过的几个题解练习一下，它们分别是： 【简单易懂】归并排序（Python） 一文看懂《最大子序列和问题》 更多题解可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。 目前已经 30K star 啦。 大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解","categories":[{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"},{"name":"经验分享","slug":"经验分享","permalink":"https://lucifer.ren/blog/tags/经验分享/"},{"name":"困难","slug":"困难","permalink":"https://lucifer.ren/blog/tags/困难/"},{"name":"中等","slug":"中等","permalink":"https://lucifer.ren/blog/tags/中等/"},{"name":"删除 k 个字符","slug":"删除-k-个字符","permalink":"https://lucifer.ren/blog/tags/删除-k-个字符/"}]},{"title":"算法小白如何高效、快速刷 leetcode？","slug":"刷题新手","date":"2020-06-12T05:08:50.617Z","updated":"2020-06-12T10:51:39.356Z","comments":true,"path":"2020/06/12/刷题新手/","link":"","permalink":"https://lucifer.ren/blog/2020/06/12/刷题新手/","excerpt":"我本身刷了大概 600 道左右的题目，总结 200 多篇的题解，另外总结了十多个常见的算法专题，基本已经覆盖了大多数的常见考点和题型，全部放在我的 Github https://github.com/azl397985856/leetcode 。 然而作为一个新手，看着茫茫多的题解和资料难免会陷入一种“不知从何开始”的境地。不必担心，你不是一个人。 实际上，我最近一直在思考“初学者如何快速提高自己的算法能力，高效刷题”。因此我也一直在不断定位自己，最终我对自己作出了定位“用清晰直白的语言还原解题全过程，做西湖区最好的算法题解”。 然而我意识到，我进去了一个很大的误区。我的想法一直是“努力帮助算法小白提高算法能力，高效刷题”。然而算法小白除了清晰直白的算法题解外，还需要系统的前置知识。因此我的假设“大家都会基础的数据结构和算法”很可能就是不成立的。","text":"我本身刷了大概 600 道左右的题目，总结 200 多篇的题解，另外总结了十多个常见的算法专题，基本已经覆盖了大多数的常见考点和题型，全部放在我的 Github https://github.com/azl397985856/leetcode 。 然而作为一个新手，看着茫茫多的题解和资料难免会陷入一种“不知从何开始”的境地。不必担心，你不是一个人。 实际上，我最近一直在思考“初学者如何快速提高自己的算法能力，高效刷题”。因此我也一直在不断定位自己，最终我对自己作出了定位“用清晰直白的语言还原解题全过程，做西湖区最好的算法题解”。 然而我意识到，我进去了一个很大的误区。我的想法一直是“努力帮助算法小白提高算法能力，高效刷题”。然而算法小白除了清晰直白的算法题解外，还需要系统的前置知识。因此我的假设“大家都会基础的数据结构和算法”很可能就是不成立的。 小白阶段划分如果让我对算法小白进行一个阶段划分的话，我会将其分为： 阶段一 系统学习数据结构和算法知识。第一，你不能根本不懂得基础，比如根本不知道什么哈希表，或者只知道其简单的 API。 第二，你不能从网上不断搜索知识，因为这些知识是零散的，不利于新手形成自己的算法观。 当你成功跨越了上面两个坎，那么恭喜你，你可以进入下一个阶段啦。 对于这个阶段，想要跨过。需要系统性学习一些基础知识，推荐啃《算法 4》或者直接啃各个大学里面的教材。实在有困难的，可以先啃《算法图解》，《我的第一本算法书》这种入个门，然后再去啃。 阶段二 针对性刷题。比如按照力扣的标签去刷。因此上面的学习阶段并不见得你要学习完所有的基础再去刷，而是学习一个专题就可以针对性地刷。比如我学了二分法，就可以找一个二分法的题目刷一下。 想要跨越这一个坎，除了多做题之外，还有一个就是多看题解，多写题解。当然要看优秀的题解，这个我会在后面提到。 如果你跨越完上面两个坎，那么恭喜你， 你已经不是算法小白了（至少对于非算法岗来说）。 我的算法观继续回到刚才的问题“我的定位误区”。正因为很多小白没有跨越阶段一，因此我的所谓的“用清晰直白的语言还原解题全过程，做西湖区最好的算法题解”对他们没有实质帮助。他们迫切需要的是一个系统地整理算法思想，套路 的东西。因此我准备搞 91，这个就是后话，不再这里赘述。 注意，上面我提到了一个名次算法观。我并不知道这个词是否真的存在，不过这并不重要。如果不存在我就赋予其含义，如果存在我就来重新定义它。 算法观指的是你对于算法全面的认识。比如我拿到一个题目，如何审题，如何抽象成算法模型，如何根据模型选取合适的数据结构和算法。这就需要你对各种数据结构与算法的特性，使用场景有着身后的理解。 我举一个例子，这个例子就是今天（2020-06-12）我的 91 群的每日一题。 API 示例： 12345678910111213141516class LRUCache: def __init__(self, capacity: int): def get(self, key: int) -&gt; int: def put(self, key: int, value: int) -&gt; None:# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value) 按照上面的过程，我们来套一个。 如何审题 看完题的话，只要抓住一个核心点即可。对于本题，核心点在于 删除最久未使用，O(1)时间。 抽象算法模型 这个题目是一个设计题。API 帮我们设计好了，只需要填充功能即可，也就是说算法模型不需要我们抽象了。 根据模型选取合适的数据结构和算法 我们的算法有两个操作：get 和 put。既然要支持这两个操作，肯定要有一个地方存数据。那么我们存到哪里呢？数组？链表？哈希表？其中链表又有很多，单向双向，循环不循环。 由于第一步审题过程中，我们获取到 O(1)时间 这个关键信息。那么： 数组无法做到更新，删除 $O(1)$ 链表无法做到查找，更新，删除 $O(1)$。 有的人说链表更新，删除是 $O(1)$，那么我要问你如何找到需要删除的节点呢？遍历找到的话最坏情况下就是 $O(N)$ 哈希表是无序的，因此不能实现 删除最久未使用。 似乎单独使用三种的任何一种都是不可以的。那么我们考虑组合多种数据结构。 我刚才说了链表只所以删除和更新都是 $O(N)$，是因为查找的时间损耗。 具体来说，我要删除图中值为 3 的节点，需要移动一次。因为我只能从头开始遍历去找。 （图 1） 又或者我要更新图中值为 7 的节点，则需要移动两次。 （图 2） 有没有什么办法可以省去这种遍历的时间损耗呢？其实我们的根本目的是找到目标节点， 而找到目标节点最暴力的方式是遍历。有没有巧妙一点的方法呢？毫无疑问，如果不借助额外的空间，这是不可能的。我们的想法只有空间换时间。 假设有这么一种数据结构，你告诉它你想要查的对象，它能帮你在 $O(1)$ 的时间内找到并返回给你结果。结合这个神秘数据结构和链表是不是我们就完成这道题了？这个神秘的数据结构就是哈希表。如果你对哈希表熟悉的话，想到几乎应该是瞬间的事情。如果不熟悉，那么经过排除，也应该可以得出这个结论。相信你随着做题数的增加，这种算法直觉会更加敏锐。 然而上面的空间复杂度是 $O(N)$。如果我的内存有限，不能承受 $O(N)$ 的空间，怎么办呢？相应地，我们可能就需要牺牲时间。那么问题是我们必须要退化到 $O(N)$ 么？显然不是，我们可以搞一些存档点。比如： 这样，我们需要操作 1 前面的，我们就从头开始遍历，如果需要操作 1 后面的，就从 1 开始遍历。时间复杂度最坏的情况可以降低到 $O(N / 2)$。通过进一步增加存档点，可以进一步减少时间，但是会增加空间。这是一种取舍。类似的取舍在实际工程中很多，这里不展开。 如果你了解过跳表， 实际上，上面的算法就是跳表的基本思想。 如果对每一道题你都能按照上面的流程走一遍，并且基于增加适当扩展，我相信你的刷题效率会高得可怕。 每道题都想这么多么？强烈建议新手都按照上面的逻辑进行思考，做题，并写题解总结。这样随着做题数的增加，量变引起质变，你会发现上面的几个步骤做下来很可能就是几秒钟的事情。如果你擅长图解，或者你经常看别人的图解（比如我的），那么这种图解能够帮你更快地检索大脑中的信息，这个时间会更短。 图解就是大脑检索信息的哈希表？哈哈，Maybe。 题解的水很深我看了很多人的题解直接就是两句话，然后跟上代码: 1234567class Solution: def integerBreak(self, n: int) -&gt; int: dp = [1] * (n + 1) for i in range(3, n + 1): for j in range(1, i): dp[i] = max(j * dp[i - j], j * (i - j), dp[i]) return dp[n] 这种题解说实话，只针对那些”自己会， 然后去题解区看看有没有新的更好的解法的人“。但是大多数看题解的人是那种自己没思路，不会做的人。那么这种题解就没什么用了。 我认为好的题解应该是新手友好的，并且能够将解题人思路完整展现的题解。比如看到这个题目，我首先想到了什么（对错没有关系），然后头脑中经过怎么样的筛选将算法筛选到具体某一个或某几个。我的最终算法是如何想到的，有没有一些先行知识。 当然我也承认自己有很多题解也是直接给的答案，这对很多人来说用处不大，甚至有可能有反作用，给他们一种”我已经会了“的假象。实际上他们根本不懂解题人本身原本的想法， 也许是写题解的人觉得”这很自然“，也可能”只是为了秀技“。 刷题顺序最后给小白一个刷题顺序，帮助大家最大化利用自己的时间。 基础篇（30 天）基础永远是最重要的，先把最最基础的这些搞熟，磨刀不误砍柴工。 数组，队列，栈 链表 树与递归 哈希表 双指针 思想篇（30 天）这些思想是投资回报率极高的，强烈推荐每一个小的专题花一定的时间掌握。 二分 滑动窗口 搜索（BFS，DFS，回溯） 动态规划 提高篇（31 天）这部分收益没那么明显，并且往往需要一定的技术积累。出现的频率相对而言比较低。但是有的题目需要你使用这些技巧。又或者可以使用这些技巧可以实现降维打击。 贪心 分治 位运算 KMP &amp; RK 并查集 前缀树 线段树 堆 最后目前，我本人也在写一本题解方面的书包括近期组织的 91 算法 ，其目标受众正是“阶段一到阶段二”。为了真正帮助刷题小白成长，我打算画三个月的时间对数据结构和算法进行系统总结，帮助大家跨过阶段一。当然我还会不断更新题解，通过清晰直白的方式来让大家跨越阶段二。 大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"},{"name":"经验分享","slug":"经验分享","permalink":"https://lucifer.ren/blog/categories/经验分享/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"},{"name":"经验分享","slug":"经验分享","permalink":"https://lucifer.ren/blog/tags/经验分享/"}]},{"title":"【LeetCode 日记】面试题46. 把数字翻译成字符串","slug":"面试题46. 把数字翻译成字符串","date":"2020-06-09T07:39:25.086Z","updated":"2020-06-09T08:35:27.087Z","comments":true,"path":"2020/06/09/面试题46. 把数字翻译成字符串/","link":"","permalink":"https://lucifer.ren/blog/2020/06/09/面试题46. 把数字翻译成字符串/","excerpt":"​","text":"​ 原题地址： https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof 题目描述给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 1: 输入: 12258输出: 5解释: 12258 有 5 种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi” 提示： 0 &lt;= num &lt; 231 思路我们另 f(n)表示给定数字 num 的情况下，从 num 的第 1 位（包含）到第 n 位（包含）有多少种不同的翻译方法。 我们从几个简单的例子入手，尝试打开思路。 对于数字 12258 来说: | （挡板）表示从这里分开翻译， ，（逗号）表示分割多个翻译方式。 f(1) = 1，分别为 1。 f(2) = 2，分别为 1|2， 12。 f(3) = 3，分别为 1|2|2，1|22，12|2 … 其实对于 f(3) 来说， 我手动的情况下，是这么想的： 先把 f(2) 结果搬过来，即 1|2，12 在 f(2)的基础上分割，我要添加第三位，也就是一个 2 到末尾。 1|2|2 这样是行的， 12|2 同样是可以的。 继续在 f(1) 的基础上分割，我要添加第三位，也就是一个 2 到末尾。 1|22 那么总的情况就是三种。OK，总结下我的逻辑： 如果我不可以和前面的数字组成 10 - 25 之间的数，那么在 f(n - 1) 的末尾添加挡板 如果可以，同时在 f(n - 1)和 f(n -2) 的末尾添加挡板 用图来表示： 因此，实际上这道题就是爬楼梯的换皮题。 代码12345678910class Solution: def translateNum(self, num: int) -&gt; int: @lru_cache def helper(s: str) -&gt; int: if not s: return 1 pre = helper(s[:-1]) if 10 &lt;= int(s[-2:]) &lt;= 25: return pre + helper(s[:-2]) return pre return helper(str(num)) 复杂度分析 时间复杂度：最坏的情况，每一个数组都可以和前面的组成新的数组， 有大约 $2^N$ 种组合，因此时间复杂度为 $O(2^N)$，而我这里使用了 @lru_cache 因此不会有重复计算，时间复杂度为 $(N)$，其中 N 为 数字长度。 空间复杂度：由于空间复杂的受递归调用栈的影响，因此空间复杂度为 $O(2^N)$，而我这里使用了 @lru_cache 因此不会有重复计算，空间复杂度为 $(N)$，其中 N 为 数字长度。 如果你愿意的话，其实优化起来也比较简单，我们只需要 bottom-up 即可。 12345678910class Solution: def translateNum(self, num: int) -&gt; int: s = str(num) n = len(s) dp = [1] * n for i in range(1, n): dp[i] = dp[i - 1] if 10 &lt;= int(s[i - 1:i + 1]) &lt;= 25: dp[i] += dp[i - 2] return dp[-1] 进而可以优化到空间 $O(1)$ 12345678910111213class Solution: def translateNum(self, num: int) -&gt; int: s = str(num) n = len(s) a = b = 1 for i in range(1, n): if 10 &lt;= int(s[i - 1:i + 1]) &lt;= 25: temp = a a = b b = temp + b else: a = b return b 更多题解可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。 目前已经 30K star 啦。 大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解","categories":[{"name":"算法，动态规划","slug":"算法，动态规划","permalink":"https://lucifer.ren/blog/categories/算法，动态规划/"},{"name":"中等","slug":"中等","permalink":"https://lucifer.ren/blog/categories/中等/"}],"tags":[{"name":"数据结构，算法，LeetCode 日记，中等","slug":"数据结构，算法，LeetCode-日记，中等","permalink":"https://lucifer.ren/blog/tags/数据结构，算法，LeetCode-日记，中等/"}]},{"title":"前端测试最佳实践（持续更新，建议收藏）","slug":"fe-test-best-practice","date":"2020-06-08T10:50:57.061Z","updated":"2020-06-08T10:51:55.415Z","comments":true,"path":"2020/06/08/fe-test-best-practice/","link":"","permalink":"https://lucifer.ren/blog/2020/06/08/fe-test-best-practice/","excerpt":"最近公司在推行单元测试，但是一些同事对于单元测试只是了解，甚至不怎么了解。因此推动单元测试的阻碍是有的，这种阻碍除了人的层面，还有基础设施的层面。希望通过本文，一方面加深大家对前端测试最佳实践的认知，另一方面可以作为手册，在日常开发中做参考。本文也会不断更新，期待你的参与。 如果大家对前端测试不太清楚，可以先看下文末我写的科普短文。如果你已经对前端测试有所了解，并且希望对前端测试有更深入的了解，以及对如何写出更好的单元测试有兴趣的话，那就让我们开始吧。","text":"最近公司在推行单元测试，但是一些同事对于单元测试只是了解，甚至不怎么了解。因此推动单元测试的阻碍是有的，这种阻碍除了人的层面，还有基础设施的层面。希望通过本文，一方面加深大家对前端测试最佳实践的认知，另一方面可以作为手册，在日常开发中做参考。本文也会不断更新，期待你的参与。 如果大家对前端测试不太清楚，可以先看下文末我写的科普短文。如果你已经对前端测试有所了解，并且希望对前端测试有更深入的了解，以及对如何写出更好的单元测试有兴趣的话，那就让我们开始吧。 写易于测试的代码（Writing test-friendly code）这是一个非常宽泛的话题，本文试图从几个具体的切入点来阐述这个庞大且模糊的话题。 纯函数（Pure Function）关于纯函数可以参考之前我写的一篇函数式教程中的入门篇。 简单来说，纯函数就是数学中的函数。有两个好处： 断言容易了。 （可推导性） 我可以多次，顺序无关地执行测试用例。 （无副作用） 我举一个例子，这是一个稍微高级一点的技巧。不过你一旦理解了其意图，就会发现其思想是多么的简单。 12345678const app = &#123; name: `lucifer's site` start(html) &#123; document.querySelector('#app').innerHTM = html; &#125;&#125;app.start(&lt;div&gt;inner&lt;/div&gt;); 上面代码如果要测试，首先你要在 node 环境模拟 document。 如果换一种写法呢？ 12345678const app = &#123; name: `lucifer's site` start(querySelector, html) &#123; querySelector('#app').innerHTM = html; &#125;&#125;app.start(document.querySelector, &lt;div&gt;inner&lt;/div&gt;); 这样模拟 querySelector 就会变得容易起来。eg: 123// .test.jsimport app from \"./app\";app.start(() =&gt; &lt;div id=\"app\"&gt;lucifer&lt;/div&gt;, &lt;div&gt;inner&lt;/div&gt;); 如果你熟悉这种看成方法的话，可能知道它的名字控制反转，英文名 IoC。 单一职责（Single Responsibility Principle）如果一个函数承担了一个以上的职责。那么对我们测试有什么影响呢？ 如果对于一个函数 f,其功能有 A 和 B。 A 的输入我们计作 ia，输出计作 oa。 B 的输入我们计作 ib，输出计作 ob。 那么 f 的圈复杂度会增加很多，具体来说。 如果 A 功能和 B 功能相关的话，其测试用例的长度增长是笛卡尔积。 如果 A 功能和 B 功能无关的话，其测试用例的长度增长是线性增长。 eg: 123456function math(a, b, operator) &#123; if (operator === \"+\") return a + b; if (operator === \"-\") return a - b; if (operator === \"*\") return a * b; if (operator === \"/\") return a / b;&#125; 如上代码有四个功能，并且四个功能互相独立。测试用例增长是线性的，也就说将其拆分为四个函数之后，测试用例的数量不变，但是单一函数的圈复杂度降低了，虽然总的软件复杂度并没有降低。 如果四个功能相互耦合的话，后果会更严重。这种情况，拆分多个功能块已经无法解决问题了。这个时候需要对功能进行再次拆解，直到子功能块相互独立。 写清晰直白的测试描述（Wrting Deadly Simply Description）这里我给一个简单的判断标准。 当这个测试报错的时候， 其他人能够只看报错信息，就知道出了什么问题。 比如这样写是好的： 12345describe(`math -&gt; add`, () =&gt; &#123; it(\"3 + 2 should equal to 5\", () =&gt; &#123; expect(3 + 2).to.be.equal(5); &#125;);&#125;); 而这样是不好的： 12345describe(`math -&gt; add`, () =&gt; &#123; it(\"add two numbers\", () =&gt; &#123; expect(3 + 2).to.be.equal(5); &#125;);&#125;); 我举的例子大家可能不屑一顾， 但是当你以我的标准去衡量的时候会发现很多用例都不合格。 逻辑覆盖率（Logic Coverage）很多人关注的是单元测试的物理覆盖率，比如行覆盖率，文件覆盖率等，而大家往往会忽略逻辑覆盖率。 eg: 1234567891011// a.jsexport default (a, b) =&gt; a / b// a.test.jsimport divide './a.js'describe(`math -&gt; divide`, () =&gt; &#123; it(\"2 / 2 should be 1\", () =&gt; &#123; expect(divide(2, 2)).to.be(1); &#125;);&#125;); 如上物理覆盖率可以达到 100%，但是很明显逻辑覆盖率却不可以。因为它连最简单的被除数不能为 0 都没包括。 一个更格式的例子，应该是： 123456789101112131415161718192021// a.jsexport default (a, b) =&gt; &#123; if (b === 0 or b === -0) throw new Error('dividend should not be zero!') if (Number(a) !== a || Number(b)=== b) throw new Error(`divisor and dividend should be number，but got $&#123;a, b&#125;`) return a / b&#125;// a.test.jsimport divide './a.js'describe(`math -&gt; divide`, () =&gt; &#123; it(\"when dividend it zero, there should throw an corresponding eror\", () =&gt; &#123; expect(divide(3, 0)).toThrowError(/dividend should not be zero/); &#125;); it(\"when dividend it zero, there should throw an corresponding eror\", () =&gt; &#123; expect(divide(3, 'f')).toThrowError(/divisor and dividend should be number/); &#125;); it(\"2 / 2 should be 1\", () =&gt; &#123; expect(divide(2, 2)).to.be(1); &#125;);&#125;); 逻辑的严密性是双向的，一方面他让你的测试用例更严密，更无懈可击。另一方面你的测试用例越严密， 就越驱使你写出更严密的代码。如上 divide 方法就是我根据测试用例反馈的结果后添加上去的。 然后我上面的测试逻辑上还是很不严密，比如： 没有考虑大数的溢出。 没有考虑无限循环小数。 这么一个简单的除法就有这么多 edge cases，如果是我们实际的业务的话，情况会更加复杂。因此写好测试从来都不是一件简单的事情。 给测试增加 lint（Add Linting）测试代码也是需要 lint 的。除了源码的一些 lint 规则，测试应该要加入一些独特的规则。 比如，你的测试代码只是把代码跑了一遍，没有进行任何断言。亦或者是直接断言expect(true.to.be(true))，都是不应该被允许的。 比如，断言的时候使用非全等，这也不好的实践。 再比如，使用toBeNull()断言，而不是: 12345expect(null).toBe(null);expect(null).toEqual(null);expect(null).toStrictEqual(null); … 类似的例子还有很多，总之测试代码也是需要 lint 的 ，并且相比于被测试代码，其应该有额外的特殊规则，来避免测试代码的腐烂问题。 CI本地测试（Local CI）可以仅对修改的文件进行测试，eg: 1jest -o 分阶段测试（Tags）我们可以按照一定分类标准对测试用例进行分类。 举个例子，我按照测试是否有 IO 将用例分为 IO 类型和 非 IO 类型。那么我就可以在提交的时候只执行非 IO 类型，这样反馈更快。等到我推送到远程的时候执行一次全量操作。 eg: 1234567describe(`\"face swiping\" -&gt; alipay #io`, () =&gt; &#123; it(\"it should go to http://www.alipay.com/identify when user choose alipay\", () =&gt; &#123; // simulate click // do heavy io // expect &#125;);&#125;); 我们可以这么做 1jest -t = \"#io\"; 同样，我可以按照其他纬度对用例进行切分，比如各种业务纬度。这在业务达到一定规模之后，收益非常明显。eg: 1jest -t = &quot;[#io|#cold|#biz]&quot;; 如上会仅测试有io,cold,biz 三个标签中的一个或者多个的用例。 文件夹和文件名本身也是一种 tag，合理利用可以减少很多工作。 框架相关（Framework）大家问的比较多的问题是如何测试视图，以及如何测试特定的某一种框架下的代码。 Vue一个典型的 Vue 项目可能有如下文件类型： html vue js ts json css 图片，音视频等媒体资源 如何对他们进行测试呢？JS 和 TS 我们暂时讨论，这个和框架相关性不大。而我们这里关心框架相关的 vue 文件和视图相关的文件。而json，图片，音视频等媒体资源是没有必要测试的。 那么如何测试 html，vue 和 css 文件呢？而大多数情况， 大家应用都是 CSR 的，html 只是一个傀儡文件，没有测试的价值。css 的话，如果要测试，只有两种情况，一种是对 CSSOM 进行测试，另外一种是对渲染树的内容进行测试。而一般大家都会对渲染树进行测试。为什么呢？留给大家来思考，欢迎文章后留言讨论。因此本文主要讨论 vue 文件，以及渲染树的测试。 实际上， vue 文件会导出一个 vue 的构造函数，并且合适的时候完成实例化和挂载的过程。而其真正渲染到中的时候，会把 template 标签，style 标签内容一并带过去，当然这中间有一些复杂逻辑存在，这不是本文重点，故不做延伸。 那么，对基于 vue 框架的应用测试主要关注一点，渲染树本身。 其实你用别的框架，或者不用框架也是一样的。 不同的是，vue 是一种基于数据驱动的框架。 1(props) =&gt; view; 因此我们是不是只要测试不同的 props 组合，是否展示我们期望的 view 就可以了？ 是也不是。 我们先假定”是“。那么我们的问题转化为： 如何组合合适的 props 如何断言 view 是否正确渲染 对于第一个问题，这个是组件设计的时候应该考虑的事情。对于第二个问题，答案是 vue-test-utils。 vue-test-utils 本身就是解决这个问题的，如果我将一个 app 看成是组件的有机体（组件以及组件之间的通信协作），并将组件看成函数的话。那么vue-test-utils 的核心功能就是: 帮你执行这些函数。 改变函数内部的状态。 触发函数之间的通信。 。。。 vue-test-utils 的 wrapper 同时完成了上面两件事setProps 和 assert。vue-test-utils 还帮你做了很多事情， 比如组件嵌套（类似函数调用栈）如何测试，怎么 mock props，router 等。 一句话来说，就像是一双无形的手，帮你操作 app 的初始化， 挂载，更新，卸载等，并且直接或者间接提供断言机制。 更多可以参考 https://vue-test-utils.vuejs.org/ 以上内容基于一个事实 我们只要测试不同的 props 组合，是否展示我们期望的 view 就可以。然而， vue 虽然将其抽象为函数，但是要注意这个函数和我上文讲到的纯函数相差甚远，就连以函数式友好闻名的 React 也做不到这一点。 也就是说，你还需要考虑副作用。从这一点上来看，这是和我上文提到的最佳实践背离的。但是真正地将副作用全部抽离开的框架不怎么流行，比如 cyclejs, elm。因此我们必须接受这个事实。我们虽然无法避免这种事情的发生，但是我们可以限制其在我们可控制的范围，典型的技巧就是沙箱机制，这同样超出了本文的论述范围，故不做引申。 ReactTODO 其他（Others）Make it Red， Make it Green其实这就是测试驱动开发的本质。 先写用例，甭管飘红不飘红，先把测试用例写好，定义好问题边界。 然后一个个将红色的变成绿色。 再结合上面我提到的技巧，做持续集成。在你打字的时候可以执行的测试用例有哪些，在你提交到本地仓库的时候可以执行的用例有哪些。 参考（Reference） 两年前写的前端测试短文 eslint-plugin-jest","categories":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/categories/前端/"},{"name":"测试","slug":"前端/测试","permalink":"https://lucifer.ren/blog/categories/前端/测试/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/tags/前端/"},{"name":"测试","slug":"测试","permalink":"https://lucifer.ren/blog/tags/测试/"},{"name":"单元测试","slug":"单元测试","permalink":"https://lucifer.ren/blog/tags/单元测试/"},{"name":"vue","slug":"vue","permalink":"https://lucifer.ren/blog/tags/vue/"}]},{"title":"《丢鸡蛋问题》重制版来袭～","slug":"887.super-egg-drop","date":"2020-06-07T16:00:00.000Z","updated":"2020-06-08T02:14:44.289Z","comments":true,"path":"2020/06/08/887.super-egg-drop/","link":"","permalink":"https://lucifer.ren/blog/2020/06/08/887.super-egg-drop/","excerpt":"这是一道 LeetCode 难度为 Hard 的题目，很多大公司都会考，来看看。 ​","text":"这是一道 LeetCode 难度为 Hard 的题目，很多大公司都会考，来看看。 ​ 原题地址：https://leetcode-cn.com/problems/super-egg-drop/ 题目描述你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N 共有 N 层楼的建筑。 每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。 你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。 每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。 你的目标是确切地知道 F 的值是多少。 无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？ 示例 1： 输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。示例 2： 输入：K = 2, N = 6输出：3示例 3： 输入：K = 3, N = 14输出：4 提示： 1 &lt;= K &lt;= 1001 &lt;= N &lt;= 10000 前置知识 递归 动态规划 思路本题也是 vivo 2020 年提前批的一个笔试题。时间一个小时，一共三道题，分别是本题，合并 k 个链表，以及种花问题。 这道题我在很早的时候做过，也写了题解。现在看来，思路没有讲清楚。没有讲当时的思考过程还原出来，导致大家看的不太明白。今天给大家带来的是 887.super-egg-drop 题解的重制版。思路更清晰，讲解更透彻，如果觉得有用，那就转发在看支持一下？OK，我们来看下这道题吧。 这道题乍一看很复杂，我们不妨从几个简单的例子入手，尝试打开思路。 假如有 2 个鸡蛋，6 层楼。 我们应该先从哪层楼开始扔呢？想了一会，没有什么好的办法。我们来考虑使用暴力的手段。 （图 1. 这种思路是不对的） 既然我不知道先从哪层楼开始扔是最优的，那我就依次模拟从第 1，第 2。。。第 6 层扔。每一层楼丢鸡蛋，都有两种可能，碎或者不碎。由于是最坏的情况，因此我们需要模拟两种情况，并取两种情况中的扔次数的较大值（较大值就是最坏情况）。 然后我们从六种扔法中选择最少次数的即可。 （图 2. 应该是这样的） 而每一次选择从第几层楼扔之后，剩下的问题似乎是一个规模变小的同样问题。嗯哼？递归？ 为了方便描述，我将 f(i, j) 表示有 i 个鸡蛋， j 层楼，在最坏情况下，最少的次数。 伪代码： 123456def superEggDrop(K, N): ans = N # 暴力枚举从第 i 层开始扔 for i in range(1, N + 1): ans = min(ans, max(self.superEggDrop(K - 1, i - 1) + 1, self.superEggDrop(K, N - i) + 1)) return ans 如上代码： self.superEggDrop(K - 1, i - 1) 指的是鸡蛋破碎的情况，我们就只剩下 K - 1 个鸡蛋， 并且 i - 1 个楼层需要 check。 self.superEggDrop(K, N - i) + 1 指的是鸡蛋没有破碎的情况，我们仍然有 K 个鸡蛋， 并且剩下 N - i 个楼层需要 check。 接下来，我们增加两行递归的终止条件，这道题就完成了。 123456789class Solution: def superEggDrop(self, K: int, N: int) -&gt; int: if K == 1: return N if N == 0 or N == 1: return N ans = N # 暴力枚举从第 i 层开始扔 for i in range(1, N + 1): ans = min(ans, max(self.superEggDrop(K - 1, i - 1) + 1, self.superEggDrop(K, N - i) + 1)) return ans 可是如何这就结束的话，这道题也不能是 hard，而且这道题是公认难度较大的 hard 之一。 上面的代码会 TLE，我们尝试使用记忆化递归来试一下，看能不能 AC。 1234567891011class Solution: @lru_cache() def superEggDrop(self, K: int, N: int) -&gt; int: if K == 1: return N if N == 0 or N == 1: return N ans = N # 暴力枚举从第 i 层开始扔 for i in range(1, N + 1): ans = min(ans, max(self.superEggDrop(K - 1, i - 1) + 1, self.superEggDrop(K, N - i) + 1)) return ans 性能比刚才稍微好一点，但是还是很容易挂。 那只好 bottom-up（动态规划）啦。 (图 3) 我将上面的过程简写成如下形式： (图 4) 与其递归地进行这个过程，我们可以使用迭代的方式。 相比于上面的递归式，减少了栈开销。然而两者有着很多的相似之处。 如果说递归是用函数调用来模拟所有情况， 那么动态规划就是用表来模拟。我们知道所有的情况，无非就是 N 和 K 的所有组合，我们怎么去枚举 K 和 N 的所有组合？ 当然是套两层循环啦！ （图 5. 递归 vs 迭代） 如上，你将 dp[i][j] 看成 superEggDrop(i, j)，是不是和递归是一摸一样？ 来看下迭代的代码： 123456789101112class Solution: def superEggDrop(self, K: int, N: int) -&gt; int: for i in range(K + 1): for j in range(N + 1): if i == 1: dp[i][j] = j if j == 1 or j == 0: dp[i][j] == j dp[i][j] = j for k in range(1, j + 1): dp[i][j] = min(dp[i][j], max(dp[i - 1][k - 1] + 1, dp[i][j - k] + 1)) return dp[K][N] 值得注意的是，在这里内外循环的顺序无关紧要，并且内外循坏的顺序对我们写代码来说复杂程度也是类似的，各位客官可以随意调整内外循环的顺序。比如这样也是可以的： 123456789101112131415class Solution: def superEggDrop(self, K: int, N: int) -&gt; int: dp = [[0] * (K + 1) for _ in range(N + 1)] for i in range(N + 1): for j in range( K + 1): if j == 1: dp[i][j] = i if i == 1 or i == 0: dp[i][j] == i dp[i][j] = i for k in range(1, i + 1): dp[i][j] = min(dp[i][j], max(dp[k - 1][j - 1] + 1, dp[i - k][j] + 1)) return dp[N][K] dp = [[0] * (N + 1) for _ in range(K + 1)] 总结一下，上面的解题方法思路是： 然而这样还是不能 AC。这正是这道题困难的地方。 一道题目往往有不止一种状态转移方程，而不同的状态转移方程往往性能是不同的。 那么这道题有没有性能更好的其他的状态转移方程呢？ 把思路逆转！ 这是《逆转裁判》 中经典的台词， 主角在深处绝境的时候，会突然冒出这句话，从而逆转思维，寻求突破口。 我们这样来思考这个问题。 既然题目要求最少的扔的次数，假设有一个函数 f(k, i)，他的功能是求出 k 个鸡蛋，扔 i 次所能检测的最高楼层。 我们只需要不断进行发问： ”f 函数啊 f 函数，我扔一次可以么？“， 也就是判断 f(k, 1) &gt;= N 的返回值 ”f 函数啊 f 函数，我扔两次呢？“， 也就是判断 f(k, 2) &gt;= N 的返回值 … ”f 函数啊 f 函数，我扔 m 次呢？“， 也就是判断 f(k, m) &gt;= N 的返回值 我们只需要返回第一个返回值为 true 的 m 即可。 想到这里，我条件发射地想到了二分法。 聪明的小朋友们，你们觉得二分可以么？为什么？欢迎评论区留言讨论。 那么这个神奇的 f 函数怎么实现呢？其实很简单。 摔碎的情况，可以检测的最高楼层是f(m - 1, k - 1) + 1。因为碎了嘛，我们多检测了摔碎的这一层。 没有摔碎的情况，可以检测的最高楼层是f(m - 1, k)。因为没有碎，也就是说我们啥都没检测出来（对能检测的最高楼层无贡献）。 我们来看下代码： 123456789class Solution: def superEggDrop(self, K: int, N: int) -&gt; int: def f(m, k): if k == 0 or m == 0: return 0 return f(m - 1, k - 1) + 1 + f(m - 1, k) m = 0 while f(m, K) &lt; N: m += 1 return m 上面的代码可以 AC。我们来顺手优化成迭代式。 123456789class Solution: def superEggDrop(self, K: int, N: int) -&gt; int: dp = [[0] * (K + 1) for _ in range(N + 1)] m = 0 while dp[m][K] &lt; N: m += 1 for i in range(1, K + 1): dp[m][i] = dp[m - 1][i - 1] + 1 + dp[m - 1][i] return m 代码代码支持：JavaSCript，Python Python: 123456789class Solution: def superEggDrop(self, K: int, N: int) -&gt; int: dp = [[0] * (K + 1) for _ in range(N + 1)] m = 0 while dp[m][K] &lt; N: m += 1 for i in range(1, K + 1): dp[m][i] = dp[m - 1][i - 1] + 1 + dp[m - 1][i] return m JavaSCript: 12345678910111213var superEggDrop = function (K, N) &#123; // 不选择dp[K][M]的原因是dp[M][K]可以简化操作 const dp = Array(N + 1) .fill(0) .map((_) =&gt; Array(K + 1).fill(0)); let m = 0; while (dp[m][K] &lt; N) &#123; m++; for (let k = 1; k &lt;= K; ++k) dp[m][k] = dp[m - 1][k - 1] + 1 + dp[m - 1][k]; &#125; return m;&#125;; 复杂度分析 时间复杂度：$O(m * K)$，其中 m 为答案。 空间复杂度：$O(K * N)$ 总结 对于困难，先举几个简单例子帮助你思考。 递归和迭代的关系，以及如何从容地在两者间穿梭。 如果你还不熟悉动态规划，可以先从递归做起。多画图，当你做多了题之后，就会越来越从容。 对于动态规划问题，往往有不止一种状态转移方程，而不同的状态转移方程往往性能是不同的。 更多题解可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。 目前已经 30K star 啦。 大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"数组","slug":"数据结构/数组","permalink":"https://lucifer.ren/blog/categories/数据结构/数组/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://lucifer.ren/blog/tags/动态规划/"}]},{"title":"刷题效率低？或许你就差这么一个插件","slug":"algo-chrome-extension","date":"2020-06-06T10:14:06.364Z","updated":"2020-06-06T10:51:33.671Z","comments":true,"path":"2020/06/06/algo-chrome-extension/","link":"","permalink":"https://lucifer.ren/blog/2020/06/06/algo-chrome-extension/","excerpt":"这两天我写了一个浏览器插件，这个插件的定位就是帮助大家提高刷题效率。","text":"这两天我写了一个浏览器插件，这个插件的定位就是帮助大家提高刷题效率。 功能介绍目前主要有四个部分组成： 前置知识。 如果你想刷这道题，你需要掌握的知识是什么？如果没掌握这个前置知识，你是刷不出来的。提醒你去复习什么东西。 关键点。有了前置知识，并不代表你就能想到，并不代表你就能做出来。有一些关键点你是要想到，不然要么就是做不出来，要么就是解法效率很低。 题解。 这里精选一些好的题解，帮助大家少走弯路。目前只放了我的题解，后续可能会陆续增加其他优秀题解。 代码。 大家可以直接复制进行调试。 计划中的功能： 国内哪个公司出过这道题， 这对于想进某一家公司的人很有用 可视化调试 复杂度分析小工具 具体做什么，等出来之后再和大家同步 如何使用（暂时没开放下载，正式开放时间等公众号通知） 下载插件 用 chrome 浏览器，访问 chrome://extensions/ 点击 load unpackd，选择刚刚下载好的插件 现在去 leetcode 就随便找一个题看看吧。 PS: 对于收录的题，展示效果类似上面的截图。对于未收录的题，展示效果如下图 视频我这里录制了一个视频，关于这个插件的。https://www.bilibili.com/video/BV1UK4y1x7zj/ 如何贡献 关注公众号《力扣加加》，点击更多 - 联系我，添加我为好友，备注插件开发。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"https://lucifer.ren/blog/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"扩展程序","slug":"扩展程序","permalink":"https://lucifer.ren/blog/tags/扩展程序/"},{"name":"Chrome","slug":"Chrome","permalink":"https://lucifer.ren/blog/tags/Chrome/"}]},{"title":"【异议！】第一期 《这个🦅题的复杂度怎么分析？》","slug":"over-fancy01","date":"2020-06-02T16:00:00.000Z","updated":"2020-06-03T08:46:26.345Z","comments":true,"path":"2020/06/03/over-fancy01/","link":"","permalink":"https://lucifer.ren/blog/2020/06/03/over-fancy01/","excerpt":"力扣加加，努力做西湖区最好的算法题解。 去年的一年时间，我在群里每天都会出题给大家做。但是就在 2020-03 开始，力扣也开展了每日一题活动。我突然觉得这个每日一题的必要性变得小了很多，并且逐渐减少了出题频率。但是我还是不愿意放弃大家一起集中进行交流学习的机会。于是我打算新开辟一个专题，这个专题一方面要和力扣官方的每日一题重合度低，另一方面要让大家有参与的热情。 \b 于是【异议！】系列应运而生。它是个什么东西呢？ 我相信大家一定在平时刷算法的过程中，一定遇到过“这解法怎么想到的？”，“这解法不对吧？”的情况，并且可悲的是没有人能够回答你。来这里，力扣加加 来回答你。 我们会对大家提出的问题进行筛选，将有意义的问题开放出来给大家讨论和学习。 本次给大家带来的/是【异议！】系列第一篇。","text":"力扣加加，努力做西湖区最好的算法题解。 去年的一年时间，我在群里每天都会出题给大家做。但是就在 2020-03 开始，力扣也开展了每日一题活动。我突然觉得这个每日一题的必要性变得小了很多，并且逐渐减少了出题频率。但是我还是不愿意放弃大家一起集中进行交流学习的机会。于是我打算新开辟一个专题，这个专题一方面要和力扣官方的每日一题重合度低，另一方面要让大家有参与的热情。 \b 于是【异议！】系列应运而生。它是个什么东西呢？ 我相信大家一定在平时刷算法的过程中，一定遇到过“这解法怎么想到的？”，“这解法不对吧？”的情况，并且可悲的是没有人能够回答你。来这里，力扣加加 来回答你。 我们会对大家提出的问题进行筛选，将有意义的问题开放出来给大家讨论和学习。 本次给大家带来的/是【异议！】系列第一篇。 事情的起源昨天有人在我的力扣题解下留言，说我的时间复杂度解释有问题。思考再三，决定将这个问题抛出来大家一起讨论一下，我会在明天的公众号给大家公布参考答案。对于回答正确且点赞数最高的，我会送出 8.88 的现金红包，参与方式以及要求在文末。 其实这是一道前几天的力扣官方每日一题，我们先来看一下题目描述： 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 输入: [2,1,5,6,2,3] 输出: 10 那么问题来了这个题目我给出了四个解法，其中前两个是超时的，后两个是可以 AC 的。 而后两个可以 AC 的有一个是单调栈的解法，这个单调栈的解法有两个精妙的地方。第一是哨兵元素的选取，第二是是用了一个栈而不是两个。 另外一个可以 AC 的解法，也就是今天我们要讨论的解法，这个解法使用了两个数组，相对于单调栈的复杂度，其常系数更大，但是其思路同样巧妙。 为了大家更好的理解这个解法，我这里贴一下它的未被优化版本。思路为： 暴力尝试所有可能的矩形。从中心向两边进行扩展。对于每一个 i，我们计算出其左边第一个高度小于它的索引 p，同样地，计算出右边第一个高度小于它的索引 q。那么以 i 为最低点能够构成的面积就是(q - p - 1) * heights[i]。 这种算法毫无疑问也是正确的。 假设 f(i) 表示求以 i 为最低点的情况下，所能形成的最大矩阵面积。那么原问题转化为max(f(0), f(1), f(2), ..., f(n - 1))。 具体算法如下： 我们使用 l 和 r 数组。l[i] 表示 左边第一个高度小于它的索引，r[i] 表示 右边第一个高度小于它的索引。 我们从前往后求出 l，再从后往前计算出 r。 再次遍历求出所有的可能面积，并取出最大的。 代码： 1234567891011121314151617class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: n = len(heights) l, r, ans = [-1] * n, [n] * n, 0 for i in range(1, n): j = i - 1 while j &gt;= 0 and heights[j] &gt;= heights[i]: j -= 1 l[i] = j for i in range(n - 2, -1, -1): j = i + 1 while j &lt; n and heights[j] &gt;= heights[i]: j += 1 r[i] = j for i in range(n): ans = max(ans, heights[i] * (r[i] - l[i] - 1)) return ans 其实 while 循环内部是没有必要一格一格移动的。 举例来说，对于数组[1,2,3,4,5]，我们要建立 r 数组。我们从 4 开始，4 的右侧第一个小于它索引的是 n（表示不存在）。同样 3 的右侧第一个小于它索引的也是 n（表示不存在），以此类推。如果用上面的解法的话，我们每次都需要从当前位置遍历到尾部，时间复杂度为$O(N^2)$。 实际上，比如遍历到 2 的时候，我们拿 2 和前面的 3 比较，发现 3 比 2 大，并且我们之前计算出了比 3 大的右侧第一个小于它索引的是 n，也就是说我们可以直接移动到 n 继续搜索，因为这中间的都比 3 大，自然比 2 大了，没有比较的意义。 这样看来时间复杂度就被优化到了$O(N)$。 代码： 123456789101112131415161718class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: n = len(heights) l, r, ans = [-1] * n, [n] * n, 0 for i in range(1, n): j = i - 1 while j &gt;= 0 and heights[j] &gt;= heights[i]: j = l[j] l[i] = j for i in range(n - 2, -1, -1): j = i + 1 while j &lt; n and heights[j] &gt;= heights[i]: j = r[j] r[i] = j for i in range(n): ans = max(ans, heights[i] * (r[i] - l[i] - 1)) return ans 这位读者看到这里产生了一个疑问，这个疑问就是我开篇所讲的。我们来看下他是怎么说的。 这位读者提到交替的这种情况时间复杂度会退化到$O(N^2)$，那么实际情况真的是这样么？ 悬赏大家对上面的优化后的算法复杂度是怎么看的？请留言告诉我！ 需要注意的是： 我们所说的复杂度是渐进复杂度，也就是说是忽略常数项的。而这里我要求你带上常系数。 这里要求计算的是整个完整算法的复杂度。 请分别说出该算法在最差情况，最好情况下的复杂度。 参与方式：复制链接，并在浏览器打开，然后在里面评论即可。链接地址：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-zhu-zhuang-tu-zhong-zui-da-de-ju-xing-duo-chong/ 大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解。","categories":[{"name":"异议！","slug":"异议！","permalink":"https://lucifer.ren/blog/categories/异议！/"}],"tags":[{"name":"异议！","slug":"异议！","permalink":"https://lucifer.ren/blog/tags/异议！/"}]},{"title":"听说这题套个BFS模板就可以 AC？","slug":"1091.shortest-path-in-binary-matrix","date":"2020-06-02T06:08:24.143Z","updated":"2020-06-02T08:10:17.418Z","comments":true,"path":"2020/06/02/1091.shortest-path-in-binary-matrix/","link":"","permalink":"https://lucifer.ren/blog/2020/06/02/1091.shortest-path-in-binary-matrix/","excerpt":"​","text":"​ 题目描述123456789在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。一条从左上角到右下角、长度为 k 的畅通路径，由满足下述条件的单元格 C_1, C_2, ..., C_k 组成：相邻单元格 C*i 和 C*&#123;i+1&#125; 在八个方向之一上连通（此时，C*i 和 C*&#123;i+1&#125; 不同且共享边或角）C_1 位于 (0, 0)（即，值为 grid[0][0]）C_k 位于 (N-1, N-1)（即，值为 grid[N-1][n-1]）如果 C_i 位于 (r, c)，则 grid[r][c] 为空（即，grid[r][c] == 0）返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。 示例 1： 输入：[[0,1],[1,0]] 输出：2 示例 2： 输入：[[0,0,0],[1,1,0],[1,1,0]] 输出：4 提示： 1 &lt;= grid.length == grid[0].length &lt;= 100grid[i][j] 为 0 或 1 思路这道题乍一看很像之前写过的一些“机器人”。但是不同的地方在于机器人只能“向下移动和向右移动”，因此机器人那个题目就很适合用动态规划来做。为什么呢？ 因为这道题可以移动的范围是八个方向，题目给的示例不是很好，我这里给大家画了一个示例。我相信你一看就明白了。 （图 1） 如图，我们发现每一个点的状态其实依赖了周围八个方向。如果我们使用动态规划来求解的时候，我们如何遍历（枚举所有子问题）呢？ 由于每一个 cell 依赖了周围八个 cell，那么我应该先更新谁呢？这个问题就会比较复杂。 具体来说， 当我需要计算 dp[1][2]的值的时候，实际上我需要先计算dp[0][2]，dp[1][1]，dp[2][2] … 等八个值，这样才能确定 dp[1][2]的值。而计算 dp[0][2] 又是八个值，dp[1][1]等也是同理。 这样就会很复杂。 而如果你做题比较多的话，分析到这里会发现，应该会想到 BFS。 即使你做题不多，那么根据题目给出的关键字最短畅通路径，也应该想到 BFS 才对。 这道题我直接复制了一个我直接总结的模板，稍微改了一下就 OK 了。大家也可以在平时刷题过程总结自己的解题模板，这在争分夺秒的打比赛环节是很重要的。 我复制的模板是下面这个，大家可以对比下我提交的代码看看相似度有多少。 12345678910111213141516171819202122232425class Solution: def updateMatrix(self, matrix: List[List[int]]) -&gt; List[List[int]]: m = len(matrix) if m == 0: return [] n = len(matrix[0]) ans = [[0] * n for _ in range(m)] seen = set() queue = collections.deque() steps = 0 for i in range(m): for j in range(n): if matrix[i][j] == 0: queue.append((i, j)) seen.add((i, j)) while queue: for _ in range(len(queue)): i, j = queue.popleft() if matrix[i][j] == 1: ans[i][j] = steps for x, y in [(i + 1, j), (i - 1, j),(i, j + 1),(i, j - 1)]: if x &gt;= 0 and x &lt; m and y &gt;=0 and y &lt; n and (x, y) not in seen: queue.append((x, y)) seen.add((x, y)) steps += 1 return ans （Python BFS 模板代码） 我来用伪代码解释下这段代码的意思： 1234567891011121314151617template BFS(board) &#123; 边界处理 seen = set() # 存储已经遍历过的节点，防止环的出现。 初始化队列 steps = 0 while 队列不为空 &#123; 逐个取出队列中的元素（不包括在 while 循环内新添加的） if 满足条件 return steps for dir in dirs &#123; 将周围的都加到队列，注意边界处理 &#125; steps += 1 &#125; return 不存在（一般是 -1）&#125; （BFS 模板伪代码） 大家可以根据我的伪代码，自己定制属于自己的模板。 值得注意的是，本题我并没有使用 seen 来记录访问过的节点，而是直接原地修改，这是一个很常见的技巧，对这个技巧不熟悉的可以看下我的小岛专题 关键点 BFS BFS 模板 代码代码支持：Python3 123456789101112131415161718192021class Solution: def shortestPathBinaryMatrix(self, grid: List[List[int]]) -&gt; int: n = len(grid) if not grid or grid[0][0] == 1 or grid[n-1][n-1] == 1: return -1 steps = 1 queue = collections.deque() queue.append((0, 0)) grid[0][0] = 1 while queue: for _ in range(len(queue)): i, j = queue.popleft() if i == n - 1 and j == n - 1: return steps for dx, dy in [(-1,-1), (1,0), (0,1), (-1,0), (0,-1), (1,1), (1,-1), (-1,1)]: # 注意越界处理 if 0 &lt;= i + dx &lt; n and 0 &lt;= j + dy &lt; n and grid[i+dx][j+dy] == 0: queue.append((i + dx, j + dy)) grid[i + dx][j + dy] = 1 steps += 1 return -1 复杂度分析 时间复杂度：最坏的情况，我们需要遍历整个 board，因此时间复杂度取决于 cell 数，故时间复杂度为 $O(N ^ 2)$，其中 N 为边长。 空间复杂度：我们没有使用 seen，仅仅是借助了队列， 故空间复杂度为 $O(N)$，如果使用 seen 的话复杂度会上升到$O(N ^ 2)$，其中 N 为边长。 补充： 空间复杂度的$O(N)$ 是怎么来的？ 我这里给大家画了一个图， 相信大家一下子就懂来。其中不同的颜色表示不同的层次，从红色开始表示第一层，然后往外扩张。可以看出队列最长的情况下和$N$同阶，因此空间复杂度为$O(N)$。 相关题目 200. 岛屿数量 695. 岛屿的最大面积 1162. 地图分析 62. 不同路径 更多题解可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。 目前已经 30K star 啦。 大家也可以关注我的公众号《力扣加加 sa》获取更多更新鲜的 LeetCode 题解","categories":[{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"BFS","slug":"算法/BFS","permalink":"https://lucifer.ren/blog/categories/算法/BFS/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"数学","slug":"数学","permalink":"https://lucifer.ren/blog/tags/数学/"},{"name":"BFS","slug":"BFS","permalink":"https://lucifer.ren/blog/tags/BFS/"}]},{"title":"力扣加加闪亮登场～","slug":"leetcode-pp","date":"2020-06-01T07:25:20.807Z","updated":"2020-06-15T13:58:36.552Z","comments":true,"path":"2020/06/01/leetcode-pp/","link":"","permalink":"https://lucifer.ren/blog/2020/06/01/leetcode-pp/","excerpt":"力扣加加，一个努力做西湖区最好的算法题解的团队。 ​","text":"力扣加加，一个努力做西湖区最好的算法题解的团队。 ​ 12脑洞前端：你已经长大了，是时候自己写题解了。力扣加加：。。。 独立的原因是让公众号的定位更加清晰，喜欢我的题解的朋友可以关注力扣加加，喜欢我的前端架构剖析，徒手造框架的朋友可以关注脑洞前端。当然如果你同时关注两个，那我会感动到哭。 虽然是新的公众号，但是我的初心不变，依然是力求用清晰直白的方式还原解题过程，努力做西湖区最好的算法题解。最后感谢大家一路以来的支持，我一定不负众望，越做越好。 规划预计力扣加加会推出五个板块。 91 算法 通过在 91 天的集中训练，帮助大家摆脱困境，征服算法。我们会帮助大家规划学习路线，91 天见证不一样的自己。群里会有专门的资深算法竞赛大佬坐阵解答大家的问题和疑问，并且会对前一天的题目进行讲解。我会在结束之后将讲义和题解放到公众号号。 （仓库部分内容） 算法题解就是对力扣中的题目进行讲解，尤其是经典的题目。并且尽量从多个角度思路，帮助大家纵向打开解题思路。目前差不多有几百的题解了。 专题讲解对于共性比较强的，我会抽离成专题形式，帮助大家横向打开解题思路。 （之后会陆续加入更多专题） 视频题解对于一些题目采用视频的方式可能更加直观方便，之后还会考虑直播。 刷题工具初步规划了两个小工具，之后出测试版本会第一时间告诉大家，如果你对开发小工具感兴趣，也可以点击公众号的联系我来和我取得联系。 （力扣加加刷题小助手） 悬赏令大家在日常生活或是在刷题过程中有时一定会产生一些疑问，百度谷歌翻来覆去的找也找不到心中所期待的答案，因此，大家可以通过力扣加加来将这些疑问提出来，不定期从大家的问题中挑选出比较经典的几个问题来供大家一起讨论，大致的问题类型如下： 日常生活中有个问题想用数据结构+算法解决，但苦于思路不清晰 问题本身比较纠结，网上众说纷纭，找不到明确的答案 脑洞问题等等 （比如这种问题） 被抽中的问题对应的朋友及问题回答出色的朋友可以获得准备的小礼物哦！ 最后，每周我们会根据公众号后台的阅读量及分享次数最多的小伙伴给予现金奖励奖励哦～。分享最多 1 人 8.88 红包，阅读最多的 1 人 6.66 红包。\u001c 不是第一也没有关系，我们会从分享排名 2-10撒 名的小伙伴中随机抽取2个 8.88 元红包，阅读排名 2-10 名的小伙伴中随机抽取2个 6.88 元红包， 每周日下午，我们会对本周的数据进行统计，并随机抽取幸运的小伙伴，并对中奖结果在力扣加加公众号进行公布，中奖的小伙伴请主动联系我哦。领奖时间截止到每周日的 24:00。 关注我公众号点关注，不迷路。如果再给 ➕ 个星标就更棒啦！ 关注加加，星标加加～ 官网 力扣加加官网","categories":[{"name":"力扣加加","slug":"力扣加加","permalink":"https://lucifer.ren/blog/categories/力扣加加/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"算法提高班","slug":"算法提高班","permalink":"https://lucifer.ren/blog/tags/算法提高班/"},{"name":"力扣加加","slug":"力扣加加","permalink":"https://lucifer.ren/blog/tags/力扣加加/"}]},{"title":"【LeetCode日记】 312. 戳气球","slug":"312.burst-balloons","date":"2020-06-01T02:20:38.111Z","updated":"2020-06-01T02:21:26.558Z","comments":true,"path":"2020/06/01/312.burst-balloons/","link":"","permalink":"https://lucifer.ren/blog/2020/06/01/312.burst-balloons/","excerpt":"​","text":"​ 312. 戳气球 作者：dp 加加 这是一道比较难且巧妙的动态规划题目；这道题目并不适合初学者看，比较适合 dp 进阶选手研究。好了，废话不多说，直接上菜。 题目描述12345678910111213141516有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。求所能获得硬币的最大数量。说明:你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100示例:输入: [3,1,5,8]输出: 167解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; [] coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 思路回溯法分析一下这道题，就是要截破所有的气球，获得硬币的最大数量，然后左右两边的气球相邻了。那就截呗，我的第一反应就是暴力，回溯法；但是肯定会超时，为什么呢？因为题目给的气球数量有点多，最多 500 个；500 的阶乘，会超时爆栈；但是我们依然写一下代码，找下突破口，小伙伴们千万不要看不起暴力，暴力是优化的突破口；如果小伙伴对回溯法不太熟悉，我建议你记住下面的模版，也可以看我之前写的文章，回溯法基本可以使用以下的模版写。回溯法省心省力，0 智商负担，懂的朋友都懂，QAQ。 代码12345678910111213141516171819202122232425var maxCoins = function (nums) &#123; let res = Number.MIN_VALUE; backtrack(nums, 0); return res; // 回溯法，状态树很大 function backtrack(nums, score) &#123; if (nums.length == 0) &#123; res = Math.max(res, score); return; &#125; for (let i = 0, n = nums.length; i &lt; n; i++) &#123; let point = (i - 1 &lt; 0 ? 1 : nums[i - 1]) * nums[i] * (i + 1 &gt;= n ? 1 : nums[i + 1]); let tempNums = [].concat(nums); // 做选择 在 nums 中删除元素 nums[i] nums.splice(i, 1); // 递归回溯 backtrack(nums, score + point); // 撤销选择 nums = [...tempNums]; &#125; &#125;&#125;; 动态规划回溯法的缺点也很明显，复杂度很高，对应本题截气球；小伙伴们可以脑补一下执行过程的状态树，这里我偷个懒就不画了；通过仔细观察这个状态树，我们会发现这个状态树的【选择】上，会有一些重复的选择分支；很明显存在了重复子问题；自然我就想到了能不能用动态规划来解决； 判读能不能用动态规划解决，还有一个问题，就是必须存在最优子结构；什么意思呢？其实就是根据局部最优，推导出答案；假设我们截破第 k 个气球是最优策略的最后一步，和上一步有没有联系呢？根据题目意思，截破第 k 个，前一个和后一个就变成相邻的了，看似是会有联系，其实是没有的。因为截破第 k 个和 k-1 个是没有联系的，脑补一下回溯法的状态树就更加明确了； 既然用动态规划，那就老套路了，把动态规划的三个问题想清楚定义好；然后找出题目的【状态】和【选择】，然后根据【状态】枚举，枚举的过程中根据【选择】计算递推就能得到答案了。 那本题的【选择】是什么呢？就是截哪一个气球。那【状态】呢？就是题目给的气球数量。 定义状态 这里有个细节，就是题目说明有两个虚拟气球，nums[-1] = nums[n] = 1；如果当前截破的气球是最后一个或者第一个，前面/后面没有气球了，不能乘以 0，而是乘以 1。 定义状态的最关键两个点，往子问题（问题规模变小）想，最后一步最优策略是什么；我们假设最后截破的气球是 k，截破 k 获得最大数量的银币就是 nums[i] _ nums[k] _ nums[j] 再加上前面截破的最大数量和后面的最大数量，即：nums[i] _ nums[k] _ nums[j] + 前面最大数量 + 后面最大数量，就是答案。 而如果我们不考虑两个虚拟气球而直接定义状态，截到最后两个气球的时候又该怎么定义状态来避免和前面的产生联系呢？这两个虚拟气球就恰到好处了，太细节了；这也是本题的一个难点之一。 那我们可以这样来定义状态，dp[i][j] = x 表示，戳破气球 i 和气球 j 之间（开区间，不包括 i 和 j）的所有气球，可以获得的最大硬币数为 x。为什么开区间？因为不能和已经计算过的产生联系，我们这样定义之后，利用两个虚拟气球，截到最后两个气球的时候就完美的避开了所有状态的联系，太细节了。 状态转移方程 而对于 dp[i][j]，i 和 j 之间会有很多气球，到底该截哪个先呢？我们直接设为 k，枚举选择最优的 k 就可以了。 所以，最终的状态转移方程为：dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[k] + nums[i] + nums[j]) 初始值和边界 由于我们利用了两个虚拟气球，边界就是气球数 n + 2 初始值，当 i == j 时，很明显两个之间没有气球，所有为 0； 如何枚举状态 因为我们最终要求的答案是 dp[0][n + 1]，就是截破虚拟气球之间的所有气球获得的最大值； 当 i == j 时，i 和 j 之间是没有气球的，所以枚举的状态很明显是 dp table 的左上部分，也就是 j 大于 i，如下图所示，只给出一部分方便思考。 从上图可以看出，我们需要从下到上，从左到右进行遍历。 代码12345678910111213141516171819var maxCoins = function (nums) &#123; let n = nums.length; // 添加两侧的虚拟气球 let points = [1, ...nums, 1]; let dp = Array.from(Array(n + 2), () =&gt; Array(n + 2).fill(0)); // 最后一行开始遍历,从下往上 for (let i = n; i &gt;= 0; i--) &#123; // 从左往右 for (let j = i + 1; j &lt; n + 2; j++) &#123; for (let k = i + 1; k &lt; j; k++) &#123; dp[i][j] = Math.max( dp[i][j], points[j] * points[k] * points[i] + dp[i][k] + dp[k][j] ); &#125; &#125; &#125; return dp[0][n + 1];&#125;; 总结简单的 dp 题目会直接告诉你怎么定义状态，告诉你怎么选择计算，你只需要根据套路判断一下能不能用 dp 解题即可，而判断能不能，往往暴力就是突破口。而困难点的 dp，我觉的都是细节问题了，要注意的细节太多了。感觉力扣加加，路西法大佬，把我领进了动态规划的大门，共勉。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"数组","slug":"数据结构/数组","permalink":"https://lucifer.ren/blog/categories/数据结构/数组/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://lucifer.ren/blog/categories/算法/动态规划/"},{"name":"回溯","slug":"算法/回溯","permalink":"https://lucifer.ren/blog/categories/算法/回溯/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode日记","slug":"LeetCode日记","permalink":"https://lucifer.ren/blog/tags/LeetCode日记/"}]},{"title":"【LeetCode日记】 101. 对称二叉树","slug":"101.symmetric-tree","date":"2020-05-31T06:28:36.936Z","updated":"2020-05-31T10:11:06.175Z","comments":true,"path":"2020/05/31/101.symmetric-tree/","link":"","permalink":"https://lucifer.ren/blog/2020/05/31/101.symmetric-tree/","excerpt":"​","text":"​ 题目地址(101. 对称二叉树)https://leetcode-cn.com/problems/symmetric-tree/ 题目描述12345678910111213141516171819202122232425给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 进阶：你可以运用递归和迭代两种方法解决这个问题吗？ 思路看到这题的时候，我的第一直觉是 DFS。然后我就想:如果左子树是镜像，并且右子树也是镜像，是不是就说明整体是镜像？。经过几秒的思考， 这显然是不对的，不符合题意。 很明显其中左子树中的节点会和右子树中的节点进行比较，我把比较的元素进行了颜色区分，方便大家看。 这里我的想法是：遍历每一个节点的时候，我都可以通过某种方法知道它对应的对称节点是谁。这样的话我直接比较两者是否一致就行了。 最初我的想法是两次遍历，第一次遍历的同时将遍历结果存储到哈希表中，然后第二次遍历去哈希表取。 这种方法可行，但是需要 N 的空间（N 为节点总数）。我想到如果两者可以同时进行遍历，是不是就省去了哈希表的开销。 如果不明白的话，我举个简单例子： 1给定一个数组，检查它是否是镜像对称的。例如，数组 [1,2,2,3,2,2,1] 是对称的。 如果用哈希表的话大概是： 1234567seen = dict()for i, num in enumerate(nums): seen[i] = numfor i, num in enumerate(nums): if seen[len(nums) - 1 - i] != num: return Falsereturn True 而同时遍历的话大概是这样的： 12345678l = 0r = len(nums) - 1while l &lt; r: if nums[l] != nums[r]: return False l += 1 r -= 1return True 其实更像本题一点的话应该是从中间分别向两边扩展 😂 代码12345678910class Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: def dfs(root1, root2): if root1 == root2: return True if not root1 or not root2: return False if root1.val != root2.val: return False return dfs(root1.left, root2.right) and dfs(root1.right, root2.left) if not root: return True return dfs(root.left, root.right) 复杂度分析 时间复杂度：$O(N)$，其中 N 为节点数。 空间复杂度：递归的深度最高为节点数，因此空间复杂度是 $O(N)$，其中 N 为节点数。 更多题解可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。 目前已经 30K star 啦。 大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的 LeetCode 题解","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"hashtable","slug":"数据结构/hashtable","permalink":"https://lucifer.ren/blog/categories/数据结构/hashtable/"},{"name":"DFS","slug":"算法/DFS","permalink":"https://lucifer.ren/blog/categories/算法/DFS/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode日记","slug":"LeetCode日记","permalink":"https://lucifer.ren/blog/tags/LeetCode日记/"}]},{"title":"【LeetCode日记】 1449. 数位成本和为目标值的最大数字","slug":"1449.form-largest-integer-with-digits-that-add-up-to-target","date":"2020-05-30T11:51:01.444Z","updated":"2020-05-30T12:21:52.715Z","comments":true,"path":"2020/05/30/1449.form-largest-integer-with-digits-that-add-up-to-target/","link":"","permalink":"https://lucifer.ren/blog/2020/05/30/1449.form-largest-integer-with-digits-that-add-up-to-target/","excerpt":"这是一道难度 Hard 的经典背包问题，属于完全背包问题，来看看背包问题的套路吧～ ​","text":"这是一道难度 Hard 的经典背包问题，属于完全背包问题，来看看背包问题的套路吧～ ​ 题目地址（1449. 数位成本和为目标值的最大数字）https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/ 题目描述1234567891011121314151617181920212223242526272829303132333435363738394041424344454647给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 最大 整数：给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。总成本必须恰好等于 target 。添加的数位中没有数字 0 。由于答案可能会很大，请你以字符串形式返回。如果按照上述要求无法得到任何整数，请你返回 &quot;0&quot; 。 示例 1：输入：cost = [4,3,2,5,6,7,2,5,5], target = 9输出：&quot;7772&quot;解释：添加数位 &apos;7&apos; 的成本为 2 ，添加数位 &apos;2&apos; 的成本为 3 。所以 &quot;7772&quot; 的代价为 2*3+ 3*1 = 9 。 &quot;997&quot; 也是满足要求的数字，但 &quot;7772&quot; 是较大的数字。 数字 成本 1 -&gt; 4 2 -&gt; 3 3 -&gt; 2 4 -&gt; 5 5 -&gt; 6 6 -&gt; 7 7 -&gt; 2 8 -&gt; 5 9 -&gt; 5示例 2：输入：cost = [7,6,5,5,5,6,8,7,8], target = 12输出：&quot;85&quot;解释：添加数位 &apos;8&apos; 的成本是 7 ，添加数位 &apos;5&apos; 的成本是 5 。&quot;85&quot; 的成本为 7 + 5 = 12 。示例 3：输入：cost = [2,4,6,2,4,6,4,4,4], target = 5输出：&quot;0&quot;解释：总成本是 target 的条件下，无法生成任何整数。示例 4：输入：cost = [6,10,15,40,40,40,40,40,40], target = 47输出：&quot;32211&quot; 提示：cost.length == 91 &lt;= cost[i] &lt;= 50001 &lt;= target &lt;= 5000 思路由于数组可以重复选择，因此这是一个完全背包问题。 01 背包对于 01 背包问题，我们的套路是： 123for i in 0 to N: for j in 1 to V + 1: dp[j] = max(dp[j], dp[j - cost[i]) 而一般我们为了处理边界问题，我们一般会这么写代码： 1234for i in 1 to N + 1: # 这里是倒序的，原因在于这里是01背包。 for j in V to 0: dp[j] = max(dp[j], dp[j - cost[i - 1]) 其中 dp[j] 表示只能选择前 i 个物品，背包容量为 j 的情况下，能够获得的最大价值。 dp[j] 不是没 i 么？ 其实我这里 i 指的是 dp[j]当前所处的循环中的 i 值 完全背包问题回到问题，我们这是完全背包问题: 1234for i in 1 to N + 1: # 这里不是倒序，原因是我们这里是完全背包问题 for j in 1 to V + 1: dp[j] = max(dp[j], dp[j - cost[i - 1]) 为什么 01 背包需要倒序，而完全背包则不可以实际上，这是一个骚操作，我来详细给你讲一下。 其实要回答这个问题，我要先将 01 背包和完全背包退化二维的情况。 对于 01 背包： 123for i in 1 to N + 1: for j in V to 0: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cost[i - 1]) 注意等号左边是 i，右边是 i - 1，这很好理解，因为 i 只能取一次嘛。 那么如果我们不降序遍历会怎么样呢？ 如图橙色部分表示已经遍历的部分，而让我们去用[j - cost[i - 1]] 往前面回溯的时候，实际上回溯的是 dp[i]j - cost[i - 1]]，而不是 dp[i - 1]j - cost[i - 1]]。 如果是降序就可以了，如图： 这个明白的话，我们继续思考为什么完全背包就要不降序了呢？ 我们还是像上面一样写出二维的代码： 123for i in 1 to N + 1: for j in 1 to V + 1: dp[i][j] = max(dp[i - 1][j], dp[i][j - cost[i - 1]) 由于 i 可以取无数次，那么正序遍历正好可以满足，如上图。 恰好装满 VS 可以不装满题目有两种可能，一种是要求背包恰好装满，一种是可以不装满（只要不超过容量就行）。而本题是要求恰好装满的。而这两种情况仅仅影响我们dp数组初始化。 恰好装满。只需要初始化 dp[0] 为 0， 其他初始化为负数即可。 可以不装满。 只需要全部初始化为 0，即可， 原因很简单，我多次强调过 dp 数组本质上是记录了一个个自问题。 dp[0]是一个子问题，dp[1]是一个子问题。。。 有了上面的知识就不难理解了。 初始化的时候，我们还没有进行任何选择，那么也就是说 dp[0] = 0，因为我们可以通过什么都不选达到最大值 0。而 dp[1],dp[2]…则在当前什么都不选的情况下无法达成，也就是无解，因为为了区分，我们可以用负数来表示，当然你可以用任何可以区分的东西表示，比如 None。 回到本题而这道题和普通的完全背包不一样，这个是选择一个组成的最大数。由小学数学知识一个数字的全排列中，按照数字降序排列是最大的，我这里用了一个骚操作，那就是 cost 从后往前遍历，因为后面表示的数字大。 代码12345678class Solution: def largestNumber(self, cost: List[int], target: int) -&gt; str: dp = [0] + [float('-inf')] * target for i in range(9, 0, -1): for j in range(1, target+1): if j &gt;= cost[i - 1]: dp[j] = max(dp[j], (dp[j-cost[i - 1]] * 10) + i) return str(dp[target]) if dp[target] &gt; 0 else '0' 复杂度分析 时间复杂度：$O(target))$ 空间复杂度：$O(target)$ 扩展最后贴几个我写过的背包问题，让大家看看历史是多么的相似。 （322. 硬币找零(完全背包问题)） 这里内外循环和本题正好是反的，我只是为了”秀技”(好玩)，实际上在这里对答案并不影响。 （518. 零钱兑换 II） 这里内外循环和本题正好是反的，但是这里必须这么做，否则结果是不对的，具体可以点进去链接看我那个题解 所以这两层循环的位置起的实际作用是什么？ 代表的含义有什么不同？ 本质上: 123for i in 1 to N + 1: for j in V to 0: ... 这种情况选择物品 1 和物品 3（随便举的例子），是一种方式。选择物品 3 个物品 1（注意是有顺序的）是同一种方式。 原因在于你是固定物品，去扫描容量。 而： 123for j in V to 0: for i in 1 to N + 1: ... 这种情况选择物品 1 和物品 3（随便举的例子），是一种方式。选择物品 3 个物品 1（注意是有顺序的）也是一种方式。原因在于你是固定容量，去扫描物品。 因此总的来说，如果你认为[1,3]和[3,1]是一种，那么就用方法 1 的遍历，否则用方法 2。 更多题解可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。 目前已经 30K star 啦。 大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的 LeetCode 题解","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"数组","slug":"数据结构/数组","permalink":"https://lucifer.ren/blog/categories/数据结构/数组/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://lucifer.ren/blog/categories/算法/动态规划/"},{"name":"背包问题","slug":"算法/背包问题","permalink":"https://lucifer.ren/blog/categories/算法/背包问题/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode日记","slug":"LeetCode日记","permalink":"https://lucifer.ren/blog/tags/LeetCode日记/"}]},{"title":"倒计时两天～91算法，儿童节发车！","slug":"91algo-05-30","date":"2020-05-30T03:40:06.964Z","updated":"2020-05-30T03:56:33.100Z","comments":true,"path":"2020/05/30/91algo-05-30/","link":"","permalink":"https://lucifer.ren/blog/2020/05/30/91algo-05-30/","excerpt":"力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。 ​","text":"力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。 ​ 91 算法第一期，从2020-06-01 到 2020-08-30。 马上就要发车了哦，大家准备好了么？儿童节，我们来啦。如果还有没参与的小伙伴，想要参与的可以在下方更多部分寻找参与方式，目前支持 QQ 和微信加入。 简介共分为三篇，基础篇，进阶篇和专题篇。 让你： 显著提高你的刷题效率，让你少走弯路 掌握常见面试题的思路和解法 掌握常见套路，了解常见算法的本质，横向对比各种题目 纵向剖析一道题，多种方法不同角度解决同一题目 第一阶段基础篇(30 天)。预计五个子栏目，每个子栏目 6 天。到时候发讲义给大家，题目的话天一道。 讲义的内容大概是我在下方讲义部分放出的链接那样哦。 规则大家的问题，打卡题目，讲义都在这里更新哦，冲鸭 🦆 。91 天见证更好的自己！不过要注意一周不打卡会被强制清退。 需要提前准备些什么？ 数据结构与算法的基础知识。 推荐看一下大学里面的教材讲义，或者看一些入门的图书，视频等，比如《图解算法》，邓俊辉的《数据结构与算法》免费视频课程。总之， 至少你要知道有哪些常见的数据结构与算法以及他们各自的特点。 有 Github 账号，且会使用 Github 常用操作。 比如提 issue，留言等。 有 LeetCode 账号，且会用其提交代码。 语言不限，大家可以用自己喜欢的任何语言。同时我也希望你不要纠结于语言本身。 具体形式是什么样的？ 总共三个大的阶段 每个大阶段划分为几个小阶段 每个小阶段前会将这个小阶段的资料发到群里 每个小阶段的时间内，每天都会出关于这个阶段的题目，第二天进行解答 比如： 第一个大阶段是基础 基础中第一个小阶段是数组，栈和队列。 数组，栈和队列正式开始前，会将资料发到群里，大家可以提前预习。 之后的每天都会围绕数组，栈和队列出一道题，第二天进行解答。大家可以在出题当天上 Github 上打卡。 大家遇到问题可以在群里回答，对于比较好的问题，会记录到 github issue 中，让更多的人看到。Github 仓库地址届时会在群里公布。 奖励对于坚持打卡满一个月的同学，可以参加抽奖，奖品包括算法模拟面试，算法相关的图书等连续打卡七天可以获得补签卡一张哦 讲义 【91 算法-基础篇】05.双指针 课程列表 回炉重铸， 91 天见证不一样的自己 更多 如何加入微信群？","categories":[{"name":"力扣加加","slug":"力扣加加","permalink":"https://lucifer.ren/blog/categories/力扣加加/"},{"name":"91天学算法","slug":"91天学算法","permalink":"https://lucifer.ren/blog/categories/91天学算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"算法提高班","slug":"算法提高班","permalink":"https://lucifer.ren/blog/tags/算法提高班/"},{"name":"91天学算法","slug":"91天学算法","permalink":"https://lucifer.ren/blog/tags/91天学算法/"},{"name":"力扣加加","slug":"力扣加加","permalink":"https://lucifer.ren/blog/tags/力扣加加/"}]},{"title":"【91算法-基础篇】05.双指针","slug":"91algo-basic-05.two-pointer","date":"2020-05-26T10:36:22.697Z","updated":"2020-06-11T12:39:54.954Z","comments":true,"path":"2020/05/26/91algo-basic-05.two-pointer/","link":"","permalink":"https://lucifer.ren/blog/2020/05/26/91algo-basic-05.two-pointer/","excerpt":"力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。 ​","text":"力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。 ​ 什么是双指针顾名思议，双指针就是两个指针，但是不同于 C，C++中的指针， 其是一种算法思想。 如果说，我们迭代一个数组，并输出数组每一项，我们需要一个指针来记录当前遍历的项，这个过程我们叫单指针（index）的话。 123for(int i = 0;i &lt; nums.size(); i++) &#123; 输出(nums[i]);&#125; （图 1） 那么双指针实际上就是有两个这样的指针，最为经典的就是二分法中的左右双指针啦。 12345678910int l = 0;int r = nums.size() - 1;while (l &lt; r) &#123; if(一定条件) return 合适的值，一般是 l 和 r 的中点 if(一定条件) l++ if(一定条件) r--&#125;// 因为 l == r，因此返回 l 和 r 都是一样的return l （图 2） 读到这里，你发现双指针是一个很宽泛的概念，就好像数组，链表一样，其类型会有很多很多， 比如二分法经常用到左右端点双指针。滑动窗口会用到快慢指针和固定间距指针。 因此双指针其实是一种综合性很强的类型，类似于数组，栈等。 但是我们这里所讲述的双指针，往往指的是某几种类型的双指针，而不是“只要有两个指针就是双指针了”。 有了这样一个算法框架，或者算法思维，有很大的好处。它能帮助你理清思路，当你碰到新的问题，在脑海里进行搜索的时候，双指针这个词就会在你脑海里闪过，闪过的同时你可以根据双指针的所有套路和这道题进行穷举匹配，这个思考解题过程本来就像是算法，我会在进阶篇《搜索算法》中详细阐述。 那么究竟我们算法中提到的双指针指的是什么呢？我们一起来看下算法中双指针的常见题型吧。 常见题型有哪些？这里我将其分为三种类类型，分别是： 快慢指针（两个指针步长不同） 左右端点指针（两个指针分别指向头尾，并往中间移动，步长不确定） 固定间距指针（两个指针间距相同，步长相同） 上面是我自己的分类，没有参考别人。可以发现我的分类标准已经覆盖了几乎所有常见的情况。 大家在平时做题的时候一定要养成这样的习惯，将题目类型进行总结，当然这个总结可以是别人总结好的，也可以是自己独立总结的。不管是哪一种，都要进行一定的消化吸收，把它们变成真正属于自己的知识。 不管是哪一种双指针，只考虑双指针部分的话 ，由于最多还是会遍历整个数组一次，因此时间复杂度取决于步长，如果步长是 1，2 这种常数的话，那么时间复杂度就是 O(N)，如果步长是和数据规模有关（比如二分法），其时间复杂度就是 O(logN)。并且由于不管规模多大，我们都只需要最多两个指针，因此空间复杂度是 O(1)。下面我们就来看看双指针的常见套路有哪些。 常见套路快慢指针 判断链表是否有环 这里给大家推荐两个非常经典的题目，一个是力扣 287 题，一个是 142 题。其中 142 题我在我的 LeetCode 题解仓库中的每日一题板块出过，并且给了很详细的证明和解答。而 287 题相对不直观，比较难以想到，这道题曾被官方选定为每日一题，也是相当经典的。 287. 寻找重复数 【每日一题】- 2020-01-14 - 142. 环形链表 II · Issue #274 · azl397985856/leetcode 读写指针。典型的是删除重复元素 这里推荐我仓库中的一道题， 我这里写了一个题解，横向对比了几个相似题目，并剖析了这种题目的本质是什么，让你看透题目本质，推荐阅读。 80.删除排序数组中的重复项 II 左右端点指针 二分查找。 二分查找会在专题篇展开，这里不多说，大家先知道就行了。 暴力枚举中“从大到小枚举”（剪枝） 一个典型的题目是我之前参加官方每日一题的时候给的一个解法，大家可以看下。这种解法是可以 AC 的。同样地，这道题我也给出了三种方法，帮助大家从多个纬度看清这个题目。强烈推荐大家做到一题多解。这对于你做题很多帮助。除了一题多解，还有一个大招是多题同解，这部分我们放在专题篇介绍。 find-the-longest-substring-containing-vowels-in-even 有序数组。 区别于上面的二分查找，这种算法指针移动是连续的，而不是跳跃性的，典型的是 LeetCode 的两数和，以及N数和系列问题。 固定间距指针 一次遍历（One Pass）求链表的中点 一次遍历（One Pass）求链表的倒数第 k 个元素 固定窗口大小的滑动窗口 模板(伪代码)我们来看下上面三种题目的算法框架是什么样的。这个时候我们没必要纠结具体的语言，这里我直接使用了伪代码，就是防止你掉进细节。 当你掌握了这种算法的细节，就应该找几个题目试试。一方面是检测自己是否真的掌握了，另一方面是“细节”，”细节“是人类，尤其是软件工程师最大的敌人，毕竟我们都是差不多先生。 快慢指针 1234567l = 0r = 0while 没有遍历完 if 一定条件 l += 1 r += 1return 合适的值 左右端点指针 12345678910l = 0r = n - 1while l &lt; r if 找到了 return 找到的值 if 一定条件1 l += 1 else if 一定条件2 r -= 1return 没找到 固定间距指针 1234567l = 0r = kwhile 没有遍历完 自定义逻辑 l += 1 r += 1return 合适的值 题目推荐如果你差不多理解了上面的东西，那么可以拿下面的题练练手。Let’s Go! 左右端点指针 16.3Sum Closest (Medium) 713.Subarray Product Less Than K (Medium) 977.Squares of a Sorted Array (Easy) Dutch National Flag Problem 下面是二分类型 33.Search in Rotated Sorted Array (Medium) 875.Koko Eating Bananas（Medium） 881.Boats to Save People（Medium） 快慢指针 26.Remove Duplicates from Sorted Array（Easy） 141.Linked List Cycle (Easy) 142.Linked List Cycle II（Medium） 287.Find the Duplicate Number（Medium） 202.Happy Number (Easy) 固定间距指针 1456.Maximum Number of Vowels in a Substring of Given Length（Medium） 固定窗口大小的滑动窗口见专题篇的滑动窗口专题（暂未发布） 其他有时候也不能太思维定式，比如 https://leetcode-cn.com/problems/consecutive-characters/ 这道题根本就没必要双指针什么的。 再比如：https://lucifer.ren/blog/2020/05/31/101.symmetric-tree/","categories":[{"name":"力扣加加","slug":"力扣加加","permalink":"https://lucifer.ren/blog/categories/力扣加加/"},{"name":"91天学算法","slug":"91天学算法","permalink":"https://lucifer.ren/blog/categories/91天学算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"算法提高班","slug":"算法提高班","permalink":"https://lucifer.ren/blog/tags/算法提高班/"},{"name":"91天学算法","slug":"91天学算法","permalink":"https://lucifer.ren/blog/tags/91天学算法/"},{"name":"力扣加加","slug":"力扣加加","permalink":"https://lucifer.ren/blog/tags/力扣加加/"}]},{"title":"回炉重铸， 91 天见证不一样的自己（2）","slug":"91-algo2","date":"2020-05-25T09:23:53.498Z","updated":"2020-05-30T03:52:03.239Z","comments":true,"path":"2020/05/25/91-algo2/","link":"","permalink":"https://lucifer.ren/blog/2020/05/25/91-algo2/","excerpt":"力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。前天想加入却没能加入的小伙伴可以进来啦，直接扫描文末二维码即可。 ​","text":"力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。前天想加入却没能加入的小伙伴可以进来啦，直接扫描文末二维码即可。 ​ 自从前天开始，就接到了非常多的入群申请， 我一个人忙不过来， 就暂停了入群，希望大家理解。今天除了宣布微信群今天开启入群 之外，还给大家带来了几个大家问的多的问题的答案。分别是我需要提前准备什么？，具体形式是怎么样的？，我还可以入群么？。 qq 群开放时间待定，开放后会第一时间在朋友圈和微信交流群进行告知 初衷为了让想学习的人能够真正学习到东西， 我打算新开一个栏目《91 天学算法》，在 91 天内来帮助那些想要学习算法，提升自己算法能力的同学，帮助大家建立完整的算法知识体系。 群里每天都会有题目，推荐大家讨论当天的题目。我们会帮助大家规划学习路线，91 天见证不一样的自己。群里会有专门的资深算法竞赛大佬坐阵解答大家的问题和疑问，并且会对前一天的题目进行讲解。1 活动时间2020-06-01 至 2020-08-30 需要提前准备些什么？ 数据结构与算法的基础知识。 推荐看一下大学里面的教材讲义，或者看一些入门的图书，视频等，比如《图解算法》，邓俊辉的《数据结构与算法》免费视频课程。总之， 至少你要知道有哪些常见的数据结构与算法以及他们各自的特点。 有 Github 账号，且会使用 Github 常用操作。 比如提 issue，留言等。 有 LeetCode 账号，且会用其提交代码。 语言不限，大家可以用自己喜欢的任何语言。同时我也希望你不要纠结于语言本身。 具体形式是什么样的？ 总共三个大的阶段 每个大阶段划分为几个小阶段 每个小阶段前会将这个小阶段的资料发到群里 每个小阶段的时间内，每天都会出关于这个阶段的题目，第二天进行解答 比如： 第一个大阶段是基础 基础中第一个小阶段是数组，栈和队列。 数组，栈和队列正式开始前，会将资料发到群里，大家可以提前预习。 之后的每天都会围绕数组，栈和队列出一道题，第二天进行解答。大家可以在出题当天上 Github 上打卡。 大家遇到问题可以在群里回答，对于比较好的问题，会记录到 github issue 中，让更多的人看到。Github 仓库地址届时会在群里公布。 有微信群么？有很多小伙伴反应没有 qq，或者平时不用 qq，能否提供微信群供学习。其实我的内心是拒绝的，这会增加系统复杂度。但是随着反应的人数越来越多，我决定开发微信群。还是和 qq 群一样的收费标准，，具体看下方。 如何加入微信群？添加我的微信，备注“91 算法”。那么怎么添加我呢？大家可以关注公众号脑洞前端，然后点击更多，在弹出的菜单中选择联系我即可。 冲鸭课程大纲可以点这里查看 收费标准： 前 50 人免费 51 - 100 收费 5 元 101 - 500 收费 10 元 目前已经满 100 人了。 本次活动并不是为了赚钱，而是为了给想学习的人营造一个良好的学习氛围，并且我们会对活跃的群员进行抽奖，活动基金就来源于大家的入群费。 入群截止时间： 2020-05-31 24:00:00","categories":[{"name":"力扣加加","slug":"力扣加加","permalink":"https://lucifer.ren/blog/categories/力扣加加/"},{"name":"91天学算法","slug":"91天学算法","permalink":"https://lucifer.ren/blog/categories/91天学算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"算法提高班","slug":"算法提高班","permalink":"https://lucifer.ren/blog/tags/算法提高班/"},{"name":"91天学算法","slug":"91天学算法","permalink":"https://lucifer.ren/blog/tags/91天学算法/"},{"name":"力扣加加","slug":"力扣加加","permalink":"https://lucifer.ren/blog/tags/力扣加加/"}]},{"title":"回炉重铸， 91 天见证不一样的自己","slug":"91-algo","date":"2020-05-23T02:31:23.707Z","updated":"2020-06-15T13:58:42.690Z","comments":true,"path":"2020/05/23/91-algo/","link":"","permalink":"https://lucifer.ren/blog/2020/05/23/91-algo/","excerpt":"力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。 ​","text":"力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。 ​ 初衷为了让想学习的人能够真正学习到东西， 我打算新开一个栏目《91 天学算法》，在 91 天内来帮助那些想要学习算法，提升自己算法能力的同学，帮助大家建立完整的算法知识体系。 群里每天都会有题目，推荐大家讨论当天的题目。我们会帮助大家规划学习路线，91 天见证不一样的自己。群里会有专门的资深算法竞赛大佬坐阵解答大家的问题和疑问，并且会对前一天的题目进行讲解。 活动时间2020-06-01 至 2020-08-30 你能够得到什么？ 显著提高你的刷题效率，让你少走弯路 掌握常见面试题的思路和解法 掌握常见套路，了解常见算法的本质，横向对比各种题目 纵向剖析一道题，多种方法不同角度解决同一题目 要求 🈲️ 不允许经常闲聊 🈲️ 不允许发广告，软文（只能发算法相关的技术文章） ✅ 一周至少参与一次打卡 违反上述条件的人员会被强制清退 课程大纲基础篇（30 天） 数组，队列，栈 链表 树与递归 哈希表 双指针 进阶篇（30 天） 堆 前缀树 并查集 跳表 剪枝技巧 RK 和 KMP 高频面试题 … 专题篇（31 天） 二分法 滑动窗口 位运算 背包问题 搜索（BFS，DFS，回溯） 动态规划 分治 贪心 … 游戏规则 每天会根据课程大纲的规划，出一道相关题目。 大家可以在指定的 Github 仓库中打卡（不可以抄作业哦），对于不会做的题目可以在群里提问。 第二天会对前一天的题目进行讲解。 奖励 对于坚持打卡满一个月的同学，可以参加抽奖，奖品包括算法模拟面试，算法相关的图书等 连续打卡七天可以获得补签卡一张哦 冲鸭为了大家的学习体验，防止不相关人员进群，同时为了更好地展开工作，我们决定采用 QQ 群的方式进行，希望大家能够理解哦。 对了，还有一句话，前 50 个进群的小伙伴免费哦 ~，50 名之后的小伙伴采取阶梯收费的形式。 收费标准： 前 50 人免费 51 - 100 收费 5 元 101 - 500 收费 10 元 目前已经满 100 人了。 想要参与的小伙伴加我的 QQ：695694307，发红包拉你进群。","categories":[{"name":"力扣加加","slug":"力扣加加","permalink":"https://lucifer.ren/blog/categories/力扣加加/"},{"name":"91天学算法","slug":"91天学算法","permalink":"https://lucifer.ren/blog/categories/91天学算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"算法提高班","slug":"算法提高班","permalink":"https://lucifer.ren/blog/tags/算法提高班/"},{"name":"91天学算法","slug":"91天学算法","permalink":"https://lucifer.ren/blog/tags/91天学算法/"},{"name":"力扣加加","slug":"力扣加加","permalink":"https://lucifer.ren/blog/tags/力扣加加/"}]},{"title":"《黑客与画家》摘抄","slug":"hacker-drawer","date":"2020-05-21T11:10:31.720Z","updated":"2020-05-21T11:36:55.720Z","comments":true,"path":"2020/05/21/hacker-drawer/","link":"","permalink":"https://lucifer.ren/blog/2020/05/21/hacker-drawer/","excerpt":"","text":"14. 梦寐以求的编程语言让我们试着描述黑客心中梦寐以求的语言来为以上内容做个小结。 这种语言干净简练，具有最高层次的抽象和互动性，而且很容易装备，可以只用很少的代码就解决常见的问题。不管是什么程序，你真正要写的代码几乎都与你自己的特定设置有关，其他具有普遍性的问题都有现成的函数库可以调用。 这种语言的句法短到令人生疑。你输入的命令中，没有任何一个字是多余的，甚至用到 shift 键的机会也很少。 这种语言的抽象程度很高，甚至你可以快速写出一个程序的原型。然后，等到你开始优化的时候，它还提供一个真正出色的性能分析器，告诉你应该重点关注什么地方。你能让多重循环快得难以置信，并且在需要的地方还能直接嵌入字节码。 这种语言有大量优秀的范例可供学习，并且非常符合直觉，你只需要花几分钟阅读范例就能领会应该如何使用此种语言。你偶尔才需要查阅操作手册， 它很薄，里面关于限定条件和例外情况的警告寥寥无几。 这种语言内核很小，但很强大。各个函数库高度独立，并且和内核一样经过精心设计，它们都能很好地协同工作。语言的每个部分就像精密照相机的各种零件一样完美契合，不需要为了兼容性问题放弃或者保留某些功能。所有的函数库的源码都能很容易得到。这种语言能很轻松地与操作系统和其他语言开发的应用程序对话。 这种语言以层的方式构建。较高的抽象层透明地构建在较低的抽象层上。如果有需要的话，你可以直接使用较低的抽象层。 除了一些绝对必要隐藏的东西。这种语言的所有细节对使用者都是透明的。它提供的抽象能力只是为了方便你开发，而不是强迫你按照它的方式行事。事实上，它鼓励你参与它的设计，给你提供与语言创作者平等的权利。你能够对它的任何部分加以改变， 甚至包括它的语法。它尽可能让你自己定义的部分与它本身定义的部分处于同等地位，这种梦幻般的编程语言不仅开放源码，更开放自身的设计。","categories":[{"name":"书摘","slug":"书摘","permalink":"https://lucifer.ren/blog/categories/书摘/"}],"tags":[{"name":"书摘","slug":"书摘","permalink":"https://lucifer.ren/blog/tags/书摘/"}]},{"title":"【LeetCode日记】 1371. 每个元音包含偶数次的最长子字符串","slug":"1371.find-the-longest-substring-containing-vowels-in-even-count","date":"2020-05-20T12:22:21.514Z","updated":"2020-05-20T12:38:23.796Z","comments":true,"path":"2020/05/20/1371.find-the-longest-substring-containing-vowels-in-even-count/","link":"","permalink":"https://lucifer.ren/blog/2020/05/20/1371.find-the-longest-substring-containing-vowels-in-even-count/","excerpt":"这道题还是蛮有意思的，我用了多种方法来解决，干货满满，点进来看看？","text":"这道题还是蛮有意思的，我用了多种方法来解决，干货满满，点进来看看？ 题目地址（1371. 每个元音包含偶数次的最长子字符串）https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/ 题目描述12345678910111213141516171819202122232425给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 &apos;a&apos;，&apos;e&apos;，&apos;i&apos;，&apos;o&apos;，&apos;u&apos; ，在子字符串中都恰好出现了偶数次。 示例 1：输入：s = &quot;eleetminicoworoep&quot;输出：13解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。示例 2：输入：s = &quot;leetcodeisgreat&quot;输出：5解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。示例 3：输入：s = &quot;bcbcbc&quot;输出：6解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。 提示：1 &lt;= s.length &lt;= 5 x 10^5s 只包含小写英文字母。 暴力法 + 剪枝思路首先拿到这道题的时候，我想到第一反应是滑动窗口行不行。 但是很快这个想法就被我否定了，因为滑动窗口（这里是可变滑动窗口）我们需要扩张和收缩窗口大小，而这里不那么容易。因为题目要求的是奇偶性，而不是类似“元音出现最多的子串”等。 突然一下子没了思路。那就试试暴力法吧。暴力法的思路比较朴素和直观。 那就是双层循环找到所有子串，然后对于每一个子串，统计元音个数，如果子串的元音个数都是偶数，则更新答案，最后返回最大的满足条件的子串长度即可。 这里我用了一个小的 trick。枚举所有子串的时候，我是从最长的子串开始枚举的，这样我找到一个满足条件的直接返回就行了（early return），不必维护最大值。这样不仅减少了代码量，还提高了效率。 代码代码支持：Python3 Python3 Code: 12345678910111213class Solution: def findTheLongestSubstring(self, s: str) -&gt; int: for i in range(len(s), 0, -1): for j in range(len(s) - i + 1): sub = s[j:j + i] has_odd_vowel = False for vowel in ['a', 'e', 'i', 'o', 'u']: if sub.count(vowel) % 2 != 0: has_odd_vowel = True break if not has_odd_vowel: return i return 0 复杂度分析 时间复杂度：双层循环找出所有子串的复杂度是$O(n^2)$，统计元音个数复杂度也是$O(n)$，因此这种算法的时间复杂度为$O(n^3)$。 空间复杂度：$O(1)$ 前缀和 + 剪枝思路上面思路中对于每一个子串，统计元音个数，我们仔细观察的话，会发现有很多重复的统计。那么优化这部分的内容就可以获得更好的效率。 对于这种连续的数字问题，这里我们考虑使用前缀和来优化。 经过这种空间换时间的策略之后，我们的时间复杂度会降低到$O(n ^ 2)$，但是相应空间复杂度会上升到$O(n)$，这种取舍在很多情况下是值得的。 代码代码支持：Python3，Java Python3 Code: 12345678910111213141516171819202122232425262728293031class Solution: i_mapper = &#123; \"a\": 0, \"e\": 1, \"i\": 2, \"o\": 3, \"u\": 4 &#125; def check(self, s, pre, l, r): for i in range(5): if s[l] in self.i_mapper and i == self.i_mapper[s[l]]: cnt = 1 else: cnt = 0 if (pre[r][i] - pre[l][i] + cnt) % 2 != 0: return False return True def findTheLongestSubstring(self, s: str) -&gt; int: n = len(s) pre = [[0] * 5 for _ in range(n)] # pre for i in range(n): for j in range(5): if s[i] in self.i_mapper and self.i_mapper[s[i]] == j: pre[i][j] = pre[i - 1][j] + 1 else: pre[i][j] = pre[i - 1][j] for i in range(n - 1, -1, -1): for j in range(n - i): if self.check(s, pre, j, i + j): return i + 1 return 0 Java Code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; public int findTheLongestSubstring(String s) &#123; int len = s.length(); if (len == 0) return 0; int[][] preSum = new int[len][5]; int start = getIndex(s.charAt(0)); if (start != -1) preSum[0][start]++; // preSum for (int i = 1; i &lt; len; i++) &#123; int idx = getIndex(s.charAt(i)); for (int j = 0; j &lt; 5; j++) &#123; if (idx == j) preSum[i][j] = preSum[i - 1][j] + 1; else preSum[i][j] = preSum[i - 1][j]; &#125; &#125; for (int i = len - 1; i &gt;= 0; i--) &#123; for (int j = 0; j &lt; len - i; j++) &#123; if (checkValid(preSum, s, i, i + j)) return i + 1 &#125; &#125; return 0 &#125; public boolean checkValid(int[][] preSum, String s, int left, int right) &#123; int idx = getIndex(s.charAt(left)); for (int i = 0; i &lt; 5; i++) if (((preSum[right][i] - preSum[left][i] + (idx == i ? 1 : 0)) &amp; 1) == 1) return false; return true; &#125; public int getIndex(char ch) &#123; if (ch == 'a') return 0; else if (ch == 'e') return 1; else if (ch == 'i') return 2; else if (ch == 'o') return 3; else if (ch == 'u') return 4; else return -1; &#125;&#125; 复杂度分析 时间复杂度：$O(n^2)$。 空间复杂度：$O(n)$ 前缀和 + 状态压缩思路前面的前缀和思路，我们通过空间（prefix）换取时间的方式降低了时间复杂度。但是时间复杂度仍然是平方，我们是否可以继续优化呢？ 实际上由于我们只关心奇偶性，并不关心每一个元音字母具体出现的次数。因此我们可以使用是奇数，是偶数两个状态来表示，由于只有两个状态，我们考虑使用位运算。 我们使用 5 位的二进制来表示以 i 结尾的字符串中包含各个元音的奇偶性，其中 0 表示偶数，1 表示奇数，并且最低位表示 a，然后依次是 e，i，o，u。比如 10110 则表示的是包含偶数个 a 和 o，奇数个 e，i，u，我们用变量 cur 来表示。 为什么用 0 表示偶数？1 表示奇数？ 回答这个问题，你需要继续往下看。 其实这个解法还用到了一个性质，这个性质是小学数学知识： 如果两个数字奇偶性相同，那么其相减一定是偶数。 如果两个数字奇偶性不同，那么其相减一定是奇数。 看到这里，我们再来看上面抛出的问题为什么用 0 表示偶数？1 表示奇数？。因为这里我们打算用异或运算，而异或的性质是： 如果对两个二进制做异或，会对其每一位进行位运算，如果相同则位 0，否则位 1。这和上面的性质非常相似。上面说奇偶性相同则位偶数，否则为奇数。因此很自然地用 0 表示偶数？1 表示奇数会更加方便。 代码代码支持：Python3 Python3 Code: 12345678910111213141516171819202122class Solution: def findTheLongestSubstring(self, s: str) -&gt; int: mapper = &#123; \"a\": 1, \"e\": 2, \"i\": 4, \"o\": 8, \"u\": 16 &#125; seen = &#123;0: -1&#125; res = cur = 0 for i in range(len(s)): if s[i] in mapper: cur ^= mapper.get(s[i]) # 全部奇偶性都相同，相减一定都是偶数 if cur in seen: res = max(res, i - seen.get(cur)) else: seen[cur] = i return res 复杂度分析 时间复杂度：$O(n)$。 空间复杂度：$O(n)$ 关键点解析 前缀和 状态压缩 相关题目 掌握前缀表达式真的可以为所欲为！","categories":[{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"前缀和","slug":"算法/前缀和","permalink":"https://lucifer.ren/blog/categories/算法/前缀和/"},{"name":"状态压缩","slug":"算法/状态压缩","permalink":"https://lucifer.ren/blog/categories/算法/状态压缩/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"前缀和","slug":"前缀和","permalink":"https://lucifer.ren/blog/tags/前缀和/"},{"name":"状态压缩","slug":"状态压缩","permalink":"https://lucifer.ren/blog/tags/状态压缩/"}]},{"title":"【LeetCode日记】 343. 整数拆分","slug":"343.integer-break","date":"2020-05-16T03:52:36.605Z","updated":"2020-05-16T03:54:00.785Z","comments":true,"path":"2020/05/16/343.integer-break/","link":"","permalink":"https://lucifer.ren/blog/2020/05/16/343.integer-break/","excerpt":"希望通过这篇题解让大家知道“题解区的水有多深”，让大家知道“什么才是好的题解”。 ​","text":"希望通过这篇题解让大家知道“题解区的水有多深”，让大家知道“什么才是好的题解”。 ​ 原题地址： https://leetcode-cn.com/problems/integer-break/ 题目描述给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。 示例 1: 输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1。示例 2: 输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。说明: 你可以假设 n 不小于 2 且不大于 58。 思路我看了很多人的题解直接就是两句话，然后跟上代码: 1234567class Solution: def integerBreak(self, n: int) -&gt; int: dp = [1] * (n + 1) for i in range(3, n + 1): for j in range(1, i): dp[i] = max(j * dp[i - j], j * (i - j), dp[i]) return dp[n] 这种题解说实话，只针对那些”自己会， 然后去题解区看看有没有新的更好的解法的人“。但是大多数看题解的人是那种自己没思路，不会做的人。那么这种题解就没什么用了。 我认为好的题解应该是新手友好的，并且能够将解题人思路完整展现的题解。比如看到这个题目，我首先想到了什么（对错没有关系），然后头脑中经过怎么样的筛选将算法筛选到具体某一个或某几个。我的最终算法是如何想到的，有没有一些先行知识。 当然我也承认自己有很多题解也是直接给的答案，这对很多人来说用处不大，甚至有可能有反作用，给他们一种”我已经会了“的假象。实际上他们根本不懂解题人本身原本的想法， 也许是写题解的人觉得”这很自然“，也可能”只是为了秀技“。 Ok，下面来讲下我是如何解这道题的。 抽象首先看到这道题，自然而然地先对问题进行抽象，这种抽象能力是必须的。LeetCode 实际上有很多这种穿着华丽外表的题，当你把这个衣服扒开的时候，会发现都是差不多的，甚至两个是一样的，这样的例子实际上有很多。 就本题来说，就有一个剑指 Offer 的原题《剪绳子》和其本质一样，只是换了描述方式。类似的有力扣 137 和 645 等等，大家可以自己去归纳总结。 137 和 645 我贴个之前写的题解 https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-xi-lie-wei-yun-suan-by-3/ 培养自己抽象问题的能力，不管是在算法上还是工程上。 务必记住这句话！ 数学是一门非常抽象的学科，同时也很方便我们抽象问题。为了显得我的题解比较高级，引入一些你们看不懂的数学符号也是很有必要的（开玩笑，没有什么高级数学符号啦）。 实际上这道题可以用纯数学角度来解，但是我相信大多数人并不想看。即使你看了，大多人的感受也是“好 nb，然而并没有什么用”。 这道题抽象一下就是： 令：（图 1）求：（图 2） 第一直觉经过上面的抽象，我的第一直觉这可能是一个数学题，我回想了下数学知识，然后用数学法 AC 了。 数学就是这么简单平凡且枯燥。 然而如果没有数学的加持的情况下，我继续思考怎么做。我想是否可以枚举所有的情况（如图 1），然后对其求最大值（如图 2）。 问题转化为如何枚举所有的情况。经过了几秒钟的思考，我发现这是一个很明显的递归问题。 具体思考过程如下： 我们将原问题抽象为 f(n) 那么 f(n) 等价于 max(1 * fn(n - 1), 2 * f(n - 2), …, (n - 1) * f(1))。 用数学公式表示就是： （图 3） 截止目前，是一点点数学 + 一点点递归，我们继续往下看。现在问题是不是就很简单啦？直接翻译图三为代码即可，我们来看下这个时候的代码： 1234567class Solution: def integerBreak(self, n: int) -&gt; int: if n == 2: return 1 res = 0 for i in range(1, n): res = max(res, max(i * self.integerBreak(n - i),i * (n - i))) return res 毫无疑问，超时了。原因很简单，就是算法中包含了太多的重复计算。如果经常看我的题解的话，这句话应该不陌生。我随便截一个我之前讲过这个知识点的图。 (图 4) 原文链接：https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md 大家可以尝试自己画图理解一下。 看到这里，有没有种殊途同归的感觉呢？ 考虑优化如上，我们可以考虑使用记忆化递归的方式来解决。只是用一个 hashtable 存储计算过的值即可。 12345678class Solution: @lru_cache() def integerBreak(self, n: int) -&gt; int: if n == 2: return 1 res = 0 for i in range(1, n): res = max(res, max(i * self.integerBreak(n - i),i * (n - i))) return res 为了简单起见（偷懒起见），我直接用了 lru_cache 注解， 上面的代码是可以 AC 的。 动态规划看到这里的同学应该发现了，这个套路是不是很熟悉？下一步就是将其改造成动态规划了。 如图 4，我们的思考方式是从顶向下，这符合人们思考问题的方式。将其改造成如下图的自底向上方式就是动态规划。 (图 5) 现在再来看下文章开头的代码： 1234567class Solution: def integerBreak(self, n: int) -&gt; int: dp = [1] * (n + 1) for i in range(3, n + 1): for j in range(1, i): dp[i] = max(j * dp[i - j], j * (i - j), dp[i]) return dp[n] dp table 存储的是图 3 中 f(n)的值。一个自然的想法是令 dp[i] 等价于 f(i)。而由于上面分析了原问题等价于 f(n)，那么很自然的原问题也等价于 dp[n]。 而 dp[i]等价于 f(i)，那么上面针对 f(i) 写的递归公式对 dp[i] 也是适用的，我们拿来试试。 12// 关键语句res = max(res, max(i * self.integerBreak(n - i),i * (n - i))) 翻译过来就是： 1dp[i] = max(dp[i], max(i * dp(n - i),i * (n - i))) 而这里的 n 是什么呢？我们说了dp是自底向下的思考方式，那么在达到 n 之前是看不到整体的n 的。因此这里的 n 实际上是 1,2,3,4… n。 自然地，我们用一层循环来生成上面一系列的 n 值。接着我们还要生成一系列的 i 值，注意到 n - i 是要大于 0 的，因此 i 只需要循环到 n - 1 即可。 思考到这里，我相信上面的代码真的是不难得出了。 关键点 数学抽象 递归分析 记忆化递归 动态规划 代码1234567class Solution: def integerBreak(self, n: int) -&gt; int: dp = [1] * (n + 1) for i in range(3, n + 1): for j in range(1, i): dp[i] = max(j * dp[i - j], j * (i - j), dp[i]) return dp[n] 总结培养自己的解题思维很重要， 不要直接看别人的答案。而是要将别人的东西变成自己的， 而要做到这一点，你就要知道“他们是怎么想到的”，“想到这点是不是有什么前置知识”，“类似题目有哪些”。 最优解通常不是一下子就想到了，这需要你在不那么优的解上摔了很多次跟头之后才能记住的。因此在你没有掌握之前，不要直接去看最优解。 在你掌握了之后，我不仅鼓励你去写最优解，还鼓励去一题多解，从多个解决思考问题。 到了那个时候， 萌新也会惊讶地呼喊“哇塞， 这题还可以这么解啊？”。 你也会低调地发出“害，解题就是这么简单平凡且枯燥。”的声音。 扩展正如我开头所说，这种套路实在是太常见了。希望大家能够识别这种问题的本质，彻底掌握这种套路。另外我对这个套路也在我的新书《LeetCode 题解》中做了介绍，本书目前刚完成草稿的编写，如果你想要第一时间获取到我们的题解新书，那么请发送邮件到 azl397985856@gmail.com，标题著明“书籍《LeetCode 题解》预定”字样。。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"hashtable","slug":"数据结构/hashtable","permalink":"https://lucifer.ren/blog/categories/数据结构/hashtable/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://lucifer.ren/blog/categories/算法/动态规划/"},{"name":"Medium","slug":"Medium","permalink":"https://lucifer.ren/blog/categories/Medium/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode日记","slug":"LeetCode日记","permalink":"https://lucifer.ren/blog/tags/LeetCode日记/"},{"name":"Medium","slug":"Medium","permalink":"https://lucifer.ren/blog/tags/Medium/"}]},{"title":"为什么eslint没有 no-magic-string？","slug":"why-no-magic-string","date":"2020-05-04T16:00:00.000Z","updated":"2020-05-05T12:41:31.066Z","comments":true,"path":"2020/05/05/why-no-magic-string/","link":"","permalink":"https://lucifer.ren/blog/2020/05/05/why-no-magic-string/","excerpt":"最近参加了几次公司组内的 Code Review， 发现了一些问题。其中一些问题可以通过工具（比如 eslint）解决。 我们就想着通过工具自动化的方式进行解决。 而这些工具中有一些是现成的，比如 魔法数。 大家对魔法数的看法也是莫衷一是。本文通过讲解什么是魔法数，eslint 是怎么检查魔法数的，以及思考为什么eslint 偏爱数字，而不是偏爱字符串来 来深入剖析一下魔法数。","text":"最近参加了几次公司组内的 Code Review， 发现了一些问题。其中一些问题可以通过工具（比如 eslint）解决。 我们就想着通过工具自动化的方式进行解决。 而这些工具中有一些是现成的，比如 魔法数。 大家对魔法数的看法也是莫衷一是。本文通过讲解什么是魔法数，eslint 是怎么检查魔法数的，以及思考为什么eslint 偏爱数字，而不是偏爱字符串来 来深入剖析一下魔法数。 计算机科学中的魔法数什么是魔法数？ 这里我摘取了维基百科的解释： 程序设计中所谓的魔术数字（magic number）可能有以下含意： • 缺乏解释或命名的独特数值 • 用于识别一个文件格式或协议的一段常量或字符串，例如UNIX的特征签名 • 防止误作他用的一段数值，例如UUID实际上魔法数真的是一个很古老的话题了。从我刚从业开始，就不停听到这样的词语。大家都对此深恶痛绝，不想看到别人的魔法数，但是时不时自己也会写一些魔法数。 如果你经常做算法题，肯定对此深有感受。 很多人（或许包括我自己）喜欢通过魔法数来炫技。当然我的心理倒不仅仅是炫技这么简单，也掺杂了诸如“这个很显然易见”，“这个我也不知道怎么起名字”的想法。 eslint 中的魔法数eslint 有一个 rule 是 no-magic-number. 为什么没有类似的比如 no-magic-string? 我们首先来看下什么是”no-magic-number”。 根据 eslint 官方描述来看，其是通过确保数字被显式赋予一个常量，从而增加代码可读性和可维护性。 如下代码被认为是不好的： 123/*eslint no-magic-numbers: “error”*/var dutyFreePrice = 100, finalPrice = dutyFreePrice + dutyFreePrice * 0.25; 而这段代码被认为是好的： 12345/*eslint no-magic-numbers: “error”*/var TAX = 0.25;var dutyFreePrice = 100, finalPrice = dutyFreePrice + dutyFreePrice * TAX; 这两段代码有什么不同？为什么下面的代码被认为是好的？ 一窥 eslint 源码通过阅读源码，我发现代码有这样一句： 1234567891011// utils/ast-utils.jsfunction isNumericLiteral(node) &#123; return ( node.type === \"Literal\" &amp;&amp; (typeof node.value === \"number\" || Boolean(node.bigint)) );&#125;// no-magic-numbers.jsif (!isNumericLiteral(node)) &#123; return;&#125; 也就是说如果字面量不是数字会被忽略。这和我们的想法这条规则只会检查魔法数字，而不会检查诸如魔法字符串等。 让我们时光倒流，将代码回退到 eslint 官方首次关于”no-magic-rule”的提交。 代码大概意思是： 如果是变量声明语句，就去检查是否强制使用 const。 如果是则观察语句是否为 const 声明。 对于其他情况，直接检查父节点的类型。2.1. 如果检查对象内部的魔法数字，则直接报错。2.2. 如果不需要检查对象类型，则进行规则过滤，即如果是[“ObjectExpression”,“Property”,“AssignmentExpression”] 中的一种的话也是没问题的。其他情况报错。 那么上面的三种类型是什么呢？ 从名字不难发现，其中 AssignmentExpression 和 ObjectExpression 属于表达式。 而 Property 则是对象属性。 ObjectExpression 的例子： 1a = &#123;&#125; 思考题：为什么 ObjectExpression 也是不被允许的？AssignmentExpression 的例子： 1a = b = 2; Property 的例子： 1a = &#123; number: 1 &#125; 也就是说，如果设置了检查对象，那么上面三种情况都会报错。否则不进行报错处理。 AST-Explorer大家使用AST explorer 来可视化 AST。 由于 eslint 使用的 ast 转化工具是 espree， 推荐大家使用 espree。 如果大家写 babel 插件的话，相应的引擎最好修改一下。 值得注意的是，上面我们用的 parent 是不会在 ast-explorer 进行显示的。原因在于其不是 ast 结构的一部分，而如果要做到，也非常容易。 前提是你懂得递归，尤其是树的递归。 如果你还不太懂树的递归， 可以关注我的 B 站LeetCode 加加的个人空间 - 哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili 通过观察 eslint/espree 的源码也可以发现，其过程是多么的自然和简单。 Magic String实际上一个第三方的 tslint 仓库的一个issue 明确指出了想要增加”no-magic-string” 的想法，只不过被仓库成员给否掉了，原因是其不够通用，除非能证明大家都需要这样一个规则。 那么问题是“为什么 no-magic-string 没有 no-magic-number 通用呢”？【每日一题】- 2020-05-05 - no-magic-string · Issue #122 · azl397985856/fe-interview · GitHub 有一个回答，小漾给出了很好的回答。但是还没有解决疑问“为什么没有 no-magic-string”这样的规则呢？ 我的观点是魔法字符串也是不好的，只不过没有不好的那么明显。 我们来看个例子： 12345name = \"lucifer\";a = \"hello, \" + name;if (type === \"add\") &#123;&#125; else if (type == \"edit\") &#123;&#125; 如上代码，就可以被认定为 magic string。但是其在现实代码中是非常普遍的，并且不对我们造成很大的困扰。如果对其改写会是这样的： 12345678name = \"lucifer\";const PRFIX = \"hello, \";const TYPE_ADD = \"add\";const TYPE_EDIT = \"edit\";a = prefix + name;if (type === TYPE_ADD) &#123;&#125; else if (type == TYPE_EDIT) &#123;&#125; 再来看看数字： 1234567if (type === 1) &#123; //&#125;if (total &gt; 5) &#123; //&#125; 如上是我实际工作中见到过的例子，还算有代表性。 上面的代码，如果不通读代码或者事先有一些背景知识，我们根本无从知晓代码的准确含义。 还有一个地方，是数字不同于字符串的。 那就是数字可能是一个无限小数。计算机无法精确表示。 那么程序就不得不进行合理近似，而如果同一个程序不同地方采用的近似手段不同，那么就会有问题。而不使用魔法数就可以就可以避免这个问题。 举个例子： 我们需要计算一个圆的面积，可能会这样做： 1area = 3.1415 * R ** 2 1area = 3.141516 * R ** 2 这样就会有问题了。 而如果我们将 PI 的值抽离到一个变量去维护，任何代码都取这个变量的值就不会有问题。那么有人可能有这样的疑问字符串如果拼写错了，是不是也是一样的么？ 比如： 1234// a.jsif (type == &apos;add&apos;) &#123;...&#125;// b.jsif (type == &apos;addd&apos;) &#123;...&#125; 事实上，这样的事情很有可能发生。 只不过这种问题相比于数字来说更容易被发现而已。 这么看来魔法数字确实给大家带来了很大的困扰，那么我们是否应该全面杜绝魔法数呢？ 取舍之间真的魔法数字(字符串吧)就是不好的么？其实也不见得。 下面再来看一个我实际工作中碰到的例子： 1234567MS = 0;if (type === \"day\") &#123; MS = 24 * 60 * 60 * 1000;&#125;if (type === \"week\") &#123; MS = 7 * 24 * 60 * 60 * 1000;&#125; 这种代码我不知道看了多少遍了。 或许这在大家眼中已然成为了一种共识，那么这种所谓的魔法数字代码的不可读问题就不存在了。 我们仍可以轻易知道代码的含义。 如果将其进行改造： 1234567891011121314151617MS = 0;const HOURS_PER_DAY = 24;const MINUTES_PER_HOUR = 60;const SECONDs_PER_MINUTE = 60;const MS_PER_SECOND = 1000;const DAYS_PER_WEEK = 7;if (type === \"day\") &#123; MS = HOURS_PER_DAY * MINUTES_PER_HOUR * SECONDs_PER_MINUTE * MS_PER_SECOND;&#125;if (type === \"week\") &#123; MS = DAYS_PER_WEEK * HOURS_PER_DAY * MINUTES_PER_HOUR * SECONDs_PER_MINUTE * MS_PER_SECOND;&#125; 上面的代码不见的要比上面的好到哪里。 《程序设计实践》提到了一点“变量命令不是越长越好，越具体越好，而是根据具体的限定范围”。 比如你在 queue 的 class 中定义的 size 字段可以直接叫 size ，而不是 queue_size。 那么一些社会或者编码常识何尝不是一种限定呢？ 如果是的话， 我们是否可以不用特殊限定，而回归到“魔法数”呢？","categories":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/categories/前端/"},{"name":"eslint","slug":"前端/eslint","permalink":"https://lucifer.ren/blog/categories/前端/eslint/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/tags/前端/"},{"name":"eslint","slug":"eslint","permalink":"https://lucifer.ren/blog/tags/eslint/"}]},{"title":"纪念LeetCode项目Star突破3W","slug":"thanksGiving3","date":"2020-04-16T03:26:35.438Z","updated":"2020-04-16T09:20:37.814Z","comments":true,"path":"2020/04/16/thanksGiving3/","link":"","permalink":"https://lucifer.ren/blog/2020/04/16/thanksGiving3/","excerpt":"差不多一年的时间，项目收获了第 3W 个 Star，平均差不多一天 100 左右的 star，非常感谢大家的关注和支持。","text":"差不多一年的时间，项目收获了第 3W 个 Star，平均差不多一天 100 左右的 star，非常感谢大家的关注和支持。 30k 截图 Star 曲线Start 曲线上来看，有一点放缓。但是整体仍然是明显的上升趋势。 (star 增长曲线图) 在力扣宣传当力扣官方也开始做每日一题的时候，我的心情是复杂的。怎么官方也开始学我搞每日一题了么？为了信仰（蹭热度），我也毅然决然参加了每日一题活动，贡献了几十篇题解。 三月份是满勤奖，四月份有一次忘记了，缺卡一天。 新书即将上线新书详情戳这里：《或许是一本可以彻底改变你刷 LeetCode 效率的题解书》，目前正在申请书号。 点名感谢各位作者，审阅，以及行政小姐姐。 视频题解最近开始做视频题解了，目前更新了五个视频。和文字题解不同，视频题解可以承载的内容会更多。 https://space.bilibili.com/519510412 我计划更新一些文字题解很难表述的内容，当然还会提供 PPT，如果你喜欢文字，直接看 PPT 即可。 视频题解部分，我会带你拆解 LeetCode 题目，识别常见问题，掌握常见套路。 注意：这不是教你解决某一道题的题解，而是掌握解题方法和思路的题解。 《力扣加加》上线啦我们的官网力扣加加上线啦 💐💐💐💐💐，有专题讲解，每日一题，下载区和视频题解，后续会增加更多内容，还不赶紧收藏起来？地址：http://leetcode-solution.cn/ 点名感谢@三天 @CYL @Josephjinn 朋友的支持很多朋友也在关注我的项目，非常开心。点名感谢 @被单-加加 @童欧巴。 交流群交流群人数也有了很大的提升。 粉丝人数也扩充到了 7000+。交流群数目也增加到了 10 个。其中 QQ 群人数最多，有将近 1800 人。为了限制人数，我开启了收费模式，希望大家不要打我 😂。 非常感谢大家一直以来的陪伴和支持，Fighting 💪。","categories":[{"name":"日记","slug":"日记","permalink":"https://lucifer.ren/blog/categories/日记/"},{"name":"技术","slug":"日记/技术","permalink":"https://lucifer.ren/blog/categories/日记/技术/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://lucifer.ren/blog/tags/日记/"}]},{"title":"『不要再问我头像如何变灰了，试试这几种滤镜吧！』","slug":"canvas-filter","date":"2020-04-11T16:00:00.000Z","updated":"2020-04-12T05:10:46.392Z","comments":true,"path":"2020/04/12/canvas-filter/","link":"","permalink":"https://lucifer.ren/blog/2020/04/12/canvas-filter/","excerpt":"在实际的工作中，有时候会有一些需求，让你做一些图片的滤镜效果，比如将图片变成黑白，调整图片亮度等。本文手把手教你如何实现五种滤镜效果，核心代码总共不到 70 行。 笔者所在的公司就有一个需求需要用到图片处理的知识，大概场景我来描述一下： 用户可以手动上传印章，并且支持给印章设置不同的显示效果，这里的效果具体指的是“线条的清晰程度”，如下图所示： 这里我们使用 Canvas 来实现。如果你对 Canvas 不熟悉，建议看下之前我写的一篇文章100 * 100 Canvas 占用内存多大，花上几分钟看完，基本上够看懂这篇文章了。","text":"在实际的工作中，有时候会有一些需求，让你做一些图片的滤镜效果，比如将图片变成黑白，调整图片亮度等。本文手把手教你如何实现五种滤镜效果，核心代码总共不到 70 行。 笔者所在的公司就有一个需求需要用到图片处理的知识，大概场景我来描述一下： 用户可以手动上传印章，并且支持给印章设置不同的显示效果，这里的效果具体指的是“线条的清晰程度”，如下图所示： 这里我们使用 Canvas 来实现。如果你对 Canvas 不熟悉，建议看下之前我写的一篇文章100 * 100 Canvas 占用内存多大，花上几分钟看完，基本上够看懂这篇文章了。 准备工作首先我们先将图片绘制到 Canvas 画布上，为了简单起见，图片大小固定为 300 x 300。 1&lt;canvas id=\"canvas\" width=\"300px\" height=\"300px\"&gt;&lt;/canvas&gt; (html) 12345678910//获取canvas元素ctx = document.getElementById(\"canvas\").getContext(\"2d\");//创建image对象var img = new Image();img.src = require(\"./seal.png\");//待图片加载完后，将其显示在canvas上img.onload = () =&gt; &#123; ctx.drawImage(img, 0, 0); this.imgData = ctx.getImageData(0, 0, 300, 300);&#125;; (js) 效果是这样的： 操作像素熟悉 Canvas 的应该知道上面的 this.imgData 实际上就是ImageData类的实例，其中 imgData.data 是一个 Uint8ClampedArray， 其描述了一个一维数组，包含以 RGBA 顺序的数据，数据使用 0 至 255（包含）的整数表示。 简单来说，就是图片像素信息，每四位表示一个像素单元。其中每四位的信息分别是 RGBA。即第一个 Bit 标记 R，第二个 Bit 表示 G，第三个 Bit 表示 B，第四个 Bit 表示 A，第五个 Bit 又是 R…，依次类推。 接下来，我们就要操作 imgData，来实现滤镜的效果。简单起见，我这里对超过 200 的值进行了一次提高亮度的操作。实际上这个值是 200，还是别的数字，需要我们化身”调参工程师”，不断实验才行。 并且粗暴地对 RGB 执行同样的逻辑是不合理的。更为合理的做法是对 RGB 的阀值分别进行度量，由于比较麻烦，我这里没有实现。但是如果你对效果要求比较高，那么最好可以分开度量。 123456789101112131415const data = this.imgData.data;for (let i = 0; i &lt; data.length; i += 4) &#123; if (data[i] &lt; 200) &#123; data[i] = data[i] + brightness &gt; 255 ? 255 : data[i] + brightness; &#125; if (data[i + 1] &lt; 200) &#123; data[i + 1] = data[i + 1] + brightness &gt; 255 ? 255 : data[i + 1] + brightness; &#125; if (data[i + 2] &lt; 200) &#123; data[i + 2] = data[i + 2] + brightness &gt; 255 ? 255 : data[i + 2] + brightness; &#125;&#125; 如上，我们对图片的像素进行了处理，以达到我们的目的，这样从用户感官上来看，显示效果发生了变化，大概效果如图： （清晰版） （模糊版） 如果你愿意的话，你也可以将处理好的图片进行导出，也很简单，直接调用 Canvas 实例的 toDataURL 方法即可，图片保存的格式也可以在这个方法中进行指定。 日常开发中，我们还可能碰到很多其他的滤镜效果。下面介绍几个比较现常见的效果。 如果你正好用到了不妨作为参考。如果遇到了新的滤镜效果， 不妨在文末向我留言，看到后会及时回答，提前感谢你的参与。 下面介绍其他四种滤镜效果。这里只贴出核心代码，完整代码可以访问我的 Github Repo 进行查看。如果你嫌下载到本地麻烦，也可以在这里在线安装并访问，打开这个链接，分别执行yarn和yarn start即可。 以下效果均以下图为原图制作： 如何实现黑白效果 12345for (let i = 0; i &lt; data.length; i += 4) &#123; // 将红黄蓝按照一定比例混合，具体比例为0.299 : 0.587 : 0.114， 这个比例需要慢慢调制。 const avg = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]; data[i] = data[i + 1] = data[i + 2] = avg;&#125; 如何实现反色效果 12345for (let i = 0; i &lt; data.length; i += 4) &#123; data[i] = 255 - data[i]; //r data[i + 1] = 255 - data[i + 1]; //g data[i + 2] = 255 - data[i + 2]; //b&#125; 如何给图片增加噪音 123456const random = ((Math.random() * 70) &gt;&gt;&gt; 0) - 35;for (let i = 0; i &lt; data.length; i += 4) &#123; data[i] = data[i] + random; data[i + 1] = data[i + 1] + random; data[i + 2] = data[i + 2] + random;&#125; 如何提高图片亮度 123456const brightness = +e.target.value;for (let i = 0; i &lt; data.length; i += 4) &#123; data[i] = data[i] + brightness &gt; 255 ? 255 : data[i] + brightness; data[i + 1] = data[i + 1] + brightness &gt; 255 ? 255 : data[i + 1] + brightness; data[i + 2] = data[i + 2] + brightness &gt; 255 ? 255 : data[i + 2] + brightness;&#125; 总结本文通过不到 70 行代码实现了五种滤镜效果，对于其他滤镜效果也可以参考这种方式来实现。还不赶紧拿上小姐姐的照片来秀一手么？","categories":[],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://lucifer.ren/blog/tags/Canvas/"},{"name":"图片处理","slug":"图片处理","permalink":"https://lucifer.ren/blog/tags/图片处理/"},{"name":"滤镜","slug":"滤镜","permalink":"https://lucifer.ren/blog/tags/滤镜/"}]},{"title":"或许是一本可以彻底改变你刷 LeetCode 效率的题解书","slug":"leetcode-book.intro","date":"2020-04-07T07:01:24.450Z","updated":"2020-04-07T11:13:53.307Z","comments":true,"path":"2020/04/07/leetcode-book.intro/","link":"","permalink":"https://lucifer.ren/blog/2020/04/07/leetcode-book.intro/","excerpt":"经过了半年时间打磨，投入诸多人力，这本 LeetCode 题解书终于快要和大家见面了。目前已经完成了大部分章节的编写工作，预计经过一段时间的打磨就会和大家见面啦 💐💐💐💐💐。","text":"经过了半年时间打磨，投入诸多人力，这本 LeetCode 题解书终于快要和大家见面了。目前已经完成了大部分章节的编写工作，预计经过一段时间的打磨就会和大家见面啦 💐💐💐💐💐。 背景自 LeetCode 题解 （现在已经接近 30k star 了）项目被大家开始关注，就有不少出版社开始联系我写书。刚开始后的时候，我并没有这个打算，觉得写这个相对于博客形式的题解要耗费时间，且并不一定效果比博客形式的效果好。后来当我向大家提及“出版社找我写书”这件事情的时候，很多人表示“想要买书，于是我就开始打算写这样一本书。但是一个完全没有写书经验的人，独立完成一本书工作量还是蛮大的，因此我打算寻求其他志同道合人士的帮助。 团队介绍团队成员大都来自 985， 211 学校计算机系，大家经常参加算法竞赛，也坚持参加 LeetCode 周赛。在这个过程中，我们积累了很多经验，希望将这些经验分享给大家，以减少大家在刷题过程中的阻碍，让大家更有效率的刷题。 本书尤其适合那些刚刚开始刷题的人，如果你刚开始刷题，或者刷了很多题面对新题还是无法很好的解决，那么这本书肯定很适合你。最后欢迎大家加入我们的读者群和作者进行交流。 读者群会在新书出版之后的第一时间开放。 作者 - xing 作者 - lucifer 作者 - BY 作者 - fanlu 作者 - lazybing 样张这里给大家开放部分章节内容给大家，让大家尝尝鲜。当然也欢迎大家提出宝贵的建议，帮助我们写出更好的内容。 我们开放了第八章第五小节给大家看，以下是具体内容： 8.5 1206. 设计跳表题目描述不使用任何库函数，设计一个跳表。 跳表是在 $O(logN)$ 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。 跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 $O(N)$。跳表的每一个操作的平均时间复杂度是 $O(logN)$，空间复杂度是 $O(N)$。 在本题中，你的设计应该要包含这些函数： bool search(int target) : 返回 target 是否存在于跳表中。 void add(int num): 插入一个元素到跳表。 bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回 false. 如果存在多个 num ，删除其中任意一个即可。 注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。 样例： 1234567891011Skiplist skiplist = new Skiplist();skiplist.add(1);skiplist.add(2);skiplist.add(3);skiplist.search(0); // 返回 falseskiplist.add(4);skiplist.search(1); // 返回 trueskiplist.erase(0); // 返回 false，0 不在跳表中skiplist.erase(1); // 返回 trueskiplist.search(1); // 返回 false，1 已被擦除 约束条件：0 &lt;= num, target &lt;= 20000最多调用 50000 次 search, add, 以及 erase 操作。 思路首先，使用跳表会将数据存储成有序的。在数据结构当中，我们通常有两种基本的线性结构，结合有序数据，表达如下： 有序链表，我们有三种基本操作： 查找指定的数据：时间复杂度为 $O(N)$, $N$ 为数据位于链表的位置。 插入指定的数据：时间复杂度为 $O(N)$, $N$ 为数据位于链表的位置。因为插入数据之前，需要先查找到可以插入的位置。 删除指定的数据：时间复杂度为 $O(N)$, $N$ 为数据位于链表的位置。因为删除数据之前，需要先查找到可以插入的位置。 有序数组： 查找指定的数据：如果使用二分查找，时间复杂度为 $O(logN)$, $N$ 为数据的个数。 插入指定的数据：时间复杂度为 $O(N)$, 因为数组是顺序存储，插入新的数据时，我们需要向后移动指定位置后面的数据，这里 $N$ 为数据的个数。 删除指定的数据：时间复杂度为 $O(N)$, 因为数组是顺序存储，删除数据时，我们需要向前移动指定位置后面的数据，这里 $N$ 为数据的个数。 而神奇的跳表能够在 $O(logN)$ 时间内完成增加、删除、搜索操作。下面我们分别分析增加、删除和搜索这 3 个三个基本操作。 跳表的查找现在我们通过一个简单的例子来描述跳表是如何实现的。假设我们有一个有序链表如下图：原始方法中，查找的时间复杂度为 $O(N)$。那么如何来提高链表的查询效率呢？如下图所示，我们可以从原始链表中每两个元素抽出来一个元素，加上一级索引，并且一级索引指向原始链表：如果我们想要查找 9 ，在原始链表中查找路径是 1-&gt;3-&gt;4-&gt;7-&gt;9, 而在添加了一级索引的查找路径是 1-&gt;4-&gt;9，很明显，查找效率提升了。按照这样的思路，我们在第 1 级索引上再加第 2 级索引，再加第 3 级索引，以此类推，这样在数据量非常大的时候，使得我们查找数据的时间复杂度为 $O(logN)$。这就是跳表的思想，也就是我们通常所说的“空间换时间”。 跳表的插入跳表插入数据看起来很简单，我们需要保持数据有序，因此，第一步我们需要像查找元素一样，找到新元素应该插入的位置，然后再插入。 但是这样会存在一个问题，如果我们一直往原始链表中插入数据，但是不更新索引，那么会导致两个索引结点之间的数据非常多，在极端情况下，跳表会退化成单链表，从而导致查找效率由 $O(logN)$ 退化为 $O(N)$。因此，我们需要在插入数据的同时，增加相应的索引或者重建索引。 方案 1：每次插入数据后，将跳表的索引全部删除后重建，我们知道索引的结点个数为 $N$（在空间复杂度分析时会有明确的数学推导），那么每次重建索引，重建的时间复杂度至少是 $O(N)$ 级别，很明显不可取。 方案 2：通过随机性来维护索引。假设跳表的每一层的提升概率为 $\\frac{1}{2}$ ，最理想的情况就是每两个元素提升一个元素做索引。而通常意义上，只要元素的数量足够多，且抽取足够随机的话，我们得到的索引将会是比较均匀的。尽管不是每两个抽取一个，但是对于查找效率来讲，影响并不很大。我们要知道，设计良好的数据结构往往都是用来应对大数据量的场景的。因此，我们这样维护索引：随机抽取 $\\frac{N}{2}$ 个元素作为 1 级索引，随机抽取 $\\frac{N}{4}$ 作为 2 级索引，以此类推，一直到最顶层索引。 那么具体代码该如何实现，才能够让跳表在每次插入新元素时，尽量让该元素有 $\\frac{1}{2}$ 的概率建立一级索引、$\\frac{1}{4}$ 的概率建立二级索引、$\\frac{1}{8}$ 的概率建立三级索引，以此类推。因此，我们需要一个概率算法。 在通常的跳表实现当中，我们会设计一个 randomLevel() 方法，该方法会随机生成 1~MAX_LEVEL 之间的数 (MAX_LEVEL 表示索引的最高层数） randomLevel() 方法返回 1 表示当前插入的元素不需要建立索引，只需要存储数据到原始链表即可（概率 1/2） randomLevel() 方法返回 2 表示当前插入的元素需要建立一级索引（概率 1/4） randomLevel() 方法返回 3 表示当前插入的元素需要建立二级索引（概率 1/8） randomLevel() 方法返回 4 表示当前插入的元素需要建立三级索引（概率 1/16） …… 可能有的同学会有疑问，我们需要一级索引中元素的个数时原始链表的一半，但是我们 randomLevel() 方法返回 2（建立一级索引）的概率是 $\\frac{1}{4}$, 这样是不是有问题呢？实际上，只要randomLevel()方法返回的数大于 1，我们都会建立一级索引，而返回值为 1 的概率是 $\\frac{1}{2}$。所以，建立一级索引的概率其实是$1- \\frac{1}{2} = \\frac{1}{2}$。同上，当 randomLevel() 方法返回值 &gt;2 时，我们会建立二级或二级以上的索引，都会在二级索引中添加元素。而在二级索引中添加元素的概率是 $1- \\frac{1}{2} - \\frac{1}{4} = \\frac{1}{4}$。以此类推，我们推导出 randomLevel() 符合我们的设计要求。 下面我们通过仿照 redis zset.c 的 randomLevel 的代码： 12345678### 1. SKIPLIST_P 为提升的概率，本案例中我们设置为 1/2, 如果我们想要节省空间利用效率，可以适当的降低该值，从而减少索引元素个数。在 redis 中 SKIPLIST_P 被设定为 0.25。# 2. redis 中通过使用位运算来提升浮点数比较的效率，在本案例中被简化def randomLevel(): level = 1 while random() &lt; SKIPLIST_P and level &lt; MAX_LEVEL: level += 1 return level 跳表的删除跳表的删除相对来讲稍微简单一些。我们在删除数据的同时，需要删除对应的索引结点。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from typing import Optionalimport randomclass ListNode: def __init__(self, data: Optional[int] = None): self._data = data # 链表结点的数据域，可以为空（目的是方便创建头节点） self._forwards = [] # 存储各个索引层级中该结点的后驱索引结点class Skiplist: _MAX_LEVEL = 16 # 允许的最大索引高度，该值根据实际需求设置 def __init__(self): self._level_count = 1 # 初始化当前层级为 1 self._head = ListNode() self._head._forwards = [None] * self._MAX_LEVEL def search(self, target: int) -&gt; bool: p = self._head for i in range(self._level_count - 1, -1, -1): # 从最高索引层级不断搜索，如果当前层级没有，则下沉到低一级的层级 while p._forwards[i] and p._forwards[i]._data &lt; target: p = p._forwards[i] if p._forwards[0] and p._forwards[0]._data == target: return True return False def add(self, num: int) -&gt; None: level = self._random_level() # 随机生成索引层级 if self._level_count &lt; level: # 如果当前层级小于 level, 则更新当前最高层级 self._level_count = level new_node = ListNode(num) # 生成新结点 new_node._forwards = [None] * level update = [self._head] * self._level_count # 用来保存各个索引层级插入的位置，也就是新结点的前驱结点 p = self._head for i in range(self._level_count - 1, -1, -1): # 整段代码获取新插入结点在各个索引层级的前驱节点，需要注意的是这里是使用的当前最高层级来循环。 while p._forwards[i] and p._forwards[i]._data &lt; num: p = p._forwards[i] update[i] = p for i in range(level): # 更新需要更新的各个索引层级 new_node._forwards[i] = update[i]._forwards[i] update[i]._forwards[i] = new_node def erase(self, num: int) -&gt; bool: update = [None] * self._level_count p = self._head for i in range(self._level_count - 1, -1, -1): while p._forwards[i] and p._forwards[i]._data &lt; num: p = p._forwards[i] update[i] = p if p._forwards[0] and p._forwards[0]._data == num: for i in range(self._level_count - 1, -1, -1): if update[i]._forwards[i] and update[i]._forwards[i]._data == num: update[i]._forwards[i] = update[i]._forwards[i]._forwards[i] return True while self._level_count &gt; 1 and not self._head._forwards[self._level_count]: self._level_count -= 1 return False def _random_level(self, p: float = 0.5) -&gt; int: level = 1 while random.random() &lt; p and level &lt; self._MAX_LEVEL: level += 1 return level 复杂度分析空间复杂度跳表通过建立索引提高查找的效率，是典型的“空间换时间”的思想，那么空间复杂度到底是多少呢？我们假设原始链表有 $N$ 个元素，一级索引有 $\\frac{N}{2}$，二级索引有 $\\frac{N}{4}$，k 级索引有 $\\frac{N}{2^k}$ 个元素，而最高级索引一般有 $2$ 个元素。所以，索引结点的总和是 $\\frac{N}{2} + \\frac{N}{2^2} + \\frac{N}{2^3}+…+ 2 \\approx N-2$ ，因此可以得出空间复杂度是 $O(N)$, $N$ 是原始链表的长度。 上面的假设前提是每两个结点抽出一个结点到上层索引。那么如果我们每三个结点抽出一个结点到上层索引，那么索引总和就是 $\\frac{N}{3} + \\frac{N}{3^2} + \\frac{N}{3^3} + 9 + 3 + 1 \\approx \\frac{N}{2}$, 额外空间减少了一半。因此我们可以通过减少索引的数量来减少空间复杂度，但是相应的会带来查找效率一定的下降。而具体这个阈值该如何选择，则要看具体的应用场景。 另外需要注意的是，在实际的应用当中，索引结点往往不需要存储完整的对象，只需要存储对象的 key 和对应的指针即可。因此当对象比索引结点占用空间大很多时，索引结点所占的额外空间（相对原始数据来讲）又可以忽略不计了。 时间复杂度查找的时间复杂度来看看时间复杂度 $O(logN)$ 是如何推导出来的，首先我们看下图： 如上图所示，此处我们假设每两个结点会抽出一个结点来作为上一级索引的结点。也就是说，原始链表有 $N$ 个元素，一级索引有 $\\frac{N}{2}$，二级索引有 $\\frac{N}{4}$，k 级索引有 $\\frac{N}{2^k}$ 个元素，而最高级索引一般有 $2$ 个元素。 也就是说：最高级索引 $x$ 满足 $2 = N/2^x$, 由此公式可以得出 $x = \\log_2(N)-1$ , 加上原始数据这一层， 跳表的总高度为 $h = \\log_2(N)$。那么，我们在查找过程中每一层索引最多遍历几个元素呢？从图中我们可以看出来每一层最多需要遍历 3 个结点。因此，由公式 时间复杂度 = 索引高度*每层索引遍历元素个数， 可以得出跳表中查找一个元素的时间复杂度为 $O(3 \\times \\log(N))$，省略常数即为 $O(\\log(N))$。 插入的时间复杂度跳表的插入分为两部分操作： 寻找到对应的位置，时间复杂度为 $O(logN)$, $N$ 为链表长度。 插入数据。我们在前面已经推导出跳表索引的高度为 $logN$。 因此，我们将数据插入到各层索引中的最坏时间复杂度为 $O(logN)$。 综上所述，插入操作的时间复杂度为 $O(logN)$ 删除的时间复杂度跳表的删除操作和查找类似，只是需要在查找后删除对应的元素。查找操作的时间复杂度是 $logN$。那么后面删除部分代码的时间复杂度是多少呢？我们知道在跳表中，每一层索引都是一个有序的单链表，而删除单个元素的复杂度为 $O(1)$, 索引层数为 $logN$，因此删除部分代码的时间复杂度为$logN$。那么删除操作的总时间复杂度为- $O(logN) + O(logN) = 2O(logN)$。我们忽略常数部分，删除元素的时间复杂度为 $O(logN)$。 扩展在工业上，使用跳表的场景很多，下面做些简单的介绍，有兴趣的可以深入了解： redis 当中 zset 使用了跳表 HBase MemStore 当中使用了跳表 LevelDB 和 RocksDB 都是 LSM Tree 结构的数据库，内部的 MemTable 当中都使用了跳表 配套网站等新书发布之后，我们会在官网开辟一个区域，大家可以直接访问查看本书配套的配套代码，包括 JavaScript，Java，Python 和 C++。 也欢迎大家留言给我们自己想要支持的语言，我们会郑重考虑大家的意见。 效果大概是这样的： 预定如果你也想要第一时间获取到我们的题解新书，那么请发送邮件到 azl397985856@gmail.com，标题著明“书籍《LeetCode 题解》预定”字样。","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"},{"name":"我的书","slug":"我的书","permalink":"https://lucifer.ren/blog/tags/我的书/"}]},{"title":"每日一荐 2020-03 汇总","slug":"daily-featured-2020-03","date":"2020-04-07T03:20:43.505Z","updated":"2020-04-07T03:21:21.673Z","comments":true,"path":"2020/04/07/daily-featured-2020-03/","link":"","permalink":"https://lucifer.ren/blog/2020/04/07/daily-featured-2020-03/","excerpt":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。","text":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。 2020-032020-03-31[好文]gRPC 使用 protobuf 进行数据封装(序列化和反序列化)，同时使用 http2 进行数据传输，为什么不直接基于 TCP 传输呢？grpc 究竟和其他 rpc 框架，比如阿里的 dubbo，facebook 的 Thrift 有什么区别？这篇文章带你了解一下。 地址：https://mp.weixin.qq.com/s/GuMp4Z8oJv9K_MJxMptsSA 2020-03-30[好文]《吊打面试官》系列 Node.js 全栈秒杀系统。这篇文章非常详细地讲述了如何使用 nodejs 构建一个秒杀系统，文中提到的知识点，我也经常在面试中向候选人提问。 https://mp.weixin.qq.com/s/LoRr76smB-M8sNp-85wdqg 2020-03-27[库]今天给大家推荐的是一个图片上传组件 - uppload。支持： 20 多种选择文件的方式 10 种编辑文件的方式 支持自定义将文件发送到服务端 主题 插件 。。。 更重要的是其源码写的很赞，模块划分，代码解耦，以及单元测试都非常值得学习， 感兴趣的可以研究一下。 https://github.com/elninotech/uppload 2020-03-26[好文]一个外国游客来中国广州游玩，定了一家酒店，但是通过 Google 地图去找，离目的地相差几英里，原因在于 Google 使用的地图坐标系统是 WGS-84 ，而国内的比如 Baidu 地图可以很好的显示，因为其用的是 GCJ-02。一句话总结来说： 原文地址：https://abstractkitchen.com/blog/a-short-guide-to-chinese-coordinate-system/ 2020-03-25[工具]微软开源的 Puppeteer 的衍生项目 Playwirght，或许能够替代 Puppeteer。 和 Puppeteer 相比，其有以下特点： 弥补了 Puppeteer 的平台局限性，为所有热门渲染引擎提供类似的功能 和 Puppeteer 基本兼容，用户可以无痛（低痛）迁移 使用了隔离的 BrowserContext，而不是像 Puppeteer 一样共用一个 defaultBrowserContext。 项目地址： https://github.com/microsoft/playwright 2020-03-24[工具]如果你是学生党或者学术党，需要经常查找文献，那么一个文献管理工具就显得很有必要。这里推荐一个工具：Zotero。 地址： https://www.zotero.org/ 2020-03-23[好文]Elasticsearch 已经火了很多年了，现在依然可以见到他们活跃的身影。笔者公司就在用，我也参与了相关开发，其使用起来很简单，但是精通起来却不容易。而很多人正好对其不熟悉，这里正好有一个非常简单易懂的中文教程：《Elasticsearch 学习：入门篇》 地址： https://www.cyhone.com/articles/introduction-of-elasticsearch/index.html 2020-03-20[工具]这是一个在线服务，用来生成几何占位符，类似于 Github 的默认头像。 （Github 的默认头像） 使用方式也很简单，并支持多种参数： 123456789&lt;img src=\"https://generative-placeholders.glitch.me/image?width=600&amp;height=300&amp;img=01\"/&gt;&lt;img src=\"https://generative-placeholders.glitch.me/image?width=600&amp;height=300&amp;img=02\"/&gt;&lt;img src=\"https://generative-placeholders.glitch.me/image?width=600&amp;height=300&amp;img=03\"/&gt; 地址： https://generative-placeholders.glitch.me/ 2020-03-19[好文]政采云的前端 leader（花名堂主） 的一个关于前端基建的分享《堂主 - 如何推动前端团队的基础设施建设 | 7500 字》。如果你的团队也在做基础建设，那么或许可以帮到你，至少可以提供一些思路。 地址： https://mp.weixin.qq.com/s/2VSa3xBpy5St8G1v0RjW9g 2020-03-14[仓库]这里有一个很有意思的仓库，专门用来做远程面试，支持白板代码，视频通话，回放等功能。效果类似之前我在使用的 showmebug。 地址： https://github.com/AgoraIO-Community/2019-Hackathon-Works-CoderLane/blob/master/README.ZH.md 2020-03-13[仓库]一个可以在浏览器端压缩图片的库，从而减少网络传输，进而减小服务端的压力。 地址： https://github.com/Donaldcwl/browser-image-compression 2020-03-12[仓库]一个获取本机网卡信息的库，可以获取到 IPv4，IPv6 以及 MAC 地址。 地址： https://github.com/scravy/node-macaddress 2020-03-11[仓库]著名的知识管理平台《羽雀》就是从最开是的 CodeMirror 迁移到了 slate，slate 其实就是一个 Markdown 编辑器。 但是羽雀最终还是转向自研道路，基于浏览器的 contenteditable 实现富文本编辑器，通过 canvas 实现表格编辑器，通过 SVG 实现思维导图编辑器。 地址：https://github.com/slatedocs/slate 2020-03-10[仓库]一个可以制作类似“Github Project”效果的库。 地址： https://github.com/lourenci/react-kanban 2020-03-09[网站]之前给大家推荐了几个在线练习的网站，有算法的，有正则的，还有 git 的。今天介绍一个练习 SQL 语句的： SQLZOO 是一款很好用的 SQL 练习网站，这里都是比较常用的 SQL 命令。不仅对每个命令的用法有详细解释，每个专题后面还有题目。循序渐进，LeetCode 也有 SQL 相关的题目，不过难度一般比较大，建议大家 把 SQLZOO 刷完基础 SQL 命令再去 LeetCode 刷 SQL 题目。 网站地址：https://sqlzoo.net/ 2020-03-05[好文]Base64 编/解码器有不同实现，有的不相互兼容，如果使用了不兼容的实现，就会有 bug，比如典型的报错“Illegal base64 character a”。本文详细介绍了产生这个问题的原因，文章通俗易懂，适合新手阅读。 记一个 Base64 有关的 Bug 2020-03-03[好文]前端新建一个项目的时候，需要用到很多配置文件，通常是以。开头，因此我们也叫 dotfiles。这篇文章介绍了前端开发常见的 dotfiles，以及其简单用法，或许可以给你一点参考。而且我在我的 mac 装机教程 中也提到了 dotfiles，只不过那边的 dotfiles 更为广泛。 文章地址： https://lyreal666.com/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE-react-typescript%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Adotfiles/ 2020-03-02[好文]原文标题《使用 TypeScript 开发 Web 应用的最佳实践》。文中基本将 TS 在日常开发中的姿势都提到了，并且总结了很多坑点，并且给出了自己的探索和思考。 文章地址：https://yrq110.me/post/front-end/best-practice-of-typescript-in-webapp-developing/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io 关注我我重新整理了下自己的公众号，并且我还给它换了一个名字脑洞前端，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。 在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。 之后我的文章会同步到微信公众号 脑洞前端 ，你可以关注获取最新的文章，并和我进行交流。 另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。 贡献 如果有想法和创意，请提issue或者进群提 如果想贡献代码，请提PR 如果需要修改项目中图片，这里存放了项目中绘制图的源代码， 大家可以用draw.io打开进行编辑。 LicenseApache-2.0","categories":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/categories/每日一荐/"},{"name":"2020-03","slug":"每日一荐/2020-03","permalink":"https://lucifer.ren/blog/categories/每日一荐/2020-03/"}],"tags":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/tags/每日一荐/"}]},{"title":"《82 年生的金智英》","slug":"82-jinzhiying","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-06T04:37:52.843Z","comments":true,"path":"2020/04/06/82-jinzhiying/","link":"","permalink":"https://lucifer.ren/blog/2020/04/06/82-jinzhiying/","excerpt":"《82 年生的金智英》（韩文原始名： 82년생 김지영）是一部由同名小说改编，于 2019 年 10 月 23 号在韩国上映的韩国电影。由金度英执导，郑裕美、孔刘主演。该片讲述出生于 1982 年的三十多岁平凡女性金智英，在产子后因为周围人事变化，以及家庭中婆婆等家人的言行一度造成其心理疾病，以及在其丈夫和家人的帮助下寻找自我恢复。 ​","text":"《82 年生的金智英》（韩文原始名： 82년생 김지영）是一部由同名小说改编，于 2019 年 10 月 23 号在韩国上映的韩国电影。由金度英执导，郑裕美、孔刘主演。该片讲述出生于 1982 年的三十多岁平凡女性金智英，在产子后因为周围人事变化，以及家庭中婆婆等家人的言行一度造成其心理疾病，以及在其丈夫和家人的帮助下寻找自我恢复。 ​ 评分 观后感金智英的生活状况和很多人一样。片子着重讲述的是女人的社会生活状况，包括但不限于被工作歧视，家庭重男轻女，社会中处于弱势位置。 工作中，由于是女性，会被歧视，调侃，连升职也会变得不顺利。借用片中的台词就是“和我一起的男同事，早就升到了 xx”。 重男轻女在韩国就好像之前的中国一样。是整个社会的意识，很难从根本上得到改观。”女生就应该相夫教子等“观念已经深入人心，尤其是老一辈。 社会中处弱势位置。片中讲述了小女孩被一个男孩子盯上，吓得给公交车路人发暗号，并向爸爸发信息求救。爸爸知道了还责怪女孩子不小心，这一幕既真实又令人深思。上厕所被偷拍，以至于上厕所不得不小心翼翼。 带孩子的种种艰辛，或许带过孩子的人会感同身受吧。 我看的时候弹幕一直在刷”我一定要对我的老婆好“，”只恋爱不结婚“。但是话容易说，两个人只有相互理解，尊重，才是对另一方好。否则也只是自己的一厢情愿，强加于人罢了。这样的话，与其说是对别人好，倒不如说是”给自己赎罪，减轻自己的心灵负担“的自私行为罢了。 总的来说，由于社会阅历等原因，这部片子没有给我感同身受的感觉。但是确是一部反映现实，控诉社会的好电影。","categories":[{"name":"电影","slug":"电影","permalink":"https://lucifer.ren/blog/categories/电影/"},{"name":"观后感","slug":"电影/观后感","permalink":"https://lucifer.ren/blog/categories/电影/观后感/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://lucifer.ren/blog/tags/电影/"}]},{"title":"《饥饿站台》","slug":"movie-eager-game","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-06T04:19:54.516Z","comments":true,"path":"2020/04/06/movie-eager-game/","link":"","permalink":"https://lucifer.ren/blog/2020/04/06/movie-eager-game/","excerpt":"《饥饿站台》 （西班牙语：El hoyo）是一部 2019 年的西班牙科幻惊悚电影。导演为加尔德图．加兹特鲁—乌鲁蒂亚里，编剧为佩德罗．里书罗、大卫・狄索拉；由伊万·马萨格、安东尼亚·圣·胡安、佐里昂・埃奎勒、埃米利奥·布阿勒、亚莉珊卓·马桑凯主演。电影情节设于一个塔状的监狱中，囚犯从监狱中间逐渐下降的大平台拿取食物。2019 年 9 月 6 日于 2019 年多伦多国际影展举行首映。","text":"《饥饿站台》 （西班牙语：El hoyo）是一部 2019 年的西班牙科幻惊悚电影。导演为加尔德图．加兹特鲁—乌鲁蒂亚里，编剧为佩德罗．里书罗、大卫・狄索拉；由伊万·马萨格、安东尼亚·圣·胡安、佐里昂・埃奎勒、埃米利奥·布阿勒、亚莉珊卓·马桑凯主演。电影情节设于一个塔状的监狱中，囚犯从监狱中间逐渐下降的大平台拿取食物。2019 年 9 月 6 日于 2019 年多伦多国际影展举行首映。 评分影评网站烂番茄的 54 条评论中，其中 45 篇给出了“新鲜”的正面评价，“新鲜度”为 83%，平均分数 7.43 分（满分 10 分）。 观后感这部片子是少有的可以在国内放映的”限制级“电影。其中有很多暴力血腥以及色情内容。本部片子的主线很简单，简单到“很多人看几分钟的简介就可以了解到整部片子的内容”。 这是一个具有讽刺意味的电影 - “世间只有三类人，一类高层人，一类底层人，还有一类正在坠落。” 片中用楼层的来反应阶级，片中多次有人从上面掉下来，其中掉落的时间都是月末。或许是过惯了好日子，无法再忍受底层的艰苦，而选择了死亡。 片子有一个设定： 每个月都会重新洗牌，交换一次楼层。 片中有合作，背叛，猜忌等人性面，这在平常的生活中很难显现。这让我想起了之前看过的《欺诈游戏》，《下一层》，以及玩过的游戏《999 逃脱系列》。人与人之间，最难建立的是信任，并且信任一旦失去便很难重新建立。如果每个人都能足够信任，就不会存在下层人被饿死的局面。 实际上，这种阶层的观念是很难消除的，这是群体意识决定的。 《乌合之众》中也反复强调过群体意识和个人意识的不同，提到“群体往往呈现出“盲目”、“冲动”、“狂热”、“轻信”的特点，而统治者又是如何利用群体的这些特点建立和巩固自身统治的”。群体意识是会被”利用“的，这种利用可能是好的方向，也可能是不好的方向。群体的力量过于巨大，如同没有被驯化的野兽一般。 我不怕鬼，但是我怕扮成“鬼”的人。","categories":[{"name":"电影","slug":"电影","permalink":"https://lucifer.ren/blog/categories/电影/"},{"name":"观后感","slug":"电影/观后感","permalink":"https://lucifer.ren/blog/categories/电影/观后感/"}],"tags":[{"name":"电影","slug":"电影","permalink":"https://lucifer.ren/blog/tags/电影/"}]},{"title":"【LeetCode日记】 1162. 地图分析","slug":"leetcode-island","date":"2020-03-30T10:13:36.154Z","updated":"2020-03-30T10:19:43.600Z","comments":true,"path":"2020/03/30/leetcode-island/","link":"","permalink":"https://lucifer.ren/blog/2020/03/30/leetcode-island/","excerpt":"LeetCode上有很多小岛题，虽然官方没有这个标签， 但是在我这里都差不多。不管是思路还是套路都比较类似，大家可以结合起来练习。 200.number-of-islands 695.max-area-of-island ​","text":"LeetCode上有很多小岛题，虽然官方没有这个标签， 但是在我这里都差不多。不管是思路还是套路都比较类似，大家可以结合起来练习。 200.number-of-islands 695.max-area-of-island ​ 原题地址：https://leetcode-cn.com/problems/as-far-from-land-as-possible/ 思路这里我们继续使用上面两道题的套路，即不用visited，而是原地修改。由于这道题求解的是最远的距离，而距离我们可以使用BFS来做。算法： 对于每一个海洋，我们都向四周扩展，寻找最近的陆地，每次扩展steps加1。 如果找到了陆地，我们返回steps。 我们的目标就是所有steps中的最大值。 实际上面算法有很多重复计算，如图中间绿色的区域，向外扩展的时候，如果其周边四个海洋的距离已经计算出来了，那么没必要扩展到陆地。实际上只需要扩展到周边的四个海洋格子就好了，其距离陆地的最近距离就是1 + 周边四个格子中到达陆地的最小距离。 我们考虑优化。 将所有陆地加入队列，而不是海洋。 陆地不断扩展到海洋，每扩展一次就steps加1，直到无法扩展位置。 最终返回steps即可。 图解： 代码12345678910111213141516class Solution: def maxDistance(self, grid: List[List[int]]) -&gt; int: n = len(grid) steps = -1 queue = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1] if len(queue) == 0 or len(queue) == n ** 2: return steps while len(queue) &gt; 0: for _ in range(len(queue)): x, y = queue.pop(0) for xi, yj in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]: if xi &gt;= 0 and xi &lt; n and yj &gt;= 0 and yj &lt; n and grid[xi][yj] == 0: queue.append((xi, yj)) grid[xi][yj] = -1 steps += 1 return steps 由于没有early return，steps 其实会多算一次。 我们可以返回值减去1，也可以steps初始化为-1。这里我选择是steps初始化为-1 复杂度分析 时间复杂度：$O(N ^ 2)$ 空间复杂度：$O(N ^ 2)$ 优化由于数组删除第一个元素（上面代码的queue.pop(0)）是$O(N)$的时间复杂度，我们可以使用deque优化，代码如下： 12345678910111213141516171819def maxDistance(self, grid: List[List[int]]) -&gt; int: from collections import deque N = len(grid) steps = -1 q = deque([(i, j) for i in range(N) for j in range(N) if grid[i][j] == 1]) if len(q) == 0 or len(q) == N ** 2: return steps move = [(-1, 0), (1, 0), (0, -1), (0, 1)] while len(q) &gt; 0: for _ in range(len(q)): x, y = q.popleft() for dx, dy in move: nx, ny = x + dx, y + dy if 0 &lt;= nx &lt; N and 0 &lt;= ny &lt; N and grid[nx][ny] == 0: q.append((nx, ny)) grid[nx][ny] = -1 steps += 1 return steps 更多题解可以访问我的LeetCode题解仓库：https://github.com/azl397985856/leetcode 。 目前已经接近30K star啦。 大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的LeetCode题解","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"hashtable","slug":"数据结构/hashtable","permalink":"https://lucifer.ren/blog/categories/数据结构/hashtable/"},{"name":"BFS","slug":"算法/BFS","permalink":"https://lucifer.ren/blog/categories/算法/BFS/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode日记","slug":"LeetCode日记","permalink":"https://lucifer.ren/blog/tags/LeetCode日记/"}]},{"title":"位运算","slug":"bit","date":"2020-03-23T16:00:00.000Z","updated":"2020-03-27T02:48:13.455Z","comments":true,"path":"2020/03/24/bit/","link":"","permalink":"https://lucifer.ren/blog/2020/03/24/bit/","excerpt":"我这里总结了几道位运算的题目分享给大家，分别是 136和137， 260 和 645， 总共加起来四道题。 四道题全部都是位运算的套路，如果你想练习位运算的话，不要错过哦～～","text":"我这里总结了几道位运算的题目分享给大家，分别是 136和137， 260 和 645， 总共加起来四道题。 四道题全部都是位运算的套路，如果你想练习位运算的话，不要错过哦～～ 前菜开始之前我们先了解下异或，后面会用到。 异或的性质 两个数字异或的结果a^b是将 a 和 b 的二进制每一位进行运算，得出的数字。 运算的逻辑是果同一位的数字相同则为 0，不同则为 1 异或的规律 任何数和本身异或则为0 任何数和 0 异或是本身 异或运算满足交换律，即： a ^ b ^ c = a ^ c ^ b OK，我们来看下这三道题吧。 136. 只出现一次的数字1题目大意是除了一个数字出现一次，其他都出现了两次，让我们找到出现一次的数。我们执行一次全员异或即可。 123456class Solution: def singleNumber(self, nums: List[int]) -&gt; int: single_number = 0 for num in nums: single_number ^= num return single_number 复杂度分析 时间复杂度：$O(N)$，其中N为数组长度。 空间复杂度：$O(1)$ 137. 只出现一次的数字2题目大意是除了一个数字出现一次，其他都出现了三次，让我们找到出现一次的数。 灵活运用位运算是本题的关键。 Python3: 1234567891011121314class Solution: def singleNumber(self, nums: List[int]) -&gt; int: res = 0 for i in range(32): cnt = 0 # 记录当前 bit 有多少个1 bit = 1 &lt;&lt; i # 记录当前要操作的 bit for num in nums: if num &amp; bit != 0: cnt += 1 if cnt % 3 != 0: # 不等于0说明唯一出现的数字在这个 bit 上是1 res |= bit return res - 2 ** 32 if res &gt; 2 ** 31 - 1 else res 为什么Python最后需要对返回值进行判断？ 如果不这么做的话测试用例是[-2,-2,1,1,-3,1,-3,-3,-4,-2] 的时候，就会输出 4294967292。 其原因在于Python是动态类型语言，在这种情况下其会将符号位置的1看成了值，而不是当作符号“负数”。 这是不对的。 正确答案应该是 - 4，-4的二进制码是 1111…100，就变成 2^32-4=4294967292，解决办法就是 减去 2 ** 32 。 之所以这样不会有问题的原因还在于题目限定的数组范围不会超过 2 ** 32 JavaScript: 123456789101112var singleNumber = function(nums) &#123; let res = 0; for (let i = 0; i &lt; 32; i++) &#123; let cnt = 0; let bit = 1 &lt;&lt; i; for (let j = 0; j &lt; nums.length; j++) &#123; if (nums[j] &amp; bit) cnt++; &#125; if (cnt % 3 != 0) res = res | bit; &#125; return res;&#125;; 复杂度分析 时间复杂度：$O(N)$，其中N为数组长度。 空间复杂度：$O(1)$ 645. 错误的集合和上面的137. 只出现一次的数字2思路一样。这题没有限制空间复杂度，因此直接hashmap 存储一下没问题。 不多说了，我们来看一种空间复杂度$O(1)$的解法。 由于和137. 只出现一次的数字2思路基本一样，我直接复用了代码。具体思路是，将nums的所有索引提取出一个数组idx，那么由idx和nums组成的数组构成singleNumbers的输入，其输出是唯二不同的两个数。 但是我们不知道哪个是缺失的，哪个是重复的，因此我们需要重新进行一次遍历，判断出哪个是缺失的，哪个是重复的。 123456789101112131415161718192021222324252627282930class Solution: def singleNumbers(self, nums: List[int]) -&gt; List[int]: ret = 0 # 所有数字异或的结果 a = 0 b = 0 for n in nums: ret ^= n # 找到第一位不是0的 h = 1 while(ret &amp; h == 0): h &lt;&lt;= 1 for n in nums: # 根据该位是否为0将其分为两组 if (h &amp; n == 0): a ^= n else: b ^= n return [a, b] def findErrorNums(self, nums: List[int]) -&gt; List[int]: nums = [0] + nums idx = [] for i in range(len(nums)): idx.append(i) a, b = self.singleNumbers(nums + idx) for num in nums: if a == num: return [a, b] return [b, a] 复杂度分析 时间复杂度：$O(N)$ 空间复杂度：$O(1)$ 260. 只出现一次的数字3题目大意是除了两个数字出现一次，其他都出现了两次，让我们找到这个两个数。 我们进行一次全员异或操作，得到的结果就是那两个只出现一次的不同的数字的异或结果。 我们刚才讲了异或的规律中有一个任何数和本身异或则为0， 因此我们的思路是能不能将这两个不同的数字分成两组 A 和 B。分组需要满足两个条件. 两个独特的的数字分成不同组 相同的数字分成相同组 这样每一组的数据进行异或即可得到那两个数字。 问题的关键点是我们怎么进行分组呢？ 由于异或的性质是，同一位相同则为 0，不同则为 1. 我们将所有数字异或的结果一定不是 0，也就是说至少有一位是 1. 我们随便取一个， 分组的依据就来了， 就是你取的那一位是 0 分成 1 组，那一位是 1 的分成一组。这样肯定能保证2. 相同的数字分成相同组, 不同的数字会被分成不同组么。 很明显当然可以， 因此我们选择是 1，也就是说两个独特的的数字在那一位一定是不同的，因此两个独特元素一定会被分成不同组。 12345678910111213141516171819class Solution: def singleNumbers(self, nums: List[int]) -&gt; List[int]: ret = 0 # 所有数字异或的结果 a = 0 b = 0 for n in nums: ret ^= n # 找到第一位不是0的 h = 1 while(ret &amp; h == 0): h &lt;&lt;= 1 for n in nums: # 根据该位是否为0将其分为两组 if (h &amp; n == 0): a ^= n else: b ^= n return [a, b] 复杂度分析 时间复杂度：$O(N)$，其中N为数组长度。 空间复杂度：$O(1)$ 更多题解可以访问我的LeetCode题解仓库：https://github.com/azl397985856/leetcode 。 目前已经接近30K star啦。 大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的LeetCode题解","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"位运算","slug":"位运算","permalink":"https://lucifer.ren/blog/tags/位运算/"}]},{"title":"一文带你 AC 十道题【滑动窗口】","slug":"slide-window","date":"2020-03-16T13:53:30.342Z","updated":"2020-03-17T02:15:12.628Z","comments":true,"path":"2020/03/16/slide-window/","link":"","permalink":"https://lucifer.ren/blog/2020/03/16/slide-window/","excerpt":"笔者最早接触滑动窗口是滑动窗口协议，滑动窗口协议（Sliding Window Protocol），属于 TCP 协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。 发送方和接收方分别有一个窗口大小 w1 和 w2。窗口大小可能会根据网络流量的变化而有所不同，但是在更简单的实现中它们是固定的。窗口大小必须大于零才能进行任何操作。 我们算法中的滑动窗口也是类似，只不过包括的情况更加广泛。实际上上面的滑动窗口在某一个时刻就是固定窗口大小的滑动窗口，随着网络流量等因素改变窗口大小也会随着改变。接下来我们讲下算法中的滑动窗口。","text":"笔者最早接触滑动窗口是滑动窗口协议，滑动窗口协议（Sliding Window Protocol），属于 TCP 协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。 发送方和接收方分别有一个窗口大小 w1 和 w2。窗口大小可能会根据网络流量的变化而有所不同，但是在更简单的实现中它们是固定的。窗口大小必须大于零才能进行任何操作。 我们算法中的滑动窗口也是类似，只不过包括的情况更加广泛。实际上上面的滑动窗口在某一个时刻就是固定窗口大小的滑动窗口，随着网络流量等因素改变窗口大小也会随着改变。接下来我们讲下算法中的滑动窗口。 介绍滑动窗口是一种解决问题的思路和方法，通常用来解决一些连续问题。 比如 LeetCode 的 209. 长度最小的子数组。更多滑动窗口题目见下方题目列表。 常见套路滑动窗口主要用来处理连续问题。比如题目求解“连续子串 xxxx”，“连续子数组 xxxx”，就应该可以想到滑动窗口。能不能解决另说，但是这种敏感性还是要有的。 从类型上说主要有： 固定窗口大小 窗口大小不固定，求解最大的满足条件的窗口 窗口大小不固定，求解最小的满足条件的窗口（上面的 209 题就属于这种） 后面两种我们统称为可变窗口。当然不管是哪种类型基本的思路都是一样的，不一样的仅仅是代码细节。 固定窗口大小对于固定窗口，我们只需要固定初始化左右指针 l 和 r，分别表示的窗口的左右顶点，并且保证： l 初始化为 0 初始化 r，使得 r - l + 1 等于窗口大小 同时移动 l 和 r 判断窗口内的连续元素是否满足题目限定的条件 4.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解 4.2 如果不满足，则继续。 可变窗口大小对于可变窗口，我们同样固定初始化左右指针 l 和 r，分别表示的窗口的左右顶点。后面有所不同，我们需要保证： l 和 r 都初始化为 0 r 指针移动一步 判断窗口内的连续元素是否满足题目限定的条件 4.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。并尝试通过移动 l 指针缩小窗口大小。循环执行 4.1 4.2 如果不满足，则继续。 形象地来看的话，就是 r 指针不停向右移动，l 指针仅仅在窗口满足条件之后才会移动，起到窗口收缩的效果。 模板代码以下是 209 题目的代码，使用 Python 编写，大家意会即可。 1234567891011class Solution: def minSubArrayLen(self, s: int, nums: List[int]) -&gt; int: l = total = 0 ans = len(nums) + 1 for r in range(len(nums)): total += nums[r] while total &gt;= s: ans = min(ans, r - l + 1) total -= nums[l] l += 1 return 0 if ans == len(nums) + 1 else ans 题目列表以下题目有的信息比较直接，有的题目信息比较隐蔽，需要自己发掘 【Python，JavaScript】滑动窗口（3. 无重复字符的最长子串） 76. 最小覆盖子串 209. 长度最小的子数组 【Python】滑动窗口（438. 找到字符串中所有字母异位词） 【904. 水果成篮】（Python3） 【930. 和相同的二元子数组】（Java，Python） 【992. K 个不同整数的子数组】滑动窗口（Python） 【1004. 最大连续 1 的个数 III】滑动窗口（Python3） 【1234. 替换子串得到平衡字符串】[Java/C++/Python] Sliding Window 【1248. 统计「优美子数组」】滑动窗口（Python） 扩展阅读 LeetCode Sliding Window Series Discussion","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"},{"name":"算法，滑动窗口","slug":"算法，滑动窗口","permalink":"https://lucifer.ren/blog/categories/算法，滑动窗口/"},{"name":"数据结构，数组","slug":"数据结构，数组","permalink":"https://lucifer.ren/blog/categories/数据结构，数组/"},{"name":"数据结构，字符串","slug":"数据结构，字符串","permalink":"https://lucifer.ren/blog/categories/数据结构，字符串/"}],"tags":[{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://lucifer.ren/blog/tags/滑动窗口/"}]},{"title":"【LeetCode 日记】85. 最大矩形","slug":"85.maximal-rectangle","date":"2020-03-03T17:13:49.879Z","updated":"2020-03-03T17:15:05.705Z","comments":true,"path":"2020/03/04/85.maximal-rectangle/","link":"","permalink":"https://lucifer.ren/blog/2020/03/04/85.maximal-rectangle/","excerpt":"这是一道 Hard 难度的题目，本题的解法很多，让我们来看一下。 ​","text":"这是一道 Hard 难度的题目，本题的解法很多，让我们来看一下。 ​ 原题地址： https://leetcode-cn.com/problems/maximal-rectangle/ 题目描述给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。 示例： 输入： 123456[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]] 输出：6 思路我在 【84. 柱状图中最大的矩形】多种方法（Python3） 使用了多种方法来解决。 然而在这道题，我们仍然可以使用完全一样的思路去完成。 不熟悉的可以看下我的题解。本题解是基于那道题的题解来进行的。 拿题目给的例子来说： 123456[ [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;], [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]] 我们逐行扫描得到 84. 柱状图中最大的矩形 中的 heights 数组： 这样我们就可以使用84. 柱状图中最大的矩形 中的解法来进行了，这里我们使用单调栈来解。 代码1234567891011121314151617181920212223class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: n, heights, st, ans = len(heights), [0] + heights + [0], [], 0 for i in range(n + 2): while st and heights[st[-1]] &gt; heights[i]: ans = max(ans, heights[st.pop(-1)] * (i - st[-1] - 1)) st.append(i) return ans def maximalRectangle(self, matrix: List[List[str]]) -&gt; int: m = len(matrix) if m == 0: return 0 n = len(matrix[0]) heights = [0] * n ans = 0 for i in range(m): for j in range(n): if matrix[i][j] == \"0\": heights[j] = 0 else: heights[j] += 1 ans = max(ans, self.largestRectangleArea(heights)) return ans 复杂度分析 时间复杂度：$O(M * N)$ 空间复杂度：$O(N)$ 欢迎关注我的公众号《脑洞前端》获取更多更新鲜的 LeetCode 题解","categories":[{"name":"数据结构，单调栈","slug":"数据结构，单调栈","permalink":"https://lucifer.ren/blog/categories/数据结构，单调栈/"},{"name":"Hard","slug":"Hard","permalink":"https://lucifer.ren/blog/categories/Hard/"}],"tags":[{"name":"数据结构，算法，LeetCode 日记，Hard","slug":"数据结构，算法，LeetCode-日记，Hard","permalink":"https://lucifer.ren/blog/tags/数据结构，算法，LeetCode-日记，Hard/"}]},{"title":"【LeetCode 日记】 84. 柱状图中最大的矩形","slug":"84.largest-rectangle-in-histogram","date":"2020-03-03T17:06:48.759Z","updated":"2020-03-03T17:14:05.348Z","comments":true,"path":"2020/03/04/84.largest-rectangle-in-histogram/","link":"","permalink":"https://lucifer.ren/blog/2020/03/04/84.largest-rectangle-in-histogram/","excerpt":"这是一道 Hard 难度的题目，本题的解法很多，让我们来看一下。 ​","text":"这是一道 Hard 难度的题目，本题的解法很多，让我们来看一下。 ​ 原题地址： https://leetcode-cn.com/problems/largest-rectangle-in-histogram/ 题目描述`给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例： 输入：[2,1,5,6,2,3]输出：10 暴力枚举 - 左右端点法（TLE）思路我们暴力尝试所有可能的矩形。由于矩阵是二维图形， 我我们可以使用左右两个端点来唯一确认一个矩阵。因此我们使用双层循环枚举所有的可能性即可。 而矩形的面积等于（右端点坐标 - 左端点坐标 + 1) * 最小的高度，最小的高度我们可以在遍历的时候顺便求出。 代码1234567891011class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: n, ans = len(heights), 0 if n != 0: ans = heights[0] for i in range(n): height = heights[i] for j in range(i, n): height = min(height, heights[j]) ans = max(ans, (j - i + 1) * height) return ans 复杂度分析 时间复杂度：$O(N^2)$ 空间复杂度：$O(1)$ 暴力枚举 - 中心扩展法（TLE）思路我们仍然暴力尝试所有可能的矩形。只不过我们这一次从中心向两边进行扩展。对于每一个 i，我们计算出其左边第一个高度小于它的索引 p，同样地，计算出右边第一个高度小于它的索引 q。那么以 i 为最低点能够构成的面积就是(q - p - 1) * heights[i]。 这种算法毫无疑问也是正确的。 我们证明一下，假设 f(i) 表示求以 i 为最低点的情况下，所能形成的最大矩阵面积。那么原问题转化为max(f(0), f(1), f(2), ..., f(n - 1))。 具体算法如下： 我们使用 l 和 r 数组。l[i] 表示 左边第一个高度小于它的索引，r[i] 表示 右边第一个高度小于它的索引。 我们从前往后求出 l，再从后往前计算出 r。 再次遍历求出所有的可能面积，并取出最大的。 代码1234567891011121314151617class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: n = len(heights) l, r, ans = [-1] * n, [n] * n, 0 for i in range(1, n): j = i - 1 while j &gt;= 0 and heights[j] &gt;= heights[i]: j -= 1 l[i] = j for i in range(n - 2, -1, -1): j = i + 1 while j &lt; n and heights[j] &gt;= heights[i]: j += 1 r[i] = j for i in range(n): ans = max(ans, heights[i] * (r[i] - l[i] - 1)) return ans 复杂度分析 时间复杂度：$O(N^2)$ 空间复杂度：$O(N)$ 优化中心扩展法（Accepted）思路实际上我们内层循环没必要一步一步移动，我们可以直接将j -= 1 改成 j = l[j], j += 1 改成 j = r[j]。 代码123456789101112131415161718class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: n = len(heights) l, r, ans = [-1] * n, [n] * n, 0 for i in range(1, n): j = i - 1 while j &gt;= 0 and heights[j] &gt;= heights[i]: j = l[j] l[i] = j for i in range(n - 2, -1, -1): j = i + 1 while j &lt; n and heights[j] &gt;= heights[i]: j = r[j] r[i] = j for i in range(n): ans = max(ans, heights[i] * (r[i] - l[i] - 1)) return ans 复杂度分析 时间复杂度：$O(N)$ 空间复杂度：$O(N)$ 单调栈（Accepted）思路实际上，读完第二种方法的时候，你应该注意到了。我们的核心是求左边第一个比 i 小的和右边第一个比 i 小的。 如果你熟悉单调栈的话，那么应该会想到这是非常适合使用单调栈来处理的场景。 为了简单起见，我在 heights 首尾添加了两个哨兵元素，这样可以减少边界处理的额外代码。 代码12345678class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: n, heights, st, ans = len(heights), [0] + heights + [0], [], 0 for i in range(n + 2): while st and heights[st[-1]] &gt; heights[i]: ans = max(ans, heights[st.pop(-1)] * (i - st[-1] - 1)) st.append(i) return ans 复杂度分析 时间复杂度：$O(N)$ 空间复杂度：$O(N)$ 欢迎关注我的公众号《脑洞前端》获取更多更新鲜的 LeetCode 题解","categories":[{"name":"数据结构，单调栈","slug":"数据结构，单调栈","permalink":"https://lucifer.ren/blog/categories/数据结构，单调栈/"},{"name":"Hard","slug":"Hard","permalink":"https://lucifer.ren/blog/categories/Hard/"}],"tags":[{"name":"数据结构，算法，LeetCode 日记，Hard","slug":"数据结构，算法，LeetCode-日记，Hard","permalink":"https://lucifer.ren/blog/tags/数据结构，算法，LeetCode-日记，Hard/"}]},{"title":"每日一荐 2020-01 汇总","slug":"daily-featured-2020-01","date":"2020-02-25T02:39:51.279Z","updated":"2020-02-25T02:41:25.898Z","comments":true,"path":"2020/02/25/daily-featured-2020-01/","link":"","permalink":"https://lucifer.ren/blog/2020/02/25/daily-featured-2020-01/","excerpt":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。","text":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。 2020-012020-01-23[资料]尤雨溪在多伦多的演讲《Vue 3.0 设计原则》对于想要学习 Vue3.0 或者想要直接从零开发 Vue3.0 的人来说，绝对是必读的。PPT 内容不多，几分钟就可以读完，不建议看视频，视频大概有 50 多分钟。 PPT 地址： https://docs.google.com/presentation/d/1r0HcS4baHy2c106DsZ4jA7Zt0R9u2MnRmmKIvAVuf1o/edit#slide=id.p 2020-01-22[软件]安卓软件的开屏广告很烦人，严重影响效率。这里推荐一个安卓 APP 可以改善这种情况, 并且不需要 root，只需要开启权限即可。注意它不是万能的，不过实际使用情况来看，还是有用的。 地址： https://www.coolapk.com/apk/me.angeldevil.autoskip 2020-01-21[好文]可访问性真的是一个非常重要的东西，尤其是对于有障碍人士。但是整个行业在这方面做的还完全不够，不管是技术能力，还是重视程度上。 比如我在使用钉钉软件的时候，他们的快捷键很少，这一点非常困扰我，当然类似的应用还有很多。我觉得整个行业应该注重起来这一块，将可访问性做好，要知道这也是用户体验中很重要的组成。这里有一篇文章 《Debugging your application for accessibility》， 从浅层次上讲解了可访问性的内容，以及基本实践，同时还推荐了一个叫 axe 的 chrome 扩展工具帮助你分析网页存在的可访问性问题，类似于 网页性能分析之于 lighthouse。 文章地址： https://blog.logrocket.com/debugging-application-accessibility/ 2020-01-20[网站]我平时有 RSS 阅读的习惯，我使用的 Feedly 管理订阅内容。但是有的网站本身并不支持 RSS 订阅。那么一种黑科技，就是使用第三方服务帮我们转换一下，生成订阅。原理很简单，就是轮训内容变化，如果变化就通知你。当然前提你要知道“如何判断发布了新内容”，这部分 feed43 做的不错。我们利用 Feed43，将任意网页制作成 RSS 订阅源。 这里有一篇少数派的文章，大家可以参考一下： https://sspai.com/post/34320 你也可以使用 rsshub 来做同样的事情，rsshub 支持私有化部署，地址： https://docs.rsshub.app/。 2020-01-19[网站]给大家介绍一个 mac 软件下载网站，效果你懂的。类似的网站还有 xclient.info。 地址：https://www.macappdownload.com/ 2020-01-17[工具]如果你想开发一个 VSCode 插件，那么一个脚手架是有用的。我推荐使用官方的脚手架工具。顺便再推荐一个 vscode 插件开发指南，来自 sorrycc，地址 https://www.yuque.com/docs/share/cf6d9191-be02-4644-aef5-afc2f2f38297 地址： https://github.com/Microsoft/vscode-generator-code 2020-01-16[工具]不改变任何功能的情况下给你的 docker image 瘦身。 Github 地址： https://github.com/docker-slim/docker-slim 2020-01-13[插件]今天推荐两个关于 Github 的 chrome 插件。 一个是用来查看 Github 提交历史的，名字是Git History Browser Extension，安装之后 git 文件右上角信息会多一个按钮。 点开之后是这种画风： 另外一个插件是OctoLinker。这个插件你可以用来方便地进行文件跳转。 2020-01-09[好文]如果你关注 Node.js 社区，那么你一定记得 Node.js v12 一个非常重磅的功能就是，内核的 HTTP Parser 默认使用 llhttp，取代了老旧的 http-parser，性能提升了 156%。 但知其然也要知其所以然，llhttp 是如何做到这一点的呢？《llhttp 是如何使 Node.js 性能翻倍的？》进行了详细的阐述。 地址： https://zhuanlan.zhihu.com/p/100660049 2020-01-08[好文]昨天介绍了《当你在浏览器中输入 google.com 并且按下回车之后发生了什么？》，今天推荐一篇《图解浏览器的基本工作原理》。 讲的内容主要是浏览器渲染相关的，让你在更大的视角，更细的粒度了解浏览器原理，最可贵的是文章通俗易懂，图文并茂，对于想了解浏览器原理而又找不到好的入门资料的同学来说很有用。 其中还提到了很多延伸知识，比如事件冒泡更微观角度是什么？事件的 passive：true 做了什么？为什么很多时候我们绘图不流畅以及如何实现平滑绘图？ 12345678window.addEventListener(\"pointermove\", event =&gt; &#123; const events = event.getCoalescedEvents(); for (let event of events) &#123; const x = event.pageX; const y = event.pageY; // draw a line using x and y coordinates. &#125;&#125;); (使用 getCoalescedEvents API 来获取组合的事件，从而绘制一条平滑的曲线) 文章地址： https://zhuanlan.zhihu.com/p/47407398 2020-01-07[好文]或许目前实际上最全的《当你在浏览器中输入 google.com 并且按下回车之后发生了什么？》。文档内容不仅局限于 DNS，TCP，HTTP，CDN。发送 HTML，解析 DOM 等过程，甚至包括了物理键盘和系统中断的工作原理，系统中断，ARP 等等更为详细的内容。 地址： https://github.com/skyline75489/what-happens-when-zh_CN 2020-01-06[框架]前端测试正在变得越来越重要，之前也写了一篇文章前端测试，那么拥有一个顺手的测试框架显得越来越重要。 我个人目前在使用的测试框架是 Jest，除了 Jest 还有很多优秀的测试框架，知己知彼，百战不殆。我们看看下： Mocha：非常老牌的测试框架，使用 Jest 之前我在用 Enzyme：一个 React 测试框架，后期我不再使用了，而是转向 Jest + react-dom/test-utils Ava Jasmine Cypress 另外你做自动化测试的话，推荐使用 Puppeteer，如果你做组件测试的话可以考虑 Jest 的快照或者 StoryBook（一个 2015 年以来一直关注并且看好的一个框架）。 关注我我重新整理了下自己的公众号，并且我还给它换了一个名字脑洞前端，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。 在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。 之后我的文章会同步到微信公众号 脑洞前端 ，你可以关注获取最新的文章，并和我进行交流。 另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。 贡献 如果有想法和创意，请提issue或者进群提 如果想贡献代码，请提PR 如果需要修改项目中图片，这里存放了项目中绘制图的源代码， 大家可以用draw.io打开进行编辑。 LicenseApache-2.0","categories":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/categories/每日一荐/"},{"name":"2020-01","slug":"每日一荐/2020-01","permalink":"https://lucifer.ren/blog/categories/每日一荐/2020-01/"}],"tags":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/tags/每日一荐/"}]},{"title":"【算法提高班】并查集","slug":"union-find","date":"2020-02-20T10:41:19.407Z","updated":"2020-02-20T11:10:06.792Z","comments":true,"path":"2020/02/20/union-find/","link":"","permalink":"https://lucifer.ren/blog/2020/02/20/union-find/","excerpt":"关于并查集的题目不少，官方给的数据是 30 道（截止 2020-02-20），但是有一些题目虽然官方没有贴并查集标签，但是使用并查集来说确非常简单。这类题目如果掌握模板，那么刷这种题会非常快，并且犯错的概率会大大降低，这就是模板的好处。","text":"关于并查集的题目不少，官方给的数据是 30 道（截止 2020-02-20），但是有一些题目虽然官方没有贴并查集标签，但是使用并查集来说确非常简单。这类题目如果掌握模板，那么刷这种题会非常快，并且犯错的概率会大大降低，这就是模板的好处。 我这里总结了几道并查集的题目： 547.朋友圈 721. 账户合并 990. 等式方程的可满足性 大家可以学了模板之后去套用一下上面的三道题，做不出来的可以看看我的题解。 并查集概述并查集算法，主要是解决图论中「动态连通性」问题的 Union-Find 算法解决的是图的动态连通性问题，这个算法本身不难，能不能应用出来主要是看你抽象问题的能力，是否能够把原始问题抽象成一个有关图论的问题。 如果你对这个算法不是很明白，推荐看一下这篇文章Union-Find 算法详解，讲的非常详细。 你可以把并查集的元素看成部门的人，几个人可以组成一个部门个数。 并查集核心的三个方法分别是union, find, connected。 union: 将两个人所在的两个部门合并成一个部门（如果两个人是相同部门，实际山不需要合并） （图来自 labuladong） find: 查找某个人的部门 leader connnected: 判断两个人是否是一个部门的 （图来自 labuladong） 模板这是一个我经常使用的模板，我会根据具体题目做细小的变化，但是大体是不变的。 12345678910111213141516class UF: parent = &#123;&#125; cnt = 0 def __init__(self, M): # 初始化 parent 和 cnt def find(self, x): while x != self.parent[x]: x = self.parent[x] return x def union(self, p, q): if self.connected(p, q): return self.parent[self.find(p)] = self.find(q) self.cnt -= 1 def connected(self, p, q): return self.find(p) == self.find(q) 如果你想要更好的性能，这个模板更适合你，相应地代码稍微有一点复杂。 12345678910111213141516171819202122232425class UF: parent = &#123;&#125; size = &#123;&#125; cnt = 0 def __init__(self, M): # 初始化 parent，size 和 cnt def find(self, x): while x != self.parent[x]: x = self.parent[x] # 路径压缩 self.parent[x] = self.parent[self.parent[x]]; return x def union(self, p, q): if self.connected(p, q): return # 小的树挂到大的树上， 使树尽量平衡 leader_p = self.find(p) leader_q = self.find(q) if self.size[leader_p] &lt; self.size[leader_q]: self.parent[leader_p] = leader_q else: self.parent[leader_q] = leader_p self.cnt -= 1 def connected(self, p, q): return self.find(p) == self.find(q) 大家可以根据情况使用不同的模板。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"},{"name":"算法系列","slug":"算法系列","permalink":"https://lucifer.ren/blog/tags/算法系列/"}]},{"title":"贪婪策略系列 - 覆盖篇","slug":"leetcode-greedy","date":"2020-02-18T16:00:52.081Z","updated":"2020-02-18T16:02:35.989Z","comments":true,"path":"2020/02/19/leetcode-greedy/","link":"","permalink":"https://lucifer.ren/blog/2020/02/19/leetcode-greedy/","excerpt":"贪婪策略是一种常见的算法思想，具体是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关，这点和动态规划一样。 LeetCode 上对于贪婪策略有 73 道题目。我们将其分成几个类型来讲解，截止目前我们暂时只提供覆盖问题，其他的可以期待我的新书或者之后的题解文章。","text":"贪婪策略是一种常见的算法思想，具体是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关，这点和动态规划一样。 LeetCode 上对于贪婪策略有 73 道题目。我们将其分成几个类型来讲解，截止目前我们暂时只提供覆盖问题，其他的可以期待我的新书或者之后的题解文章。 覆盖我们挑选三道来讲解，这三道题除了使用贪婪法，你也可以尝试动态规划来解决。 45. 跳跃游戏 II，困难 1024. 视频拼接，中等 1326. 灌溉花园的最少水龙头数目，困难 覆盖问题的一大特征，我们可以将其抽象为给定数轴上的一个大区间 I 和 n 个小区间 i[0], i[1], ..., i[n - 1]，问最少选择多少个小区间，使得这些小区间的并集可以覆盖整个大区间。 我们来看下这三道题吧。 45. 跳跃游戏 II题目描述给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。说明: 假设你总是可以到达数组的最后一个位置。 思路贪婪策略，即我们每次在可跳范围内选择可以使得跳的更远的位置，由于题目保证了你总是可以到达数组的最后一个位置,因此这种算法是完备的。 如下图，开始的位置是 2，可跳的范围是橙色的。然后因为 3 可以跳的更远，所以跳到 3 的位置。 如下图，然后现在的位置就是 3 了，能跳的范围是橙色的，然后因为 4 可以跳的更远，所以下次跳到 4 的位置。 写代码的话，我们用 end 表示当前能跳的边界，对于上边第一个图的橙色 1，第二个图中就是橙色的 4，遍历数组的时候，到了边界，我们就重新更新新的边界。 图来自 https://leetcode-cn.com/u/windliang/ 代码代码支持：Python3 Python3 Code: 12345678910class Solution: def jump(self, nums: List[int]) -&gt; int: n, cnt, furthest, end = len(nums), 0, 0, 0 for i in range(n - 1): furthest = max(furthest, nums[i] + i) if i == end: cnt += 1 end = furthest return cnt 复杂度分析 时间复杂度：$O(N)$。 空间复杂度：$O(1)$。 1024. 视频拼接题目描述你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。 视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。 我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。 示例 1： 输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10输出：3解释：我们选中 [0,2], [8,10], [1,9] 这三个片段。然后，按下面的方案重制比赛片段：将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。示例 2： 输入：clips = [[0,1],[1,2]], T = 5输出：-1解释：我们无法只用 [0,1] 和 [0,2] 覆盖 [0,5] 的整个过程。示例 3： 输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9输出：3解释：我们选取片段 [0,4], [4,7] 和 [6,9] 。示例 4： 输入：clips = [[0,4],[2,8]], T = 5输出：2解释：注意，你可能录制超过比赛结束时间的视频。 提示： 1 &lt;= clips.length &lt;= 1000 &lt;= clips[i][0], clips[i][1] &lt;= 1000 &lt;= T &lt;= 100 思路贪婪策略，我们选择满足条件的最大值。和上面的不同，这次我们需要手动进行一次排序，实际上贪婪策略经常伴随着排序，我们按照 clip[0]从小到大进行排序。 如图： 1 不可以，因此存在断层 2 可以 3 不行，因为不到 T 我们当前的 clip 开始结束时间分别为 s，e。 上一段 clip 的结束时间是 t1，上上一段 clip 结束时间是 t2。 那么这种情况下 t1 实际上是不需要的，因为 t2 完全可以覆盖它： 那什么样 t1 才是需要的呢？如图： 用代码来说的话就是s &gt; t2 and t2 &lt;= t1 代码代码支持：Python3 Python3 Code: 12345678910111213141516class Solution: def videoStitching(self, clips: List[List[int]], T: int) -&gt; int: # t1 表示选取的上一个clip的结束时间 # t2 表示选取的上上一个clip的结束时间 t2, t1, cnt = -1, 0, 0 clips.sort(key=lambda a: a[0]) for s, e in clips: # s &gt; t1 已经确定不可以了， t1 &gt;= T 已经可以了 if s &gt; t1 or t1 &gt;= T: break if s &gt; t2 and t2 &lt;= t1: cnt += 1 t2 = t1 t1 = max(t1,e) return cnt if t1 &gt;= T else - 1 复杂度分析 时间复杂度：由于使用了排序（假设是基于比较的排序），因此时间复杂度为 $O(NlogN)$。 空间复杂度：$O(1)$。 1326. 灌溉花园的最少水龙头数目题目描述在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。 花园里总共有 n + 1 个水龙头，分别位于 [0, 1, …, n] 。 给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i - ranges[i], i + ranges[i]] 。 请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。 示例 1： 输入：n = 5, ranges = [3,4,1,1,0,0]输出：1解释：点 0 处的水龙头可以灌溉区间 [-3,3]点 1 处的水龙头可以灌溉区间 [-3,5]点 2 处的水龙头可以灌溉区间 [1,3]点 3 处的水龙头可以灌溉区间 [2,4]点 4 处的水龙头可以灌溉区间 [4,4]点 5 处的水龙头可以灌溉区间 [5,5]只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。示例 2： 输入：n = 3, ranges = [0,0,0,0]输出：-1解释：即使打开所有水龙头，你也无法灌溉整个花园。示例 3： 输入：n = 7, ranges = [1,2,1,0,2,1,0,1]输出：3示例 4： 输入：n = 8, ranges = [4,0,0,0,0,0,0,0,4]输出：2示例 5： 输入：n = 8, ranges = [4,0,0,0,4,0,0,0,4]输出：1 提示： 1 &lt;= n &lt;= 10^4ranges.length == n + 10 &lt;= ranges[i] &lt;= 100 思路贪心策略，我们尽量找到能够覆盖最远（右边）位置的水龙头，并记录它最右覆盖的土地。 我们使用 furthest[i] 来记录经过每一个水龙头 i 能够覆盖的最右侧土地。 一共有 n+1 个水龙头，我们遍历 n + 1 次。 对于每次我们计算水龙头的左右边界，[i - ranges[i], i + ranges[i]] 我们更新左右边界范围内的水龙头的 furthest 最后从土地 0 开始，一直到土地 n ，记录水龙头数目 代码代码支持：Python3 Python3 Code: 123456789101112131415class Solution: def minTaps(self, n: int, ranges: List[int]) -&gt; int: furthest, cnt, cur = [0] * n, 0, 0 for i in range(n + 1): l = max(0, i - ranges[i]) r = min(n, i + ranges[i]) for j in range(l, r): furthest[j] = max(furthest[j], r) while cur &lt; n: if furthest[cur] == 0: return -1 cur = furthest[cur] cnt += 1 return cnt 复杂度分析 时间复杂度：时间复杂度取决 l 和 r，也就是说取决于 ranges 数组的值，假设 ranges 的平均大小为 Size 的话，那么时间复杂度为 $O(N * Size)$。 空间复杂度：我们使用了 furthest 数组， 因此空间复杂度为 $O(N)$。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"},{"name":"贪婪","slug":"贪婪","permalink":"https://lucifer.ren/blog/categories/贪婪/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"},{"name":"算法系列","slug":"算法系列","permalink":"https://lucifer.ren/blog/tags/算法系列/"},{"name":"贪婪","slug":"贪婪","permalink":"https://lucifer.ren/blog/tags/贪婪/"}]},{"title":"构造二叉树系列","slug":"构造二叉树专题","date":"2020-02-08T11:59:44.329Z","updated":"2020-06-11T03:46:59.951Z","comments":true,"path":"2020/02/08/构造二叉树专题/","link":"","permalink":"https://lucifer.ren/blog/2020/02/08/构造二叉树专题/","excerpt":"构造二叉树是一个常见的二叉树考点，相比于直接考察二叉树的遍历，这种题目的难度会更大。截止到目前(2020-02-08) LeetCode 关于构造二叉树一共有三道题目，分别是： 105. 从前序与中序遍历序列构造二叉树 106. 从中序与后序遍历序列构造二叉树 889. 根据前序和后序遍历构造二叉树 今天就让我们用一个套路一举攻破他们。 ​","text":"构造二叉树是一个常见的二叉树考点，相比于直接考察二叉树的遍历，这种题目的难度会更大。截止到目前(2020-02-08) LeetCode 关于构造二叉树一共有三道题目，分别是： 105. 从前序与中序遍历序列构造二叉树 106. 从中序与后序遍历序列构造二叉树 889. 根据前序和后序遍历构造二叉树 今天就让我们用一个套路一举攻破他们。 ​ 105. 从前序与中序遍历序列构造二叉树题目描述12345678910111213141516根据一棵树的前序遍历与中序遍历构造二叉树。注意:你可以假设树中没有重复的元素。例如，给出前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 思路我们以题目给出的测试用例来讲解： 前序遍历是根左右，因此 preorder 第一个元素一定整个树的根。由于题目说明了没有重复元素，因此我们可以通过 val 去 inorder 找到根在 inorder 中的索引 i。而由于中序遍历是左根右，我们容易找到 i 左边的都是左子树，i 右边都是右子树。 我使用红色表示根，蓝色表示左子树，绿色表示右子树。 根据此时的信息，我们能构造的树是这样的： 我们 preorder 继续向后移动一位，这个时候我们得到了第二个根节点”9“，实际上就是左子树的根节点。 我们 preorder 继续向后移动一位，这个时候我们得到了第二个根节点”20“，实际上就是右子树的根节点。其中右子树由于个数大于 1，我们无法确定，我们继续执行上述逻辑。 根据此时的信息，我们能构造的树是这样的： 我们不断执行上述逻辑即可。简单起见，递归的时候每次我都开辟了新的数组，这个其实是没有必要的，我们可以通过四个变量来记录 inorder 和 preorder 的起始位置即可。 代码代码支持：Python3 Python3 Code: 123456789101112class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: # 实际上inorder 和 postorder一定是同时为空的，因此你无论判断哪个都行 if not preorder: return None root = TreeNode(preorder[0]) i = inorder.index(root.val) root.left = self.buildTree(preorder[1:i + 1], inorder[:i]) root.right = self.buildTree(preorder[i + 1:], inorder[i+1:]) return root 复杂度分析 时间复杂度：由于每次递归我们的 inorder 和 preorder 的总数都会减 1，因此我们要递归 N 次，故时间复杂度为 $O(N)$，其中 N 为节点个数。 空间复杂度：我们使用了递归，也就是借助了额外的栈空间来完成， 由于栈的深度为 N，因此总的空间复杂度为 $O(N)$，其中 N 为节点个数。 空间复杂度忽略了开辟数组的内存消耗。 106. 从中序与后序遍历序列构造二叉树如果你会了上面的题目，那么这个题目对你来说也不是难事，我们来看下。 题目描述12345678910111213141516根据一棵树的中序遍历与后序遍历构造二叉树。注意:你可以假设树中没有重复的元素。例如，给出中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3]返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 思路我们以题目给出的测试用例来讲解： 后序遍历是左右根，因此 postorder 最后一个元素一定整个树的根。由于题目说明了没有重复元素，因此我们可以通过 val 去 inorder 找到根在 inorder 中的索引 i。而由于中序遍历是左根右，我们容易找到 i 左边的都是左子树，i 右边都是右子树。 我使用红色表示根，蓝色表示左子树，绿色表示右子树。 根据此时的信息，我们能构造的树是这样的： 其中右子树由于个数大于 1，我们无法确定，我们继续执行上述逻辑。我们 postorder 继续向前移动一位，这个时候我们得到了第二个根节点”20“，实际上就是右子树的根节点。 根据此时的信息，我们能构造的树是这样的： 我们不断执行上述逻辑即可。简单起见，递归的时候每次我都开辟了新的数组，这个其实是没有必要的，我们可以通过四个变量来记录 inorder 和 postorder 的起始位置即可。 代码代码支持：Python3 Python3 Code: 1234567891011class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: # 实际上inorder 和 postorder一定是同时为空的，因此你无论判断哪个都行 if not inorder: return None root = TreeNode(postorder[-1]) i = inorder.index(root.val) root.left = self.buildTree(inorder[:i], postorder[:i]) root.right = self.buildTree(inorder[i+1:], postorder[i:-1]) return root 复杂度分析 时间复杂度：由于每次递归我们的 inorder 和 postorder 的总数都会减 1，因此我们要递归 N 次，故时间复杂度为 $O(N)$，其中 N 为节点个数。 空间复杂度：我们使用了递归，也就是借助了额外的栈空间来完成， 由于栈的深度为 N，因此总的空间复杂度为 $O(N)$，其中 N 为节点个数。 空间复杂度忽略了开辟数组的内存消耗。 889. 根据前序和后序遍历构造二叉树题目描述1234567891011121314151617返回与给定的前序和后序遍历匹配的任何二叉树。 pre 和 post 遍历中的值是不同的正整数。 示例：输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]输出：[1,2,3,4,5,6,7] 提示：1 &lt;= pre.length == post.length &lt;= 30pre[] 和 post[] 都是 1, 2, ..., pre.length 的排列每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。 思路我们以题目给出的测试用例来讲解： 前序遍历是根左右，因此 preorder 第一个元素一定整个树的根，preorder 第二个元素（如果存在的话）一定是左子树。由于题目说明了没有重复元素，因此我们可以通过 val 去 postorder 找到 pre[1]在 postorder 中的索引 i。而由于后序遍历是左右根，因此我们容易得出。 postorder 中的 0 到 i(包含)是左子树，preorder 的 1 到 i+1（包含）也是左子树。 其他部分可以参考上面两题。 代码代码支持：Python3 Python3 Code: 1234567891011121314class Solution: def constructFromPrePost(self, pre: List[int], post: List[int]) -&gt; TreeNode: # 实际上pre 和 post一定是同时为空的，因此你无论判断哪个都行 if not pre: return None node = TreeNode(pre[0]) if len(pre) == 1: return node i = post.index(pre[1]) node.left = self.constructFromPrePost(pre[1:i + 2], post[:i + 1]) node.right = self.constructFromPrePost(pre[i + 2:], post[i + 1:-1]) return node 复杂度分析 时间复杂度：由于每次递归我们的 postorder 和 preorder 的总数都会减 1，因此我们要递归 N 次，故时间复杂度为 $O(N)$，其中 N 为节点个数。 空间复杂度：我们使用了递归，也就是借助了额外的栈空间来完成， 由于栈的深度为 N，因此总的空间复杂度为 $O(N)$，其中 N 为节点个数。 空间复杂度忽略了开辟数组的内存消耗。 总结如果你仔细对比一下的话，会发现我们的思路和代码几乎一模一样。注意到每次递归我们的两个数组个数都会减去 1，因此我们递归终止条件不难写出，并且递归问题规模如何缩小也很容易，那就是数组总长度减去 1。 我们拿最后一个题目来说： 12node.left = self.constructFromPrePost(pre[1:i + 2], post[:i + 1])node.right = self.constructFromPrePost(pre[i + 2:], post[i + 1:-1]) 我们发现 pre 被拆分为两份，pre[1:i + 2]和 pre[i + 2:]。很明显总数少了 1，那就是 pre 的第一个元素。 也就是说如果你写出一个，其他一个不用思考也能写出来。 而对于 post 也一样，post[:i + 1] 和 post[i + 1:-1]，很明显总数少了 1，那就是 post 最后一个元素。 这个解题模板足够简洁，并且逻辑清晰，大家可以用我的模板试试～ 关注我更多题解可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。 目前已经 30K star 啦。 大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"},{"name":"二叉树","slug":"二叉树","permalink":"https://lucifer.ren/blog/categories/二叉树/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"},{"name":"算法系列","slug":"算法系列","permalink":"https://lucifer.ren/blog/tags/算法系列/"},{"name":"二叉树","slug":"二叉树","permalink":"https://lucifer.ren/blog/tags/二叉树/"}]},{"title":"我的日程安排表系列","slug":"leetcode-我的日程安排表系列","date":"2020-02-03T02:51:10.406Z","updated":"2020-02-03T05:15:54.238Z","comments":true,"path":"2020/02/03/leetcode-我的日程安排表系列/","link":"","permalink":"https://lucifer.ren/blog/2020/02/03/leetcode-我的日程安排表系列/","excerpt":"《我的日程安排表》截止目前（2020-02-03）在 LeetCode 上一共有三道题，其中两个中等难度，一个困难难度,分别是： 729. 我的日程安排表 I 731. 我的日程安排表 II 732. 我的日程安排表 III 另外 LeetCode 上有一个类似的系列《会议室》，截止目前（2020-02-03）有两道题目。其中一个简单一个中等，分别是： 252. 会议室 253. 会议室 II 今天我们就来攻克它们。","text":"《我的日程安排表》截止目前（2020-02-03）在 LeetCode 上一共有三道题，其中两个中等难度，一个困难难度,分别是： 729. 我的日程安排表 I 731. 我的日程安排表 II 732. 我的日程安排表 III 另外 LeetCode 上有一个类似的系列《会议室》，截止目前（2020-02-03）有两道题目。其中一个简单一个中等，分别是： 252. 会议室 253. 会议室 II 今天我们就来攻克它们。 729. 我的日程安排表 I题目地址https://leetcode-cn.com/problems/my-calendar-i 题目描述实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。 MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end。 当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。 每次调用 MyCalendar.book 方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。 请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) 示例 1: MyCalendar();MyCalendar.book(10, 20); // returns trueMyCalendar.book(15, 25); // returns falseMyCalendar.book(20, 30); // returns true解释:第一个日程安排可以添加到日历中. 第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了。第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 。说明: 每个测试用例，调用 MyCalendar.book 函数最多不超过 100 次。调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 [0, 10^9]。 暴力法思路首先我们考虑暴力法。每插入一个元素我们都判断其是否和已有的所有课程重叠。 我们定一个函数intersected(calendar, calendars)，其中 calendar 是即将要插入的课程，calendars 是已经插入的课程。 只要 calendar 和 calendars 中的任何一个课程有交叉，我们就返回 True，否则返回 False。 对于两个 calendar，我们的判断逻辑都是一样的。假设连个 calendar 分别是[s1, e1]和[s2, e2]。那么如果s1 &gt;= e2 or s2 &lt;= e1, 则两个课程没有交叉，可以预定，否则不可以。如图，1，2，3 可以预定，剩下的不可以。 代码是这样的： 12345678def intersected(calendar, calendars): for [start, end] in calendars: if calendar[0] &gt;= end or calendar[1] &lt;= start: continue else: return True return False 复杂度分析： 时间复杂度：$O(N^2)$。N 指的是日常安排的数量，对于每个新的日常安排，我们检查新的日常安排是否发生冲突来决定是否可以预订新的日常安排。 空间复杂度: $O(N)$。 这个代码写出来之后整体代码就呼之欲出了，全部代码见下方代码部分。 代码代码支持 Python3: Python3 Code: 1234567891011121314151617181920212223242526272829303132## @lc app=leetcode.cn id=729 lang=python3## [729] 我的日程安排表 I## @lc code=startclass MyCalendar: def __init__(self): self.calendars = [] def book(self, start: int, end: int) -&gt; bool: def intersected(calendar, calendars): for [start, end] in calendars: if calendar[0] &gt;= end or calendar[1] &lt;= start: continue else: return True return False if intersected([start, end], self.calendars): return False self.calendars.append([start, end]) return True # Your MyCalendar object will be instantiated and called as such: # obj = MyCalendar() # param_1 = obj.book(start,end) # @lc code=end 实际上我们还可以换个角度，上面的思路判断交叉部分我们考虑的是“如何不交叉”，剩下的就是交叉。我们也可以直接考虑交叉。还是上面的例子，如果两个课程交叉，那么一定满足s1 &lt; e2 and e1 &gt; s2。基于此，我们写出下面的代码。 代码支持 Python3: Python3 Code: 12345678910111213141516171819202122232425## @lc app=leetcode.cn id=729 lang=python3## [729] 我的日程安排表 I## @lc code=startclass MyCalendar: def __init__(self): self.calendars = [] def book(self, start: int, end: int) -&gt; bool: for s, e in self.calendars: if start &lt; e and end &gt; s: return False self.calendars.append([start, end]) return True # Your MyCalendar object will be instantiated and called as such: # obj = MyCalendar() # param_1 = obj.book(start,end) # @lc code=end 二叉查找树法思路和上面思路类似，只不过我们每次都对 calendars 进行排序，那么我们可以通过二分查找日程安排的情况来检查新日常安排是否可以预订。如果每次插入之前都进行一次排序，那么时间复杂度会很高。如图，我们的[s1,e1], [s2,e2], [s3,e3] 是按照时间顺序排好的日程安排。我们现在要插入[s,e],我们使用二分查找，找到要插入的位置，然后和插入位置的课程进行一次比对即可，这部分的时间复杂度是 O(logN)$。 我们考虑使用平衡二叉树来维护这种动态的变化，在最差的情况时间复杂度会退化到上述的$O(N^2)$，平均情况是$O(NlogN)$，其中 N 是已预订的日常安排数。 代码代码支持 Python3: Python3 Code: 1234567891011121314151617181920212223242526272829class Node: def __init__(self, start, end): self.start = start self.end = end self.left = self.right = None def insert(self, node): if node.start &gt;= self.end: if not self.right: self.right = node return True return self.right.insert(node) elif node.end &lt;= self.start: if not self.left: self.left = node return True return self.left.insert(node) else: return Falseclass MyCalendar(object): def __init__(self): self.root = None def book(self, start, end): if self.root is None: self.root = Node(start, end) return True return self.root.insert(Node(start, end)) 731. 我的日程安排表 II题目地址https://leetcode-cn.com/problems/my-calendar-ii 题目描述实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。 MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end。 当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。 每次调用 MyCalendar.book 方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。 请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) 示例： MyCalendar();MyCalendar.book(10, 20); // returns trueMyCalendar.book(50, 60); // returns trueMyCalendar.book(10, 40); // returns trueMyCalendar.book(5, 15); // returns falseMyCalendar.book(5, 10); // returns trueMyCalendar.book(25, 55); // returns true解释：前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间 10。第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。 提示： 每个测试用例，调用 MyCalendar.book 函数最多不超过 1000 次。调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 [0, 10^9]。 暴力法思路暴力法和上述思路类似。但是我们多维护一个数组 intersectedCalendars 用来存储二次预定的日程安排。如果课程第一次冲突，我们将其加入 intersectedCalendars，如果和 intersectedCalendars 也冲突了，说明出现了三次预定，我们直接返回 False。 代码代码支持 Python3: Python3 Code: 123456789101112131415class MyCalendarTwo: def __init__(self): self.calendars = [] self.intersectedCalendars = [] def book(self, start: int, end: int) -&gt; bool: for [s, e] in self.intersectedCalendars: if start &lt; e and end &gt; s: return False for [s, e] in self.calendars: if start &lt; e and end &gt; s: self.intersectedCalendars.append([max(start, s), min(end, e)]) self.calendars.append([start, end]) return True 二叉查找树法和上面的题目类似，我们仍然可以使用平衡二叉树来简化查找逻辑。具体可以参考这个 discussion 每次插入之前我们都需要进行一次判断，判断是否可以插入。如果不可以插入，直接返回 False，否则我们进行一次插入。 插入的时候，如果和已有的相交了，我们判断是否之前已经相交了一次，如果是返回 False，否则返回 True。关于如何判断是否和已有的相交，我们可以在 node 节点增加一个字段的方式来标记，在这里我们使用 single_overlap，True 表示产生了二次预定，False 则表示没有产生过两次及以上的预定。 代码代码支持 Python3: Python3 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Node: def __init__(self, start, end): self.start = start self.end = end self.left = None self.right = None self.single_overlap = Falseclass MyCalendarTwo: def __init__(self): self.root = None def book(self, start, end): if not self.canInsert(start, end, self.root): return False self.root = self.insert(start, end, self.root) return True def canInsert(self, start, end, root): if not root: return True if start &gt;= end: return True if end &lt;= root.start: return self.canInsert(start, end, root.left) elif start &gt;= root.end: return self.canInsert(start, end, root.right) else: if root.single_overlap: return False elif start &gt;= root.start and end &lt;= root.end: return True else: return self.canInsert(start, root.start, root.left) and self.canInsert(root.end, end, root.right) def insert(self, start, end, root): if not root: root = Node(start, end) return root if start &gt;= end: return root if start &gt;= root.end: root.right = self.insert(start, end, root.right) elif end &lt;= root.start: root.left = self.insert(start, end, root.left) else: root.single_overlap = True a = min(root.start, start) b = max(root.start, start) c = min(root.end, end) d = max(root.end, end) root.start, root.end = b, c root.left, root.right = self.insert(a, b, root.left), self.insert(c, d, root.right) return root# Your MyCalendarTwo object will be instantiated and called as such:# obj = MyCalendarTwo()# param_1 = obj.book(start,end) 732. 我的日程安排表 III题目地址https://leetcode-cn.com/problems/my-calendar-iii/ 题目描述实现一个 MyCalendar 类来存放你的日程安排，你可以一直添加新的日程安排。 MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end。 当 K 个日程安排有一些时间上的交叉时（例如 K 个日程安排都在同一时间内），就会产生 K 次预订。 每次调用 MyCalendar.book 方法时，返回一个整数 K ，表示最大的 K 次预订。 请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) 示例 1: MyCalendarThree();MyCalendarThree.book(10, 20); // returns 1MyCalendarThree.book(50, 60); // returns 1MyCalendarThree.book(10, 40); // returns 2MyCalendarThree.book(5, 15); // returns 3MyCalendarThree.book(5, 10); // returns 3MyCalendarThree.book(25, 55); // returns 3解释:前两个日程安排可以预订并且不相交，所以最大的 K 次预订是 1。第三个日程安排[10,40]与第一个日程安排相交，最高的 K 次预订为 2。其余的日程安排的最高 K 次预订仅为 3。请注意，最后一次日程安排可能会导致局部最高 K 次预订为 2，但答案仍然是 3，原因是从开始到最后，时间[10,20]，[10,40]和[5,15]仍然会导致 3 次预订。说明: 每个测试用例，调用 MyCalendar.book 函数最多不超过 400 次。调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 [0, 10^9]。 二叉查找树法思路我们仍然可以使用上述的平衡二叉树的做法。只不过我们需要额外维护一个全局的最大值“k”，表示需要多少个预定。最终我们返回 k。 同时每一个 node 我们都增加一个属性 k，用来表示局部的最大值，对于每次插入，我们将 node 的 k 和全部的 k 进行比较，取出最大值即可。 代码代码支持 Python3: Python3 Code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Node(object): def __init__(self, start, end, ktime=1): self.k = ktime self.s = start self.e = end self.right = None self.left = Noneclass MyCalendarThree(object): def __init__(self): self.root = None self.k = 0 def book(self, start, end): self.root = self.insert(self.root, start, end, 1) return self.k def insert(self, root, start, end, k): if start &gt;= end: return root if not root: self.k = max(self.k, k) return Node(start, end, k) else: if start &gt;= root.e: root.right = self.insert(root.right, start, end, k) return root elif end &lt;= root.s: root.left = self.insert(root.left, start, end, k) return root else: a = min(root.s, start) b = max(root.s, start) c = min(root.e, end) d = max(root.e, end) root.left = self.insert(root.left, a, b, a == root.s and root.k or k) root.right = self.insert(root.right, c,d, d == root.e and root.k or k) root.k += k root.s = b root.e = c self.k = max(root.k, self.k) return root Count Map 法思路这个是我在看了 Discussion [C++] Map Solution, beats 95%+ 之后写的解法，解法非常巧妙。 我们使用一个 count map 来存储所有的预定，对于每次插入，我们执行count[start] += 1和count[end] -= 1。 count[t] 表示从 t 开始到下一个 t 我们有几个预定。因此我们需要对 count 进行排序才行。 我们维护一个最大值来 cnt 来表示需要的预定数。 比如预定[1,3]和[5,7]，我们产生一个预定即可： 再比如预定[1,5]和[3,7]，我们需要两个预定： 我们可以使用红黑树来简化时间复杂度，如果你使用的是 Java，可以直接使用现成的数据结构 TreeMap。我这里偷懒，每次都排序，时间复杂度会很高，但是可以 AC。 读到这里，你可能会发现： 这个解法似乎更具有通用型。对于第一题我们可以判断 cnt 是否小于等于 1，对于第二题我们可以判断 cnt 是否小于等于 2。 如果你不借助红黑树等数据结构直接使用 count-map 法，即每次都进行一次排序，第一题和第二题可能会直接超时。 代码代码支持 Python3: Python3 Code: 12345678910111213141516171819class MyCalendarThree: def __init__(self): self.count = dict() def book(self, start: int, end: int) -&gt; int: self.count[start] = self.count.get(start, 0) + 1 self.count[end] = self.count.get(end, 0) - 1 cnt = 0 cur = 0 for k in sorted(self.count): cur += self.count[k] cnt = max(cnt, cur) return cnt # Your MyCalendarThree object will be instantiated and called as such: # obj = MyCalendarThree() # param_1 = obj.book(start,end) 相关题目LeetCode 上有一个类似的系列《会议室》，截止目前（2020-02-03）有两道题目。其中一个简单一个中等，解题思路非常类似，大家用这个解题思路尝试一下，检测一下自己是否已经掌握。两道题分别是： 252. 会议室 253. 会议室 II 总结我们对 LeetCode 上的专题《我的日程安排》的三道题进行了汇总。对于区间判断是否重叠，我们可以反向判断，也可以正向判断。 暴力的方法是每次对所有的课程进行判断是否重叠，这种解法可以 AC。我们也可以进一步优化，使用二叉查找树来简化时间复杂度。最后我们介绍了一种 Count-Map 方法来通用解决所有的问题，不仅可以完美解决这三道题，还可以扩展到《会议室》系列的两道题。","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"},{"name":"算法系列","slug":"算法系列","permalink":"https://lucifer.ren/blog/tags/算法系列/"}]},{"title":"BigPipe和微前端","slug":"bigpipe-and-micro-fe","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T07:05:11.796Z","comments":true,"path":"2020/02/02/bigpipe-and-micro-fe/","link":"","permalink":"https://lucifer.ren/blog/2020/02/02/bigpipe-and-micro-fe/","excerpt":"你可能听说过 BigPipe，这是一个十多年前的技术，而 BigPipe 通常都会跟“性能优化”同时被提起。微前端也是一个很早被提出的技术，但是最近几年才开始比较流行。而目前微前端能够解决的最大的问题恐怕就是遗留系统改造。我们可以将新技术构造的系统和旧技术构造的系统完美融合到一起，彼此构建，发布，运行等不受干扰。 那么 BigPipe 究竟和微前端有什么关系呢，我为什么要把这两个放到一起来看？","text":"你可能听说过 BigPipe，这是一个十多年前的技术，而 BigPipe 通常都会跟“性能优化”同时被提起。微前端也是一个很早被提出的技术，但是最近几年才开始比较流行。而目前微前端能够解决的最大的问题恐怕就是遗留系统改造。我们可以将新技术构造的系统和旧技术构造的系统完美融合到一起，彼此构建，发布，运行等不受干扰。 那么 BigPipe 究竟和微前端有什么关系呢，我为什么要把这两个放到一起来看？ 回答这个问题之前，我们先来看下什么是 BigPipe，以及什么是微前端。 BigPipeBigPipe 最早上 FaceBook 用来提升自家网站性能的一个秘密武器。其核心思想在于将页面分成若干小的构件，我们称之为 pagelet。每一个构件之间并行执行。 那么 BigPipe 做了什么？和传统方式有什么不同呢？我们知道浏览器处理我们的 HTML 文档以及其中包含的 CSS，JS 等资源的时候是从上到下串行执行的。如果我们把浏览器处理的过程划分为若干阶段（stage），那么这些阶段之间有着明显的时间先后关系。那么我们能不能将其并行化，从而减少时间呢？这就是 BigPipe 的基本思想。 话不多说，我们通过一段代码来帮助大家理解,比如你的项目首页是 home.html，大概这样子： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script&gt; window.BigPipe = &#123; render(selector, content) &#123; document.querySelector(selector).innerHTML = content; &#125; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"pagelet1\"&gt;&lt;/div&gt; &lt;div id=\"pagelet2\"&gt;&lt;/div&gt; &lt;div id=\"pagelet3\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 浏览器首先加载过来就是一个占位元素，这部分没有 JS 和 CSS，只有 HTML 部分，因此会很快。 之后我们慢慢填充pagelet1,pagelet2, pagelet3,在用户看来，就是一种“渐进式渲染”的效果。 服务端代码大概是： 12345678910111213141516171819202122232425const app = require('express')();const fs = require('fs');// 模拟真实场景function wirteChunk(content, delay, res) &#123; return new Promise(r =&gt; &#123; setTimeout(function() &#123; res.write(content); delay); &#125;)&#125;app.get('/', function (req, res) &#123; // 为了简化代码，直接同步读。 强烈不建议生产环境这么做！ res.write(fs.readFileSync(__dirname + \"/home.html\").toString()); const p1 = wirteChunk('&lt;script&gt;BigPipe.render(\"#pagelet1\",\"hello\");&lt;/script&gt;', 1000) const p2 = wirteChunk('&lt;script&gt;BigPipe.render(\"#pagelet2\",\"word\");&lt;/script&gt;', 2000) const p3 = wirteChunk('&lt;script&gt;BigPipe.render(\"#pagelet3\",\"!\");&lt;/script&gt;', 3000) Promise.all([p1, p2, p3]).then(res.end)&#125;);app.listen(3000); 从这里我们可以看出，BigPipe 不是框架，不是新技术。我们只需要按照这样做就行了。 这对于页面可以细分为多个块，块之间关联不大的场景非常有用。如果还是不太明白，可以看下这篇文章 -bigpipe-pipelining-web-pages-for-high-performance 说完了 BigPipe，我们再来看一下微前端。 微前端和后端微服务类似，“微前端是一种架构风格，其中众多独立交付的前端应用组合成一个大型整体。” 如果你想做微前端，一定要能够回答出这 10 个问题。 微应用的注册、异步加载和生命周期管理； 微应用之间、主从之间的消息机制； 微应用之间的安全隔离措施； 微应用的框架无关、版本无关； 微应用之间、主从之间的公共依赖的库、业务逻辑(utils)以及版本怎么管理； 微应用独立调试、和主应用联调的方式，快速定位报错（发射问题）； 微应用的发布流程； 微应用打包优化问题； 微应用专有云场景的出包方案； 渐进式升级：用微应用方案平滑重构老项目。 这里有一篇文档，区别与别的微前端文章的点在于其更加靠近规范层面，而不是结合自己的业务场景做的探索。这篇文章来自于阿里团队。 文章地址： https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw 还有一篇文章也不错，一并推荐给大家 - 大前端时代下的微前端架构：实现增量升级、代码解耦、独立部署 微前端中有一个重要的需要解决的问题是子系统之间的路由。而我们的 BigPipe 如果被当作一个个子应用的，那不就是微前端中的一个点么？BigPipe 也好，微前端也好，都是一种概念，一种指导思想。微前端是不限于技术栈的， 你可以使用传统的 ssr，也可以使用 csr，也可以使用现代 csr + ssr 等，框架也可以五花八门。 如何将这些系统组合起来，并且能够有条不紊地进行合作完成一个完整的应用？这是微前端所研究和要解决的问题。 对于微前端，我们隔离各个应用的方式有几种： iframe 类似 bigpipe 这种客户端异步加载技术 web-components 不管采用哪种方式，我们的大体逻辑都是： 先加载主框架 异步加载各个子应用 只不过加载子应用，我们可以通过 iframe 去加载，也可以使用 web-component 去加载，也可以使用类似 bigpipe 的方式分段并行加载。我们甚至可以将这几者进行结合使用。而 iframe 和 web-compoents 顺带解决了诸如 js 和 css 等隔离的作用，而 bigPipe 只是对资源加载的一个有效控制，其本身并没有什么特殊含义，更不要说诸如 js 和 css 等隔离作用了。 事物关联当前端有了 Nodejs 之后，我们发现可以做的事情变多了，除了 BigPipe，我们又去做 ssr，又要做 graphql，还要做微前端，海报服务，AI 等等。当你从大的视角看的时候，会发现这些技术或多或少都有交集，比如我刚才提到的 ssr。 我们知道 ssr 中有一点就是我们先返回给用户一个有内容的 html，这个 html 在服务端生成，由于在服务端生成，因此只有样式，没有绑定事件，所以后续我们需要在客户端合成事件。 如果将上面 BigPipe 的代码拿过来看的话，会发现我们的 html markup 可以看作服务端渲染内容（可以是直接写死的，也可以是服务端动态生成的）。之后我们输出后续 pagelet 的 JS 代码到前端，前端继续去执行。基于 BigPipe 我们甚至可以控制页面优先级显示。我们再继续去看的话， BFF 常见的一个功能“合并请求”在这里扮演了什么样的角色？大家可以自己想一下。当你不断从不同角度思考问题，会发现很多东西都有关联。每一个技术背后往往都会落到几个基本的原理上。了解技术初始产生背后解决的问题对于掌握一个技术来说非常重要。","categories":[],"tags":[{"name":"BigPipe","slug":"BigPipe","permalink":"https://lucifer.ren/blog/tags/BigPipe/"},{"name":"微前端","slug":"微前端","permalink":"https://lucifer.ren/blog/tags/微前端/"}]},{"title":"Floyd-Warshall 解题模板，助你快速AC","slug":"1334.find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance","date":"2020-02-01T14:45:03.057Z","updated":"2020-02-01T14:48:16.559Z","comments":true,"path":"2020/02/01/1334.find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/","link":"","permalink":"https://lucifer.ren/blog/2020/02/01/1334.find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/","excerpt":"Floyd-Warshall 是解决任意两点间的最短路径的一种算法，LeetCode 有很多题目都用了，掌握这套解题模板帮你快速 AC。","text":"Floyd-Warshall 是解决任意两点间的最短路径的一种算法，LeetCode 有很多题目都用了，掌握这套解题模板帮你快速 AC。 题目地址（1334. 阈值距离内邻居最少的城市）https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/ 题目描述123456789有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。 示例 1： 12345678910111213输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4输出：3解释：城市分布图如上。每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：城市 0 -&gt; [城市 1, 城市 2] 城市 1 -&gt; [城市 0, 城市 2, 城市 3] 城市 2 -&gt; [城市 0, 城市 1, 城市 3] 城市 3 -&gt; [城市 1, 城市 2] 城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。示例 2： 123456789101112131415161718192021输入：n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2输出：0解释：城市分布图如上。 每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：城市 0 -&gt; [城市 1] 城市 1 -&gt; [城市 0, 城市 4] 城市 2 -&gt; [城市 3, 城市 4] 城市 3 -&gt; [城市 2, 城市 4]城市 4 -&gt; [城市 1, 城市 2, 城市 3] 城市 0 在阈值距离 4 以内只有 1 个邻居城市。 提示：2 &lt;= n &lt;= 1001 &lt;= edges.length &lt;= n * (n - 1) / 2edges[i].length == 30 &lt;= fromi &lt; toi &lt; n1 &lt;= weighti, distanceThreshold &lt;= 10^4所有 (fromi, toi) 都是不同的。 思路这道题的本质就是： 在一个无向图中寻找每两个城镇的最小距离，我们使用 Floyd-Warshall 算法（英语：Floyd-Warshall algorithm），中文亦称弗洛伊德算法，是解决任意两点间的最短路径的一种算法。 筛选最小距离不大于 distanceThreshold 的城镇。 统计每个城镇，其满足条件的城镇有多少个 我们找出最少的即可 Floyd-Warshall 算法的时间复杂度和空间复杂度都是$O(N^3)$, 而空间复杂度可以优化到$O(N^2)$。Floyd-Warshall 的基本思想是对于每两个点之间的最小距离，要么经过中间节点 k，要么不经过，我们取两者的最小值，这是一种动态规划思想，详细的解法可以参考Floyd-Warshall 算法(wikipedia) 代码代码支持：Python3 Python3 Code: 1234567891011121314151617181920212223242526class Solution: def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -&gt; int: # 构建dist矩阵 dist = [[float('inf')] * n for _ in range(n)] for i, j, w in edges: dist[i][j] = w dist[j][i] = w for i in range(n): dist[i][i] = 0 for k in range(n): for i in range(n): for j in range(n): dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) # 过滤 res = 0 minCnt = float('inf') for i in range(n): cnt = 0 for d in dist[i]: if d &lt;= distanceThreshold: cnt += 1 if cnt &lt;= minCnt: minCnt = cnt res = i return res 关键点解析 Floyd-Warshall 算法 你可以将本文给的 Floyd-Warshall 算法当成一种解题模板使用","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"图","slug":"数据结构/图","permalink":"https://lucifer.ren/blog/categories/数据结构/图/"},{"name":"解题模板","slug":"解题模板","permalink":"https://lucifer.ren/blog/categories/解题模板/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"解题模板","slug":"解题模板","permalink":"https://lucifer.ren/blog/tags/解题模板/"},{"name":"图","slug":"图","permalink":"https://lucifer.ren/blog/tags/图/"},{"name":"Floyd-Warshall","slug":"Floyd-Warshall","permalink":"https://lucifer.ren/blog/tags/Floyd-Warshall/"}]},{"title":"【LeetCode日记】 1332. 删除回文子序列","slug":"1332.remove-palindromic-subsequences","date":"2020-02-01T12:26:45.779Z","updated":"2020-02-01T12:28:46.186Z","comments":true,"path":"2020/02/01/1332.remove-palindromic-subsequences/","link":"","permalink":"https://lucifer.ren/blog/2020/02/01/1332.remove-palindromic-subsequences/","excerpt":"LeetCode 上有很多抖机灵的题目，需要你仔细审题，否则很容易被套路。这里就有一道，我们来看下。 ​","text":"LeetCode 上有很多抖机灵的题目，需要你仔细审题，否则很容易被套路。这里就有一道，我们来看下。 ​ 原题地址：https://leetcode-cn.com/problems/remove-palindromic-subsequences/ 题目描述s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。12345678910111213141516171819202122232425262728293031323334353637返回删除给定字符串中所有字符（字符串为空）的最小删除次数。「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。 示例 1：输入：s = &quot;ababa&quot;输出：1解释：字符串本身就是回文序列，只需要删除一次。示例 2：输入：s = &quot;abb&quot;输出：2解释：&quot;abb&quot; -&gt; &quot;bb&quot; -&gt; &quot;&quot;.先删除回文子序列 &quot;a&quot;，然后再删除 &quot;bb&quot;。示例 3：输入：s = &quot;baabb&quot;输出：2解释：&quot;baabb&quot; -&gt; &quot;b&quot; -&gt; &quot;&quot;.先删除回文子序列 &quot;baab&quot;，然后再删除 &quot;b&quot;。示例 4：输入：s = &quot;&quot;输出：0 提示：0 &lt;= s.length &lt;= 1000s 仅包含字母 &apos;a&apos; 和 &apos;b&apos;在真实的面试中遇到过这道题？ 思路这又是一道“抖机灵”的题目，类似的题目有1297.maximum-number-of-occurrences-of-a-substring 由于只有 a 和 b 两个字符。其实最多的消除次数就是 2。因为我们无论如何都可以先消除全部的 1 再消除全部的 2（先消除 2 也一样），这样只需要两次即可完成。 我们再看一下题目给的一次消除的情况，题目给的例子是“ababa”，我们发现其实它本身就是一个回文串，所以才可以一次全部消除。那么思路就有了： 如果 s 是回文，则我们需要一次消除 否则需要两次 一定要注意特殊情况， 对于空字符串，我们需要 0 次 代码代码支持：Python3 Python3 Code: 123456789101112131415class Solution: def removePalindromeSub(self, s: str) -&gt; int: if s == '': return 0 def isPalindrome(s): l = 0 r = len(s) - 1 while l &lt; r: if s[l] != s[r]: return False l += 1 r -= 1 return True return 1 if isPalindrome(s) else 2 如果你觉得判断回文不是本题重点，也可以简单实现： Python3 Code: 12345class Solution: def removePalindromeSub(self, s: str) -&gt; int: if s == '': return 0 return 1 if s == s[::-1] else 2 关键点解析 注意审题目，一定要利用题目条件“只含有 a 和 b 两个字符”否则容易做的很麻烦","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"字符串","slug":"数据结构/字符串","permalink":"https://lucifer.ren/blog/categories/数据结构/字符串/"},{"name":"回文","slug":"算法/回文","permalink":"https://lucifer.ren/blog/categories/算法/回文/"},{"name":"Easy","slug":"Easy","permalink":"https://lucifer.ren/blog/categories/Easy/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode日记","slug":"LeetCode日记","permalink":"https://lucifer.ren/blog/tags/LeetCode日记/"},{"name":"Easy","slug":"Easy","permalink":"https://lucifer.ren/blog/tags/Easy/"}]},{"title":"【LeetCode日记】 335. 路径交叉","slug":"335.self-crossing","date":"2020-01-30T17:07:11.232Z","updated":"2020-01-30T17:10:33.464Z","comments":true,"path":"2020/01/31/335.self-crossing/","link":"","permalink":"https://lucifer.ren/blog/2020/01/31/335.self-crossing/","excerpt":"这是一道 Hard 难度的题目，题目的难点在于我们不可以使用额外的空间完成。让我们来看下怎么做吧。 ​","text":"这是一道 Hard 难度的题目，题目的难点在于我们不可以使用额外的空间完成。让我们来看下怎么做吧。 ​ 原题地址：https://leetcode-cn.com/problems/self-crossing/ 题目描述123456789101112131415161718192021222324252627282930313233给定一个含有 n 个正数的数组 x。从点 (0,0) 开始，先向北移动 x[0] 米，然后向西移动 x[1] 米，向南移动 x[2] 米，向东移动 x[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。编写一个 O(1) 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。 示例 1:┌───┐│ │└───┼──&gt; │输入: [2,1,1,2]输出: true示例 2:┌──────┐│ │││└────────────&gt;输入: [1,2,3,4]输出: false示例 3:┌───┐│ │└───┼&gt;输入: [1,1,1,1]输出: true 思路符合直觉的做法是$O(N)$时间和空间复杂度的算法。这种算法非常简单，但是题目要求我们使用空间复杂度为$O(1)$的做法。 关于空间复杂度为$O(N)$的算法可以参考我之前的874.walking-robot-simulation。 思路基本是类似，只不过 obstacles（障碍物）不是固定的，而是我们不断遍历的时候动态生成的，我们每遇到一个点，就将其标记为 obstacle。随着算法的进行，我们的 obstacles 逐渐增大，最终和 N 一个量级。 我们考虑进行优化。我们仔细观察发现，如果想让其不相交，从大的范围来看只有两种情况： 我们画的圈不断增大。 我们画的圈不断减少。 （有没有感觉像迷宫？） 这样我们会发现，其实我们画最新一笔的时候，并不是之前画的所有的都需要考虑，我们只需要最近的几个就可以了，实际上是最近的五个，不过不知道也没关系，我们稍后会讲解。 红色部分指的是我们需要考虑的，而剩余没有被红色标注的部分则无需考虑。不是因为我们无法与之相交，而是我们一旦与之相交，则必然我们也一定会与红色标记部分相交。 然而我们画的方向也是不用考虑的。比如我当前画的方向是从左到右，那和我画的方向是从上到下有区别么？在这里是没区别的，不信我帮你将上图顺时针旋转 90 度看一下： 方向对于我们考虑是否相交没有差别。 当我们仔细思考的时候，会发现其实相交的情况只有以下几种： 这个时候代码就呼之欲出了。 我们只需要遍历数组 x，假设当前是第 i 个元素。 如果 x[i] &gt;= x[i - 2] and x[i - 1] &lt;= x[i - 3]，则相交（第一种情况） 如果 x[i - 1] &lt;= x[i - 3] and x[i - 2] &lt;= x[i]，则相交（第二种情况） 如果 i &gt; 3 and x[i - 1] == x[i - 3] and x[i] + x[i - 4] == x[i - 2]，则相交（第三种情况） 如果 i &gt; 4 and x[i] + x[i - 4] &gt;= x[i - 2] and x[i - 1] &gt;= x[i - 3] - x[i - 5] and x[i - 1] &lt;= x[i - 3] and x[i - 2] &gt;= x[i - 4] and x[i - 3] &gt;= x[i - 5] ，则相交（第四种情况） 否则不相交 关键点解析 一定要画图辅助 对于这种$O(1)$空间复杂度有固定的套路。常见的有： 直接修改原数组 滑动窗口（当前状态并不是和之前所有状态有关，而是仅和某几个有关）。 我们采用的是滑动窗口。但是难点就在于我们怎么知道当前状态和哪几个有关。对于这道题来说，画图或许可以帮助你打开思路。另外面试的时候说出$O(N)$的思路也不失为一个帮助你冷静分析问题的手段。 代码代码支持：Python3 Python3 Code: 12345678910111213141516class Solution: def isSelfCrossing(self, x: List[int]) -&gt; bool: n = len(x) if n &lt; 4: return False for i in range(3, n): if x[i] &gt;= x[i - 2] and x[i - 1] &lt;= x[i - 3]: return True if x[i - 1] &lt;= x[i - 3] and x[i - 2] &lt;= x[i]: return True if i &gt; 3 and x[i - 1] == x[i - 3] and x[i] + x[i - 4] == x[i - 2]: return True if i &gt; 4 and x[i] + x[i - 4] &gt;= x[i - 2] and x[i - 1] &gt;= x[i - 3] - x[i - 5] \\ and x[i - 1] &lt;= x[i - 3] and x[i - 2] &gt;= x[i - 4] and x[i - 3] &gt;= x[i - 5]: return True return False","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"hashtable","slug":"数据结构/hashtable","permalink":"https://lucifer.ren/blog/categories/数据结构/hashtable/"},{"name":"就地算法","slug":"算法/就地算法","permalink":"https://lucifer.ren/blog/categories/算法/就地算法/"},{"name":"Hard","slug":"Hard","permalink":"https://lucifer.ren/blog/categories/Hard/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode日记","slug":"LeetCode日记","permalink":"https://lucifer.ren/blog/tags/LeetCode日记/"},{"name":"Hard","slug":"Hard","permalink":"https://lucifer.ren/blog/tags/Hard/"}]},{"title":"【LeetCode日记】 50. Pow(x, n)","slug":"50.powx-n","date":"2020-01-29T14:44:15.972Z","updated":"2020-01-29T14:50:43.468Z","comments":true,"path":"2020/01/29/50.powx-n/","link":"","permalink":"https://lucifer.ren/blog/2020/01/29/50.powx-n/","excerpt":"这是一道让我们实现系统函数的造轮子题目，我们来看下。 ​","text":"这是一道让我们实现系统函数的造轮子题目，我们来看下。 ​ 原题地址：https://leetcode-cn.com/problems/powx-n/description/ 题目描述12345678910111213141516171819实现 pow(x, n) ，即计算 x 的 n 次幂函数。示例 1:输入: 2.00000, 10输出: 1024.00000示例 2:输入: 2.10000, 3输出: 9.26100示例 3:输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25说明:-100.0 &lt; x &lt; 100.0n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 解法零 - 遍历法思路这道题是让我们实现数学函数幂，因此直接调用系统内置函数是不被允许的。 符合直觉的做法是将x乘以n次，这种做法的时间复杂度是$O(N)$。 经实际测试，这种做法果然超时了。测试用例通过 291/304，在 0.00001\\n2147483647这个测试用例挂掉了。如果是面试，这个解法可以作为一种兜底解法。 代码语言支持: Python3 Python3 Code: 12345678910class Solution: def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n &lt; 0: return 1 / self.myPow(x, -n) res = 1 for _ in range(n): res *= x return res 解法一 - 普通递归（超时法）思路首先我们要知道： 如果想要求 x ^ 4，那么我们可以求 (x^2)^2 如果是奇数，会有一点不同。 比如 x ^ 5 就等价于 x * (x^2)^2。 当然 x ^ 5 可以等价于 (x ^ 2) ^ 2.5, 但是这不相当于直接调用了幂函数了么。对于整数，我们可以很方便的模拟，但是小数就不方便了。 我们的思路就是： 将 n 地板除 2，我们不妨设结果为 a 那么 myPow(x, n) 就等价于 myPow(x, a) * myPow(x, n - a) 很可惜这种算法也会超时，原因在于重复计算会比较多，你可以试一下缓存一下计算看能不能通过。 如果你搞不清楚有哪些重复计算，建议画图理解一下。 代码语言支持: Python3 Python3 Code: 123456789class Solution: def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n == 1: return x if n &lt; 0: return 1 / self.myPow(x, -n) return self.myPow(x, n // 2) * self.myPow(x, n - n // 2) 解法二 - 优化递归思路上面的解法每次直接 myPow 都会调用两次自己。我们不从缓存计算角度，而是从减少这种调用的角度来优化。 我们考虑 myPow 只调用一次自身可以么？ 没错，是可以的。 我们的思路就是： 如果 n 是偶数，我们将 n 折半，底数变为 x^2 如果 n 是奇数， 我们将 n 减去 1 ，底数不变，得到的结果再乘上底数 x 这样终于可以 AC。 代码语言支持: Python3 Python3 Code: 123456789class Solution: def myPow(self, x: float, n: int) -&gt; float: if n == 0: return 1 if n == 1: return x if n &lt; 0: return 1 / self.myPow(x, -n) return self.myPow(x _ x, n // 2) if n % 2 == 0 else x _ self.myPow(x, n - 1) 解法三 - 位运算思路我们来从位（bit）的角度来看一下这道题。如果你经常看我的题解和文章的话，可能知道我之前写过几次相关的“从位的角度思考分治法”，比如 LeetCode 458.可怜的小猪。 以 x 的 10 次方举例。10 的 2 进制是 1010，然后用 2 进制转 10 进制的方法把它展成 2 的幂次的和。 因此我们的算法就是： 不断的求解 x 的 2^0 次方，x 的 2^1 次方，x 的 2^2 次方等等。 将 n 转化为二进制表示 将 n 的二进制表示中1的位置pick 出来。比如 n 的第 i 位为 1，那么就将 x^i pick 出来。 将 pick 出来的结果相乘 这里有两个问题： 第一个问题是似乎我们需要存储 x^i 以便后续相乘的时候用到。实际上，我们并不需要这么做。我们可以采取一次遍历的方式来完成，具体看代码。 第二个问题是，如果我们从低位到高位计算的时候，我们如何判断最高位置是否为 1？我们需要一个 bitmask 来完成，这种算法我们甚至需要借助一个额外的变量。 然而我们可以 hack 一下，直接从高位到低位进行计算，这个时候我们只需要判断最后一位是否为 1 就可以了，这个就简单了，我们直接和 1 进行一次与运算即可。 代码语言支持: Python3 Python3 Code: 1234567891011class Solution: def myPow(self, x: float, n: int) -&gt; float: if n &lt; 0: return 1 / self.myPow(x, -n) res = 1 while n: if n &amp; 1 == 1: res *= x x *= x n &gt;&gt;= 1 return res 关键点解析 超时分析 hashtable 数学分析 位运算 二进制转十进制 相关题目 458.可怜的小猪","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"hashtable","slug":"数据结构/hashtable","permalink":"https://lucifer.ren/blog/categories/数据结构/hashtable/"},{"name":"数学","slug":"算法/数学","permalink":"https://lucifer.ren/blog/categories/算法/数学/"},{"name":"位运算","slug":"算法/位运算","permalink":"https://lucifer.ren/blog/categories/算法/位运算/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode日记","slug":"LeetCode日记","permalink":"https://lucifer.ren/blog/tags/LeetCode日记/"}]},{"title":"【LeetCode日记】 874. 模拟行走机器人","slug":"874.walking-robot-simulation","date":"2020-01-29T11:34:39.765Z","updated":"2020-01-29T12:05:37.678Z","comments":true,"path":"2020/01/29/874.walking-robot-simulation/","link":"","permalink":"https://lucifer.ren/blog/2020/01/29/874.walking-robot-simulation/","excerpt":"这是一道 LeetCode 难度为 easy 的题目，没有高深的算法，有的只是套路，我们来看下。 ​","text":"这是一道 LeetCode 难度为 easy 的题目，没有高深的算法，有的只是套路，我们来看下。 ​ 原题地址：https://leetcode-cn.com/problems/walking-robot-simulation/submissions/ 题目描述12345678910111213141516171819202122232425262728293031323334机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：-2：向左转 90 度-1：向右转 90 度1 &lt;= x &lt;= 9：向前移动 x 个单位长度在网格上有一些格子被视为障碍物。第 i 个障碍物位于网格点 (obstacles[i][0], obstacles[i][1])如果机器人试图走到障碍物上方，那么它将停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。返回从原点到机器人的最大欧式距离的平方。 示例 1：输入: commands = [4,-1,3], obstacles = []输出: 25解释: 机器人将会到达 (3, 4)示例 2：输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]输出: 65解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处 提示：0 &lt;= commands.length &lt;= 100000 &lt;= obstacles.length &lt;= 10000-30000 &lt;= obstacle[i][0] &lt;= 30000-30000 &lt;= obstacle[i][1] &lt;= 30000答案保证小于 2 ^ 31 思路这道题之所以是简单难度，是因为其没有什么技巧。你只需要看懂题目描述，然后把题目描述转化为代码即可。 唯一需要注意的是查找障碍物的时候如果你采用的是线形查找会很慢，很可能会超时。 我实际测试了一下，确实会超时 一种方式是使用排序，然后二分查找，如果采用基于比较的排序算法，那么这种算法的瓶颈在于排序本身，也就是$O(NlogN)$。 另一种方式是使用集合，将 obstacles 放入集合，然后需要的时候进行查询，查询的时候的时间复杂度为$O(1)$。 这里我们采用第二种方式。 接下来我们来“翻译”一下题目。 由于机器人只能往前走。因此机器人往东西南北哪个方向走取决于它的朝向。 我们使用枚举来表示当前机器人的朝向。 题目只有两种方式改变朝向，一种是左转（-2），另一种是右转（-1）。 题目要求的是机器人在运动过程中距离原点的最大值，而不是最终位置距离原点的距离。 为了代码书写简单，我建立了一个直角坐标系。用机器人的朝向和 x 轴正方向的夹角度数来作为枚举值，并且这个度数是 0 &lt;= deg &lt; 360。我们不难知道，其实这个取值就是0, 90,180,270 四个值。那么当 0 度的时候，我们只需要不断地 x+1，90 度的时候我们不断地 y + 1 等等。 关键点解析 理解题意，这道题容易理解错题意，求解为最终位置距离原点的距离 建立坐标系 使用集合简化线形查找的时间复杂度。 代码代码支持： Python3 Python3 Code: 1234567891011121314151617181920212223242526272829303132333435class Solution: def robotSim(self, commands: List[int], obstacles: List[List[int]]) -&gt; int: pos = [0, 0] deg = 90 ans = 0 obstaclesSet = set(map(tuple, obstacles)) for command in commands: if command == -1: deg = (deg + 270) % 360 elif command == -2: deg = (deg + 90) % 360 else: if deg == 0: i = 0 while i &lt; command and not (pos[0] + 1, pos[1]) in obstaclesSet: pos[0] += 1 i += 1 if deg == 90: i = 0 while i &lt; command and not (pos[0], pos[1] + 1) in obstaclesSet: pos[1] += 1 i += 1 if deg == 180: i = 0 while i &lt; command and not (pos[0] - 1, pos[1]) in obstaclesSet: pos[0] -= 1 i += 1 if deg == 270: i = 0 while i &lt; command and not (pos[0], pos[1] - 1) in obstaclesSet: pos[1] -= 1 i += 1 ans = max(ans, pos[0] ** 2 + pos[1] ** 2) return ans","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"hashtable","slug":"数据结构/hashtable","permalink":"https://lucifer.ren/blog/categories/数据结构/hashtable/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode日记","slug":"LeetCode日记","permalink":"https://lucifer.ren/blog/tags/LeetCode日记/"}]},{"title":"一行代码就可以通过 LeetCode？来看下我是怎么做到的！","slug":"1227.airplane-seat-assignment-probability","date":"2020-01-18T15:46:42.563Z","updated":"2020-01-18T15:59:33.965Z","comments":true,"path":"2020/01/18/1227.airplane-seat-assignment-probability/","link":"","permalink":"https://lucifer.ren/blog/2020/01/18/1227.airplane-seat-assignment-probability/","excerpt":"这是一道 LeetCode 为数不多的概率题，我们来看下。 ​","text":"这是一道 LeetCode 为数不多的概率题，我们来看下。 ​ 原题地址：https://leetcode-cn.com/problems/airplane-seat-assignment-probability/description/ 题目描述123456789101112131415161718192021222324252627有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。剩下的乘客将会：如果他们自己的座位还空着，就坐到自己的座位上，当他们自己的座位被占用时，随机选择其他座位第 n 位乘客坐在自己的座位上的概率是多少？ 示例 1：输入：n = 1输出：1.00000解释：第一个人只会坐在自己的位置上。示例 2：输入: n = 2输出: 0.50000解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。 提示：1 &lt;= n &lt;= 10^5 暴力递归这是一道 LeetCode 为数不多的概率题，我们来看下。 思路我们定义原问题为 f(n)。对于第一个人来说，他有 n 中选择，就是分别选择 n 个座位中的一个。由于选择每个位置的概率是相同的，那么选择每个位置的概率应该都是 1 / n。 我们分三种情况来讨论： 如果第一个人选择了第一个人的位置（也就是选择了自己的位置），那么剩下的人按照票上的座位做就好了，这种情况第 n 个人一定能做到自己的位置 如果第一个人选择了第 n 个人的位置，那么第 n 个人肯定坐不到自己的位置。 如果第一个人选择了第 i (1 &lt; i &lt; n)个人的位置，那么第 i 个人就相当于变成了“票丢的人”，此时问题转化为 f(n - i + 1)。 此时的问题转化关系如图： （红色表示票丢的人） 整个过程分析： 代码代码支持 Python3: Python3 Code: 12345678910class Solution: def nthPersonGetsNthSeat(self, n: int) -&gt; float: if n == 1: return 1 if n == 2: return 0.5 res = 1 / n for i in range(2, n): res += self.nthPersonGetsNthSeat(n - i + 1) * 1 / n return res 上述代码会栈溢出。 暴力递归 + hashtable思路我们考虑使用记忆化递归来减少重复计算，虽然这种做法可以减少运行时间，但是对减少递归深度没有帮助。还是会栈溢出。 代码代码支持 Python3: Python3 Code: 123456789101112131415class Solution: seen = &#123;&#125; def nthPersonGetsNthSeat(self, n: int) -&gt; float: if n == 1: return 1 if n == 2: return 0.5 if n in self.seen: return self.seen[n] res = 1 / n for i in range(2, n): res += self.nthPersonGetsNthSeat(n - i + 1) * 1 / n self.seen[n] = res return res 动态规划思路上面做法会栈溢出。其实我们根本不需要运行就应该能判断出栈溢出，题目已经给了数据规模是 1 &lt;= n &lt;= 10 ** 5。 这个量级不管什么语言，除非使用尾递归，不然一般都会栈溢出，具体栈深度大家可以查阅相关资料。 既然是栈溢出，那么我们考虑使用迭代来完成。 很容易想到使用动态规划来完成。其实递归都写出来，写一个朴素版的动态规划也难不到哪去，毕竟动态规划就是记录子问题，并建立子问题之间映射而已，这和递归并无本质区别。 代码代码支持 Python3: Python3 Code: 1234567891011121314class Solution: def nthPersonGetsNthSeat(self, n: int) -&gt; float: if n == 1: return 1 if n == 2: return 0.5 dp = [1, .5] * n for i in range(2, n): dp[i] = 1 / n for j in range(2, i): dp[i] += dp[i - j + 1] * 1 / n return dp[-1] 这种思路的代码超时了，并且仅仅执行了 35/100 testcase 就超时了。 数学分析思路我们还需要进一步优化时间复杂度，我们需要思考是否可以在线性的时间内完成。 我们继续前面的思路进行分析, 不难得出，我们不妨称其为等式 1： 1234f(n)= 1/n + 0 + 1/n * (f(n-1) + f(n-2) + ... + f(2))= 1/n * (f(n-1) + f(n-2) + ... + f(2) + 1)= 1/n * (f(n-1) + f(n-2) + ... + f(2) + f(1)) 似乎更复杂了？没关系，我们继续往下看，我们看下 f(n - 1)，我们不妨称其为等式 2。 1f(n-1) = 1/(n-1) * (f(n-2) + f(n-3) + ... + f(1)) 我们将等式 1 和等式 2 两边分别同时乘以 n 和 n - 1 12n * f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(1)(n-1) * f(n-1) = f(n-2) + f(n-3) + ... + f(1) 我们将两者相减： 1n * f(n) - (n-1)*f(n-1) = f(n-1) 我们继续将 (n-1)*f(n-1) 移到等式右边，得到： 1n * f(n) = n * f(n-1) 也就是说: 1f(n) = f(n - 1) 当然前提是 n 大于 2。 既然如此，我们就可以减少一层循环， 我们用这个思路来优化一下上面的 dp 解法。这种解法终于可以 AC 了。 代码代码支持 Python3: Python3 Code: 123456789101112class Solution: def nthPersonGetsNthSeat(self, n: int) -&gt; float: if n == 1: return 1 if n == 2: return 0.5 dp = [1, .5] * n for i in range(2, n): dp[i] = 1/n+(n-2)/n * dp[n-1] return dp[-1] 优化数学分析思路上面我们通过数学分析，得出了当 n 大于 2 时： 1f(n) = f(n - 1) 那么是不是意味着我们随便求出一个 n 就好了？ 比如我们求出 n = 2 的时候的值，是不是就知道 n 为任意数的值了。 我们不难想出 n = 2 时候，概率是 0.5，因此只要 n 大于 1 就是 0.5 概率，否则就是 1 概率。 代码代码支持 Python3: Python3 Code: 123class Solution: def nthPersonGetsNthSeat(self, n: int) -&gt; float: return 1 if n == 1 else .5 关键点 概率分析 数学推导 动态规划 递归 + mapper 栈限制大小 尾递归","categories":[{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"数学","slug":"算法/数学","permalink":"https://lucifer.ren/blog/categories/算法/数学/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://lucifer.ren/blog/categories/算法/动态规划/"},{"name":"概率","slug":"算法/概率","permalink":"https://lucifer.ren/blog/categories/算法/概率/"},{"name":"递归","slug":"算法/递归","permalink":"https://lucifer.ren/blog/categories/算法/递归/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"数学","slug":"数学","permalink":"https://lucifer.ren/blog/tags/数学/"},{"name":"概率","slug":"概率","permalink":"https://lucifer.ren/blog/tags/概率/"},{"name":"递归","slug":"递归","permalink":"https://lucifer.ren/blog/tags/递归/"},{"name":"动态规划","slug":"动态规划","permalink":"https://lucifer.ren/blog/tags/动态规划/"}]},{"title":"原来状态机也可以用来刷 LeetCode？","slug":"1262.greatest-sum-divisible-by-three","date":"2020-01-12T09:02:00.924Z","updated":"2020-01-12T09:06:56.830Z","comments":true,"path":"2020/01/12/1262.greatest-sum-divisible-by-three/","link":"","permalink":"https://lucifer.ren/blog/2020/01/12/1262.greatest-sum-divisible-by-three/","excerpt":"什么？ 状态机还可以用来刷 LeetCode？ 如果你还不知道，那么就快进来看看吧！","text":"什么？ 状态机还可以用来刷 LeetCode？ 如果你还不知道，那么就快进来看看吧！ 题目地址： https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/description/ 题目描述12345678910111213141516171819202122232425给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。 示例 1：输入：nums = [3,6,5,1,8]输出：18解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。示例 2：输入：nums = [4]输出：0解释：4 不能被 3 整除，所以无法选出数字，返回 0。示例 3：输入：nums = [1,2,3,4,4]输出：12解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。 提示：1 &lt;= nums.length &lt;= 4 * 10^41 &lt;= nums[i] &lt;= 10^4 暴力法思路一种方式是找出所有的能够被 3 整除的子集，然后挑选出和最大的。由于我们选出了所有的子集，那么时间复杂度就是 $O(2^N)$ ， 毫无疑问会超时。这里我们使用回溯法找子集，如果不清楚回溯法，可以参考我之前的题解，很多题目都用到了，比如78.subsets。 更多回溯题目，可以访问上方链接查看（可以使用一套模板搞定）： 代码12345678910111213141516class Solution: def maxSumDivThree(self, nums: List[int]) -&gt; int: self.res = 0 def backtrack(temp, start): total = sum(temp) if total % 3 == 0: self.res = max(self.res, total) for i in range(start, len(nums)): temp.append(nums[i]) backtrack(temp, i + 1) temp.pop(-1) backtrack([], 0) return self.res 减法 + 排序减法的核心思想是，我们求出总和。如果总和不满足题意，我们尝试减去最小的数，使之满足题意。 思路这种算法的思想，具体来说就是： 我们将所有的数字加起来，我们不妨设为 total total 除以 3，得到一个余数 mod， mod 可能值有 0，1，2. 同时我们建立两个数组，一个是余数为 1 的数组 one，一个是余数为 2 的数组 two 如果 mod 为 0，我们直接返回即可。 如果 mod 为 1，我们可以减去 one 数组中最小的一个（如果有的话），或者减去两个 two 数组中最小的（如果有的话），究竟减去谁取决谁更小。 如果 mod 为 2，我们可以减去 two 数组中最小的一个（如果有的话），或者减去两个 one 数组中最小的（如果有的话），究竟减去谁取决谁更小。 由于我们需要取 one 和 two 中最小的一个或者两个，因此对数组 one 和 two 进行排序是可行的，如果基于排序的话，时间复杂度大致为 $O(NlogN)$，这种算法可以通过。 以题目中的例 1 为例： 以题目中的例 2 为例： 代码12345678910111213141516171819202122232425class Solution: def maxSumDivThree(self, nums: List[int]) -&gt; int: one = [] two = [] total = 0 for num in nums: total += num if num % 3 == 1: one.append(num) if num % 3 == 2: two.append(num) one.sort() two.sort() if total % 3 == 0: return total elif total % 3 == 1 and one: if len(two) &gt;= 2 and one[0] &gt; two[0] + two[1]: return total - two[0] - two[1] return total - one[0] elif total % 3 == 2 and two: if len(one) &gt;= 2 and two[0] &gt; one[0] + one[1]: return total - one[0] - one[1] return total - two[0] return 0 减法 + 非排序思路上面的解法使用到了排序。 我们其实观察发现，我们只是用到了 one 和 two 的最小的两个数。因此我们完全可以在线形的时间和常数的空间完成这个算法。我们只需要分别记录 one 和 two 的最小值和次小值即可，在这里，我使用了两个长度为 2 的数组来表示，第一项是最小值，第二项是次小值。 代码123456789101112131415161718192021222324252627282930313233class Solution: def maxSumDivThree(self, nums: List[int]) -&gt; int: one = [float('inf')] * 2 two = [float('inf')] * 2 total = 0 for num in nums: total += num if num % 3 == 1: if num &lt; one[0]: t = one[0] one[0] = num one[1] = t elif num &lt; one[1]: one[1] = num if num % 3 == 2: if num &lt; two[0]: t = two[0] two[0] = num two[1] = t elif num &lt; two[1]: two[1] = num if total % 3 == 0: return total elif total % 3 == 1 and one: if len(two) &gt;= 2 and one[0] &gt; two[0] + two[1]: return total - two[0] - two[1] return total - one[0] elif total % 3 == 2 and two: if len(one) &gt;= 2 and two[0] &gt; one[0] + one[1]: return total - one[0] - one[1] return total - two[0] return 0 有限状态机思路我在数据结构与算法在前端领域的应用 - 第二篇 中讲到了有限状态机。 状态机表示若干个状态以及在这些状态之间的转移和动作等行为的数学模型。通俗的描述状态机就是定义了一套状态変更的流程：状态机包含一个状态集合，定义当状态机处于某一个状态的时候它所能接收的事件以及可执行的行为，执行完成后，状态机所处的状态。 状态机使用非常广泛，比如正则表达式的引擎，编译器的词法和语法分析，网络协议，企业应用等很多领域都会用到。 拿本题中来说，我们从左到右扫描数组的过程，将会不断改变状态机的状态。 我们使用 state 数组来表示本题的状态： state[0] 表示 mod 为 0 的 最大和 state[1] 表示 mod 为 1 的 最大和 state[2] 表示 mod 为 1 的 最大和 我们的状态转移方程就会很容易。说到状态转移方程，你可能会想到动态规划。没错！这种思路可以直接翻译成动态规划，算法完全一样。如果你看过我上面提到的文章，那么状态转移方程对你来说就会很容易。如果你不清楚，那么请往下看： 我们从左往右不断读取数字，我们不妨设这个数字为 num。 如果 num % 3 为 0。 那么我们的 state[0], state[1], state[2] 可以直接加上 num（题目限定了 num 为非负）， 因为任何数字加上 3 的倍数之后，mod 3 的值是不变的。 如果 num % 3 为 1。 我们知道 state[2] + num 会变成一个能被三整除的数，但是这个数字不一定比当前的 state[0]大。 代码表示就是max(state[2] + num, state[0])。同理 state[1] 和 state[2] 的转移逻辑类似。 同理 num % 3 为 2 也是类似的逻辑。 最后我们返回 state[0]即可。 代码123456789101112131415161718class Solution: def maxSumDivThree(self, nums: List[int]) -&gt; int: state = [0, float('-inf'), float('-inf')] for num in nums: if num % 3 == 0: state = [state[0] + num, state[1] + num, state[2] + num] if num % 3 == 1: a = max(state[2] + num, state[0]) b = max(state[0] + num, state[1]) c = max(state[1] + num, state[2]) state = [a, b, c] if num % 3 == 2: a = max(state[1] + num, state[0]) b = max(state[2] + num, state[1]) c = max(state[0] + num, state[2]) state = [a, b, c] return state[0] 当然这个代码还可以简化： 1234567891011class Solution: def maxSumDivThree(self, nums: List[int]) -&gt; int: state = [0, float('-inf'), float('-inf')] for num in nums: temp = [0] * 3 for i in range(3): temp[(i + num) % 3] = max(state[(i + num) % 3], state[i] + num) state = temp return state[0] 关键点解析 贪婪法 状态机 数学分析 扩展实际上，我们可以采取加法（贪婪策略），感兴趣的可以试一下。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"https://lucifer.ren/blog/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"https://lucifer.ren/blog/tags/动态规划/"},{"name":"状态机","slug":"状态机","permalink":"https://lucifer.ren/blog/tags/状态机/"},{"name":"贪心","slug":"贪心","permalink":"https://lucifer.ren/blog/tags/贪心/"}]},{"title":"LeetCode一道令人发指的陷阱题","slug":"1297.maximum-number-of-occurrences-of-a-substring","date":"2020-01-10T04:34:25.412Z","updated":"2020-01-10T04:36:32.041Z","comments":true,"path":"2020/01/10/1297.maximum-number-of-occurrences-of-a-substring/","link":"","permalink":"https://lucifer.ren/blog/2020/01/10/1297.maximum-number-of-occurrences-of-a-substring/","excerpt":"LeetCode 有一些题目会给你设置陷阱，给你一些干扰信息。这个时候你需要小心，不要被他们带跑偏了。那么是什么样的陷阱呢？让我们来看一下！","text":"LeetCode 有一些题目会给你设置陷阱，给你一些干扰信息。这个时候你需要小心，不要被他们带跑偏了。那么是什么样的陷阱呢？让我们来看一下！ 题目地址（1297. 子串的最大出现次数）https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring 题目描述123456789101112131415161718192021222324252627282930313233给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：子串中不同字母的数目必须小于等于 maxLetters 。子串的长度必须大于等于 minSize 且小于等于 maxSize 。示例 1：输入：s = &quot;aababcaab&quot;, maxLetters = 2, minSize = 3, maxSize = 4输出：2解释：子串 &quot;aab&quot; 在原字符串中出现了 2 次。它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。示例 2：输入：s = &quot;aaaa&quot;, maxLetters = 1, minSize = 3, maxSize = 3输出：2解释：子串 &quot;aaa&quot; 在原字符串中出现了 2 次，且它们有重叠部分。示例 3：输入：s = &quot;aabcabcab&quot;, maxLetters = 2, minSize = 2, maxSize = 3输出：3示例 4：输入：s = &quot;abcde&quot;, maxLetters = 2, minSize = 3, maxSize = 3输出：0提示：1 &lt;= s.length &lt;= 10^51 &lt;= maxLetters &lt;= 261 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length)s 只包含小写英文字母。 暴力法题目给的数据量不是很大，为 1 &lt;= maxLetters &lt;= 26，我们试一下暴力法。 思路暴力法如下： 先找出所有满足长度大于等于 minSize 且小于等于 maxSize 的所有子串。（平方的复杂度） 对于 maxLetter 满足题意的子串，我们统计其出现次数。时间复杂度为 O(k),其中 k 为子串长度 返回最大的出现次数 代码Pythpn Code: 1234567891011121314151617181920class Solution: def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -&gt; int: n = len(s) letters = set() cnts = dict() res = 0 for i in range(n - minSize + 1): length = minSize while i + length &lt;= n and length &lt;= maxSize: t = s[i:i + length] for c in t: if len(letters) &gt; maxLetters: break letters.add(c) if len(letters) &lt;= maxLetters: cnts[t] = cnts.get(t, 0) + 1 res = max(res, cnts[t]) letters.clear() length += 1 return res 上述代码会超时。我们来利用剪枝来优化。 剪枝思路还是暴力法的思路，不过我们在此基础上进行一些优化。首先我们需要仔细阅读题目，如果你足够细心或者足够有经验，可能会发现其实题目中 maxSize 没有任何用处，属于干扰信息。 也就是说我们没有必要统计长度大于等于 minSize 且小于等于 maxSize 的所有子串，而是统计长度为 minSize 的所有字串即可。原因是，如果一个大于 minSize 长度的字串若是满足条件，那么该子串其中必定有至少一个长度为 minSize 的字串满足条件。因此一个大于 minSize 长度的字串出现了 n 次，那么该子串其中必定有一个长度为 minSize 的子串出现了 n 次。 代码代码支持 Python3，Java： Python Code： 12345678910 def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -&gt; int: counter, res = &#123;&#125;, 0 for i in range(0, len(s) - minSize + 1): sub = s[i : i + minSize] if len(set(sub)) &lt;= maxLetters: counter[sub] = counter.get(sub, 0) + 1 res = max(res, counter[sub]) return res;# @lc code=end Java Code： 12345678910111213141516171819 public int maxFreq(String s, int maxLetters, int minSize, int maxSize) &#123; Map&lt;String, Integer&gt; counter = new HashMap&lt;&gt;(); int res = 0; for (int i = 0; i &lt; s.length() - minSize + 1; i++) &#123; String substr = s.substring(i, i + minSize); if (checkNum(substr, maxLetters)) &#123; int newVal = counter.getOrDefault(substr, 0) + 1; counter.put(substr, newVal); res = Math.max(res, newVal); &#125; &#125; return res;&#125;public boolean checkNum(String substr, int maxLetters) &#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int i = 0; i &lt; substr.length(); i++) set.add(substr.charAt(i)); return set.size() &lt;= maxLetters;&#125; 关键点解析 滑动窗口 识别题目干扰信息 看题目限制条件，对于本题有用的信息是1 &lt;= maxLetters &lt;= 26 扩展我们也可以使用滑动窗口来解决，感兴趣的可以试试看。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"https://lucifer.ren/blog/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"陷阱题","slug":"陷阱题","permalink":"https://lucifer.ren/blog/tags/陷阱题/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://lucifer.ren/blog/tags/滑动窗口/"}]},{"title":"掌握前缀表达式真的可以为所欲为！","slug":"1310.xor-queries-of-a-subarray","date":"2020-01-09T12:51:02.477Z","updated":"2020-01-09T12:54:20.701Z","comments":true,"path":"2020/01/09/1310.xor-queries-of-a-subarray/","link":"","permalink":"https://lucifer.ren/blog/2020/01/09/1310.xor-queries-of-a-subarray/","excerpt":"前缀表达式是一种非常常见和重要的知识点，如果你还不知道，那就赶紧点进来看看吧！","text":"前缀表达式是一种非常常见和重要的知识点，如果你还不知道，那就赶紧点进来看看吧！ 题目地址（1310. 子数组异或查询）https://leetcode-cn.com/problems/xor-queries-of-a-subarray 题目描述123456789101112131415161718192021222324252627282930313233343536有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。并返回一个包含给定查询 queries 所有结果的数组。示例 1：输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]输出：[2,7,14,8]解释：数组中元素的二进制表示形式是：1 = 00013 = 00114 = 01008 = 1000查询的 XOR 值为：[0,1] = 1 xor 3 = 2[1,2] = 3 xor 4 = 7[0,3] = 1 xor 3 xor 4 xor 8 = 14[3,3] = 8示例 2：输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]输出：[8,0,4,4]提示：1 &lt;= arr.length &lt;= 3 * 10^41 &lt;= arr[i] &lt;= 10^91 &lt;= queries.length &lt;= 3 * 10^4queries[i].length == 20 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length 暴力法思路最直观的思路是双层循环即可，果不其然超时了。 代码123456789101112class Solution: def xorQueries(self, arr: List[int], queries: List[List[int]]) -&gt; List[int]: res = [] for (L, R) in queries: i = L xor = 0 while i &lt;= R: xor ^= arr[i] i += 1 res.append(xor) return res 前缀表达式思路比较常见的是前缀和，这个概念其实很容易理解，即一个数组中，第 n 位存储的是数组前 n 个数字的和。 对 [1,2,3,4,5,6] 来说，其前缀和可以是 pre=[1,3,6,10,15,21]。我们可以使用公式 pre[𝑖]=pre[𝑖−1]+nums[𝑖]得到每一位前缀和的值，从而通过前缀和进行相应的计算和解题。其实前缀和的概念很简单，但困难的是如何在题目中使用前缀和以及如何使用前缀和的关系来进行解题。 这道题是前缀对前缀异或，我们利用了异或的性质 x ^ y ^ x = y。 代码代码支持 Python3，Java，C++： Python Code： 1234567891011121314151617181920## @lc app=leetcode.cn id=1218 lang=python3## [1218] 最长定差子序列## @lc code=startclass Solution: def xorQueries(self, arr: List[int], queries: List[List[int]]) -&gt; List[int]: pre = [0] res = [] for i in range(len(arr)): pre.append(pre[i] ^ arr[i]) for (L, R) in queries: res.append(pre[L] ^ pre[R + 1]) return res# @lc code=end Java Code： 123456789101112131415161718public int[] xorQueries(int[] arr, int[][] queries) &#123; int[] preXor = new int[arr.length]; preXor[0] = 0; for (int i = 1; i &lt; arr.length; i++) preXor[i] = preXor[i - 1] ^ arr[i - 1]; int[] res = new int[queries.length]; for (int i = 0; i &lt; queries.length; i++) &#123; int left = queries[i][0], right = queries[i][1]; res[i] = arr[right] ^ preXor[right] ^ preXor[left]; &#125; return res; &#125; C++ Code: 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; xorQueries(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123; vector&lt;int&gt;res; for(int i=1; i&lt;arr.size(); ++i)&#123; arr[i]^=arr[i-1]; &#125; for(vector&lt;int&gt;temp :queries)&#123; if(temp[0]==0)&#123; res.push_back(arr[temp[1]]); &#125; else&#123; res.push_back(arr[temp[0]-1]^arr[temp[1]]); &#125; &#125; return res; &#125;&#125;; 关键点解析 异或的性质 x ^ y ^ x = y 前缀表达式 相关题目 303. 区域和检索 - 数组不可变 1186.删除一次得到子数组最大和","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"https://lucifer.ren/blog/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"前缀和","slug":"前缀和","permalink":"https://lucifer.ren/blog/tags/前缀和/"},{"name":"前缀表达式","slug":"前缀表达式","permalink":"https://lucifer.ren/blog/tags/前缀表达式/"}]},{"title":"数据结构快速盘点","slug":"basic-data-structure","date":"2020-01-02T16:00:00.000Z","updated":"2020-01-14T01:56:11.121Z","comments":true,"path":"2020/01/03/basic-data-structure/","link":"","permalink":"https://lucifer.ren/blog/2020/01/03/basic-data-structure/","excerpt":"这篇文章不是讲解数据结构的文章，而是结合现实的场景帮助大家理解和复习数据结构与算法，如果你的数据结构基础很差，建议先去看一些基础教程，再转过来看。 本篇文章的定位是侧重于前端的，通过学习前端中实际场景的数据结构，从而加深大家对数据结构的理解和认识。","text":"这篇文章不是讲解数据结构的文章，而是结合现实的场景帮助大家理解和复习数据结构与算法，如果你的数据结构基础很差，建议先去看一些基础教程，再转过来看。 本篇文章的定位是侧重于前端的，通过学习前端中实际场景的数据结构，从而加深大家对数据结构的理解和认识。 线性结构数据结构我们可以从逻辑上分为线性结构和非线性结构。线性结构有数组，栈，链表等， 非线性结构有树，图等。 其实我们可以称树为一种半线性结构。 需要注意的是，线性和非线性不代表存储结构是线性的还是非线性的，这两者没有任何关系，它只是一种逻辑上的划分。比如我们可以用数组去存储二叉树。 一般而言，有前驱和后继的就是线性数据结构。比如数组和链表。其实一叉树就是链表。 数组数组是最简单的数据结构了，很多地方都用到它。 比如有一个数据列表等，用它是再合适不过了。其实后面的数据结构很多都有数组的影子。 我们之后要讲的栈和队列其实都可以看成是一种受限的数组, 怎么个受限法呢？我们后面讨论。 我们来讲几个有趣的例子来加深大家对数组这种数据结构的理解。 React HooksHooks 的本质就是一个数组， 伪代码： 那么为什么 hooks 要用数组？ 我们可以换个角度来解释，如果不用数组会怎么样？ 12345678910111213141516171819function Form() &#123; // 1. Use the name state variable const [name, setName] = useState(\"Mary\"); // 2. Use an effect for persisting the form useEffect(function persistForm() &#123; localStorage.setItem(\"formData\", name); &#125;); // 3. Use the surname state variable const [surname, setSurname] = useState(\"Poppins\"); // 4. Use an effect for updating the title useEffect(function updateTitle() &#123; document.title = name + \" \" + surname; &#125;); // ...&#125; 基于数组的方式，Form 的 hooks 就是 [hook1, hook2, hook3, hook4],我们可以得出这样的关系， hook1 就是[name, setName] 这一对，hook2 就是 persistForm 这个。 如果不用数组实现，比如对象，Form 的 hooks 就是 123456&#123; 'key1': hook1, 'key2': hook2, 'key3': hook3, 'key4': hook4,&#125; 那么问题是 key1，key2，key3，key4 怎么取呢？ 关于 React hooks 的本质研究，更多请查看React hooks: not magic, just arrays React 将如何确保组件内部hooks保存的状态之间的对应关系这个工作交给了开发人员去保证，即你必须保证 HOOKS 的顺序严格一致，具体可以看 React 官网关于 Hooks Rule 部分。 队列队列是一种受限的序列，它只能够操作队尾和队首，并且只能只能在队尾添加元素，在队首删除元素。 队列作为一种最常见的数据结构同样有着非常广泛的应用， 比如消息队列 “队列”这个名称,可类比为现实生活中排队（不插队的那种） 在计算机科学中, 一个 队列(queue) 是一种特殊类型的抽象数据类型或集合。集合中的实体按顺序保存。 队列基本操作有两种: 向队列的后端位置添加实体，称为入队 从队列的前端位置移除实体，称为出队。 队列中元素先进先出 FIFO (first in, first out)的示意： (图片来自 https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/queue/README.zh-CN.md) 我们前端在做性能优化的时候，很多时候会提到的一点就是“HTTP 1.1 的队头阻塞问题”，具体来说就是 HTTP2 解决了 HTTP1.1 中的队头阻塞问题，但是为什么 HTTP1.1 有队头阻塞问题，HTTP2 究竟怎么解决的很多人都不清楚。 其实“队头阻塞”是一个专有名词，不仅仅这里有，交换器等其他都有这个问题，引起这个问题的根本原因是使用了队列这种数据结构。 对于同一个 tcp 连接，所有的 http1.0 请求放入队列中，只有前一个请求的响应收到了，然后才能发送下一个请求，这个阻塞主要发生在客户端。 这就好像我们在等红绿灯，即使旁边绿灯亮了，你的这个车道是红灯，你还是不能走，还是要等着。 HTTP/1.0 和 HTTP/1.1:在HTTP/1.0 中每一次请求都需要建立一个 TCP 连接，请求结束后立即断开连接。在HTTP/1.1 中，每一个连接都默认是长连接(persistent connection)。对于同一个 tcp 连接，允许一次发送多个 http1.1 请求，也就是说，不必等前一个响应收到，就可以发送下一个请求。这样就解决了 http1.0 的客户端的队头阻塞，而这也就是HTTP/1.1中管道(Pipeline)的概念了。但是，http1.1规定，服务器端的响应的发送要根据请求被接收的顺序排队，也就是说，先接收到的请求的响应也要先发送。这样造成的问题是，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送。也会造成队头阻塞。可见，http1.1 的队首阻塞发生在服务器端。 如果用图来表示的话，过程大概是： HTTP/2 和 HTTP/1.1: 为了解决HTTP/1.1中的服务端队首阻塞，HTTP/2采用了二进制分帧 和 多路复用 等方法。二进制分帧中，帧是HTTP/2数据通信的最小单位。在HTTP/1.1数据包是文本格式，而HTTP/2的数据包是二进制格式的，也就是二进制帧。采用帧可以将请求和响应的数据分割得更小，且二进制协议可以更高效解析。HTTP/2中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。多路复用用以替代原来的序列和拥塞机制。在HTTP/1.1中，并发多个请求需要多个 TCP 链接，且单个域名有 6-8 个 TCP 链接请求限制。在HHTP/2中，同一域名下的所有通信在单个链接完成，仅占用一个 TCP 链接，且在这一个链接上可以并行请求和响应，互不干扰。 此网站可以直观感受HTTP/1.1和HTTP/2的性能对比。 栈栈也是一种受限的序列，它只能够操作栈顶，不管入栈还是出栈，都是在栈顶操作。 在计算机科学中, 一个 栈(stack) 是一种抽象数据类型,用作表示元素的集合,具有两种主要操作: push, 添加元素到栈的顶端(末尾);pop, 移除栈最顶端(末尾)的元素.以上两种操作可以简单概括为“后进先出(LIFO = last in, first out)”。 此外,应有一个 peek 操作用于访问栈当前顶端(末尾)的元素。（只返回不弹出） “栈”这个名称,可类比于一组物体的堆叠(一摞书,一摞盘子之类的)。 栈的 push 和 pop 操作的示意: (图片来自 https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/stack/README.zh-CN.md) 栈在很多地方都有着应用，比如大家熟悉的浏览器就有很多栈，其实浏览器的执行栈就是一个基本的栈结构，从数据结构上说，它就是一个栈。这也就解释了，我们用递归的解法和用循环+栈的解法本质上是差不多。 比如如下 JS 代码： 1234567891011function bar() &#123; const a = 1; const b = 2; console.log(a, b);&#125;function foo() &#123; const a = 1; bar();&#125;foo(); 真正执行的时候，内部大概是这样的： 我画的图没有画出执行上下文中其他部分（this 和 scope 等）， 这部分是闭包的关键，而我这里不是将闭包的，是为了讲解栈的。 社区中有很多“执行上下文中的 scope 指的是执行栈中父级声明的变量”说法，这是完全错误的， JS 是词法作用域，scope 指的是函数定义时候的父级，和执行没关系 栈常见的应用有进制转换，括号匹配，栈混洗，中缀表达式（用的很少），后缀表达式（逆波兰表达式）等。 合法的栈混洗操作，其实和合法的括号匹配表达式之间存在着一一对应的关系，也就是说 n 个元素的栈混洗有多少种，n 对括号的合法表达式就有多少种。感兴趣的可以查找相关资料 链表链表是一种最基本数据结构，熟练掌握链表的结构和常见操作是基础中的基础。 (图片来自： https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/linked-list/traversal) React Fiber很多人都说 fiber 是基于链表实现的，但是为什么要基于链表呢，可能很多人并没有答案，那么我觉得可以把这两个点（fiber 和链表）放到一起来讲下。 fiber 出现的目的其实是为了解决 react 在执行的时候是无法停下来的，需要一口气执行完的问题的。 图片来自 Lin Clark 在 ReactConf 2017 分享 上面已经指出了引入 fiber 之前的问题，就是 react 会阻止优先级高的代码（比如用户输入）执行。因此 fiber打算自己自建一个虚拟执行栈来解决这个问题，这个虚拟执行栈的实现是链表。 Fiber 的基本原理是将协调过程分成小块，一次执行一块，然乎将运算结果保存起来，并判断是否有时间（react 自己实现了一个类似 requestIdleCallback 的功能）继续执行下一块。如果有时间，则继续。 否则跳出，让浏览器主线程歇一会，执行别的优先级高的代码。 当协调过程完成（所有的小块都运算完毕）， 那么就会进入提交阶段， 真正的进行副作用（side effect）操作，比如更新 DOM，这个过程是没有办法取消的，原因就是这部分有副作用。 问题的关键就是将协调的过程划分为一块块的，最后还可以合并到一起，有点像 Map／Reduce。 React 必须重新实现遍历树的算法，从依赖于内置堆栈的同步递归模型，变为具有链表和指针的异步模型。 Andrew 是这么说的： 如果你只依赖于[内置]调用堆栈，它将继续工作直到堆栈为空。。。 如果我们可以随意中断调用堆栈并手动操作堆栈帧，那不是很好吗？这就是 React Fiber 的目的。 Fiber 是堆栈的重新实现，专门用于 React 组件。 你可以将单个 Fiber 视为一个虚拟堆栈帧。 react fiber 大概是这样的： 12345678910111213let fiber = &#123; tag: HOST_COMPONENT, type: \"div\", return: parentFiber, children: childFiber, sibling: childFiber, alternate: currentFiber, stateNode: document.createElement(\"div\"), props: &#123; children: [], className: \"foo\" &#125;, partialState: null, effectTag: PLACEMENT, effects: []&#125;; 从这里可以看出 fiber 本质上是个对象，使用 parent，child，sibling 属性去构建 fiber 树来表示组件的结构树，return, children, sibling 也都是一个 fiber，因此 fiber 看起来就是一个链表。 细心的朋友可能已经发现了， alternate 也是一个 fiber， 那么它是用来做什么的呢？它其实原理有点像 git， 可以用来执行 git revert ,git commit 等操作，这部分挺有意思，我会在我的《从零开发 git》中讲解 想要了解更多的朋友可以看这个文章 如果可以翻墙， 可以看英文原文 这篇文章也是早期讲述 fiber 架构的优秀文章 我目前也在写关于《从零开发 react 系列教程》中关于 fiber 架构的部分，如果你对具体实现感兴趣，欢迎关注。 非线性结构那么有了线性结构，我们为什么还需要非线性结构呢？ 答案是为了高效地兼顾静态操作和动态操作。大家可以对照各种数据结构的各种操作的复杂度来直观感受一下。 树树的应用同样非常广泛，小到文件系统，大到因特网，组织架构等都可以表示为树结构，而在我们前端眼中比较熟悉的 DOM 树也是一种树结构，而 HTML 作为一种 DSL 去描述这种树结构的具体表现形式。如果你接触过 AST，那么 AST 也是一种树，XML 也是树结构。。。树的应用远比大多数人想象的要得多。 树其实是一种特殊的图，是一种无环连通图，是一种极大无环图，也是一种极小连通图。 从另一个角度看，树是一种递归的数据结构。而且树的不同表示方法，比如不常用的长子 + 兄弟法，对于你理解树这种数据结构有着很大用处， 说是一种对树的本质的更深刻的理解也不为过。 树的基本算法有前中后序遍历和层次遍历，有的同学对前中后这三个分别具体表现的访问顺序比较模糊，其实当初我也是一样的，后面我学到了一点，你只需要记住：所谓的前中后指的是根节点的位置，其他位置按照先左后右排列即可。比如前序遍历就是根左右, 中序就是左根右，后序就是左右根， 很简单吧？ 我刚才提到了树是一种递归的数据结构，因此树的遍历算法使用递归去完成非常简单，幸运的是树的算法基本上都要依赖于树的遍历。 但是递归在计算机中的性能一直都有问题，因此掌握不那么容易理解的”命令式地迭代”遍历算法在某些情况下是有用的。如果你使用迭代式方式去遍历的话，可以借助上面提到的栈来进行，可以极大减少代码量。 如果使用栈来简化运算，由于栈是 FILO 的，因此一定要注意左右子树的推入顺序。 树的重要性质： 如果树有 n 个顶点，那么其就有 n - 1 条边，这说明了树的顶点数和边数是同阶的。 任何一个节点到根节点存在唯一路径, 路径的长度为节点所处的深度 实际使用的树有可能会更复杂，比如使用在游戏中的碰撞检测可能会用到四叉树或者八叉树。以及 k 维的树结构 k-d 树等。 （图片来自 https://zh.wikipedia.org/wiki/K-d%E6%A0%91） 二叉树二叉树是节点度数不超过二的树，是树的一种特殊子集，有趣的是二叉树这种被限制的树结构却能够表示和实现所有的树，它背后的原理正是长子 + 兄弟法，用邓老师的话说就是二叉树是多叉树的特例，但在有根且有序时，其描述能力却足以覆盖后者。 实际上， 在你使用长子 + 兄弟法表示树的同时，进行 45 度角旋转即可。 一个典型的二叉树： 标记为 7 的节点具有两个子节点, 标记为 2 和 6; 一个父节点,标记为 2,作为根节点, 在顶部,没有父节点。 (图片来自 https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/README.zh-CN.md) 对于一般的树，我们通常会去遍历，这里又会有很多变种。 下面我列举一些二叉树遍历的相关算法: 94.binary-tree-inorder-traversal 102.binary-tree-level-order-traversal 103.binary-tree-zigzag-level-order-traversal 144.binary-tree-preorder-traversal 145.binary-tree-postorder-traversal 199.binary-tree-right-side-view 相关概念： 真二叉树 （所有节点的度数只能是偶数，即只能为 0 或者 2） 另外我也专门开设了二叉树的遍历章节, 具体细节和算法可以去那里查看。 堆堆其实是一种优先级队列，在很多语言都有对应的内置数据结构，很遗憾 javascript 没有这种原生的数据结构。不过这对我们理解和运用不会有影响。 堆的特点： 在一个 最小堆(min heap) 中, 如果 P 是 C 的一个父级节点, 那么 P 的 key(或 value)应小于或等于 C 的对应值.正因为此，堆顶元素一定是最小的，我们会利用这个特点求最小值或者第 k 小的值。 在一个 最大堆(max heap) 中, P 的 key(或 value)大于 C 的对应值。 需要注意的是优先队列不仅有堆一种，还有更复杂的，但是通常来说，我们会把两者做等价。 相关算法： 295.find-median-from-data-stream 二叉查找树二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。 二叉查找树具有下列性质的二叉树： 若左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若右子树不空，则右子树上所有节点的值均大于它的根节点的值； 左、右子树也分别为二叉排序树； 没有键值相等的节点。 对于一个二叉查找树，常规操作有插入，查找，删除，找父节点，求最大值，求最小值。 二叉查找树，之所以叫查找树就是因为其非常适合查找，举个例子，如下一颗二叉查找树，我们想找节点值小于且最接近 58 的节点，搜索的流程如图所示： （图片来自 https://www.geeksforgeeks.org/floor-in-binary-search-tree-bst/） 另外我们二叉查找树有一个性质是： 其中序遍历的结果是一个有序数组。有时候我们可以利用到这个性质。 相关题目： 98.validate-binary-search-tree 二叉平衡树平衡树是计算机科学中的一类数据结构，为改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了平衡树。 在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。 一些数据库引擎内部就是用的这种数据结构，其目标也是将查询的操作降低到 logn（树的深度），可以简单理解为树在数据结构层面构造了二分查找算法。 基本操作： 旋转 插入 删除 查询前驱 查询后继 AVL是最早被发明的自平衡二叉查找树。在 AVL 树中，任一节点对应的两棵子树的最大高度差为 1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是 {\\displaystyle O(\\log {n})} O(\\log{n})。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL 树得名于它的发明者 G. M. Adelson-Velsky 和 Evgenii Landis，他们在 1962 年的论文 An algorithm for the organization of information 中公开了这一数据结构。 节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子 1、0 或 -1 的节点被认为是平衡的。带有平衡因子 -2 或 2 的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。 红黑树在 1972 年由鲁道夫·贝尔发明，被称为”对称二叉 B 树”，它现代的名字源于 Leo J. Guibas 和 Robert Sedgewick 于 1978 年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在 {\\displaystyle O(\\log {n})} O(\\log{n})时间内完成查找，插入和删除，这里的 n 是树中元素的数目 字典树(前缀树)又称 Trie 树，是一种树形结构。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。 (图来自 https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin)它有 3 个基本性质： 根节点不包含字符，除根节点外每一个节点都只包含一个字符； 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串； 每个节点的所有子节点包含的字符都不相同。 immutable 与 字典树immutableJS的底层就是share + tree. 这样看的话，其实和字典树是一致的。 相关算法： 208.implement-trie-prefix-tree 图前面讲的数据结构都可以看成是图的特例。 前面提到了二叉树完全可以实现其他树结构，其实有向图也完全可以实现无向图和混合图，因此有向图的研究一直是重点考察对象。 图论〔Graph Theory〕是数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。 图的表示方法 邻接矩阵(常见) 空间复杂度 O(n^2),n 为顶点个数。 优点： 直观，简单。 适用于稠密图 判断两个顶点是否连接，获取入度和出度以及更新度数，时间复杂度都是 O(1) 关联矩阵 邻接表 对于每个点，存储着一个链表，用来指向所有与该点直接相连的点对于有权图来说，链表中元素值对应着权重 例如在无向无权图中： （图片来自 https://zhuanlan.zhihu.com/p/25498681） 可以看出在无向图中，邻接矩阵关于对角线对称，而邻接链表总有两条对称的边而在有向无权图中： （图片来自 https://zhuanlan.zhihu.com/p/25498681） 图的遍历图的遍历就是要找出图中所有的点，一般有以下两种方法： 深度优先遍历：(Depth First Search, DFS) 深度优先遍历图的方法是，从图中某顶点 v 出发， 不断访问邻居， 邻居的邻居直到访问完毕。 广度优先搜索：(Breadth First Search, BFS) 广度优先搜索，可以被形象地描述为 “浅尝辄止”，它也需要一个队列以保持遍历过的顶点顺序，以便按出队的顺序再去访问这些顶点的邻接顶点。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"}]},{"title":"每日一荐 2019-12 汇总","slug":"daily-featured-2019-12","date":"2020-01-01T12:33:17.345Z","updated":"2020-02-25T02:41:19.734Z","comments":true,"path":"2020/01/01/daily-featured-2019-12/","link":"","permalink":"https://lucifer.ren/blog/2020/01/01/daily-featured-2019-12/","excerpt":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。","text":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。 2019-122019-12-31[见闻]今天是我的生日，祝我生日快乐 🎂 ～～～～ 一般公司的卫生间贴的都是公司信息或心灵鸡汤，但是谷歌卫生间贴的是如何找到代码 Bug，不得不感叹“这实在是太硬核了”！ 2019-12-24[技巧]今天是平安夜，苹果 🍎 和圣诞礼物 🎁 都收到了么？ 今天给大家推荐的是一个 linux 中非常常见的命令 grep 的常用用法。 图版本： 文字版本： Matches patterns in input text.Supports simple patterns and regular expressions. Search for an exact string:grep search_string path/to/file Search in case-insensitive mode:grep -i search_string path/to/file Search recursively (ignoring non-text files) in current directory for an exact string:grep -RI search_string . Use extended regular expressions (supporting ?, +, {}, () and |):grep -E ^regex$ path/to/file Print 3 lines of [C]ontext around, [B]efore, or [A]fter each match:grep -C|B|A 3 search_string path/to/file Print file name with the corresponding line number for each match:grep -Hn search_string path/to/file Use the standard input instead of a file:cat path/to/file | grep search_string Invert match for excluding specific strings:grep -v search_string 2019-12-23[学习方法]很多人问我如何保持高效率。 首先要说的是我的效率并不是很高，这也就是我为什么还在不断学习提高效率的原因之一。那么既然有人问了我就班门弄斧回答一下，大家有什么好的方法和技巧欢迎提出来交流。 为了让自己保持高效率，我自己开了一个仓库记录了自己保持“高效率”的方式。希望可以给大家启发，本仓库内容持续更新～ 仓库大纲： 仓库截图： 仓库地址：https://github.com/azl397985856/To-Be-Productive 2019-12-20[新闻]Facebook 发布 Hermes， 一个新的专门用于 React Native 的 JS 引擎。 文章地址：https://facebook.github.io/react-native/blog/2019/07/17/hermes 2019-12-19[好文]很多高级语言有自动的垃圾回收器，比如 JS，JAVA，Go 等。其会自动地进行垃圾回收工作，而不必像诸如 C 和 C++那样手动分配和清除内存。 对于 old space 的垃圾回收算法有一个是标记清除，从一个根对象开始对于所有可达的对象进行标记，剩下的就是不可达的，我们将其进行清除，本文讲解了三色标记法（黑色，白色和灰色），三色标记法本质上进行一次 DFS，并将内存对象分到三个部分，DFS 完成之后清除不可达的内存（白色）。这篇文章以动画形式讲解了三色标记法的具体过程。 文章（《一张图了解三色标记法》）地址：http://idiotsky.top/2017/08/16/gc-three-color/ 2019-12-18[教程]哈弗大学 CS50 系列，内容持续更新，现在最新的是 2019 年。 你可以跟着教程来重新学习 CS 基础。 地址：https://cs50.harvard.edu/college/ 2019-12-17[网站]Learn Git Branching 是一个交互式学习 Git 的网站。沙盒里你能执行相应的命令，还能看到每个命令的执行情况； 通过一系列刺激的关卡挑战，逐步深入的学习 Git 的强大功能，在这个过程中你可能还会发现一些有意思的事情。 地址： https://learngitbranching.js.org/ 2019-12-16[新闻]最新版本的 Chrome 和 Firefo 浏览器取消 EV 证书的显示。 只有用户点击了锁 🔒，才会显示出 EV 证书的信息。 为什么会这样？想要知道答案的可以点击原文阅读。 原文地址：Chrome and Firefox Changes Spark the End of EV Certificates 2019-12-13[类库]loki 是一个 React Storybook 组件回归测试工具。React Storybook 是一个我 15 年就开始关注的一个工具，本身的设计思想我比较喜欢。现在除了支持 React，也支持 React Native，Vue，Angular 等，甚至最新的 Svelte 也支持。 loki Github 地址： https://github.com/oblador/loki 2019-12-12[技巧]Angular 的 Commit Message Conventions 是一套很流行的 Commit Message 规约。简单方便，一目了然，更重要的是这种约定化如果形成一种默契，不管对于之后查看，还是生成各种外部资料（比如 CHNAGELOG）都是非常方便的。 详细信息： https://gist.github.com/stephenparish/9941e89d80e2bc58a153 相关工具也有很多，我个人使用的是Commitizen 2019-12-11[好文]文章标题 《花椒前端基于 WebAssembly 的 H.265 播放器研发》，本文从背景介绍，技术调研，实际方案到最后的实践效果，完整地讲述了通过 wasm 将 H.265 应用到不支持其的浏览器的过程。干货满满，其架构图画的也是我比较喜欢的风格。 文章地址： https://zhuanlan.zhihu.com/p/73772711 2019-12-10[技巧]我们有时候需要在终端访问一些国外的资源。我目前采取的措施主要是给终端设置 proxy。 12alias proxy=&apos;export all_proxy=socks5://127.0.0.1:1086&apos;alias unproxy=&apos;unset all_proxy&apos; 其中socks5://127.0.0.1:1086是我的本机的正向代理地址。 如下是使用效果： 如图显示我们代理成功了，而且我们可以方便的在不想要代理的时候去掉代理。 2019-12-09[类库]对于前端，我们经常需要将组件进行可视化的展示。在 Vue 中，我们通常会用 docsify 或者 vuepress 等。而对于 react 比较有名的有 storybook 和 docz。 当然这并不是绝对的，比如 storybook 也在支持 vue 和 webcomponents。 2019-12-06[技能]在分析 CPU、内存、磁盘等的性能指标时，有几种工具是高频出现的，如 top、vmstat、pidstat，这里稍微总结一下: CPU：top、vmstat、pidstat、sar、perf、jstack、jstat；内存：top、free、vmstat、cachetop、cachestat、sar、jmap；磁盘：top、iostat、vmstat、pidstat、du/df；网络：netstat、sar、dstat、tcpdump；应用：profiler、dump 分析。排查 Java 应用的线上异常或者分析应用代码瓶颈，可以使用阿里开源的 Arthas ，nodejs 应用可以使用 alinode 2019-12-05[好文]如果你想做微前端，一定要能够回答出这 10 个问题。 微应用的注册、异步加载和生命周期管理； 微应用之间、主从之间的消息机制； 微应用之间的安全隔离措施； 微应用的框架无关、版本无关； 微应用之间、主从之间的公共依赖的库、业务逻辑(utils)以及版本怎么管理； 微应用独立调试、和主应用联调的方式，快速定位报错（发射问题）； 微应用的发布流程； 微应用打包优化问题； 微应用专有云场景的出包方案； 渐进式升级：用微应用方案平滑重构老项目。 今天推荐的这个文档，区别与别的微前端文章的点在于其更加靠近规范层面，而不是结合自己的业务场景做的探索。这篇文章来自于阿里团队。 文章地址： https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw 2019-12-04[工具]相信大家使用 shell 的时候，会经常碰到忘记的 option，或者某一个用法记不清楚。遇到这种问题通常我们会用 man 或者命令提供的–help 查看用法。 这里给大家介绍另外一种工具tldr, 它是一个将 man page 进行简化，将大家常用的用法总结出来的工具。 安全也非常简单，只需要 npm install -g(前提是你必须安装 node)， 如果你不想安装也没有关系，它还提供了web 版。另外你也可以参考这里定制你的主题 仓库地址： https://github.com/tldr-pages/tldr 2019-12-03[技巧]今天给大家介绍的是Google高级搜索技巧。我们经常使用搜索引擎搜索一些东西，不管是遇到问题想寻求解决方案也好，想学习一些新东西也好，掌握一定的搜索技巧是可以让你搜索的过程事半功倍，尤其是常用的技巧一定要记住。 2019-12-02[软件]我们公司在使用的一个完全开源的堡垒机，是符合 4A 的专业运维审计系统。 地址： https://github.com/jumpserver/jumpserver 关注我我重新整理了下自己的公众号，并且我还给它换了一个名字脑洞前端，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。 在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。 之后我的文章会同步到微信公众号 脑洞前端 ，你可以关注获取最新的文章，并和我进行交流。 另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。 贡献 如果有想法和创意，请提issue或者进群提 如果想贡献代码，请提PR 如果需要修改项目中图片，这里存放了项目中绘制图的源代码， 大家可以用draw.io打开进行编辑。 LicenseApache-2.0","categories":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/categories/每日一荐/"},{"name":"2019-12","slug":"每日一荐/2019-12","permalink":"https://lucifer.ren/blog/categories/每日一荐/2019-12/"}],"tags":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/tags/每日一荐/"}]},{"title":"致作者","slug":"to-author","date":"2019-12-11T04:35:19.047Z","updated":"2019-12-11T04:35:19.047Z","comments":true,"path":"2019/12/11/to-author/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/to-author/","excerpt":"写给我敬爱的作者们，关于“云写书”的初衷，愿景，规划以及具体细节。","text":"写给我敬爱的作者们，关于“云写书”的初衷，愿景，规划以及具体细节。 初衷建立作者群，让大家参与进来的目的有三个。 缩短写作的周期 我希望这本书尽快与大家见面，毕竟时间就是金钱，一个人的力量还是很有限的，目前计划作者控制在2-10个人，参与人数不限制。 结识志同道合的朋友，将来可以继续合作 本来计划写别的书的，只是突然觉得LeetCode题解这块受众更大，大家普遍希望有这么一本书，因此才决定先写这本。我也希望之后写别的书的时候大家也可以在一起合作。 更好地推广 作者们也可以起到很好地宣传作用，毕竟是自己深度参与的书，大家宣传的意愿很会有的。 愿景背靠着 Github LeetCode排名第一的项目，再加上多个媒体平台的宣传推广，我个人觉得市场还是有的，另外市面上的多是以数据结构和算法为基础进行讲解，而不是LeetCode题解方面，这方面我认为是一个缺口。 另外我看了很多相关的资料，包括电子书，实体书以及博客，官方articles等，决定要不就是不够系统，要不就是不够通俗易懂。 我的受众群体是想找工作的LeetCode新手，帮助他们攻克一些高频题目，掌握解题技巧，更加有效率地刷题 规划 2019-10 建立初步的成员名单，制定写作规范，联系LeetCode官方授权 2019-11 分配章节给大家，大家分别书写 2019-12 汇总大家的文章，进行审阅 &amp; 校验 Code StyleTODO 文章格式TODO 大纲这个是我之前写的大纲，需要微调， 大家可以先大概看一下 https://lucifer.ren/blog/2019/10/03/draft/ 样张 一文搞懂《链表反转》 文科生都能看懂的循环移位算法 一文看懂《最大子序列和问题》 如何参与要参加写作的， 给出你写过的文章，最好LeetCode或者算法相关，然后等待我审核，写文章的时候语言要求python，不会的可以花几个小时学习一下。 另外需要提供三种语言(分别是JS，Java和Python)的代码到我新建的一个仓库中，专门给这本书放源码，按照语言和章节划分一下。 作者们别忘记让我拉你进组织，我们的组织是https://github.com/leetcode-book 如果语言有什么困难，直接群里沟通，我相信语言不是问题。 另外大家写题解的时候，一定少用语言特有的东西。 有能力的欢迎提供其他语言的代码实现","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"},{"name":"LeetCode题解书","slug":"LeetCode/LeetCode题解书","permalink":"https://lucifer.ren/blog/categories/LeetCode/LeetCode题解书/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"}]},{"title":"使用web-component搭建企业级组件库","slug":"web-components-enterprize","date":"2019-12-11T04:35:19.047Z","updated":"2019-12-11T04:35:19.047Z","comments":true,"path":"2019/12/11/web-components-enterprize/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/web-components-enterprize/","excerpt":"前端目前比较主流的框架有react，vuejs，angular等。 我们通常去搭建组件库的时候都是基于某一种框架去搭建，比如ant-design是基于react搭建的UI组件库，而elementUI则是基于vuejs搭建的组件库。 虽然目前社区有相关工具，提供框架之间的转化服务，比如讲vuejs组件转化为react组件。但是毕竟是不同的框架，有不同的标准。因此框架api发生变动，那么你就需要重写转化逻辑，显然是不灵活的，因此我们暂不讨论这种情况。作为公司而言，就需要为不同的框架写不同的组件库，尽管逻辑都是一样的。 另外如果框架升级，比如从1.x升级到2.x，那么对应组件库就需要升级，如果公司的组件库有很多（vuejs，react，angular等），那么这种升级的概率就会更大。","text":"前端目前比较主流的框架有react，vuejs，angular等。 我们通常去搭建组件库的时候都是基于某一种框架去搭建，比如ant-design是基于react搭建的UI组件库，而elementUI则是基于vuejs搭建的组件库。 虽然目前社区有相关工具，提供框架之间的转化服务，比如讲vuejs组件转化为react组件。但是毕竟是不同的框架，有不同的标准。因此框架api发生变动，那么你就需要重写转化逻辑，显然是不灵活的，因此我们暂不讨论这种情况。作为公司而言，就需要为不同的框架写不同的组件库，尽管逻辑都是一样的。 另外如果框架升级，比如从1.x升级到2.x，那么对应组件库就需要升级，如果公司的组件库有很多（vuejs，react，angular等），那么这种升级的概率就会更大。 什么是web-component？那么有没有更好的方案，一次编写，到处使用呢？ 答案就是借助web component。 Web Components 是一系列加入w3c的HTML和DOM的特性，使得开发者可以创建可复用的组件。 由于web components是由w3c组织去推动的，因此它很有可能在不久的将来成为浏览器的一个标配。 Web Components 主要由以下四个部分组成： Custom Elements – 定义新html元素的api Shadow DOM – Encapsulated DOM and styling, with composition HTML Imports – Declarative methods of importing HTML documents into other documents HTML Templates – The &lt;template&gt; element, which allows documents to contain inert chunks of DOM web-component有什么优点使用web components搭建组件库能够带来什么好处呢？前面说了，web components 是w3c推动的一系列的规范，它是一个标准。 如果我们使用web components的api 开发一个组件，这个组件是脱离框架存在的，也就是说你可以在任何框架中使用它，当然也可以直接在原生js中使用。 我们无须为不同的框架编写不同的组件库。 使用web components编写的组件库的基本使用方法大概是这样的： 1234&lt;script src=\"/build/duiba.js\"&gt;&lt;/script&gt;&lt;!-- 运营位组件 --&gt;&lt;operation-list&gt;&lt;/operation-list&gt; 毫不夸张地说， web components 就是未来。 但是web components的api还是相对复杂的，因此用原生的api开发web components还是相对比较复杂的，就好像你直接用原生canvas api去开发游戏一样。 下面我们介绍下用于简化web components开发的库。 polymerpolymer是我接触的第一个web componment开发库，那已经是很多年前的往事了。 Build modern apps using web components 更多介绍polymer stencilstencil是在polymer之后出现的一个库。第一次接触时在Polymer Summit 2017的分享上，这里贴下地址Using Web Components in Ionic - Polymer Summit 2017。 Stencil is a tool developers use to create Web Components with some powerful features baked in, but it gets out of the way at runtime. 那么powerful features具体指的是什么？ 12345Virtual DOMAsync rendering (inspired by React Fiber)Reactive data-bindingTypeScriptJSX 它也是一个用于生成web compoennt的tool。 不同的是她提供了更多的特性(Reactive data-binding,TypeScript,JSX, virtual dom)以及更强的性能(virtual dom, Async rendering). 细心的人可能已经发现了，我将Virtual DOM既归为特性，又归为性能，没错！ Virtual DOM提供了一种到真实dom的映射，使得开发者不必关心真实dom，从这个层面讲它是特性。 从虚拟dom之间的diff，并将diff info patch到real dom（调和）的过程来看，它是性能。 用stencil开发web components体验大概是这样的： 12345678910111213141516171819202122import &#123; Component, Prop, State &#125; from '@stencil/core';@Component(&#123; tag: 'my-component', styleUrl: 'my-component.scss'&#125;)export class MyComponent &#123; // Indicate that name should be a property on our new component @Prop() first: string; @Prop() last: string; @State() isVisible: boolean = true; render() &#123; return ( &lt;p&gt; Hello, my name is &#123;this.first&#125; &#123;this.last&#125; &lt;/p&gt; ); &#125;&#125; Demo这是我基于stenciljs + storybook写的一个小例子。大家可以clone，并运行查看效果。 duiba-components 通过这样搭建的企业级组件库，就可以轻松地为不同业务线提供基础组件库，而不必担心使用者（各个业务方）的技术栈。 将来业务方的框架升级（比如vue1升级到vue2），我们的组件库照样可以使用。 可以想象，如果es标准发展地够好，web components 等规范也足够普及，无框架时代将会到来。 无框架，不代表不使用库。 只需要借助工具库就可以开发足够通用的组件，也不需要babel这样的转换器，更不需要各种polyfill。那么开发者大概会非常幸福吧，可惜这样的日子不可能存在，但是离这个目标足够近也是极好的。","categories":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/categories/前端/"},{"name":"组件化","slug":"前端/组件化","permalink":"https://lucifer.ren/blog/categories/前端/组件化/"},{"name":"web-component","slug":"前端/web-component","permalink":"https://lucifer.ren/blog/categories/前端/web-component/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/tags/前端/"},{"name":"组件化","slug":"组件化","permalink":"https://lucifer.ren/blog/tags/组件化/"},{"name":"web-component","slug":"web-component","permalink":"https://lucifer.ren/blog/tags/web-component/"}]},{"title":"累死累活干不过一个写PPT的","slug":"ppt-data","date":"2019-12-11T04:35:19.046Z","updated":"2020-04-13T06:52:46.387Z","comments":true,"path":"2019/12/11/ppt-data/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/ppt-data/","excerpt":"无论是身处什么行业什么领域，数据分析越来越成为一向必不可少的技能，而运用数据思维进行决策更能产生形成高质量的决策结果。 随着互联网的不断发展和物联网设备的不断普及，我们日常生活中的各种数据被存储下来，让我们可以通过定量分析数据，利用数据实现更好的决策制定。","text":"无论是身处什么行业什么领域，数据分析越来越成为一向必不可少的技能，而运用数据思维进行决策更能产生形成高质量的决策结果。 随着互联网的不断发展和物联网设备的不断普及，我们日常生活中的各种数据被存储下来，让我们可以通过定量分析数据，利用数据实现更好的决策制定。 现在越来越多的公司开始注重这一块，一方面自建数据体系，一方面去买一些数据。而对于我们个人似乎还没有意识到或者开始挖掘数据对我们的价值。 笔者最近的工作大都是做一些基础设施搭建和流程优化相关的工作。这部分工作对很多人来说都是“隐形”的，对上层使用者来说很难有很大的感知。对于领导来说，如果你只是闷头去做事情，他们也是很难知道你干的怎么样，如果这之间再加上你没有什么反馈，就会给同事和领导一种“不靠谱”的感觉。 因此给予反馈和直观展示自己劳动成果的能力就显得非常重要。然而如果你能很好展示自己的劳动成果，那么只需要将这个给老板看就是一种很好很直观的反馈。 这篇文章，我们来谈一下，如何量化我们的工作，如何将我们的工作成果展示出来。如何让同事，让领导体会到我们工作的成果。我会通过几个例子来帮助大家快速理解，以及掌握这门“技术”。 《让数据开口说话》是我给这篇文章的标题，让数据开口说话，你就可以少说一点，并且摆数据就是摆事实，数据带来的说服力要比你说的话强很多。 关于我我是一个对技术充满兴趣的程序员, 擅长前端工程化，前端性能优化，前端标准化等。 做过.net， 搞过 Java，现在是一名前端工程师。 除了我的本职工作外，我会在开源社区进行一些输出和分享，GitHub 共计获得 1.5W star。比较受欢迎的项目有leetcode 题解 , 宇宙最强的前端面试指南 和我的第一本小书 收集数据如果让数据开头说话，那么首先第一步你要有数据。 因此我们的第一步就是收集数据，那么在这之前你需要知道你需要什么数据。这部分的内容随着每个人任务不同肯定是不一样的。因此有着很大的灵活性， 有一个指导思想就是对关键指标分解。比如我现在要做打包时间进行优化，那么打包时间由哪些时间决定。 1打包时间 = 阶段1 时间 + 阶段2 时间 + 阶段3 时间 我们减少打包时间肯定要减少其中一个或多个。 有时候我们无法找到这种简单的分解，那就教大家另外一个技巧：运用对比。 一方面可以基于时间进行对比，比如环比增长，同比增长等数据都是这么来的。 另一方面我们可以基于用户属性进行对比，比如用户年龄，性别，偏好，操作系统类型，地域属性等。 下面我举几个例子。 打包优化假如你被分配了一个任务。让你对项目的打包过程进行优化。 你需要对打包时间进行优化，减少打包的时间 你需要对打包的最终产物进行优化，减少打出的包的包体大小。 将打包变得尽可能的简单，也就说尽量减少人为的操作过程。 你接到了这样一个任务，你会如何去做？ 这里我们不考虑具体的具体思路和细节。 假设你的架构思路，方案规划，各种 fallback 已经想好了。我们如何通过上面提到的让数据说话的角度来收集数据呢？ 换句话说，我们需要收集哪些数据？ 打包时间对于打包时间的数据，最简单的我们计算一下总体的打包时间。 最后我们只需要对比优化前后的总体打包时间差异即可。 这对于老板来说可能已经够了，但是这缺乏一些精确性，我们无法知道通过优化了哪个环节进行减少了打包时间。 因此一种简单的改进是将打包划分为多个阶段，每个阶段分别进行统计计时 ⌛️ 。 包的大小包的大小的数据其实和上面讲的打包时间思路类似。 我们当然可以只统计总体包大小。 但是为了获得更加灵活的定制和更加精确的范围我们可以对包进行一定的划分。这个划分可以是业务纬度，也可以是纯技术纬度。 打包命令这部分比较简单，我们只需要简单地统计手动操作的次数即可。 通过收集以上的数据，我们就可以用数据来表示我们的成果，让数据说话，关于如何使用这些数据，我们稍后讨论。 页面加载性能优化假如你被分配了一个任务。让你对项目的页面加载速度进行优化。你会怎么做？ 这个任务有点太宽泛了，更多的时候会有一些更精确的指标，比如将网络状态为fast 3G的中端机型的白屏时间降低到3s以内。 timing性能优化的第一步就是测量，没有测量就没有优化。我们不能为了优化而优化， 而是看到了某些点需要优化才去优化的。 而发现这个点一个重要的方式就是要靠测量。 说到测量，普遍接受的方式是，在浏览器中进行打点，将浏览器打开网页的过程看作是一个旅行。那么我们每到一个地方就拍张带有时间的照片（事件），最后我们对这些照片按照时间进行排列， 然后分析哪部分是我们的瓶颈点等。 有了这些 timing 我们可以很方便的计算各项性能指标。我们还可以自定义一些我们关心的指标，比如请求时间（成功和失败分开统计），较长 js 操作时间，或者比较重要的功能等。 总之收集到这些数据之后，我们只需要根据我们的需求去定制一些指标即可。 这样我们就很容易展示出这样的画面： 人效提升假如你是一个项目的管理者，上级分配给你一个任务，要在未来几个季度去做“研发效率提升”，也就是提高“交付速度”。 你会怎么做这件事？ 任务这个事情是比较主观的了，因此我们切实需要一些可以量化的东西来辅助我们。 我们考虑将需求进行拆分，变成一个个任务。一个需求可能有多个任务。 我们考虑对每一个任务进行计时，而不是需求，因为需求有太大的差异。我们可以针对任务进行分类，然后我们的目标就可以变成“减少同类任务的交付时长”。 但是这种粒度似乎还是有点大。我们可以采取标签的形式，对任务进行交叉分类。 任务纬度可能还是有点太大，我们可以采取更小的粒度划分，比如模块和组件。 这样我们的统计纬度就丰富起来了，我们不仅可以总体进行统计分析，我们还可以根据 tag 和 tag 的组合进行汇总。 比如一个典型的统计结果大概是： 12345678- task1 (tagA) - module1 (tagA) - component1 (tagB) - component2 (tagA) - module2 (tagB) - module3 (tagB)- task2 (tagA)- task3 (tagC) 比如这里有一种 tag 叫“是否复用了以前的代码”，那么我们就很容易统计出组件复用率，也就很容易很直观地知道前后的差距了。 用户拉新和留存再比如我们需要做“用户拉新和留存”，我们应该怎么做？ 这个留做思考题，大家可以思考一下。 我这里抛砖引玉一下，比如我们的统计纬度可以是： 12345- 用户访问时长 (tagA)- 跳出率 (tagB)- 新用户 (tagA)- 流失的老用户 (tagB)- 地址位置 (tagA) 假如我的 tag 有两个分别是 用户 id 和时间， 我们就可以方便地统计每个用户的活动数据趋势。 让数据说话有了数据，我们如何通过数据来增强表现力呢？ 一种非常有效的措施是可视化。现在的可视化引擎和工具有很多，功能也非常复杂。 但是我发现我个人需要的就那么几个，可能大家每个人需要的种类不大一样，但是我相信作为个人，你需要的种类不会很多。因此自己根据自身的实际情况，挑选适合自己的几种类型，做到迎刃有余就足够了。 对于我而言，我常用的是饼图，用来表示分布关系。 曲线图用来表示趋势。用柱状图表示对比+趋势。用热度图表示离散的数据分布等等。 我们可以使用一些现有的成熟的产品来帮助我们将刚才我们收集到的数据转化为各种图表，比如 画布 这个网站能做的图表种类比较少。 当然作为一名前端我们也可以自己写代码去更灵活地展示我们的数据，比如D3或者百度的echarts 任何类型的图表都可以做，只有你想不到，没有它做不到。 相对折中一点，我们可以选择支持代码定制的一些产品，在特殊情况我们可以自定义。 累死累活干不过做 PPT 的有了这些数据图表，是时候写一份 PPT 来秀一下了。 一种方式是使用你电脑的办公软件或者一些在线的幻灯片制作工具做，比如slides 。 另一种方式通过写代码的方式实现，作为程序员我推荐使用第二种。这里推荐一款nodejs cli 工具 nodeppt,还有另外一个JS 框架 reveal.js 。上面提到的 slides 背后的原理就是它。 总结这篇文章我主要讲述了如何量化我们的工作，并将我们的工作成果展示出来。从而摆脱“干了很多事情，却说不出来，甚至功劳被人无情拿走的尴尬局面”。 首先我们将了如何收集数据，收集数据的一些技巧，这里通过几个实际工作的例子，分别是“打包优化”，“性能优化”，“人效提升”，“用户留存” ，来帮助大家理解这个过程，掌握这个技巧。 有了数据之后，我们需要通过一些手段将其数据展示出来，给人直观的感受，最好有视觉冲击感。这里我推荐了几个工具和平台，大家可以根据自己的情况选择。 最后结合我们实际情况，PPT 是一个很好的展示自己的东西，不管是晋升还是宣传都是很好的方式，这里我也推荐了几个产品，帮助大家更快更好地将图表展示出来。 让数据开口说话，你就可以少说一点，并且摆数据就是摆事实，数据带来的说服力要比你说的话强很多。 关注我最近我重新整理了下自己的公众号，并且我还给他换了一个名字《脑洞前端》，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。 我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解前端是我的目标。 之后我的文章同步到微信公众号 脑洞前端 ，您可以关注获取最新的文章，或者和我进行交流。 交流群现在还是初级阶段，需要大家的意见和反馈，为了减少沟通成本，我组建了交流群。大家可以扫码进入 QQ 群 微信群 (由于微信的限制，100 个人以上只能邀请加入， 你可以添加我的机器人回复“大前端”拉你进群)","categories":[],"tags":[{"name":"技能","slug":"技能","permalink":"https://lucifer.ren/blog/tags/技能/"},{"name":"PPT","slug":"PPT","permalink":"https://lucifer.ren/blog/tags/PPT/"}]},{"title":"一文搞懂《链表反转》","slug":"reverseList","date":"2019-12-11T04:35:19.046Z","updated":"2020-04-13T06:50:26.832Z","comments":true,"path":"2019/12/11/reverseList/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/reverseList/","excerpt":"翻转链表一直都是热门题目，笔者就在某大型互联网公司的面试题中碰到过这种题目，这种题目很常常见，相对应的变形和扩展也很多，今天我们就来攻克它吧。","text":"翻转链表一直都是热门题目，笔者就在某大型互联网公司的面试题中碰到过这种题目，这种题目很常常见，相对应的变形和扩展也很多，今天我们就来攻克它吧。 反转链表反转链表是这个系列中最简单的了，没有别的要求，就是将一个链表从头到尾进行反转，最后返回反转后的链表即可。 我们来看一个 LeetCode 题目, 206. 反转链表, 官方难度为 Easy。 题目描述12345678反转一个单链表。示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 思路链表的翻转过程，初始化一个为 null 的 previous node（prev），然后遍历链表的同时，当前 node （curr）的下一个（next）指向前一个 node（prev）， 在改变当前 node 的指向之前，用一个临时变量记录当前 node 的下一个 node（curr.next). 即 1234ListNode temp = curr.next;curr.next = prev;prev = curr;curr = temp; 举例如图：翻转整个链表 1-&gt;2-&gt;3-&gt;4-&gt;null -&gt; 4-&gt;3-&gt;2-&gt;1-&gt;null 代码我们直接来看下代码： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */function reverseList(head) &#123; if (!head || !head.next) return head; let cur = head; let pre = null; while (cur) &#123; const next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre;&#125; 这里不再赘述，如果不理解，想看更多更详细内容，请参考我的LeetCode 题解 - 206.reverse-linked-list 分组反转这个题目和上面的有点类似，只不过我们并不是从头到尾反转，而是每 k 个为一组进行反转。LeetCode 同样有原题25. K 个一组翻转链表官方难度为 Hard。 题目描述123456789101112131415161718给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。示例 :给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5说明 :你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 思路我们的思路还是一样的，我们把每 k 位的位置当成是尾节点即可。 我们的任务就是每次反转头尾之间的所有节点，然后将链表重新拼起来即可。 我们先来写一下反转头尾之间的所有节点这个方法。 1234567891011121314151617181920// 翻转head到tail之间的部分，不包括head和tail// 返回原链表的第一个元素，也就是翻转后的最后一个元素function reverseList(head, tail) &#123; if (head === null || head.next === null) return head; let cur = head.next; first = cur; let pre = head; // 这里就是翻转不包括head的原因，否则就是head.pre了（当然我们没有pre指针） // 这里就是翻转不包括tail的原因，否则就是tail.next了。 while (cur !== tail) &#123; const next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; // 拼接 head.next = pre; first.next = cur; return first;&#125; 这里的反转不包括 head 和 tail，并不是我一开始的思路，但是在慢慢想的过程，发现这样写代码会更优雅。 上面的代码如果是 head 是我们的头节点，tail 是 null，那么就等效于上面的那道题。也就是说我们的这个 k 分组是上面题目的一般形式，当 k 为链表长度的时候，就会变成上面那道题了。 还有一点不同的是，我们每次反转之后都要对链表进行拼接，这是上面那个反转所没有的，这里要注意一下。 12head.next = pre;first.next = cur; 这里是对每一组（k个nodes）进行翻转， 先分组，用一个count变量记录当前节点的个数 用一个start 变量记录当前分组的起始节点位置的前一个节点 用一个end变量记录要翻转的最后一个节点位置 翻转一组（k个nodes）即(start, end) - start and end exclusively。 翻转后，start指向翻转后链表, 区间（start，end）中的最后一个节点, 返回start 节点。 如果不需要翻转，end 就往后移动一个（end=end.next)，每一次移动，都要count+1. 如图所示 步骤 4 和 5： 翻转区间链表区间（start， end） 举例如图，head=[1,2,3,4,5,6,7,8], k = 3 NOTE: 一般情况下对链表的操作，都有可能会引入一个新的dummy node，因为head有可能会改变。这里head 从1-&gt;3,dummy (List(0))保持不变。 这种做法的时间复杂度为 O(n)，空间复杂度为 O(1)。 代码Java 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ReverseKGroupsLinkedList &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; if (head == null || k == 1) &#123; return head; &#125; ListNode dummy = new ListNode(0); dummy.next = head; ListNode start = dummy; ListNode end = head; int count = 0; while (end != null) &#123; count++; // group if (count % k == 0) &#123; // reverse linked list (start, end] start = reverse(start, end.next); end = start.next; &#125; else &#123; end = end.next; &#125; &#125; return dummy.next; &#125; /** * reverse linked list from range (start, end), return last node. * for example: * 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8 * | | * start end * * After call start = reverse(start, end) * * 0-&gt;3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8 * | | * start end * first * */ private ListNode reverse(ListNode start, ListNode end) &#123; ListNode curr = start.next; ListNode prev = start; ListNode first = curr; while (curr != end)&#123; ListNode temp = curr.next; curr.next = prev; prev = curr; curr = temp; &#125; start.next = prev; first.next = curr; return first; &#125;&#125; Python3 代码： 1234567891011121314151617181920212223242526272829class Solution: def reverseKGroup(self, head: ListNode, k: int) -&gt; ListNode: if head is None or k &lt; 2: return head dummy = ListNode(0) dummy.next = head start = dummy end = head count = 0 while end: count += 1 if count % k == 0: start = self.reverse(start, end.next) end = start.next else: end = end.next return dummy.next def reverse(self, start, end): prev, curr = start, start.next first = curr while curr != end: temp = curr.next curr.next = prev prev = curr curr = temp start.next = prev first.next = curr return first JavaScript 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */// 翻转head到tail之间的部分，不包括head和tail// 返回原链表的第一个元素，也就是翻转后的最后一个元素function reverseList(head, tail) &#123; if (head === null || head.next === null) return head; let cur = head.next; first = cur; let pre = head; // 这里就是翻转不包括head的原因 while (cur !== tail) &#123; // 这里就是翻转不包括tail的原因 const next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; // 拼接 head.next = pre; first.next = cur; return first;&#125;/** * @param &#123;ListNode&#125; head * @param &#123;number&#125; k * @return &#123;ListNode&#125; */var reverseKGroup = function(head, k) &#123; if (head === null || k === 1) &#123; return head; &#125; let cnt = 0; const dummy = &#123; next: head, &#125;; let start = dummy; let end = head; while (end !== null) &#123; cnt++; if (cnt % k !== 0) &#123; end = end.next; &#125; else &#123; start = reverseList(start, end.next); end = start.next; &#125; &#125; return dummy.next;&#125;; 这里不再赘述，如果不理解，想看更多更详细内容，请参考我的LeetCode 题解 - 25.reverse-nodes-in-k-groups-cn 分组反转 - 增强版这道题目来自字节跳动面试题。 题目描述要求从后往前以k个为一组进行翻转。 例子，1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8, k = 3, 从后往前以k=3为一组， 6-&gt;7-&gt;8 为一组翻转为8-&gt;7-&gt;6，3-&gt;4-&gt;5为一组翻转为5-&gt;4-&gt;3.1-&gt;2只有2个nodes少于k=3个，不翻转。最后返回： 1-&gt;2-&gt;5-&gt;4-&gt;3-&gt;8-&gt;7-&gt;6 思路这里的思路跟从前往后以k个为一组进行翻转类似，可以进行预处理： 翻转链表 对翻转后的链表进行从前往后以k为一组翻转。 翻转步骤2中得到的链表。 例子：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8, k = 3 翻转链表得到：8-&gt;7-&gt;6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1 以k为一组翻转： 6-&gt;7-&gt;8-&gt;3-&gt;4-&gt;5-&gt;2-&gt;1 翻转步骤#2链表： 1-&gt;2-&gt;5-&gt;4-&gt;3-&gt;8-&gt;7-&gt;6 类似题目 Swap Nodes in Pairs","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"},{"name":"链表反转","slug":"算法/链表反转","permalink":"https://lucifer.ren/blog/categories/算法/链表反转/"},{"name":"链表","slug":"数据结构/链表","permalink":"https://lucifer.ren/blog/categories/数据结构/链表/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"},{"name":"字节跳动","slug":"字节跳动","permalink":"https://lucifer.ren/blog/tags/字节跳动/"},{"name":"链表","slug":"链表","permalink":"https://lucifer.ren/blog/tags/链表/"}],"author":{"name":"snowan","avatar":"https://avatars1.githubusercontent.com/u/6018815?s=40&v=4","url":"https://github.com/snowan"}},{"title":"【RFC】XXX 公司监控体系需求与技术调研","slug":"rfc-monitor","date":"2019-12-11T04:35:19.046Z","updated":"2020-03-23T01:59:45.654Z","comments":true,"path":"2019/12/11/rfc-monitor/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/rfc-monitor/","excerpt":"线上问题回溯困难，无法快速准确重现问题，导致客户满意度下降，影响团队交付效率和质量，建立完善的监控体系可以很好的解决这个问题。","text":"线上问题回溯困难，无法快速准确重现问题，导致客户满意度下降，影响团队交付效率和质量，建立完善的监控体系可以很好的解决这个问题。 背景线上问题回溯困难，无法快速准确重现问题，导致客户满意度下降，影响团队交付效率和质量。 需求期望有一套工具，系统或者平台，可以满足： 在收到用户反馈的时候能够快速重现问题并解决。 测试同学发现问题，不需要花费大量事件和开发人员重现，沟通，以及记录问题重现路径等 线上发现问题可以进行告警，防止大规模用户有问题，并且不能及时感知和解决。 缩短团队内部 BUG 修复的闭环流程，减少非本质复杂度问题的干扰，快速将问题聚焦到具体的代码。 带着上面的需求，我们来看下市面上已有的经典方案， 在这里挑选几个具有代表性的。 市面上已有的方案对比LogRocket一句话概括： 用看录像的方式重现问题。 官网地址： https://logrocket.com/ 特点 更多功能： https://docs.logrocket.com/docs 接入方式 价格 Sentry一句话概括： 开源，强大的监控平台。 官网地址： https://sentry.io/ 特点功能较多，提供了较多的概念和功能，比如 Context，ENvironments，Breadcrumbs 等。另外其和 CI，CD 集成地也非常好。 详细内容： https://docs.sentry.io/workflow/releases/?platform=node 另外其支持的平台和扩展功能非常多，如果对这部分有特殊要求，Sentry 无疑是优先考虑的选择。 接入方式 Sign up for an account Install your SDK 12# Using yarn$ yarn add @sentry/node@5.8.0 Configure it 12const Sentry = require(\"@sentry/node\");Sentry.init(&#123; dsn: \"https://&lt;key&gt;@sentry.io/&lt;project&gt;\" &#125;); 价格 FunDebug一句话概括：国内知名度较高的监控工具，国内业务这块很有竞争力。 https://www.fundebug.com/ 特点支持小程序，小游戏。多种现成的报警方式，支持 WebHook，智能报警（同样的代码产生的同一个错误，在不同浏览器上的报错信息是各不相同的），内置团队协作工具。 接入方式这里以 Vue 项目为例。 免费注册 创建项目 配置 1npm install fundebug-javascript fundebug-vue --save 123456import * as fundebug from \"fundebug-javascript\";import fundebugVue from \"fundebug-vue\";fundebug.init(&#123; apikey: \"API-KEY\"&#125;);fundebugVue(fundebug, Vue); 价格 其他后期可能功能点 性能监控 用户行为监控（已经有埋点，不不确定是否可以 Cover 这个需求） 自研假设我们已经做好了我们自己的监控平台，我们需要对公司内部甚至外部宣传我们的监控平台，我们会怎么进行宣传。 然后带着这些东西，我们进行规划，技术选型，排期，写代码，测试，上线。 宣传语 接入方便，侵入性小 支持多端，扩展性强（支持多种框架定制接入），完美契合业务发展 打通客服系统，开发直接对接到客户，免去了中间对接的信息缺失和时间损耗。 重现率高，能够准确重现用户的现场情况 打通报警系统 打通调试平台… 优劣分析优势完美契合我们自身的业务，后期好维护和增添功能 劣势如果功能需要做的超出市面，需要耗费巨大的人力和财力。 如果市面上不断发展，功能不能断完善，内部如果想要这样的功能要么继续追赶，要不买一套商用的，但是之前的努力岂不是白费了。除非内部两套系统，但是这种模式未免太反直觉。 架构与选型对外都宣传完了，我们需要具体开始进行架构与选型了。 定义对外接口我们对外宣传的目标是接入方便，侵入性小。因此一定要简洁，这里参考了以上几个平台的写法，其实这几个平台的都是大同小异。 注册应用获取 AppId 安装 1npm i --save @lucifer/monitor 引用 12345678910import monitor from \"@lucifer/monitor\";monitor.init(&#123; user: &#123; name: \"\", email: \"\", mobile: \"\", isVIP: true &#125;, appId: \"lucifer520\"&#125;); 多端和多框架支持 Vue： 123456789101112import Vue form 'vue';import monitor from '@lucifer/connectors/vue';monitor.init(&#123; user: &#123; name: '', email: '', mobile: '', isVIP: true &#125;, appId: 'lucifer520'&#125;)monitor.use(Vue) Wechat： 12345678910import monitor from \"@lucifer/connectors/wechat\";monitor.init(&#123; user: &#123; name: \"\", email: \"\", mobile: \"\", isVIP: true &#125;, appId: \"lucifer520\"&#125;); 定义内部接口架构图： 接口系统交互图会在详细设计中给出，这里只给出大致范围： logs 服务器和告警平台的交互接口 rules 的规则解析 logs 的解析 构建系统对接 调试系统对接 … 业务形态特点 数据量会随着采集规模增大而增加，因此预估用户数量以及增长速度对系统架构设计有很大影响 终端的上报策略对影响很大，断网，弱网等情况如何上报也对结果有影响 框架选型 &amp; 规范 &amp; 约定暂无 其他解决方案 Badjs FrontJS","categories":[],"tags":[{"name":"RFC","slug":"RFC","permalink":"https://lucifer.ren/blog/tags/RFC/"},{"name":"技术调研","slug":"技术调研","permalink":"https://lucifer.ren/blog/tags/技术调研/"},{"name":"监控","slug":"监控","permalink":"https://lucifer.ren/blog/tags/监控/"}]},{"title":"文科生都能看懂的循环移位算法","slug":"rotate-list","date":"2019-12-11T04:35:19.046Z","updated":"2020-04-13T06:50:26.835Z","comments":true,"path":"2019/12/11/rotate-list/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/rotate-list/","excerpt":"循环移位问题真的是一个特别经典的问题了，今天我们就来攻克它。 循环移位的表现形式有很多种，就数据结构来说包括数组，字符串，链表等。就算法来说，有包含问题，直接移动问题，还有查找问题等。 虽然表现形式有很多，但是本质都是一样的，因为从逻辑上来讲其实他们都是线性数据结构，那么让我们来看一下吧。","text":"循环移位问题真的是一个特别经典的问题了，今天我们就来攻克它。 循环移位的表现形式有很多种，就数据结构来说包括数组，字符串，链表等。就算法来说，有包含问题，直接移动问题，还有查找问题等。 虽然表现形式有很多，但是本质都是一样的，因为从逻辑上来讲其实他们都是线性数据结构，那么让我们来看一下吧。 数组循环移位LeetCode 和 编程之美等都有这道题目，题目难度为 Easy。LeeCode 链接 题目描述123456789101112131415161718192021给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。示例 1:输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]示例 2:输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]说明:尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的 原地 算法。 不符合题意的解法如果你拿到这道题没有思路，不要紧张，因为你不是一个人。 让我们先不要管题目的时间和空间复杂度的限制， 来用最最普通的方式实现它，看能不能得出一点思路。 最简单的做法就是新开辟一个完全一样的数组，然后每次移动的时候从 copy 的数组中取即可，由于新开辟的数组不会被改变，因此这种做法可行，我们直接看下代码： 1234567891011function RShift(list, k) &#123; // 空间复杂度O(n) // 时间复杂度O(n) const copy = [...list]; const n = list.length; for (let i = 0; i &lt; n; i++) &#123; list[(k + i) % n] = copy[i]; &#125; return list;&#125; 实际上我们还可以优化一下，如果 k 是 N 的倍数，实际上是不需要做任何移动的，因此直接返回即可。 12345function RShift(list, k) &#123; const n = list.length; if (k % n === 0) return; // 剩下代码&#125; 由于我们需要覆盖原来的数组，那么原来的数组中的数据就会缺失，因此我们最简单的就是开辟一个完全一样的数组，这样就避免了问题，但是这样的空间复杂度是 N。我们有没有办法优化这个过程呢？ 而且如果 k 是负数呢？ 这其实在考察我们思考问题的严谨性。 除此之外，我们还应该思考： k 的范围是多少？如果很大，我的算法还有效么？ n 的范围是多少？如果很大，我的算法还有效么? 上面两个问题的答案都是有效。 因为 k 就算再大，我们只需要求模，求模的值当成新的 k 即可。因此 k 最大不过就是 n。 如果 n 很大，由于我们的算法是 O(N)的复杂度，也就是线性，这个复杂度还是比较理想的。 时间换空间我们来试一下常数空间复杂度的解法，这种做法思路很简单，我们只需要每次移动一位，移动 k 次即可，移动一次的时间复杂度是 1，k 次共用一个变量即可，因此总的空间复杂度可以降低到 1。 我们来看下代码，这次我们把上面提到的 k 为负数的情况考虑进去。 123456789101112131415161718function RShift(list, k) &#123; const n = list.length; if (k % n === 0) return; let cnt = Math.abs(k &gt; 0 ? k % n : n + (k % n)); let t = null; while (cnt--) &#123; t = list[n - 1]; // 右移一位 for (let i = n - 1; i &gt; 0; i--) &#123; list[i] = list[i - 1]; &#125; list[0] = t; &#125; return list;&#125; 虽然上面的解法是常数空间复杂度，但是时间复杂度是 O(N * K)，K 取值不限制的话，就是 O(N^2)，还是不满足题意。不过没关系，我们继续思考。 我们再来看一种空间换时间的做法，这种做法的思路是拼接一个完全一样的数组到当前数组的尾部，然后问题就转化为截取数组使之满足右移的效果，这样的时间复杂度 O(N),空间复杂度是 O(N). 我们看下代码： 12345function RShift(list, k) &#123; const n = list.length; let i = Math.abs(k &gt; 0 ? k % n : n + (k % n)); return list.concat([...list]).slice(n - i, n * 2 - i);&#125; 哈哈，虽然离题目越来越远了，但是扩展了思路，也不错，这就是刷题的乐趣。 三次翻转法我们来看下另外一种方法 - 经典的三次翻转法，我们可以这么做： 先把[0, n - k - 1]翻转 然后把[n - k, n - 1]翻转 最后把[0, n - 1]翻转 12345678910111213141516171819function reverse(list, start, end) &#123; let t = null; while (start &lt; end) &#123; t = list[start]; list[start] = list[end]; list[end] = t; start++; end--; &#125;&#125;function RShift(list, k) &#123; const n = list.length; if (k % n === 0) return; reverse(list, 0, n - k - 1); reverse(list, n - k, n - 1); reverse(list, 0, n - 1); return list;&#125; 这里给一个简单的数学证明： 对于[0, n - k - 1] 部分，我们翻转一次后新的坐标 y 和之前的坐标 x 的关系可以表示为y = n - 1 - k - x 对于[n - k, n -1] 部分，我们翻转一次后新的坐标 y 和之前的坐标 x 的关系可以表示为y = 2 * n - 1 - k - x 最后我们整体进行翻转的时候，新的坐标 y 和之前的坐标 x 的关系可以表示为 y = n - 1 - (n - 1 - k - x) 即 y = k + x (0 &lt;= x &lt;= n - k - 1) y = n - 1 - (2 * n - 1 - k - x) 即 y = k + x - n (n - k &lt;= x &lt;= n - 1) 正好满足我们的位移条件。 这种做法时间复杂度是 O(N)空间复杂度 O(1)，终于满足了我们的要求。 字符串循环移位字符串和数组真的是一模一样，因为字符串也可以看成是字符序列，因此字符串就是数组。本质上来说，它和数组循环移位题目没有任何区别， 现在让我们来通过一道题来感受下。 题目描述给定两个字符串 s1 和 s2，要求判定 s2 是否能被 s1 循环移位得到的字符串包含。比如，给定 s1 = AABCD 和 s2 = CDAA，返回 true 。 给定 s1 = ABCD，s2 = ACBD， 则返回 false。 题目来自《编程之美》 暴力法s1 我们每次移动一位，然后判断逐一判断以每一个位置开头的字符串是否包含 s2，如果包含则返回 true，否则继续匹配。 这种做法很暴力，时间复杂度 O(n^2)，在 n 特别大的时候不是很有效。 代码如下： 1234567891011121314151617181920212223242526function RIncludes(s1, s2) &#123; const n = s1.length; const m = s2.length; let t = null; let p1; // s1的指针 let p2; // s2的指针 for (let i = 0; i &lt; n; i++) &#123; t = s1[0]; for (let j = 0; j &lt; n - 1; j++) &#123; s1[j] = s1[j + 1]; &#125; s1[n - 1] = t; p1 = 0; p2 = 0; while (p1 &lt; n &amp;&amp; p2 &lt; m) &#123; if (s1[p1] === s2[p2]) &#123; p1++; p2++; &#125; else break; &#125; if (p2 === m) return true; &#125; return false;&#125; 巧用模运算另外一种方法就是上面那种空间换时间的方式，我们将两个 s1 连接到一起，然后直接双指针即可，这里不再赘述。 这种方法虽然巧妙，但是我们花费了额外的 N 的空间，能否不借助额外的空间呢？答案是可以的，我们可以假想已经存在了另外一个相同的 s1，并且我们将它连接到 s1 的末尾。注意这里是假想，实际不存在，因此空间复杂度是 O(1)。那么如何实现呢？ 答案还是利用求模。 1234567891011121314151617181920212223function RIncludes(s1, s2) &#123; const n = s1.length; const m = s2.length; let t = null; let p1; // s1的指针 let p2; // s2的指针 for (let i = 0; i &lt; n; i++) &#123; p1 = i; // 这一行代码变了 p2 = 0; while (p1 &lt; 2 * n &amp;&amp; p2 &lt; m) &#123; // 不需要循环移动一位了，也就是说省了一个N的循环 if (s1[p1 % n] === s2[p2]) &#123; // 这一行代码变了 p1++; p2++; &#125; else break; &#125; if (p2 === m) return true; &#125; return false;&#125; 至此，这道题就告一段落了，大家如果有别的方法，也欢迎在评论区留言。 链表循环移位链表不同于前面的数组和字符串，我们来个题目感受一下。 这里出一个 LeetCode 题目，官方难度为中等难度的一个题 - 61. 旋转链表 题目描述123456789101112131415161718给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。示例 1:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL示例 2:输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 思路其实这个思路简单，就是先找到断点，然后重新拼接链表即可。这个断点其实就是第n - k % n个节点， 其中 k 为右移的位数，n 为链表长度。这里取模的原因和上面一样，为了防止 k 过大做的无谓运算。但是这道题目限定了 k 是非负数，那么我们就不需要做这个判断了。 如图所示： 代码也很简单，我们来看下。 代码1234567891011121314151617181920212223var rotateRight = function(head, k) &#123; if (head === null || head.next === null) return head; let p1 = head; let n = 1; let res = null; while (p1 &amp;&amp; p1.next) &#123; p1 = p1.next; n++; &#125; let cur = 1; let p2 = head; while (cur &lt; n - (k % n)) &#123; p2 = p2.next; cur++; &#125; p1.next = head; res = p2.next; p2.next = null; return res;&#125;; 扩展 循环移位的有序数组，查找某一个值，要求时间复杂度为 O(logn) 这道题我在《每日一题》出过","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"字符串","slug":"数据结构/字符串","permalink":"https://lucifer.ren/blog/categories/数据结构/字符串/"},{"name":"数组","slug":"数据结构/数组","permalink":"https://lucifer.ren/blog/categories/数据结构/数组/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"},{"name":"循环移位","slug":"算法/循环移位","permalink":"https://lucifer.ren/blog/categories/算法/循环移位/"},{"name":"链表","slug":"数据结构/链表","permalink":"https://lucifer.ren/blog/categories/数据结构/链表/"},{"name":"编程之美","slug":"编程之美","permalink":"https://lucifer.ren/blog/categories/编程之美/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"数组","slug":"数组","permalink":"https://lucifer.ren/blog/tags/数组/"},{"name":"链表","slug":"链表","permalink":"https://lucifer.ren/blog/tags/链表/"},{"name":"循环移位","slug":"循环移位","permalink":"https://lucifer.ren/blog/tags/循环移位/"},{"name":"字符串","slug":"字符串","permalink":"https://lucifer.ren/blog/tags/字符串/"},{"name":"编程之美","slug":"编程之美","permalink":"https://lucifer.ren/blog/tags/编程之美/"}]},{"title":"值得关注的技术类大会","slug":"tech-conf","date":"2019-12-11T04:35:19.046Z","updated":"2019-12-11T04:35:19.046Z","comments":true,"path":"2019/12/11/tech-conf/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/tech-conf/","excerpt":"作为一个技术人，怎么能不参加和关注几场技术大会呢？让我们来看下那些你不能错过的技术大会吧。","text":"作为一个技术人，怎么能不参加和关注几场技术大会呢？让我们来看下那些你不能错过的技术大会吧。 JSConf地址 React Conf地址 Google IO地址 D2地址 QCon地址 更多技术大会 https://juejin.im/events https://segmentfault.com/events https://www.huodongxing.com https://www.bagevent.com https://www.hdb.com https://www.meetup.com … 欢迎大家补充～","categories":[{"name":"技术大会","slug":"技术大会","permalink":"https://lucifer.ren/blog/categories/技术大会/"},{"name":"JSConf","slug":"技术大会/JSConf","permalink":"https://lucifer.ren/blog/categories/技术大会/JSConf/"},{"name":"React Conf","slug":"技术大会/React-Conf","permalink":"https://lucifer.ren/blog/categories/技术大会/React-Conf/"},{"name":"Google IO","slug":"技术大会/Google-IO","permalink":"https://lucifer.ren/blog/categories/技术大会/Google-IO/"},{"name":"D2","slug":"技术大会/D2","permalink":"https://lucifer.ren/blog/categories/技术大会/D2/"},{"name":"QCon","slug":"技术大会/QCon","permalink":"https://lucifer.ren/blog/categories/技术大会/QCon/"}],"tags":[{"name":"技术大会","slug":"技术大会","permalink":"https://lucifer.ren/blog/tags/技术大会/"},{"name":"JSConf","slug":"JSConf","permalink":"https://lucifer.ren/blog/tags/JSConf/"},{"name":"Google IO","slug":"Google-IO","permalink":"https://lucifer.ren/blog/tags/Google-IO/"},{"name":"D2","slug":"D2","permalink":"https://lucifer.ren/blog/tags/D2/"},{"name":"QCon","slug":"QCon","permalink":"https://lucifer.ren/blog/tags/QCon/"}]},{"title":"纪念LeetCode项目Star突破2W","slug":"thanksGaving-2","date":"2019-12-11T04:35:19.046Z","updated":"2019-12-11T04:35:19.046Z","comments":true,"path":"2019/12/11/thanksGaving-2/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/thanksGaving-2/","excerpt":"假期这几天我买了《逆转裁判 123》合集，面对着这香喷喷的冷饭吃了半天。从 GBA 玩到 NDS，从 NDS 玩到 3DS, 现在 NS 虽然没有出新作有点遗憾。不过有了高清重制，也当是个回忆和收藏了 🎉🎉","text":"假期这几天我买了《逆转裁判 123》合集，面对着这香喷喷的冷饭吃了半天。从 GBA 玩到 NDS，从 NDS 玩到 3DS, 现在 NS 虽然没有出新作有点遗憾。不过有了高清重制，也当是个回忆和收藏了 🎉🎉 目前打通了第一第二关，剩下的过一段时间再玩好啦 😁 回到正题，就在今天，我的《leetcode 题解》项目成功突破 2w star， 并且现在 Github 搜索关键字”LeetCode”我的项目已经排名第一啦，这是继 1W star 之后的第二个巨大突破，非常感谢大家一路以来的支持和陪伴。 最近在写一本关于LeetCode题解的书，有很多人表示想买，这无形之中给了我很大的压力，名字还没定，暂时给它取一个代号《攻克 LeetCode》。 新书《攻克 LeetCode》 这里是《攻克 LeetCode》的草稿目录，目前有 20 章的内容，本书要讲的内容就是 LeetCode 上反复出现的算法，经过我进一步提炼，抽取数百道题目在这里进行讲解，帮助大家理清整体思绪，从而高效率地刷题，做到事半功倍。我这里总结了 7 个常见的数据结构和 7 个常见的算法以及 5 个常见的算法思想。 7 个数据结构分别是： 数组，栈，队列，链表，二叉树，散列表，图 7 个算法分别是：二分法，递归，回溯法，排序，双指针，滑动窗口，并查集 5 个算法思想分别是：分治，贪心，深度优先遍历，广度优先遍历，动态规划 只有掌握了这些基础的数据结构和算法，更为复杂的算法才能得心应手，事半功倍。而 LeetCode 的题目虽然不断出新，但是最终用到的算法永远是那几个，很多题目都是穿着新的衣服的老面孔了。大家学好这些基础套路之后会更加明白这个道理。 后期可能会有大幅度修改，希望大家提出宝贵意见，以特别的方式参与到这本书的编写中来。 2W star截图 Star 曲线 (star 增长曲线图) 知乎引流上次主要讲了项目从开始建立到拥有 1W star 的经历，本次书接前文，继续讲一下后面的故事。 上回提到知乎上的“量子位”在帮我做宣传，引入了不小的流量。 我就想为什么不自己去拉流量呢？我自己以作者的角度去回答一些问题岂不是更好，更受欢迎么？于是我就开始在知乎上回答问题，很开心其中一个还获得了专业认可。 事实上并没有我想的那么好，我回答了两个 LeetCode 话题的内容，虽然也有几百的点赞和感谢，但是这离我的目标还差很远。 但是转念一想，我知乎刚起步，也没什么粉丝，并且写答案的时间也就一个月左右，这样想就好多了。 我相信将来会有更多的人看到我的答案，然后加入进来。 建立自己的博客现在我发表的文章都是在各大平台。这有一个很大的问题就是各个平台很难满足你的需求，比如按照标签，按照日期进行归档。 甚至很多平台的阅读体验很差，比如没有导航功能，广告太多等。因此我觉得自己搭建一个博客还是很有必要的，这个渠道也为我吸引了少部分的流量，目前添加的主要内容大概有： 总体上来说效果还是不错的，之后的文章会在博客首发，各个平台也会陆续更新，感兴趣的可以来个 RSS 订阅，订阅方式已经在《每日一荐 - 九月刊》里面介绍了。 GithubDaily 的 推荐GithubDaily 转载了量子位的文章也为我的仓库涨了至少几百的 star，非常感谢。GithubDaily 是一个拥有 3W 多读者的公众号，大家有兴趣的可以关注一波。 其他自媒体的推荐一些其他自媒体也会帮忙推广我的项目 口耳相传我后来才知道竟然有海外华侨和一些华人社区都能看到我了。 （一亩三分地是一个集中讨论美国加拿大留学的论坛） 另外通过朋友之间口耳相传的介绍也变得越来越多。 非常感谢大家一直以来的陪伴和支持，我们一起努力，加油 💪。 如果你还没有加入我们，看了这篇文章想加入，那么可以访问我的项目主页 leetcode 题解我在这里等着你。","categories":[{"name":"日记","slug":"日记","permalink":"https://lucifer.ren/blog/categories/日记/"},{"name":"技术","slug":"日记/技术","permalink":"https://lucifer.ren/blog/categories/日记/技术/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://lucifer.ren/blog/tags/日记/"}]},{"title":"我是如何刷 LeetCode 的？","slug":"how-am-I-conque-leetcode","date":"2019-12-11T04:35:19.045Z","updated":"2020-04-13T06:50:26.821Z","comments":true,"path":"2019/12/11/how-am-I-conque-leetcode/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/how-am-I-conque-leetcode/","excerpt":"我就是那个 @量子位 答案里面提到的“lucifer 小哥哥”。 我本人从开始准备算法以来，大概经过了几个月的时间，这期间自己成长了很多，从刷题菜鸡，到现在对刷题套路，题型有了自己的理解，感受还是蛮多的。我本人不是算法高手，算是勤能补拙类型。不过经过几个月的学习和练习，不仅面试变得更加得心应手，而且在工作中写更容易写出干净优雅，性能好的代码。","text":"我就是那个 @量子位 答案里面提到的“lucifer 小哥哥”。 我本人从开始准备算法以来，大概经过了几个月的时间，这期间自己成长了很多，从刷题菜鸡，到现在对刷题套路，题型有了自己的理解，感受还是蛮多的。我本人不是算法高手，算是勤能补拙类型。不过经过几个月的学习和练习，不仅面试变得更加得心应手，而且在工作中写更容易写出干净优雅，性能好的代码。 我将自己这几个月的刷题经历都整理了下来，除了给出思路和关键点，还横向地对知识点进行整理，尽量做到一题多解，多题同解。 现在GitHub仓库有18k+的✨ ， 欢迎大家关注。仓库地址： azl397985856/leetcode 那么今天我就来回答一下这个问题，谈一下我是怎么刷leetcode的。 对于我来说，刷题的过程其实就是学习数据结构和算法的过程， 不仅仅是为了刷题而刷题，这样你才能感受到刷题的乐趣。 第一遍按tag刷，第二遍一题多解，多题同解个人建议，第一遍刷的时候可以先快速按照tag过一遍，快速感受一下常见数据结构和算法的套路，这样自己有一个感性的认识。 第二遍我们就不能像第一遍那样了，这个阶段我们需要多个角度思考问题，尽量做到一题多解，多题同解。我们需要对问题的本质做一些深度的理解，将来碰到类似的问题我们才能够触类旁通。 但是很多人做了几遍，碰到新题还是没有任何头绪，这是一个常见的问题，这怎么办呢？ 我们继续往下看。 艾宾浩斯记忆曲线总结并记忆是学习以及刷题过程中非常重要的一环，不管哪个阶段，我们都需要做对应的总结，这样将来我们再回过头看的时候，才能够快读拾起来。 信息输入大脑后，遗忘也就随之开始了。遗忘率随时间的流逝而先快后慢，特别是在刚刚识记的短时间里，遗忘最快，这就是著名的艾宾浩斯遗忘曲线。 anki就是根据艾宾浩斯记忆曲线开发的一个软件，它是一个使记忆变得容易的学习软件。因为它是一个自定义多功能的记忆方式，可以大大减少你的学习时间，也可以大大提高 你的学习容量。 对于我本人而言，我在anki里面写了很多leetcode题目和套路的Card，然后anki会自动帮我安排复习时间，大大减少我的认知负担，提高了我的复习效率。 这个是我的anki card 大家可以直接导入使用，但是还是建议大家自己制作卡片，毕竟每个人情况不一样，并且制作卡片的过程也是记忆的过程。 使用方法： anki - 文件 - 导入 - 下拉格式选择“打包的 anki集合”，然后选中你下载好的文件，确定即可。 更多关于anki使用方法的请查看anki官网 目前已更新卡片一览（仅列举正面） 二分法解决问题的关键点是什么，相关问题有哪些? 如何用栈的特点来简化操作， 涉及到的题目有哪些？ 双指针问题的思路以及相关题目有哪些？ 滑动窗口问题的思路以及相关题目有哪些？ 回溯法解题的思路以及相关题目有哪些？ 数论解决问题的关键点是什么，相关问题有哪些? 位运算解决问题的关键点是什么，相关问题有哪些? 殊途同归大家刷了很多题之后，就会发现来来回回，题目就那么几种类型，因此掌握已有题目类型是多么重要。那样leetcode出题的老师，很多也是在原有的题目基础上做了适当扩展（比如two-sum,two-sum2,three-sum, four-sum等等）或者改造（使得不那么一下子看出问题的本质，比如猴子吃香蕉问题）。 其中算法，主要是以下几种： 基础技巧：分治、二分、贪心 排序算法：快速排序、归并排序、计数排序 搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等 图论：最短路径、最小生成树 动态规划：背包问题、最长子序列 数据结构，主要有如下几种： 数组与链表：单 / 双向链表 栈与队列 哈希表 堆：最大堆 ／ 最小堆 树与图：最近公共祖先、并查集 字符串：前缀树（字典树） ／ 后缀树 (图片来自leetcode) 坚持做到了以上几点，我们还需要坚持。这个其实是最难的，不管做什么事情，坚持都是最重要也是最难的。 为了督促自己，同时帮助大家成长，我在群里举办《每日一题》活动，每日一题是在交流群（包括微信和qq）里进行的一种活动，大家一起 解一道题，这样讨论问题更加集中，会得到更多的反馈。而且 这些题目可以被记录下来，日后会进行筛选添加到仓库的题解模块。 大家如果发现自己很难坚持下去，也可以加入我的群聊，我们互相监督。 另外我还专门组建了slack群，有兴趣的可以加群后在群里喊即可。 关注我大家可以关注我的公众号《脑洞前端》，公众号后台回复“大前端”，拉你进《大前端面试宝典 - 图解前端群》。回复“leetcode”，拉你进《leetcode题解交流群》 最后祝大家刷题愉快，拿到自己心仪的offer。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"},{"name":"学习方法","slug":"学习方法","permalink":"https://lucifer.ren/blog/categories/学习方法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"},{"name":"学习方法","slug":"学习方法","permalink":"https://lucifer.ren/blog/tags/学习方法/"}]},{"title":"","slug":"ibinhouse","date":"2019-12-11T04:35:19.045Z","updated":"2019-12-11T04:35:19.045Z","comments":true,"path":"2019/12/11/ibinhouse/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/ibinhouse/","excerpt":"","text":"信息输入大脑后，遗忘也就随之开始了。遗忘率随时间的流逝而先快后慢，特别是在刚刚识记的短时间里，遗忘最快，这就是著名的艾宾浩斯遗忘曲线。","categories":[],"tags":[]},{"title":"零基础的前端开发初学者应如何系统地学习？","slug":"how-am-I-learn-fe","date":"2019-12-11T04:35:19.045Z","updated":"2020-04-13T06:50:26.825Z","comments":true,"path":"2019/12/11/how-am-I-learn-fe/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/how-am-I-learn-fe/","excerpt":"回想四年前我刚入行的时候，那时候很多人对于前端的看法是“切图，画页面，有个编辑器+浏览器就能干，门槛低”，现在已经完全不是那样了，可以说现在的前端这个职业的门槛虽然还是没怎么变，但是整个行业的门槛提升了，换句话说就是整个行业对于前端这个职位要求更高了，对于前端小白的需求量降低，对于高级前端的需求量还在上升，甚至是供小于求的局面。从市场经济学角度上讲你只有进入到高级级别，才能真正吃到行业的红利。 因此想要入行的朋友要先想清楚，不要头脑发热，如果你想清楚了，那么请继续往下看。说实话，现在的前端大环境对初学者来说实在有点不友好，学习资料鱼龙混杂，良莠不齐，有质量很高的学习资料，也有谬论，前后不一，观点错误，或者讲述不清晰的。 更可怕的是质量低下的文章有时候更受欢迎，因此需要大家有很好的甄别能力，但这对于初学者来说实在有些困难，我在这里就来谈一下 初学者如何少走弯路，并且系统性地学习前端。","text":"回想四年前我刚入行的时候，那时候很多人对于前端的看法是“切图，画页面，有个编辑器+浏览器就能干，门槛低”，现在已经完全不是那样了，可以说现在的前端这个职业的门槛虽然还是没怎么变，但是整个行业的门槛提升了，换句话说就是整个行业对于前端这个职位要求更高了，对于前端小白的需求量降低，对于高级前端的需求量还在上升，甚至是供小于求的局面。从市场经济学角度上讲你只有进入到高级级别，才能真正吃到行业的红利。 因此想要入行的朋友要先想清楚，不要头脑发热，如果你想清楚了，那么请继续往下看。说实话，现在的前端大环境对初学者来说实在有点不友好，学习资料鱼龙混杂，良莠不齐，有质量很高的学习资料，也有谬论，前后不一，观点错误，或者讲述不清晰的。 更可怕的是质量低下的文章有时候更受欢迎，因此需要大家有很好的甄别能力，但这对于初学者来说实在有些困难，我在这里就来谈一下 初学者如何少走弯路，并且系统性地学习前端。 兴趣是最好的老师兴趣不管对于学习什么来说都是最好的老师。当然前端也不例外，如果你对这一门感兴趣，绝对会对你有很大的帮助。 关于如何培养兴趣，我提一点，你可以尝试去做一些小的“发明创造”，从而激发自己内心的“成就感”。这些小发明可以是一些小工具，小页面。你可以从开源社区，比如Github或者一些论坛，甚至自己的生活中收集一些创作素材。对于我来说，我就做过一个“前端开发工作流”的软件，“siri”， “小门神”等，从而带来成就感，提升自己的兴趣。 权威，权威，还是权威其实技术越往上走，越会关注标准，关注协议等更上层和抽象的东西。而制定这些协议和标准的人往往都是世界上的“殿堂级”程序员，因此关注这些东西对于他们来说就是权威，对他们来说就非常很重要，但是这对于初学者来说似乎还比较遥远。那么初学者如何对接“权威”呢？刚才提到了网上的学习资料参差不齐，这其实对于入门学习来说是很不利的，就像童年时期对于整个人生的影响一样，入门阶段对于整个前端开发生涯的影响也是巨大的。关于如何初学者如何对接权威，我这里总结了以下三点：看一些权威的书籍，包括前端基础，软件工程以及算法等。这里不太建议看太老的，毕竟技术的发展是很快的，以前非常经典的书并一定适合看了，尤其是初学者而言。这里前端方面我重点推荐两本书，一本是《你不知道的JS》，一本是《JavaScript语言精粹》。除了前端，你还可以看一些软工类的书，我个人比较喜欢的有《程序员修炼之道》等，算法类的有《图解算法》，《编程之美》等。其他的我就不一一赘述了，想要更多书单的可以私信我。 查权威资料。 这里我推荐两个，一个是MDN的文章，真的是又全面又专业，绝对是前端开发必备神器，哪里不会点哪里。 另外推荐一个Google开发者 ， 里面干货很多，绝对权威。这里顺便再安利一个软件，用来查文档什么的，简直如虎添翼，这个软件的名字是Dash，大家可以把自己常用的框架，类库等导进去，想用的时候直接查询即可，比去网上搜更快更高效，这个软件对于定制的支持度也是蛮高的，谁用谁知道。 （大家可以看到我下载了很多documentation） （你可以直达某一个documentation搜索，也可以全局搜索，甚至可以搜goole和stackoverflow，是不是很贴心？） 关注一些圈内权威人士。 我一般会关注几个圈内比较知名的人的知乎，微博和twitter。这是我关注的Github的权威人士列表。其实这些都是公开的，你也可以点开我的知乎，微博资料看我或者大佬们关注了谁。 做一些完整的简单项目大家可以尝试做一些简单的项目，不要嫌简单。 在做的过程往往能发现很多问题，如果有问题那这正好是自己提高的机会。 如果你觉得很简单，也没有关系，你可以思考一下，我有没有可能做的更好？我能不能把这些东西封装起来，建立更高一层的抽象（A New Level of Abstraction），做到DRY(Don’t Repeat Yourself)。接下来就是关于怎么找项目。 你可以找个正式工作或者实习来做，也可以自己找一些小项目来练手， 比较常见的练手项目有模仿某个网站，APP或者搭建自己的个人主页，博客系统等。做好了不仅可以当敲门砖，说不定会收益很长时间呢。实在没有什么项目练手，这里再推荐一个网站，你可以再上面打怪升级。freecodecamp现在你已经掌握了前端开发的基本概念和技能，那么如何做到更进一步，持续成长，做到高级呢？我相信这是很多人的疑问，下面我们就来看一下。 学习路线你可能已经听过过大前端这个词，我这里不是劝退你哦。以下内容很高能，不过很多知识点不知道没关系，因为就算是工作了很多年了老手也很难了解其中的大半知识点。我个人为了让自己巩固知识，同时也为了帮助他人，总结了大前端下的30多个主题内容，内容覆盖大前端的方方面面，虽然是从面试角度出发，但是你用来提升自己，查缺补漏也是很有用的。 多图预警： 拿《编程题》主题来说，我总结了各大公司常考的几十道题目。 对于其他主题也是一样，我都会尽可能地深度讲解和剖析，并且从多方面理解，我相信这是在市面上很少见的。 而且我还画了很多图，来帮助大家理解一些抽象的知识点。 项目地址： https://lucifer.ren/fe-interview/#/ 欢迎围观。 开源项目 实话实说，很多优秀的思想，规范，写法我都是从优秀的开源项目中学来的。 我会不定期阅读一些优秀的开源项目源码，也会参与到开源的工作中去，这给我自己带来了很大的提升。 不仅技术得到了提升，团队协作，规范化等方面也有了质的提高，另外还认识了一些优秀的人。四年来，我阅读了很多优秀的源码，也尝试自己去造一些轮子，并开源出去，回馈社区。 输入 + 输出前面重点讲述的是输入。 其实学习的过程不仅仅是输入，输出也是很好的学习方法。 输出的形式有很多，比如写博客，讲给别人，开源出去让别人用等。 这其实是很好的学习机会，这种学习方法可以让你的成长速度呈指数型增长，因此千万不要小看它。 我会通过以练代学的方式来学习，比如我学习React，我会迅速看文档，然后写demo，最后我会自己《从零实现React》来内化它。 我还会定期做总结，写文章，写开源项目，做分享等，目的一方面是影响他人，另一方面是成长自己。 持续学习选择了技术这条路，就要做好持续学习，每日精进的准备，跟上时代潮流是很有必要的。 日报周报。 大家可以订阅一些前端方面的日报周报，这方面其实有很多，这里只推荐一个我常看的一个JavaScript周刊。我自己也出了一款《每日一荐》, 每天推荐一个优秀的开源项目，优秀文章， 周一到周五我们不见不散。 深度参与开源项目。 关于如何参与开源项目其实可以另起一篇文章了，这里不再赘述，感性的话，我会再写一篇文章，大家记得关注我就好。 定期总结，技术输出。 我的习惯是对于学习的内容定期和不定期地进行总结。 比如最近我在总结的[《leetcode题解》]（现在有18k+ ✨了）(https://github.com/azl397985856/leetcode)，[《大前端面试宝典》](https://github.com/azl397985856/fe-interview) 千万不要觉得算法对前端不重要，算法，网络，操作系统属于基础，从事相关工作的都应该认真学习，打好基础才行。 关注我大家可以关注我的公众号《脑洞前端》，公众号后台回复“大前端”，拉你进《大前端面试宝典 - 图解前端群》。回复“leetcode”，拉你进《leetcode题解交流群》 最后祝大家在前端的路上越走越远。","categories":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/categories/前端/"},{"name":"学习方法","slug":"学习方法","permalink":"https://lucifer.ren/blog/categories/学习方法/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/tags/前端/"},{"name":"学习方法","slug":"学习方法","permalink":"https://lucifer.ren/blog/tags/学习方法/"}]},{"title":"从老鼠试毒问题来看二分法","slug":"laoshushidu","date":"2019-12-11T04:35:19.045Z","updated":"2019-12-11T04:35:19.045Z","comments":true,"path":"2019/12/11/laoshushidu/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/laoshushidu/","excerpt":"很多人对于二分法的理解比较片面，之前碰到一个题目，从一个先升序后降序的数列中，比如 1 2 3 7 4 3 2 中运用二分法去查找一个给定的元素，很多人说根本不能二分，因为没有排序。其实 这道题完全可以使用二分查找进行解答， 如果你觉得不可以的话，很可能对二分法理解还比较片面。 这里以另外一个更加有趣（至少我认为）的例子来讲解一下二分法。","text":"很多人对于二分法的理解比较片面，之前碰到一个题目，从一个先升序后降序的数列中，比如 1 2 3 7 4 3 2 中运用二分法去查找一个给定的元素，很多人说根本不能二分，因为没有排序。其实 这道题完全可以使用二分查找进行解答， 如果你觉得不可以的话，很可能对二分法理解还比较片面。 这里以另外一个更加有趣（至少我认为）的例子来讲解一下二分法。 题目面试题： 有1000个一模一样的瓶子，其中有1瓶是毒药，老鼠喝了有毒的会在24h之后死亡。求最少需要多少老鼠才能在24h里找到有毒的那瓶。 解法这道题的解法有很多，今天我们来聊下用二分法来解这道题。 这道题似乎和我们看的的常见的二分法有很大的区别，但是仔细想一下， 二分法本质是将问题的规模缩小到原有的一半，带着这样的思想我们再来看一下。类似的，三分法就是将问题规模缩小为原来的1/3. 我们先对1000个瓶子进行编号，从1-1000这样子。 不过我们不是通过我们大家平时生活中使用的十进制，而是使用再计算机中使用的二进制， 同时让大家感受一下二进制的魅力。 为了方便讲解，我们假设不是1000个瓶子，而是4个。 我们来编一下号： 123400 // #101 // #210 // #311 // #4 我们的目标是找到哪个瓶子有毒，换句话说我们目标是找到有毒瓶子的编号，再换句话说我们的目标是找到有毒瓶子的3个bit分别是什么，是0还是1. 比如有毒的是3号瓶子，那么我们就是想确认第一个bit是0，第二个bit是1，第三个bit是1，即011，转化为10进制就是3号。 那么如何确定每一个bit是什么呢？ 回想一下，我们手上有老鼠，老鼠有两个state，alive 或者 died，这就是我们拥有的全部。 接下来我们逐一对瓶子进行分组，分组的依据就是每一个bit的值。 比如: 12345// 00 01 #g1:1 第一个bit是0// 10 11 #g1:2 第一个bit是1// 00 10 #g2:1 第二个bit是0// 01 11 #g2:2 第二个bit是1 我们来找第一个老鼠#1 来喝g:1:1, 如果他死了，那么毒就在这一组，也就是说毒的第一个bit是0，否则是1 我们来找第二个老鼠#2 来喝g:2:1, 如果他死了，那么毒就在这一组，也就是说毒的第二个bit是0，否则是1 所以我们可以看出, 两只老鼠就搞定了，我们按照这个思路，可以推到出1000个瓶子只需要10个瓶子, 即 log2 1000， 2的10次方是1024，因此10个老鼠够了，如果1025个瓶子的话，就需要11个老鼠了。 如果你仔细思考的话，不难看出，我们是在用老鼠喝了水之后的反应（生或死）来进行判断每一个bit的数字，不管生死，我们总能得出这个bit的值，是0还是1. 因此每使用一只老鼠我们都将问题规模缩小为原来的1／2. 这是典型的二分法。 这是最优解么是的，这是最优解，如果你愿意用严格的数学来证明的话，你可以试一下数学归纳法。 如果你想感性的判断一下的话，可以继续往下读。 什么是最优解？ 最优解就是要让未知世界无机可乘，也就是说在最坏的情况下得到最优（现实世界都是未知的）。上面的例子，不管小老鼠是生还是死，我们都可以将问题规模缩小到1/2. 也就是说最坏的情况就是最好的情况，也就是说没有最坏情况。 那么我们是否可以将问题规模缩小的1／3 或者更小呢？ 我们可以三分么简单来说，不可以， 因为老鼠只有两种observable state， 即alive， died. 假如我们有10个小球，其中有一个是异常的，其他9个都是一样的，我们怎么才能通过最少的称量来确定是哪一个异常，是重还是轻？ 这个时候我们就可以使用三分法了，为什么？因为天平有三个state， 平衡，左倾，右倾，使得我们”有可能“ 将问题规模缩小为1/3， 事实上，确实可以实现将问题规模缩小到1/3。 我会在之后的文章中进行讲解小球的问题最优策略， 并解释为什么这是最优策略。 Bonus基于比较的排序都无法逃脱nlogn时间复杂度的命运，这是为什么？能否利用本篇文章的思想进行解释？","categories":[{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"二分法","slug":"算法/二分法","permalink":"https://lucifer.ren/blog/categories/算法/二分法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"}]},{"title":"【LeetCode题解】1186.删除一次得到子数组最大和","slug":"leetcode-1186","date":"2019-12-11T04:35:19.045Z","updated":"2019-12-11T04:35:19.045Z","comments":true,"path":"2019/12/11/leetcode-1186/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/leetcode-1186/","excerpt":"LeetCode 1186题，最大子数组的进阶版本。","text":"LeetCode 1186题，最大子数组的进阶版本。 题目地址https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/ 题目描述12345678910111213141516171819202122232425262728293031给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。注意，删除一个元素后，子数组 不能为空。请看示例：示例 1：输入：arr = [1,-2,0,3]输出：4解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。示例 2：输入：arr = [1,-2,-2,3]输出：3解释：我们直接选出 [3]，这就是最大和。示例 3：输入：arr = [-1,-1,-1,-1]输出：-1解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。 我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。 提示：1 &lt;= arr.length &lt;= 10^5-10^4 &lt;= arr[i] &lt;= 10^4 思路暴力法符合知觉的做法是求出所有的情况，然后取出最大的。 我们只需要两层循环接口，外循环用于确定我们丢弃的元素，内循环用于计算subArraySum。 12345678910111213141516class Solution: def maximumSum(self, arr: List[int]) -&gt; int: res = arr[0] def maxSubSum(arr, skip): res = maxSub = float(\"-inf\") for i in range(len(arr)): if i == skip: continue maxSub = max(arr[i], maxSub + arr[i]) res = max(res, maxSub) return res# 这里循环到了len(arr)项，表示的是一个都不删除的情况 for i in range(len(arr) + 1): res = max(res, maxSubSum(arr, i)) return res 空间换时间上面的做法在LC上会TLE， 因此我们需要换一种思路，既然超时了，我们是否可以从空间换时间的角度思考呢？我们可以分别从头尾遍历，建立两个subArraySub的数组l和r。 其实这个不难想到，很多题目都用到了这个技巧。 具体做法： 一层遍历， 建立l数组，l[i]表示从左边开始的以arr[i]结尾的subArraySum的最大值 一层遍历， 建立r数组，r[i]表示从右边开始的以arr[i]结尾的subArraySum的最大值 一层遍历， 计算 l[i - 1] + r[i + 1] 的最大值 l[i - 1] + r[i + 1]的含义就是删除arr[i]的子数组最大值 上面的这个步骤得到了删除一个的子数组最大值， 不删除的只需要在上面循环顺便计算一下即可 123456789101112131415161718class Solution: def maximumSum(self, arr: List[int]) -&gt; int: n = len(arr) l = [arr[0]] * n r = [arr[n - 1]] * n if n == 1: return arr[0] res = arr[0] for i in range(1, n): l[i] = max(l[i - 1] + arr[i], arr[i]) res = max(res, l[i]) for i in range(n - 2, -1, -1): r[i] = max(r[i + 1] + arr[i], arr[i]) res = max(res, r[i]) for i in range(1, n - 1): res = max(res, l[i - 1] + r[i + 1]) return res 动态规划上面的算法虽然时间上有所改善，但是正如标题所说，空间复杂度是O(n),有没有办法改进呢？答案是使用动态规划。 具体过程： 定义max0，表示以arr[i]结尾且一个都不漏的最大子数组和 定义max1，表示以arr[i]或者arr[i - 1]结尾，可以漏一个的最大子数组和 遍历数组，更新max1和max0（注意先更新max1，因为max1用到了上一个max0） 其中max1 = max(max1 + arr[i], max0), 即删除arr[i - 1]或者删除arr[i] 其中max0 = max(max0 + arr[i], arr[i])， 一个都不删除 12345678910111213141516171819202122232425262728## @lc app=leetcode.cn id=1186 lang=python3## [1186] 删除一次得到子数组最大和## @lc code=startclass Solution: def maximumSum(self, arr: List[int]) -&gt; int: # DP max0 = arr[0] max1 = arr[0] res = arr[0] n = len(arr) if n == 1: return max0 for i in range(1, n): # 先更新max1，再更新max0，因为max1用到了上一个max0 max1 = max(max1 + arr[i], max0) max0 = max(max0 + arr[i], arr[i]) res = max(res, max0, max1) return res# @lc code=end 关键点解析 空间换时间 头尾双数组 动态规划 相关题目 42.trapping-rain-water","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"}]},{"title":"从零打造一个舒服的Mac开发环境 - 装机篇","slug":"mac-setup-for-fe","date":"2019-12-11T04:35:19.045Z","updated":"2019-12-11T04:35:19.045Z","comments":true,"path":"2019/12/11/mac-setup-for-fe/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/mac-setup-for-fe/","excerpt":"前两天新买的16寸mac pro到手了。 本来想直接将旧电脑的数据做一个迁移，但是有同学反应想看“如何从零打造一个舒适的开发环境”，于是就有了这篇文章。","text":"前两天新买的16寸mac pro到手了。 本来想直接将旧电脑的数据做一个迁移，但是有同学反应想看“如何从零打造一个舒适的开发环境”，于是就有了这篇文章。 开箱 配置和价格在正式开始之前，我们先来介绍下主机的配置。 2.3GHz 8-core 9th-generation Intel Core i9 processor Turbo Boost up to 4.8GHz AMD Radeon Pro 5500M with 4GB of GDDR6 memory 32GB 2666MHz DDR4 memory 1TB SSD storage¹ 16-inch Retina display with True Tone Touch Bar and Touch ID Four Thunderbolt 3 ports 这个电脑要比15寸的pro重100多克，扬声器，显卡要比15寸的更加好一点，touch bar重也将ESC和TouchID做成了实体键，最关键的是和15寸价格一样，我这个配置下来价格是RMB 25,135 。 如何从零打造一个舒适的开发环境 文字版 视频版P1&amp;P2 视频录制的声音比较小 Next本期视频只是一个简单的装机，以及系统配置。并不涉及到软件的深度使用，如果感兴趣可以给我留言，我会在之后给大家带来相关的攻略。","categories":[],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://lucifer.ren/blog/tags/Mac/"},{"name":"装机","slug":"装机","permalink":"https://lucifer.ren/blog/tags/装机/"},{"name":"必备软件","slug":"必备软件","permalink":"https://lucifer.ren/blog/tags/必备软件/"}]},{"title":"每日一荐 2019-11 汇总","slug":"daily-featured-2019-11","date":"2019-12-11T04:35:19.044Z","updated":"2019-12-11T04:35:19.044Z","comments":true,"path":"2019/12/11/daily-featured-2019-11/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/daily-featured-2019-11/","excerpt":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。","text":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。 2019-112019-11-29[网站]之前我在每日一题出了一道题 2019-08-16 - 怎么在浏览器中操作本地的文件。 一个可行的思路就是在本地创建一个服务器，比如 node 服务器，浏览器操作发送请求到服务器，然后 node 去操作本地文件。 现在 Chrome 支持 native fs api，使得这个过程原生支持，想要体验的可以访问这里 https://labs.vaadin.com/native-fs/ ， 如果你愿意，你可以将它添加为 Chrome APP。 2019-11-28[工具]今天给大家推荐的工具是效率类软件 Alfred 的灵魂 workflows（工作流）。 以下是我使用频率比较高的 workflow，使用频率低的会被我定期清理掉。 我自己制作的工作流不在这里展示和推荐 下载地址： Chrome Bookmarks Colors Dash Kill Process RamdaDocs TerminalFinder Yosemite iOS Simulator Youdao 2019-11-27[软件]mac 端不能右键新建文件，这在某些时候不是很方便。 没有这个软件的时候，我是在编辑器中新建或者是使用 touch 命令。 使用了这个New File Menu软件之后多了一种更方便的选择，你可以直接右键新建，Just Like Windows Users。 地址： https://apps.apple.com/cn/app/new-file-menu/id1064959555?l=en&amp;mt=12 2019-11-26[网站]一个网站，可以分析的 Github 仓库，采用手绘风格，对于厌倦了标准图形的我来说简直是耳目一新的感觉。 项目地址： https://repo-analytics.github.io/ 2019-11-25[技巧]Chrome 开发者工具有非常好用但是却鲜为人知的功能。今天给大家介绍一个功能 - 代码覆盖率。 指的是你下载的代码有多少是被执行了的，这在做性能优化的时候很有用。如果一些代码根本没执行，就可以延迟加载。 使用方法： Ctrl+Shift+P for windows CMD+Shift+P for mac 输入 coverage， 选择如图的选项，并确定。 然后你就能看到检测结果了： 2019-11-22[工具]Github Large File Storage （简称 git-lfs）, 可以用来存储大文件，比如上 GB 的大文件，相比于传统的 Github 存储，这种方式空间更大，速度更快，并且工作流程和传统 Git flow 并无二致。 地址：https://git-lfs.github.com/ 2019-11-21[娱乐]文章标题 【The skeptic’s guide to interpreting developer marketing speak 🗺️】 - 暂翻译为【如何翻译开发人员的营销术语】 里面讲了各种开发人员常用的营销术语，以及对应我们应该怎么去解读 ta。比如： 现代化 就是说刚刚git init AI加持 就是说无数的if else switch case语句 最小化 就是说没有测试用例，没有例子 跨平台 就是说我听说Electron可以跨平台，于是我就用它写了 … 文章地址： https://changelog.com/posts/the-skeptics-guide-to-interpreting-developer-marketing-speak 2019-11-20[工具]微信的一个插件，功能有很多。 不过目前已经不再维护了。 消息自动回复 消息防撤回 远程控制(已支持语音) 微信多开 第二次登录免认证 聊天置底功能(类似置顶) 微信窗口置顶 会话多选删除 自动登录开关 通知中心快捷回复 聊天窗口表情包复制 &amp; 存储… 我用的比较多的功能恐怕就是双开和防撤回了。 消息防撤回 微信多开 仓库地址：https://github.com/TKkk-iOSer/WeChatPlugin-MacOS/tree/master 2019-11-19[工具]JS 依赖检测工具，可以用来生成图片，可视化程度很高，还可以做成自动化，集成到 CI CD ，支持 CommonJS，AMD 和 ES Module。 项目地址： https://github.com/pahen/madge 2019-11-18[娱乐]今天给大家推荐一个在线 nokia 短信图片生成器，可以自己输入短语，一键生成。 网站地址： https://zzkia.noddl.me:8020/ 2019-11-15[网站]有的什么我们需要在 Google Play 上下载软件，但是苦于没有通畅的网络(关于如何获取畅通的网络我在 2019-11-01 讲到，感兴趣可以翻过去看看)。因此一个 Google Play 镜像就很重要了。 这就如同我们 npm 和 cnpm 的关系。我们可以在这里直接下载 apkx。 apkx 需要特殊的安装工具，或者一些小技巧才能安装。 网站地址： https://apkpure.com/ 2019-11-14[技巧]很多时候我们会看到一些英文的简写。比如邮件，IM 等，这些简称能够帮我们提高沟通效率，如果你不知道一些常见的简写，沟通的时候就难免有障碍，以下是一些常见的简写，欢迎补充。 2019-11-13[技巧]今天要分享的是关于 Bash 中历史记录那些事。 第一个要介绍的是history, history is an alias for fc -l 1,你可以通过这个命令来查看最近你使用的命令。 然后你可以用!n(n 指的是 history 命令返回的命令编号)再次执行。其中有许多缩写，最有用的就是 !$， 用于指代上次键入的参数，!! 可以指代上次键入的命令。 第二个要介绍的是历史搜索ctrl + r, 然后输入你想搜索的关键字即可 第三个要介绍的是上下方向键，你可以通过他在历史记录中上下移动。即按下上返回当前上一个命名，按下下返回当前下一个命令。 还有一个小插曲，似乎和历史有那么一点点关系。 就是cd -,切换到上一次的工作路径 如果你还知道什么和历史记录相关的命令，欢迎大家补充。 2019-11-12[技巧]dig 命令是常用的域名查询工具，可以用来测试域名系统工作是否正常。 如下dig lucifer.ren， 可以发现很多信息，包括域名最终解析到了到了另外一个域名azl397985856.github.io, IP 是185.199.108.153. 这个工具在很多情况下非常有用，尤其是对于喜欢命令行的你来说。 其实 dig 是usr/bin下的一个可执行文件，更多用法请man dig查看。 12~ type dig# dig is /usr/bin/dig 2019-11-11[分享]今天是双十一，大家剁手快乐。 今天给大家分享一下前一段时间刚刚举行的大会React Conf 2019，这个是 React 最高规模的技术会议。喜欢 React 的小伙伴千万不要错过了，这里有全套视频。 地址：https://www.youtube.com/playlist?list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh 2019-11-08[好文]前几天读了一篇文章《Scaling webapps for newbs &amp; non-techies》，文章从最简单的单体应用，逐步讲到大型应用架构，不仅讲的通俗易懂，并且图画的也非常好，是我喜欢的风格。 很期待他的第二篇《the cloud for newbs and non-techies》。 （A single server + database）（Adding a Reverse Proxy） 文章地址： https://arcentry.com/blog/scaling-webapps-for-newbs-and-non-techies/ 2019-11-07[学习方法]前一段时间看了一篇文章 -《如何构建自己的产品知识库》。这篇文章的亮点在于其所提到的技巧能够横向类比到任何领域。换句话说你可以按照它将的方法构建你自己的知识库。 里面有一句话产品知识体系是对产品知识搜集、筛选、整理后形成的知识组合，并且这些知识能够用于解决实际遇到的问题。 学习任何知识又何尝不是呢？很多人问我学习方法，其实这个东西非常地系统，很难通过几个技巧完成，也很难在短期内看到很明显的效果。大家可以看一下，说不定对你的学习和生活所有启发，即便你不是一个产品经理。 文章地址: https://www.toutiao.com/a6738596936057618951/ 后期如果有机会的话，我也会分享一下自己的学习方法 2019-11-06[工具]像 PS 和 Sketch 一样，figma 也是一个设计工具，和其他相比团队显得更简单，这点有点像蓝湖。做设计的同学要了解起来了。 地址： https://www.figma.com/ 2019-11-05[观点]VSCode 和 MDN 进行了官方联动，详情. 再也不用跳出 IDE 用 Dash 查了。 用 Alfred + Dash 虽然方便，但是不免有一种应用跳出的感觉。现在就很方便了，如果之后有更多的联动支持，相信体验会越来越好。 2019-11-04[好文]最近几年啊，我本人也看了很多关于微服务的介绍，理念，落地等技术文章，今天给大家推荐一篇阿里飞冰团队发布的技术文，这或许是最简单的微服务落地技术文章。这篇文章详细讲述了业务场景，并详细记录了解决问题的过程以及对比了业界的一些解决方案，管中窥豹，让读者慢慢走进微服务，从这篇文章可以学习到icestark这个微服务的解决方案是怎么从从到有再到落地产生实际业务价值的。 文章地址： https://zhuanlan.zhihu.com/p/88449415#h5o-9 2019-11-01[工具]身为一个程序员，科学上网是标配。市面上免费的软件大多不稳定，出了问题很难及时解决。 自建服务器虽然好，但是还是有一点繁琐的，尤其是碰到了“开会”，IP 端口就会被封锁，自己处理就比较麻烦了。 今天给大家推荐一下 SSNG 的订阅功能，有了这个订阅地址就相当于有了无数的自建服务器，然后你可以在不同的节点之间进行切换。一般而言，我会对服务器进行测速，然后选择速度最快，如果某一个服务器挂了，我只需要一键切换到另外一个即可，无需额外操作。 市面上有很多这种订阅服务，这里推荐一个付费的服务 KyCloud，挺便宜的，我订阅的是 45／季度，平均一个月 15，50G 流量，基本对于我来说非常够用了。 使用方式也非常简单，只需要以下三步即可。 下载对应客户端 点击复制订阅地址 将地址粘贴到客户端 提示： 你也可以像我一样测速，然后根据速度选择节点。 关注我我重新整理了下自己的公众号，并且我还给它换了一个名字脑洞前端，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。 在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。 之后我的文章会同步到微信公众号 脑洞前端 ，你可以关注获取最新的文章，并和我进行交流。 另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。","categories":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/categories/每日一荐/"},{"name":"2019-11","slug":"每日一荐/2019-11","permalink":"https://lucifer.ren/blog/categories/每日一荐/2019-11/"}],"tags":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/tags/每日一荐/"}]},{"title":"《LeetCode题解攻略》 - 草稿目录","slug":"draft","date":"2019-12-11T04:35:19.044Z","updated":"2019-12-11T04:35:19.044Z","comments":true,"path":"2019/12/11/draft/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/draft/","excerpt":"这个我为自己的新书写的一个目录，计划在一星期左右定下来大体目录，然后投入完善，希望大家多提意见，你的意见很可能会影响到这本书的内容，期待你以特别的方式参与进来，此致敬礼。","text":"这个我为自己的新书写的一个目录，计划在一星期左右定下来大体目录，然后投入完善，希望大家多提意见，你的意见很可能会影响到这本书的内容，期待你以特别的方式参与进来，此致敬礼。 1. 准备知识1.1 学习这本书之前需要什么基础很多人觉得算法很难，需要很多公式以及数学知识。 其实并不是这样的，除非你是做算法岗位，否则并不会要求你对数学，几何学，概率学有多深的造诣，其实更看重的是分析问题，解决问题的能力和基础编码能力。 但是我们不排除LeetCode有一些数学题目，我们会在后面的章节中讲到，但是说实话LeetCode的数学题目不会涉及很难的数学知识。而且通常我们也可以通过变通的方式解决，比如LeetCode有一道水壶倒水的问题，以下是题目描述： 1给你一个装满水的 8 升满壶和两个分别是 5 升、3 升的空壶，请想个优雅的办法，使得其中一个水壶恰好装 4 升水，每一步的操作只能是倒空或倒满。 这道题我们可以用GCD（最大公约数）解决，如果你不知道这个数学知识点也没问题。 我们可以通过BFS来解决，其实学习算法尤其是刷LeetCode只需要我们掌握简单的数学知识，高中的数学知识通常来说就足够了。 另外一个大家需要掌握的数学知识是关于后面要讲的复杂度分析，这里需要一点简单的数学知识，不过不要担心，非常简单，不会有高等数学的内容。 学习本书最好你对一种编程语言比较熟悉，出于读者的受众群体和代码简洁性，我选取了Python作为本书的主要编程语言，如果大家对Python不熟悉也没有关系，我会尽量少使用语言特有的语法糖，从而减少大家对于语言层面的认知负担。 另外Python被誉为最容易入门的语言之一也是实至名归，大家可以放心。 退一步讲，语言不应该成为我们学习算法的障碍，不是么？那让我们一起进入LeetCode的世界吧！ 1.2 基础数据结构和算法在真正的刷题之前，我们一定要先打好基础，学好基本的数据结构和算法，然后以练代学进行提升和消化。 从广义上来说，数据结构其实就是数据的存储结构，算法就是操作数据的方法。而平时以及本书所探讨的其实是更为狭义角度的数据结构和算法。其实指的是某些非常典型的数据结构和算法，比如数组，链表，栈，队列，树，图等数据结构，以及二分法，动态规划，快速排序等经典的算法。 数据结构是为算法所服务的，而算法是要建立在某一种或者几种数据结构之上才可以发挥作用，这两个是相辅相成的关系。某些算法一定要建立在某种数据结构之上才行，相信你读完这本书会对这句话产生更为深刻的印象。 本书要讲的内容就是在LeetCode上反复出现的算法，经过进一步提炼，抽取近百道题目在这里进行讲解，帮助大家理清整体结构，从而高效率地刷题。 我这里总结了 7 个常见的数据结构和 7 个常见的算法以及 5 个常见的算法思想。 7 个数据结构分别是： 数组，栈，队列，链表，二叉树，散列表，图 7 个算法分别是：二分法，递归，回溯法，排序，双指针，滑动窗口，并查集 5 个算法思想分别是：分治，贪心，深度优先遍历，广度优先遍历，动态规划 只有掌握了这些基础的数据结构和算法，更为复杂的算法才能得心应手，刷题才会事半功倍。而LeetCode的题目虽然不断出新，但是最终用到的算法永远是那几个，很多题目都是穿着新衣服的老面孔了。大家学好这些基础套路之后会更加明白这个道理。 1.3 如何刷LeetCodeLeetcode网站使用方法LeetCode官网收录了许多互联网公司的算法题目，一度被称为刷题神器，今天我们就来介绍下如何使用LeetCode网站，以下所讲述的内容都是以力扣中国为例。 LeetCode目前有1000多道题目，并且一直持续更新，其中有一些是带锁的，需要会员才能查看。 最上面标签栏的Problems，给出了四个分类：Algorithms、Database、Shell和Concurrency，分别表示算法题、数据库题、Shell和并发题，第一个就是我们所需要刷的算法题，并发是2019年才添加的新的模块。 点开Algorithms后，我们可以看到一列题目的列表，每个题目都有一个序号，后面的接受率（Acceptance）表示提交的正确率，Difficulty表示难易程度。这里有个小技巧，衡量一道题目难不难除了看难度之外，还可以看下接受率，接受率越低代表题目越难，这个指标有时候比难度更靠谱。 LeetCode按难易程度分成了三个级别，分别是Easy、Medium和Hard。 Easy 通常不需要太多思考和也不会有复杂的细节，比较特别适合新手或者拿来热身。 Medium级别就会有些难度，一般都会涉及到经典的算法，需要一定的思考。 Hard级别是最难的，有些时候是算法本身的难度，有些时候特别需要你考虑到各种细节。 你可以对题目进行筛选和排序。 如果我们只想要找某一类型的题，可以通过Tags或Company来筛选。 另外我们在做某一题时，觉得还想再做一个类似的，可以点击题目描述下方Show Similar Problems或Tags来找到相似的问题。 每个题目都有各自的Discuss区域。在这里，许多人都把自己的思路和代码放到了上面，你可以发贴提问，也可以回复别人，里面大神很多，题解质量都很高，如果实在没有思路或者想看下有没有更好的思路可以来逛一下。通常来说我建议你优先看Post或者投票最多的。 点开某一个题目，会跳转到具体题目详情页面，你可以在右侧的代码区切换选择自己需要的编程语言。 代码编写完了之后，不要急着提交，先可以测试运行下（Run Code），你可以多写几个测试用力跑一下，没有问题再提交，要知道比赛的时候错误提交要加时间的。 我们可以点开More Details查看详细运行结果信息。 每道题旁边的My Submissions可以找到自己的对于该题的提交情况，这里可以看到自己过去所有的提交，点Accepted 或 Wrong Answer就可以查看自己过去提交的代码情况，包括代码是什么，跑的时间以及时间分布图等。 以上就是LeetCode的主要功能，希望通过这一节内容能让你对LeetCode网站有所了解，从而更快地进行刷题。 应该怎么刷LeetCode我本人从开始准备算法以来刷了很多题，自己成长了很多，从刷题菜鸡，到现在对刷题套路，题型有了自己的理解，感受还是蛮多的。我本人不是算法高手，算是勤能补拙类型。不过经过几个月的学习和练习，不仅面试变得更加得心应手，而且在工作中写更容易写出干净优雅，性能好的代码。 对于我来说，刷题的过程其实就是学习数据结构和算法的过程， 不仅仅是为了刷题而刷题，这样你才能感受到刷题的乐趣。刷题至少要刷两遍，理想情况是根据自己的遗忘曲线刷多次，这个我后面也会讲到。 第一遍按tag刷 建议第一遍刷的时候可以先快速按照tag过一遍，快速感受一下常见数据结构和算法的套路，这样自己有一个感性的认识。 第二遍一题多解，多题同解 第二遍我们就不能像第一遍那样了，这个阶段我们需要多个角度思考问题，尽量做到一题多解，多题同解。我们需要对问题的本质做一些深度的理解，将来碰到类似的问题我们才能够触类旁通。 但是很多人做了几遍，碰到新题还是没有任何头绪，这是一个常见的问题，这怎么办呢？ 总结并记忆是学习以及刷题过程中非常重要的一环， 不管哪个阶段，我们都需要做对应的总结，这样将来我们再回过头看的时候，才能够快读拾起来。 anki就是根据艾宾浩斯记忆曲线开发的一个软件，它是一个使记忆变得更容易的学习软件。支持深度自定义。 对于我本人而言，我在anki里面写了很多LeetCode题目和套路的Card，然后anki会自动帮我安排复习时间，大大减少我的认知负担，提高了我的复习效率。大家可以在书后的附录中下载anki卡片。 目前已更新卡片一览（仅列举正面） 二分法解决问题的关键点是什么，相关问题有哪些? 如何用栈的特点来简化操作， 涉及到的题目有哪些？ 双指针问题的思路以及相关题目有哪些？ 滑动窗口问题的思路以及相关题目有哪些？ 回溯法解题的思路以及相关题目有哪些？ 数论解决问题的关键点是什么，相关问题有哪些? 位运算解决问题的关键点是什么，相关问题有哪些? 大家刷了很多题之后，就会发现来来回回，题目就那么几种类型，因此掌握已有题目类型是多么重要。那样LeetCode出题的老师，很多也是在原有的题目基础上做了适当扩展（比如two-sum,two-sum2,three-sum, four-sum等等）或者改造（使得不那么一下子看出问题的本质，比如猴子吃香蕉问题）。 其中算法，主要是以下几种： 12345基础技巧：分治、二分、贪心排序算法：快速排序、归并排序、计数排序搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等图论：最短路径、最小生成树动态规划：背包问题、最长子序列 数据结构，主要有如下几种： 123456数组与链表：单 / 双向链表栈与队列哈希表堆：最大堆 ／ 最小堆树与图：最近公共祖先、并查集字符串：前缀树（字典树） ／ 后缀树 做到了以上几点，我们还需要坚持。这个其实是最难的，不管做什么事情，坚持都是最重要也是最难的。 为了督促自己，同时帮助大家成长，我在群里举办《每日一题》活动，每日一题是在交流群（包括微信和qq）里进行的一种活动，大家一起 解一道题，这样讨论问题更加集中，会得到更多的反馈。而且 这些题目可以被记录下来，日后会进行筛选添加到仓库的题解模块， 感兴趣的可以到书后的附录部分进群交流。 1.4 复杂度分析想学算法，首先要学的第一件事就是如何判断一个算法的好坏。 好的程序有很多的评判标准，包括但不限于可读性，扩展性性能等。 这里我们来看其中一种 - 性能。 坏的程序可能性能也很好，但是好的程序通常性能都比较好。那么如何分析一个算法的性能好坏呢？这就是我们要讲的复杂度分析，所有的数据结构教程都会把这个放在前面来讲，不仅仅是因为他们是基础，更因为他们真的非常重要。学会了复杂度分析，你才能够对你的算法进行分析，从而帮助你写出复杂度更优的算法。 那么怎么样才能衡量一个算法代码的执行效率呢？ 如下是一个从1加到n的一个算法，这个算法用了一层循环来完成，并且借助了一个变量res来完成。 12345def sum(n): res = 0 for i in range(1, n + 1): res += i return res 我们将这个方法从更微观的角度来进行分析，上述代码会执行n次循环体的内容，每一次执行都是常数时间，我们不妨假设执行的时间是x。我们假设赋值语句res = 0和return res的时间分别为y和z 那么执行的总时间我们约等于 n * x + y + z, 我们粗略将x，y和z都看成一样的，我们得出总时间为 (n + 2) * x 换句话说算法的时间和数据的规模成正比。 实际上，这更是一种叫做大O表示法的基本思想, 它是一种描述算法性能的记法，这种描述和编译系统、机器结构、处理器的快慢等因素无关。 这种描述的参数是n，表示数据的规模。 这里的O表示量级（order），比如说“二分查找是$O(logN)$的”，也就是说它需要“通过 logn量级的操作去查找一个规模为n的数据结构（通常是数组）”。这种渐进地估计对算法的理论分析和大致比较是非常有价值，可以很快地对算法进行一个大致地估算。例如，一个拥有较小常数项的 $O(N^2)$算法在规模n较小的情况下可能比一个高常数项的$O(N)$算法运行得更快。但是随着n足够大以后，具有较慢上升函数的算法必然工作得更快，因此在采用大O标记复杂度的时候，可以忽略系数。 我们还应该区分算法的最好情况，最坏情况和平均情况，但是这不在本书的讨论范畴，本书的所有复杂度均指的是平均复杂度。 那么如何分析一个算法的复杂度呢？下面我们介绍几种常见时间复杂度，几乎所有的算法的复杂度都是以下中的一种 我对时间复杂度进行了一个小的分类。 第一类是常数阶。 一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。 1234cnt = 1l = 0r = len(list) - 1# 不管这种代码有多少行，都是常数复杂度，即$O(1)$,因此系数是被忽略的。 第二类是 n,n^2,n^3 … 一个简单的方法是关注循环执行次数最多的那一段代码就好了，这段执行次数最多的代码执行次数的n的量级，就是整个算法的时间复杂度。即如果是一层N的循环，那么时间复杂度就是$O(N)$, 如果嵌套了两层N的循环，那么时间复杂度就是$O(N^2)$，依次类推。 123456789101112class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: n = len(nums) mapper = &#123;&#125; for i in range(n): if (target - nums[i] in mapper): return [mapper[target - nums[i]], i] else: mapper[nums[i]] = i return [] 如上代码，我们进行了一层的循环，那么时间复杂度就是$O(N^2)$ 第三类是对数阶。 logn nlogn 这同样是一种非常常见的复杂度，多见于二分查找和一些排序算法。 123456789101112131415161718def numRescueBoats(self, people: List[int], limit: int) -&gt; int: res = 0 l = 0 r = len(people) - 1 people.sort() while l &lt; r: total = people[l] + people[r] if total &gt; limit: r -= 1 res += 1 else: r -= 1 l += 1 res += 1 if (l == r): return res + 1 return res 上面的代码是一个典型的二分查找，其时间复杂度是logn 第四类是指数阶 2^n 指数的增长已经非常恐怖了，一个典型的例子是fabnicca数列的递归实现版本。 1234def fibonacci(n): if n &lt; 2: return n return fibonacci(n-1) + fibonacci(n-2) 如果你把上述的计算过程看成树的一个节点，那么整个计算过程就像是一颗很大的树。这棵树有很多的重复计算，大致算下来的话，是2^n。 第五类是对数阶 n！ 我们知道n个不相同的数字的全排列有n!个。 1234def factorrail(n): if n == 1: return 1 return n * factorrail(n - 1) 很明显上面的代码就是n! 下面给出上面列举的几种常见的时间复杂度的趋势图对比，大家直观感受一下。 （各种复杂度的渐进趋势对比） 从算法可以分析出时间复杂度，相反题目的时间复杂度要求，我们甚至可以猜测出可能用到的算法，比如算法要求logn，那么就有可能是二分法。 空间复杂度分析比时间复杂度分析要简单地多,常见的空间复杂度有$O(1)$、$O(N)$、$O(N^2)$、$O(logN)$、$O(logN)$、$O(N!)$这样的对数阶复杂度基本不会有，关于空间复杂度这里不做更多介绍了。 总结时间复杂度是算法的基石，学习它对于我们学习后面的章节有很大的帮助。 我们引入了大O表示法来衡量算法的好坏。接着通过若干实例了解了各种时间复杂度，其实对于复杂度，掌握上面提到的几种常见的就已经够应付绝大多数场合了。 通过上面的学习，相信你对评估一个算法的时间复杂度有了初步的了解。随着学习的深入，相信你会对复杂度分析有着更为深入的理解。 2. 数学之美LeetCode中有很多数学问题，截止到本书出版，LeetCode中有数学标签的题目一共是159，在所有标签的分类中排名第3。这些题目中有些是包着数学外衣的伪数学问题，还有一些是真正数学问题。这需要大家有着极强的分辨能力。不要被数学两个字吓住了，本章不会讲非常复杂的数学概念和公式，实际上你只需要一些高中数学知识即可。 除非是面试算法岗位，笔试和面试题才会涉及到一些比较复杂度的数学知识，比如微积分，线性代数，概率论，信息论等。 虽然有的题目可以用数学公式轻松解决，但是这并不意味你需要对数学有很深的造诣。举例来说，LeetCode 69.实现开方，就是一道可以使用纯数学方法 - 牛顿迭代法来解决的一道题，但是你完全可以使用二分法解决，尽管效率远远不及牛顿迭代法，实际上现在的计算器计算开方也不是二分法计算的。但是这通常是一个加分项，如果你可以通过别的方法解决，也未尝不可。 很多题目一眼看上去就是个数学问题，如果你尝试使用数学的角度没有什么思路或者解不出来的时候，可以考虑换最常规，最符合直觉的做法，当然做之前要估算一下数据范围和时间，不要写完才发现超时。 有些题目只是涉及到一些数学名词，并且会在题目中详细地进行解释。 比如关于质数性质，阶乘性质的题目，还有一些造轮子题目，比如实现Pow等。还有一些干脆定义一个数学概念，让你去做。比如开心数，回文数，丑数等。 我们这章主要讲解纯数学问题，需要用到一些数学的性质类的题目，这或许是大家更想要看的。 2.1 N-SUM 题目LeetCode上有很多经典的系列问题，今天我们就来看一下N-SUM系列问题。 2.2 连续整数和这是一个非常经典，被各种收录的一个题目，这道题好在虽然简单，但是却可以从多个纬度进行解决，非常适合用来查考一个人的真实水平，一些比较大的公司也会用它来进行算法面试的第一道题。 2.3 最大数2.4 分数到小数2.5 最大整除子集2.6 质数排列 质数 全排列 2.8 快乐数 这类题目是给定一个定义（情景），让你实现算法找出满足特定条件的数字 3. 回文的艺术回文是很多教材中被提到的一个题目，通常是用来学习栈的一个练习题，LeetCode中有关回文的题目也是蛮多的，单从数据结构上来看就有字符串，数字和链表。今天我们就结合几个LeetCode题目来攻克它。 3.1 回文字符串3.2 回文链表3.3 回文数字3.4 回文总数4. 游戏之乐我很喜欢玩游戏，实际上很多游戏背后都是有很多算法存在的，我们通过LeetCode上一些关于游戏的题目来一窥究竟吧，虽然这里的题目和实际游戏用到的算法难度差很多，但是这里的基本思想是一样的。 4.1 生命游戏4.2 报数4.3 数独游戏5. BFS &amp; DFS这是LeetCode后期新增的一个板块，题目还比较少。 6. 二分法二分法真的是一个非常普遍的算法了，更严格的说其实是一种思想，如果把二改成N其实就是一种分治思想。LeetCode关于二分法的题目实在太多了，我们挑选几个代表性的来感受一下，LeetCode到底是如何考察我们二分法的。 6.1 你真的了解二分法么？6.2 一些显然的二分6.3 隐藏的二分法二进制和二分法？ 744 吃香蕉 循环数组 数学开方 等等 6.4 寻找峰值7. 神奇的比特前菜： 如何将一个IP地址用一个字节存储，支持序列化和反序列化操作。 计算机是用过二进制来表示信息的，有时候我们从二进制思考问题，会发现一个全新的世界。 7.1 那些特立独行的数字7.2 桶中摸黑白球7.3 实现加法7.4 二进制 1 的个数7.5 悲惨的老鼠8. 设计题有时候我们面对的不是一个算法题，而是一个设计题目，这种题目比较开放，让你自己设计数据结构和算法。这比限定数据结构和算法更能考察一个人综合运用知识的能力，是一个经常被拿来进行面试的一类题目。 8.1 设计 LRU8.2 设计 LFU8.3 最小栈8.4 队列实现栈8.5 设计 Trie 树9. 双指针双指针的题目真的非常多，可以看出这个是一个重要重要的知识点。在实际使用过程中，我将双指针问题分为两种，一种是头尾双指针，一种是快慢双指针。 9.1 头尾指针9.1.1 盛水问题9.1.2 两数相加 29.2 快慢指针9.2.1 删除有序数组的重复元素9.2.2 链表中的快慢指针10. 查表与动态规划如果说递归是从问题的结果倒推，直到问题的规模缩小到寻常。 那么动态规划就是从寻常入手， 逐步扩大规模到最优子结构。 这句话需要一定的时间来消化, 如果不理解，可以过一段时间再来看。 递归的解决问题非常符合人的直觉，代码写起来比较简单。但是我们通过分析（可以尝试画一个递归树），可以看出递归在缩小问题规模的同时可能会 重复计算。 279.perfect-squares 中 我通过递归的方式来解决这个问题，同时内部维护了一个缓存 来存储计算过的运算，那么我们可以减少很多运算。 这其实和动态规划有着异曲同工的地方。 10.1 爬楼梯10.2 聪明的盗贼六（七）个版本，带你一步步进化，走向极致 10.3 不同路径10.4 硬币找零10.5 最短编辑距离11. 滑动窗口你可能听过TCP的滑动窗口，这里要讲的滑动窗口其实思想是一样的，这里要讲的滑动窗口通常被用在处理连续数组或者字符的问题上。 最长连续不重复子串最短子数组之和滑动窗口最大值12. 博弈博弈，词语解释是局戏、围棋、赌博。 现代数学中有博弈论，亦名“对策论”、“赛局理论”，属应用数学的一个分支， 表示在多决策主体之间行为具有相互作用时，各主体根据所掌握信息及对自身能力的认知，做出有利于自己的决策的一种行为理论。 这类问题通常没那么直接和好下手，需要你进行一定的推演才能发现问题的本质。 12.1 alec12.2 Nim12.3 486. 预测赢家13. 股票系列LeetCode上有很多经典的系列问题，今天我们就来看一下这个股票系列问题。 13.1 股票买卖的最佳时机 113.2 股票买卖的最佳时机 213.3 股票买卖的最佳时机 313.4 股票买卖的最佳时机 414. 分治法分治是一种非常重要的算法思想，而不是一个算法。和具体算法不同，算法思想在任何数据结构下都可以使用。 14.1 合并 K 个排序链表14.2 数组中的第 K 个最大元素14.3 搜索二维矩阵15. 贪心法贪心或许是最难的一种算法思想了。 15.1 跳跃游戏15.2 任务调度器16. 回溯这是一种非常暴力的搜索算法，优点是书写简单有固定模板，且适用范围很广。 16.1 求组合数 116.2 求组合数 216.3 求所有子集16.4 全排列16.5 海岛问题17. 一些有趣的题目这里让我们来看一下LeetCode上那些惊人的算法。 17.1 求众数17.2 手撕排序17.3 星期几17.4 量筒问题17.5 实现开方17.6 4的次方18. 一些通用解题模板不仅是平时做工程项目，刷题的过程也非常讲究风格一致，如果有一些非常优秀的模板可以直接拿来用，一方便减少做题时间和出错的可能，另一方面做题风格一致有利于自己回顾。 如果你是在面试，相信一定也会为你加分不少。 18.1 二分法18.2 回溯法18.3 递归18.4 并查集 朋友圈 计算小岛数2 19. 融会贯通这里我们要把本书降到的知识进行融会贯通，纵向上我们不满足于一种解法，我们尝试使用多种解法去解决。 横向上我们需要去总结哪些题目和这道题目类似。 这通常被用在第二遍刷LeetCode的过程中。 19.1 最大子序列和问题19.2 循环移位问题19.3 k 问题20. 解题技巧&amp;面试技巧在水平知识一样的情况下，如果能够LeetCode上效率更好？如何面试的时候加分，这是本章我们要探讨的主要内容。 一定要看限制条件，很多时候限制条件起到了提示的作用，并且可以帮助你过滤错误答案 21. 参考","categories":[{"name":"书","slug":"书","permalink":"https://lucifer.ren/blog/categories/书/"},{"name":"算法","slug":"书/算法","permalink":"https://lucifer.ren/blog/categories/书/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"},{"name":"书","slug":"书","permalink":"https://lucifer.ren/blog/tags/书/"},{"name":"草稿","slug":"草稿","permalink":"https://lucifer.ren/blog/tags/草稿/"}]},{"title":"《一文看懂浏览器事件循环》","slug":"event-loop","date":"2019-12-11T04:35:19.044Z","updated":"2019-12-11T04:35:19.044Z","comments":true,"path":"2019/12/11/event-loop/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/event-loop/","excerpt":"实际上浏览器的事件循环标准是由 HTML 标准规定的，具体来说就是由whatwg规定的，具体内容可以参考event-loops in browser。而NodeJS中事件循环其实也略有不同，具体可以参考event-loops in nodejs 我们在讲解事件模型的时候，多次提到了事件循环。 事件指的是其所处理的对象就是事件本身，每一个浏览器都至少有一个事件循环，一个事件循环至少有一个任务队列。循环指的是其永远处于一个“无限循环”中。不断将注册的回调函数推入到执行栈。 那么事件循环究竟是用来做什么的？浏览器的事件循环和NodeJS的事件循环有什么不同？让我们从零开始，一步一步探究背后的原因。","text":"实际上浏览器的事件循环标准是由 HTML 标准规定的，具体来说就是由whatwg规定的，具体内容可以参考event-loops in browser。而NodeJS中事件循环其实也略有不同，具体可以参考event-loops in nodejs 我们在讲解事件模型的时候，多次提到了事件循环。 事件指的是其所处理的对象就是事件本身，每一个浏览器都至少有一个事件循环，一个事件循环至少有一个任务队列。循环指的是其永远处于一个“无限循环”中。不断将注册的回调函数推入到执行栈。 那么事件循环究竟是用来做什么的？浏览器的事件循环和NodeJS的事件循环有什么不同？让我们从零开始，一步一步探究背后的原因。 为什么要有事件循环JS引擎要回答这个问题，我们先来看一个简单的例子： 12345678function c() &#123;&#125;function b() &#123; c();&#125;function a() &#123; b();&#125;a(); 以上一段简单的JS代码，究竟是怎么被浏览器执行的？ 首先，浏览器想要执行JS脚本，需要一个“东西”，将JS脚本（本质上是一个纯文本），变成一段机器可以理解并执行的计算机指令。这个“东西”就是JS引擎，它实际上会将JS脚本进行编译和执行，整个过程非常复杂，这里不再过多介绍，感兴趣可以期待下我的V8章节，如无特殊说明，以下都拿V8来举例子。 有两个非常核心的构成，执行栈和堆。执行栈中存放正在执行的代码，堆中存放变量的值，通常是不规则的。 当V8执行到a()这一行代码的时候，a会被压入栈顶。 在a的内部，我们碰到了b()，这个时候b被压入栈顶。 在b的内部，我们又碰到了c()，这个时候c被压入栈顶。 c执行完毕之后，会从栈顶移除。 函数返回到b，b也执行完了，b也从栈顶移除。 同样a也会被移除。 整个过程用动画来表示就是这样的： (在线观看) 这个时候我们还没有涉及到堆内存和执行上下文栈，一切还比较简单，这些内容我们放到后面来讲。 DOM 和 WEB API现在我们有了可以执行JS的引擎，但是我们的目标是构建用户界面，而传统的前端用户界面是基于DOM构建的，因此我们需要引入DOM。DOM是文档对象模型，其提供了一系列JS可以直接调用的接口，理论上其可以提供其他语言的接口，而不仅仅是JS。 而且除了DOM接口可以给JS调用，浏览器还提供了一些WEB API。 DOM也好，WEB API也好，本质上和JS没有什么关系，完全不一回事。JS对应的ECMA规范，V8用来实现ECMA规范，其他的它不管。 这也是JS引擎和JS执行环境的区别，V8是JS引擎，用来执行JS代码，浏览器和Node是JS执行环境，其提供一些JS可以调用的API即JS bindings。 由于浏览器的存在，现在JS可以操作DOM和WEB API了，看起来是可以构建用户界面啦。 有一点需要提前讲清楚，V8只有栈和堆，其他诸如事件循环，DOM，WEB API它一概不知。原因前面其实已经讲过了，因为V8只负责JS代码的编译执行，你给V8一段JS代码，它就从头到尾一口气执行下去，中间不会停止。 另外这里我还要继续提一下，JS执行栈和渲染线程是相互阻塞的。为什么呢？ 本质上因为JS太灵活了，它可以去获取DOM中的诸如坐标等信息。 如果两者同时执行，就有可能发生冲突，比如我先获取了某一个DOM节点的x坐标，下一时刻坐标变了。 JS又用这个“旧的”坐标进行计算然后赋值给DOM，冲突便发生了。 解决冲突的方式有两种： 限制JS的能力，你只能在某些时候使用某些API。 这种做法极其复杂，还会带来很多使用不便。 JS和渲染线程不同时执行就好了，一种方法就是现在广泛采用的相互阻塞。 实际上这也是目前浏览器广泛采用的方式。 单线程 or 多线程 or 异步前面提到了你给V8一段JS代码，它就从头到尾一口气执行下去，中间不会停止。 为什么不停止，可以设计成可停止么，就好像C语言一样？ 假设我们需要获取用户信息，获取用户的文章，获取用的朋友。 单线程无异步由于是单线程无异步，因此我们三个接口需要采用同步方式。 123fetchUserInfoSync().then(doSomethingA); // 1sfetchMyArcticlesSync().then(doSomethingB);// 3sfetchMyFriendsSync().then(doSomethingC);// 2s 由于上面三个请求都是同步执行的，因此上面的代码会先执行fetchUserInfoSync，一秒之后执行fetchMyArcticlesSync，再过三秒执行fetchMyFriendsSync。 最可怕的是我们刚才说了JS执行栈和渲染线程是相互阻塞的。 因此用户就在这期间根本无法操作，界面无法响应，这显然是无法接受的。 多线程无异步由于是多线程无异步，虽然我们三个接口仍然需要采用同步方式，但是我们可以将代码分别在多个线程执行，比如我们将这段代码放在三个线程中执行。 线程一： 1fetchUserInfoSync().then(doSomethingA); // 1s 线程二： 1fetchMyArcticlesSync().then(doSomethingB); // 3s 线程三： 1fetchMyFriendsSync().then(doSomethingC); // 2s 由于三块代码同时执行，因此总的时间最理想的情况下取决与最慢的时间，也就是3s，这一点和使用异步的方式是一样的（当然前提是请求之间无依赖）。为什么要说最理想呢？由于三个线程都可以对DOM和堆内存进行访问，因此很有可能会冲突，冲突的原因和我上面提到的JS线程和渲染线程的冲突的原因没有什么本质不同。因此最理想情况没有任何冲突的话是3s，但是如果有冲突，我们就需要借助于诸如锁来解决，这样时间就有可能高于3s了。 相应地编程模型也会更复杂，处理过锁的程序员应该会感同身受。 单线程 + 异步如果还是使用单线程，改成异步是不是会好点？问题的是关键是如何实现异步呢？这就是我们要讲的主题 - 事件循环。 事件循环究竟是怎么实现异步的？我们知道浏览器中JS线程只有一个，如果没有事件循环，就会造成一个问题。 即如果JS发起了一个异步IO请求，在等待结果返回的这个时间段，后面的代码都会被阻塞。 我们知道JS主线程和渲染进程是相互阻塞的，因此这就会造成浏览器假死。 如何解决这个问题？ 一个有效的办法就是我们这节要讲的事件循环。 其实事件循环就是用来做调度的，浏览器和NodeJS中的事件循坏就好像操作系统的调度器一样。操作系统的调度器决定何时将什么资源分配给谁。对于有线程模型的计算机，那么操作系统执行代码的最小单位就是线程，资源分配的最小单位就是进程，代码执行的过程由操作系统进行调度，整个调度过程非常复杂。 我们知道现在很多电脑都是多核的，为了让多个core同时发挥作用，即没有一个core是特别闲置的，也没有一个core是特别累的。操作系统的调度器会进行某一种神秘算法，从而保证每一个core都可以分配到任务。 这也就是我们使用NodeJS做集群的时候，Worker节点数量通常设置为core的数量的原因，调度器会尽量将每一个Worker平均分配到每一个core，当然这个过程并不是确定的，即不一定调度器是这么分配的，但是很多时候都会这样。 了解了操作系统调度器的原理，我们不妨继续回头看一下事件循环。 事件循环本质上也是做调度的，只不过调度的对象变成了JS的执行。事件循环决定了V8什么时候执行什么代码。V8只是负责JS代码的解析和执行，其他它一概不知。浏览器或者NodeJS中触发事件之后，到事件的监听函数被V8执行这个时间段的所有工作都是事件循环在起作用。 我们来小结一下： 对于V8来说，它有： 调用栈（call stack） 这里的单线程指的是只有一个call stack。只有一个call stack 意味着同一时间只能执行一段代码。 堆（heap） 对于浏览器运行环境来说： WEB API DOM API 任务队列 事件来触发事件循环进行流动 以如下代码为例： 12345678function c() &#123;&#125;function b() &#123; c();&#125;function a() &#123; setTimeout(b, 2000)&#125;a(); 执行过程是这样的： (在线观看) 因此事件循环之所以可以实现异步，是因为碰到异步执行的代码“比如fetch，setTimeout”，浏览器会将用户注册的回调函数存起来，然后继续执行后面的代码。等到未来某一个时刻，“异步任务”完成了，会触发一个事件，浏览器会将“任务的详细信息”作为参数传递给之前用户绑定的回调函数。具体来说，就是将用户绑定的回调函数推入浏览器的执行栈。 但并不是说随便推入的，只有浏览器将当然要执行的JS脚本“一口气”执行完，要”换气“的时候才会去检查有没有要被处理的“消息”。如果于则将对应消息绑定的回调函数推入栈。当然如果没有绑定事件，这个事件消息实际上会被丢弃，不被处理。比如用户触发了一个click事件，但是用户没有绑定click事件的监听函数，那么实际上这个事件会被丢弃掉。 我们来看一下加入用户交互之后是什么样的，拿点击事件来说： 12345678910111213$.on('button', 'click', function onClick() &#123; setTimeout(function timer() &#123; console.log('You clicked the button!'); &#125;, 2000);&#125;);console.log(\"Hi!\");setTimeout(function timeout() &#123; console.log(\"Click the button!\");&#125;, 5000);console.log(\"Welcome to loupe.\"); 上述代码每次点击按钮，都会发送一个事件，由于我们绑定了一个监听函数。因此每次点击，都会有一个点击事件的消息产生，浏览器会在“空闲的时候”对应将用户绑定的事件处理函数推入栈中执行。 伪代码: 12345while (true) &#123; if (queue.length &gt; 0) &#123; queue.processNextMessage() &#125;&#125; 动画演示： (在线观看) 加入宏任务&amp;微任务我们来看一个更复制的例子感受一下。 12345678910111213console.log(1)setTimeout(() =&gt; &#123; console.log(2)&#125;, 0)Promise.resolve().then(() =&gt; &#123; return console.log(3)&#125;).then(() =&gt; &#123; console.log(4)&#125;)console.log(5) 上面的代码会输出：1、5、3、4、2。 如果你想要非常严谨的解释可以参考 whatwg 对其进行的描述 -event-loop-processing-model。 下面我会对其进行一个简单的解释。 浏览器首先执行宏任务，也就是我们script（仅仅执行一次） 完成之后检查是否存在微任务，然后不停执行，直到清空队列 执行宏任务 其中： 宏任务主要包含：setTimeout、setInterval、setImmediate、I/O、UI交互事件 微任务主要包含：Promise、process.nextTick、MutaionObserver 等 有了这个知识，我们不难得出上面代码的输出结果。 由此我们可以看出，宏任务&amp;微任务只是实现异步过程中，我们对于信号的处理顺序不同而已。如果我们不加区分，全部放到一个队列，就不会有宏任务&amp;微任务。这种人为划分优先级的过程，在某些时候非常有用。 加入执行上下文栈说到执行上下文，就不得不提到浏览器执行JS函数其实是分两个过程的。一个是创建阶段Creation Phase,一个是执行阶段Execution Phase。 同执行栈一样，浏览器每遇到一个函数，也会将当前函数的执行上下文栈推入栈顶。 举个例子： 1234567891011function a(num) &#123; function b(num) &#123; function c(num) &#123; const n = 3 console.log(num + n) &#125; c(num); &#125; b(num);&#125;a(1); 遇到上面的代码。 首先会将a的压入执行栈，我们开始进行创建阶段Creation Phase， 将a的执行上下文压入栈。然后初始化a的执行上下文，分别是VO，ScopeChain（VO chain）和 This。 从这里我们也可以看出，this其实是动态决定的。VO指的是variables, functions 和 arguments。 并且执行上下文栈也会同步随着执行栈的销毁而销毁。 伪代码表示： 12345const EC = &#123; 'scopeChain': &#123; &#125;, 'variableObject': &#123; &#125;, 'this': &#123; &#125;&#125; 我们来重点看一下ScopeChain(VO chain)。如上图的执行上下文大概长这个样子，伪代码： 12345678910111213141516171819202122232425262728global.VO = &#123; a: pointer to a(), scopeChain: [global.VO]&#125;a.VO = &#123; b: pointer to b(), arguments: &#123; 0: 1 &#125;, scopeChain: [a.VO, global.VO]&#125;b.VO = &#123; c: pointer to c(), arguments: &#123; 0: 1 &#125;, scopeChain: [b.VO, a.VO, global.VO]&#125;c.VO = &#123; arguments: &#123; 0: 1 &#125;, n: 3 scopeChain: [c.VO, b.VO, a.VO, global.VO]&#125; 引擎查找变量的时候，会先从VOC开始找，找不到会继续去VOB…，直到GlobalVO，如果GlobalVO也找不到会返回Referrence Error，整个过程类似原型链的查找。 值得一提的是，JS是词法作用域，也就是静态作用域。换句话说就是作用域取决于代码定义的位置，而不是执行的位置，这也就是闭包产生的本质原因。 如果上面的代码改造成下面的： 123456function c() &#123;&#125;function b() &#123;&#125;function a() &#123;&#125;a()b()c() 或者这种： 12345678function c() &#123;&#125;function b() &#123; c();&#125;function a() &#123; b();&#125;a(); 其执行上下文栈虽然都是一样的，但是其对应的scopeChain则完全不同，因为函数定义的位置发生了变化。拿上面的代码片段来说,c.VO会变成这样： 123c.VO = &#123; scopeChain: [c.VO, global.VO]&#125; 也就是说其再也无法获取到a和b中的VO了。 总结通过这篇文章，希望你对单线程，多线程，异步，事件循环，事件驱动等知识点有了更深的理解和感悟。除了这些大的层面，我们还从执行栈，执行上下文栈角度讲解了我们代码是如何被浏览器运行的，我们顺便还解释了作用域和闭包产生的本质原因。 最后我总结了一个浏览器运行代码的整体原理图，希望对你有帮助： 下一节浏览器的事件循环和NodeJS的事件循环有什么不同, 敬请期待～ 参考 Node.js event loop - logrocket event-loop - nodejs.org what-is-the-execution-context-in-javascript Event Loop in JS - youtube","categories":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/categories/前端/"},{"name":"浏览器","slug":"前端/浏览器","permalink":"https://lucifer.ren/blog/categories/前端/浏览器/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/tags/前端/"},{"name":"浏览器","slug":"浏览器","permalink":"https://lucifer.ren/blog/tags/浏览器/"},{"name":"事件循环","slug":"事件循环","permalink":"https://lucifer.ren/blog/tags/事件循环/"}]},{"title":"每日一荐 2019-10 汇总","slug":"daily-featured-2019-10","date":"2019-12-11T04:35:19.043Z","updated":"2019-12-11T04:35:19.044Z","comments":true,"path":"2019/12/11/daily-featured-2019-10/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/daily-featured-2019-10/","excerpt":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。","text":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。 2019-102019-10-31[技能]虽然我们不是专门的网络工程师，但是不免在实际工作以及面试中会需要这方面的知识，当然这是浅层的即可。如果完全不知道，那么对于一些网络性能优化问题肯定是没有概念，从而无从下手的。 网上关于HTTP协议的文章很多，面试的时候关于HTTP三大版本的差异也是热门考点。这篇文章就通俗易懂地解释了HTTP/2与HTTP/3 的新特性, 相比于之前，为什么要推出新的协议，核心解决了什么问题？有什么不足？ 这些东西网上资料要么就是太专业，要么就是太笼统和人云亦云，这篇文章是相对比较适合新手读的一个文章。 文章地址： https://segmentfault.com/a/1190000020714686#articleHeader16 2019-10-30[类库]很多年前我自己写过一个简陋的pub/sub库, 这个仓库甚至被一些人在用。很多时候我们需要用到这种灵活的pub/sub功能，这个时候我们就会自己实现，或者用一些开源的。 今天给大家介绍的就是鼎鼎大名的Jason Miller写的一个tiny event pub sub implement，代码就几十行，不仅注释详实，而且给出了丰富的类型定义，代码简单易懂，非常适合学习。 代码地址： https://github.com/developit/mitt/blob/master/src/index.js 2019-10-29[网站]上一次给大家分享了一个常用正则的VSCode插件（2019-10-11期），另外的《大前端面试宝典》也讲到了正则的学习，并给出了我认为非常不错的学习资料。 今天我继续给大家介绍几个正则学习&amp;练习的网站。 Regex Golf 是一个有名的正则练习网站，会根据你的正则打分，难度偏高。 regexone 是一个交互友好，面向新手的一个正则练习网站，可以交互式地学习正则，右边还贴心地给出了Notes，另外语言不同其实正则规范也不太一样，这个网站给出了不同语言的正则讲解，很用心。值得一题的是，里面的资料非常新，最新的/u- interpret the regular expression as unicode codepoints 都有。 regexr这个不是练习的， 是用来可视化的， 和之前的regexper有点像，就连域名都差不多，不过这个用户体验是真的棒。 The regular expression game 是一个过关类型的正则练习网站，有意思的是它可以根据你写的正则匹配程度进行打分，即使你没有全部匹配也是可以得分的。 2019-10-28[工具]这个是人称贺老的百姓网贺师俊Hax整理的一份中文技术活动日程， 这些活动有几个特点： 技术活动的主要语言是中文 技术活动的主要参与者是程序员 技术活动的主要日程接受公开报名 技术活动具有一定规模 目前这个仓库仅有个简陋的 yaml 数据文件，记录技术活动的时间和一些信息。后续希望能加入一个更好的查询界面。活动组织者可直接修改数据文件并提交PR，或提交issue描述一下活动情况。活动组织者也可以 watch 本仓库，这样当有变动时（通常是会议信息更新），可以收到通知。 仓库地址：https://github.com/hax/chinese-tech-conf-schedule 2019-10-25[工具]今天给大家推荐的是一个我个人非常喜欢的一个好用且免费图床工具 - IPic。 这个工具不仅内置免费的微博图床,还可以自己定义，我本人还添加了腾讯云的COS 使用起来也非常简单，直接复制图片，然后点击对应的图片即可，另外值得一提的是它本身还支持直接生成MardDown链接，这对经常用MarkDown写作的我来说绝对是一个非常实用的功能。 另外它还搭配了一个软件IPic Mover用来迁移图床，比如你的文章里面都是新浪图床，只需要一键就可以瞬间迁移到别的平台，比如腾讯云COS。 不过这个搭配的工具是收费的，但是有免费体验时间。 2019-10-24[技能]今天是1024程序员节，祝广大的程序员们节日快乐。🎩🎩🎩🎩🎩🎩 之前给大家介绍了一款跨平台的Web平台技术栈检测工具Wappalyzer。这几天我看了下他的源码，觉得很不错，于是就想着推荐给大家。 Wappalyzer的整体架构非常有意思，这里讲一下我发现的主要特点，更多细节等待着你的探索。 平台相关的代码放在drivers文件夹下，公共的代码在src/wappalyzer.js 特地写了validate脚本来检测代码。 将检测逻辑抽离到了src/app.json中， 以配置文件的形式存放（这个json文件结构设计地很精巧，应该是花了心思的） 主要采用正则来检测应用 考虑到间接引用，比如框架A引用了B，那么检测到了A也会把B带上 如果想快速上手可以看下ta提供的测试用例，非常简洁。 Github地址： https://github.com/AliasIO/Wappalyzer 2019-10-23[网站]今天给广大的前端朋友们介绍一个在线做题的网站，可以瞬间在线知道答案，而且不需要登陆，一共58道题目，不知道后续会不会更新。 这个网站的题目我看了其实没有什么新意，但是不需要登陆而是直接使用LocalStorage来存储你的答题情况对用户来说很轻量，给我的感觉很好，感兴趣的可以试一下。 (题目列表) (题目详情) 网址： https://quiz.typeofnan.dev/ 2019-10-22[观点]前一段时间王思聪的股权遭到了冻结，据中新经纬记者计算，王思聪名下冻结股权价值合计已经超过8445万元。 “这种情况一般是王思聪欠别人钱，别人追讨，作为诉讼保全措施冻结的。”金杜律师事务所律师李量接受虎嗅采访时说，“王思聪欠钱可以是直接欠，或和贾跃亭一样，给别人提供担保，承担了连带责任。” 但是实际上这种冻结对于王思聪来说根本起不到作用，他会有很多方法来免除所谓的强制执行，他只要将自己的股权先一步将股权质押给万达集团，这样质押权人就对被保全的股份有优先权, 换句话说这对王思聪来说这种冻结根本无效。 现实中有很多这样的事情，这些规则似乎是在限制那些“能力不足”的人，而对社会上这些“制造规则的人”无能为力。更可悲的是，很多人对这些不知道，不关注。其实越是贫穷的家庭，越是生活在社会底层的人，他们的后代，大概率还会是穷人。其实，我们奋斗的目标无非就是：让子女一出生就站在了别人的肩膀上！ 2019-10-21[效率]我是一个有着轻微强迫症的人，社交软件的小红点有时候会打乱我的节奏，将我从专注模式(Focus Mode)强制转化为发散模式（Diffuse Mode）。 这两种模式适合我们做不同类型的工作，因此掌控小红点，避免这种不希望的模式切换是提高效率的一个有效途径。 我的做法是： 手机静音 电脑关闭红点提醒 mac电脑可以在系统偏好设置 - 通知 - 对应APP - 将标记应用程序的勾去掉 一般而言，你也不用担心会错过什么东西，因为右侧通知还是会有的，比如钉钉的会议提醒等。 经过这样的设置，你就可以自由切换两种模式，而不会被频繁打断，当然还是会有人来打断你，这个问题我们以后再讲。 2019-10-18[类库]UMI的官方定位是可插拔的企业级 react 应用框架。其作者云谦也是Ant-Design，dvajs的核心贡献者，同时也是我早期关注的人之一。这个项目的价值绝对不亚于更受大家欢迎的dvajs，是一个值得学习的项目。 说白了，Umi 和 create-react-app（cra）类似，就是现有技术栈的组合，封装细节，让开发者用起来更简单，只写业务代码就可以了，它有几个特点： 零配置就是默认选型都给你做好了。 开箱即用就是技术栈都固化了。 约定大于配置，开发模式也固化好了。 下图是云谦介绍umi的定位的时候贴的一张架构图： 项目地址：https://github.com/umijs/umi 2019-10-17[工具]之前分享过《2019-09-23 - 为什么一行80个字符是一个值得遵守的规范，即使你拥有4k显示器？》，里面提到了并排窗口的问题。 多个显示器确实可以提高效率，如果你能高效地利用每一个显示器，效果会更棒。 配合4k大屏显示器效果更棒 今天介绍的这款工具就是一款窗口布局工具，能够快速修改当前窗口大小并放置在指定位置，Moom 默认操作点设立在了窗口左上角的绿色按钮上，将鼠标hover在绿钮上就会弹出一个选择菜单，里面有五种尺寸可选，单击选项即可变化窗口大小，并能将窗口移动到指定位置。 搭配使用快捷键效果更棒 2019-10-16[工具]今天给大家推荐的是一款非常好用的Chrome插件，可以用来查看网站是由什么技术栈构建的。其实类似的软件也有别的，但是这个是我使用过的最好的一个。 （这个是其官网的检测结果） （这个是GitHub的检测结果） 项目主页： https://www.wappalyzer.com 2019-10-15[技能]今天给大家分享一个微信小技巧，据说有的人还不知道，所以今天就把它分享出来，大家如果有什么微信使用小技巧也欢迎在下方进行评论。 今天的小技巧是判断对方是否把你拉黑或者删除: 给对方转账，是好友会让你输入密码，不是好友都不用你输入密码，直接弹出下图，整个过程好友不知情的！ 如果拉黑会提示： 请确认你和他（她）的好友关系是否正常 如果删除，则会提示： 你不是收款方的好友 点开好友名片，如果显示左图，说明她真的没有发过一条朋友圈。若显示右图，点开个人相册却什么也看不到，那么你有可能被删除、拉黑、朋友圈屏蔽，或者发过朋友圈但设为私密了。 为了搞清楚对方是删除还是屏蔽，你就可以用到开头转账的那一招啦！ 2019-10-14[好文]如果想做一些高级的东西，编译是一个绕不过的坎，Babel是一个前端的转义工具，Babel有着自己的插件系统，这是个系列文章，通过这个系列你可以学到AST，以及Babel插件相关的东西，并且你可以自己动手写一个Babel插件。 文章地址： Step-by-step guide for writing a custom babel transformation Creating custom JavaScript syntax with Babel 2019-10-12[工具]前端在调试兼容性样式的时候是一个很头疼的问题，各个浏览器以及同一个浏览器不同版本支持的css都是不同的，比如有些不支持Grid，有些不支持cal函数。如果你自己根据这些去修改代码肯定是非常低效的，这个Chrome插件就是解决这样的问题，你可以在高级的浏览器上调试，自行禁用一些css特性来debug。 仓库地址： https://github.com/keithclark/css-feature-toggle-devtools-extension chrome插件地址： https://chrome.google.com/webstore/detail/css-feature-toggles/aeinmfddnniiloadoappmdnffcbffnjg 2019-10-11[工具]常用正则大全, 支持vscode扩展插件 值得一提的是它支持VSCode插件形式使用： 目前有57个正则： 插件地址： https://github.com/any86/any-rule 2019-10-10[技能]傅里叶变换是一种在各个领域都经常使用的数学工具。这个网站将为你介绍傅里叶变换能干什么，为什么傅里叶变换非常有用，以及你如何利用傅里叶变换干漂亮的事。傅立叶变换有很多实际的应用，比如MP3的原理，MP3是如何将声波转化为二进制，并如何进行压缩的？ 比如JPEG的原理等。 这个文章（网站）是我见过傅立叶变换最直观的一个解释之一，并且支持交互式操作。 网站地址： http://www.jezzamon.com/fourier/zh-cn.html 2019-10-09[工具]VSCode是我经常使用的一个软件，结合自己的开发习惯我也会增加很多配置和插件等，如何将这些插件进行备份以便将来换电脑可以及时同步过来，这里关于VScode的配置我用的是VSCode setting sync 插件。 这个需要结合Gist使用，具体使用方式请查看官方文档： 其实我有一个专门的开发常用配置文件备份仓库用来存放这些东西，这是我的仓库存放的配置，这样我即使换了电脑也能很快地用到我最舒服的配置。 如果大家没有更好的方式，不妨采用这种方式，如果你有更好的方式欢迎给我留言。 2019-10-08[工具]今天是国庆结束的第一天，大家假期玩的怎么样？ 希望大家可以尽快从假期的状态中转变回来。今天给大家推荐一个我个人使用比较多的一个功能，就是剪贴板历史。 我在使用手机的时候（笔者使用的是安卓机），会经常复制一些文字或者图片，然后进行粘贴，有时候会需要粘贴之前复制的一个东西，因此剪贴板历史就显得很重要，手机上我用的就是搜索输入法自带的剪贴板历史功能。 而在电脑上我使用的是Alfred自带的剪贴板历史功能，只不过默认不开启，你需要去配置一下才行。 然后你就可以查看你的剪贴板历史了： 关注我我重新整理了下自己的公众号，并且我还给它换了一个名字脑洞前端，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。 在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。 之后我的文章会同步到微信公众号 脑洞前端 ，你可以关注获取最新的文章，并和我进行交流。 另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。","categories":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/categories/每日一荐/"},{"name":"2019-10","slug":"每日一荐/2019-10","permalink":"https://lucifer.ren/blog/categories/每日一荐/2019-10/"}],"tags":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/tags/每日一荐/"}]},{"title":"布隆过滤器","slug":"bloom-filter","date":"2019-12-11T04:35:19.042Z","updated":"2020-04-13T06:50:26.819Z","comments":true,"path":"2019/12/11/bloom-filter/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/bloom-filter/","excerpt":"假设你现在要处理这样一个问题，你有一个网站并且拥有很多访客，每当有用户访问时，你想知道这个ip是不是第一次访问你的网站。你会怎么做呢？","text":"假设你现在要处理这样一个问题，你有一个网站并且拥有很多访客，每当有用户访问时，你想知道这个ip是不是第一次访问你的网站。你会怎么做呢？ hashtable 可以么一个显而易见的答案是将所有的ip用hashtable存起来，每次访问都去hashtable中取，然后判断即可。但是题目说了网站有很多访客，假如有10亿个用户访问过，每个ip的长度是4 byte，那么你一共需要4 * 1000000000 = 4000000000Bytes = 4G , 如果是判断URL黑名单，由于每个URL会更长，那么需要的空间可能会远远大于你的期望。 bit另一个稍微难想到的解法是bit， 我们知道bit有0和1两种状态，那么用来表示存在，不存在再合适不过了。 加入有10亿个ip，我们就可以用10亿个bit来存储，那么你一共需要 1 * 1000000000 = (4000000000 / 8) Bytes = 128M, 变为原来的1/32,如果是存储URL这种更长的字符串，效率会更高。 基于这种想法，我们只需要两个操作，set(ip) 和 has(ip) 这样做有两个非常致命的缺点： 当样本分布极度不均匀的时候，会造成很大空间上的浪费 我们可以通过散列函数来解决 当元素不是整型（比如URL）的时候，BitSet就不适用了 我们还是可以使用散列函数来解决， 甚至可以多hash几次 布隆过滤器布隆过滤器其实就是bit + 多个散列函数, 如果经过多次散列的值再bit上都为1，那么可能存在(可能有冲突)。 如果有一个不为1，那么一定不存在（一个值经过散列函数得到的值一定是唯一的），这也是布隆过滤器的一个重要特点。 布隆过滤器的应用 网络爬虫判断某个URL是否已经被爬取过 K-V数据库 判断某个key是否存在 比如Hbase的每个Region中都包含一个BloomFilter，用于在查询时快速判断某个key在该region中是否存在。 钓鱼网站识别 浏览器有时候会警告用户，访问的网站很可能是钓鱼网站，用的就是这种技术 从这个算法大家可以对 tradeoff(取舍) 有更入的理解。","categories":[{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"布隆过滤器","slug":"算法/布隆过滤器","permalink":"https://lucifer.ren/blog/categories/算法/布隆过滤器/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"}]},{"title":"浏览器事件模型","slug":"browser-event","date":"2019-12-11T04:35:19.042Z","updated":"2019-12-11T04:35:19.042Z","comments":true,"path":"2019/12/11/browser-event/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/browser-event/","excerpt":"我想你很可能听说过事件驱动, 但是事件驱动到底是什么？为什么说浏览器是事件驱动的呢？为什么 NodeJS 也是事件驱动的 ？ 两者是一回事么？ 实际上不管是浏览器还是 Nodejs 都是事件驱动的，都有自己的事件模型。在这里，我们只讲解浏览器端的事件模型，如果对 Nodejs 事件模型感兴趣的，请期待我的 Nodejs 部分的讲解。","text":"我想你很可能听说过事件驱动, 但是事件驱动到底是什么？为什么说浏览器是事件驱动的呢？为什么 NodeJS 也是事件驱动的 ？ 两者是一回事么？ 实际上不管是浏览器还是 Nodejs 都是事件驱动的，都有自己的事件模型。在这里，我们只讲解浏览器端的事件模型，如果对 Nodejs 事件模型感兴趣的，请期待我的 Nodejs 部分的讲解。 什么是事件驱动事件驱动通俗地来说就是什么都抽象为事件。 一次点击是一个事件 键盘按下是一个事件 一个网络请求成功是一个事件 页面加载是一个事件 页面报错是一个事件 … 浏览器依靠事件来驱动APP运行下去，如果没有了事件驱动，那么APP会直接从头到尾运行完，然后结束，事件驱动是浏览器的基石。 本篇文章不讲解事件循环的内容，事件循环部分会在本章的其他章节讲解，敬请期待。 一个简单的例子其实现实中的红绿灯就是一种事件，它告诉我们现在是红灯状态，绿灯状态，还是黄灯状态。 我们需要根据这个事件自己去完成一些操作，比如红灯和黄灯我们需要等待，绿灯我们可以过马路。 下面我们来看一个最简单的浏览器端的事件： html代码： 1&lt;button&gt;Change color&lt;/button&gt; js代码： 12345var btn = document.querySelector('button');btn.onclick = function() &#123; console.log('button clicked')&#125; 代码很简单，我们在button上注册了一个事件，这个事件的handler是一个我们定义的匿名函数。当用户点击了这个被注册了事件的button的时候，这个我们定义好的匿名函数就会被执行。 如何绑定事件我们有三种方法可以绑定事件，分别是行内绑定，直接赋值，用addEventListener。 内联 这个方法非常不推荐 html代码： 1&lt;button onclick=\"handleClick()\"&gt;Press me&lt;/button&gt; 然后在script标签内写： 123function handleClick() &#123; console.log('button clicked')&#125; 直接赋值 和我上面举的例子一样： 12345var btn = document.querySelector('button');btn.onclick = function() &#123; console.log('button clicked')&#125; 这种方法有两个缺点 不能添加多个同类型的handler12btn.onclick = functionA;btn.onclick = functionB; 这样只有functionB有效，这可以通过addEventListener来解决。 不能控制在哪个阶段来执行，这个会在后面将事件捕获/冒泡的时候讲到。这个同样可以通过addEventListener来解决。 因此addEventListener横空出世，这个也是目前推荐的写法。 addEventListener 旧版本的addEventListener第三个参数是bool，新版版的第三个参数是对象，这样方便之后的扩展，承载更多的功能, 我们来重点介绍一下它。 addEventListener可以给Element，Document，Window，甚至XMLHttpRequest等绑定事件，当指定的事件发生的时候，绑定的回调函数就会被以某种机制进行执行，这种机制我们稍后就会讲到。 语法： 123target.addEventListener(type, listener[, options]);target.addEventListener(type, listener[, useCapture]);target.addEventListener(type, listener[, useCapture, wantsUntrusted ]); // Gecko/Mozilla only type是你想要绑定的事件类型，常见的有click, scroll, touch, mouseover等，旧版本的第三个参数是bool，表示是否是捕获阶段，默认是false，即默认为冒泡阶段。新版本是一个对象，其中有capture（和上面功能一样），passive和once。 once用来执行是否只执行一次，passive如果被指定为true表示永远不会执行preventDefault(),这在实现丝滑柔顺的滚动的效果中很重要。更多请参考Improving scrolling performance with passive listeners 框架中的事件实际上，我们现在大多数情况都是用框架来写代码，因此上面的情况其实在现实中是非常少见的，我们更多看到的是框架封装好的事件，比如React的合成事件，感兴趣的可以看下这几篇文章。 React SyntheticEvent Vue和React的优点分别是什么？两者的最核心差异对比是什么？ 虽然我们很少时候会接触到原生的事件，但是了解一下事件对象，事件机制，事件代理等还是很有必要的，因为框架的事件系统至少在这方面还是一致的，这些内容我们接下来就会讲到。 事件对象所有的事件处理函数在被浏览器执行的时候都会带上一个事件对象，举个例子： 12345function handleClick(e) &#123; console.log(e);&#125; btn.addEventListener('click', handleClick); 这个e就是事件对象，即event object。 这个对象有一些很有用的属性和方法，下面举几个常用的属性和方法。 属性 target x, y等位置信息 timeStamp eventPhase … 方法 preventDefault 用于阻止浏览器的默认行为，比如a标签会默认进行跳转，form会默认校验并发送请求到action指定的地址等 stopPropagation 用于阻止事件的继续冒泡行为，后面讲事件传播的时候会提到。 … 事件传播 前面讲到了事件默认是绑定到冒泡阶段的，如果你显式令useCapture为true，则会绑定到捕获阶段。 事件捕获很有意思，以至于我会经常出事件的题目加上一点事件传播的机制，让候选人进行回答，这很能体现一个人的水平。了解事件的传播机制，对于一些特定问题有着非常大的作用。 一个Element上绑定的事件触发了，那么其实会经过三个阶段。 第一个阶段 - 捕获阶段 从最外层即HTML标签开始，检查当前元素有没有绑定对应捕获阶段事件，如果有则执行，没有则继续往里面传播，这个过程递归执行直到触达触发这个事件的元素为止。 伪代码： 1234567891011121314151617function capture(e, currentElement) &#123; if (currentElement.listners[e.type] !== void 0) &#123; currentElement.listners[e.type].forEach(fn =&gt; fn(e)) &#125; // pass down if (currentElement !== e.target) &#123; // getActiveChild用于获取当前事件传播链路上的子节点 capture(e, getActiveChild(currentElement, e)) &#125; else &#123; bubble(e, currentElement) &#125;&#125;// 这个Event对象由引擎创建capture(new Event(), document.querySelector('html')) 第二个阶段 - 目标阶段 上面已经提到了，这里省略了。 第三个阶段 - 冒泡阶段 从触发这个事件的元素开始，检查当前元素有没有绑定对应冒泡阶段事件，如果有则执行，没有则继续往里面传播，这个过程递归执行直到触达HTML为止。 伪代码： 123456789function bubble(e, currentElement) &#123; if (currentElement.listners[e.type] !== void 0) &#123; currentElement.listners[e.type].forEach(fn =&gt; fn(e)) &#125; // returning if (currentElement !== document.querySelector('html')) &#123; bubble(e, currentElement.parent) &#125;&#125; 上述的过程用图来表示为： 如果你不希望事件继续冒泡，可以用之前我提到的stopPropagation。 伪代码： 12345678910111213141516171819function bubble(e, currentElement) &#123; let stopped = false; function cb() &#123; stopped = true; &#125; if (currentElement.listners[e.type] !== void 0) &#123; currentElement.listners[e.type].forEach(fn =&gt; &#123; fn(&#123; ...e, stopPropagation: cb &#125;); if (stopped) return; &#125;) &#125; // returning if (currentElement !== document.querySelector('html')) &#123; bubble(e, currentElement.parent) &#125;&#125; 事件代理利用上面提到的事件冒泡机制，我们可以选择做一些有趣的东西。 举个例子： 我们有一个如下的列表，我们想在点击对应列表项的时候，输出是点击了哪个元素。 HTML代码： 123456&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; JS代码： 1document.querySelector('ul').addEventListener('click', e =&gt; console.log(e.target.innerHTML)) 在线地址 上面说了addEventListener会默认绑定到冒泡阶段，因此事件会从目标阶段开始，向外层冒泡，到我们绑定了事件的ul上，ul中通过事件对象的target属性就能获取到是哪一个元素触发的。 “事件会从目标阶段开始”，并不是说事件没有捕获阶段，而是我们没有绑定捕获阶段，我描述给省略了。 我们只给外层的ul绑定了事件处理函数，但是可以看到li点击的时候，实际上会打印出对应li的内容（1，2，3或者4）。 我们无须给每一个li绑定事件处理函数，不仅从代码量还是性能上都有一定程度的提升。 这个有趣的东西，我们给了它一个好听的名字“事件代理”。在实际业务中我们会经常使用到这个技巧，这同时也是面试的高频考点。 总结事件其实不是浏览器特有的，和JS语言也没有什么关系，这也是我为什么没有将其划分到JS部分的原因。很多地方都有事件系统，但是各种事件模型又不太一致。 我们今天讲的是浏览器的事件模型，浏览器基于事件驱动，将很多东西都抽象为事件，比如用户交互，网络请求，页面加载，报错等，可以说事件是浏览器正常运行的基石。 我们在使用的框架都对事件进行了不同程度的封装和处理，除了了解原生的事件和原理，有时候了解一下框架本身对事件的处理也是很有必要的。 当发生一个事件的时候，浏览器会初始化一个事件对象，然后将这个事件对象按照一定的逻辑进行传播，这个逻辑就是事件传播机制。 我们提到了事件传播其实分为三个阶段，按照时间先后顺序分为捕获阶段，目标阶段和冒泡阶段。开发者可以选择监听不同的阶段，从而达到自己想要的效果。 事件对象有很多属性和方法，允许你在事件处理函数中进行读取和操作，比如读取点击的坐标信息，阻止冒泡等。 最后我们通过一个例子，说明了如何利用冒泡机制来实现事件代理。 本文只是一个浏览器事件机制的科普文，并没有也不会涉及到很多细节。希望这篇文章能让你对浏览器时间有更深的理解，如果你对nodejs时间模型感兴趣，请期待我的nodejs事件模型。 事件循环和事件循环也有千丝万缕的联系，如果有时间，我会出一篇关于时间循环的文章。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://lucifer.ren/blog/categories/浏览器/"},{"name":"事件","slug":"浏览器/事件","permalink":"https://lucifer.ren/blog/categories/浏览器/事件/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://lucifer.ren/blog/tags/浏览器/"},{"name":"事件","slug":"事件","permalink":"https://lucifer.ren/blog/tags/事件/"}]},{"title":"每日一荐 2019-09 汇总","slug":"daily-featured-2019-09","date":"2019-12-11T04:35:19.042Z","updated":"2020-02-25T02:41:56.368Z","comments":true,"path":"2019/12/11/daily-featured-2019-09/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/daily-featured-2019-09/","excerpt":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。","text":"每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。 项目主页维护当前月份的内容，想看往期内容，可以去每日一荐主仓库翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。 2019-092019-09-30[工具]今天是 9 月的最后一天，明天就是十一了，提前祝大家国庆节快乐 ～～～ 🎉🎉🎉🎉🎉🎉🎉 ！ 今天再来给大家安利 6 个 chrome 扩展程序，排名不分先后。 Proxy SwitchyOmega 此扩展为 SwitchySharp 的升级版，可替代 SwitchyPlus 或 Proxy Switchy. 可轻松快捷地管理和切换多个代理设置，是一个我使用多年的一个插件，配合 PAC 食用味道更好。 下载地址 OneTab 节省高达 95％的内存，并减轻标签页混乱现象。 有些标签关了舍不得，不关太多看的很乱并且更关键的是占用内存。有了这个工具就不存在这些问题了。 下载地址 AdBlock Plus Adblock Plus 是世界上最流行的浏览器扩展，世界各地有数百万用户在使用它。这是一个社区驱动的开源项目，有数百名志愿者为 Adblock Plus 的成功作出了贡献，以实现所有烦人的广告被自动阻挡。 下载地址 Multi-highlight 普通的网页搜索只能一个一个搜索，不能同时搜索多个关键字，这个扩展提供了这种功能上的扩展。 下载地址 HTML5 Outliner 我平时再看文章或者文档的时候习惯先看一遍目录或者大纲，然后再决定我到底要不要看，看哪里。我相信很多人和我一样有着同样的习惯。但是很多网站，包括 infoq，知乎等大网站这方面都做的比较差。下图是我的个人博客的大纲功能： 因此这款工具对于我这种人来说就非常重要了，他能根据当前网页的结果快速生成大纲，并且支持锚点功能，当然它也有很多覆盖不到的情况，因为标题的种类实现太多了，大家完全可以写一个div class = &#39;header&#39;从而让这个工具无用武之地。 这也从侧面说明了语义化的重要性，不仅对于障碍人士重要，对于无障碍人士也有很大的意义。 下载地址 眼睛护航 把网页背景变成眼睛保护色或适合夜晚阅读的夜间模式，一些无法变色的小区块可以通过单击进行变色。到了晚上将自动从绿色护眼模式变为夜间阅读模式。当然，也可以手动强制使用绿色模式或夜间模式。 这在一些体验差的网站上极为重要，还有一些大量使用亮瞎眼的颜色网站也有很好的作用，类似提升阅读体验的扩展还有简悦。 下载地址 2019-09-29[工具]如果你是一个站长，那么你一定需要一个网站速度测试工具。 你的用户如果都是中国用户，那么用站长工具-国内测试应该就够用了。 如果你的用户有海外的话，可以试试站长工具-国际测试 (国内测速) (国际测试) 不得不吐槽下，网站体验做的不太好，而且广告有点多。 另外还有一个网站，不过这个只能够测试国内的网速，17ce的体验做的稍微好一点，广告也没有那么显眼，如果你的客户只是国内，不妨考虑这个。 最后介绍一个国外的网站pingdom，如果客户是全球的，可以考虑用这个，这个是这几个中用户体验做的最好的。给出的技术指标比较多一点，但是他没有区域分布热力图, 并且支持的区域也不多。 2019-09-27[类库]之前我写了一篇 【前端测试】 的草稿，一直搁置到现在，之前我做后端的时候，写测试尤其是单元测试是很普遍的。但是做前端这么久发现大家对这方面不是很重视， 其实前端也是非常需要做测试的。 今天给大家推荐的是一个非常流行的前端测试框架 jest 的 GUI 工具majestic (⚡ Zero config GUI for Jest) 2019-09-26[工具]你一定有想用某一个功能的快捷键，却想不出来的情况。也一定面临过多个软件快捷键不统一带来的烦恼，比如 A 软件CMD + S是保存， 另外一个软件 B 是Shift + S。 对于第一种问题，我们可以用一个叫 cheatsheet 的 mac 软件，有了它你就可以通过长按 command 键，从而查看当前应用的快捷键。 cheatsheet 下载地址： https://cheatsheet-mac.en.softonic.com/mac 顺便吐槽一下，cheatsheet 官网用户体验这块做的不怎么样 对于按键不统一的问题，我们可以直接修改对应软件的快捷键即可，毕竟大多数软件都是支持快捷键定制的，还有一些服务快捷键我们可以去系统偏好设置 - 键盘 - 服务中修改。 另外给大家安利一个软件Karabiner-Elements, 它是一个 mac 上好用的键盘定制工作，可以用来改键，定制超级键等，更多功能等你挖掘。 配合 HHKB 效果更佳 Karabiner-Elements 下载地址： https://github.com/tekezo/Karabiner-Elements 2019-09-25[技能]熟练使用命令行是一种常常被忽视，或者被认为难以掌握的技能，一旦掌握，会极大提高你工作的效率。当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。 今天介绍的这个仓库，首发于 Quora， 后面迁移到了 Github，并由众多高手做出了许多改进，现在已经有 6W+ Star 了。 仓库目录（目录是我用工具自己抓的，非官方提供）： 仓库地址： https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md 2019-09-24[工具]今天给大家分享的是 VSCode 前一段时间推出的 SSH 扩展，实际使用效果非常棒，除了延迟，让你感觉不到你是在操作远程的文件。虽然有延迟，但是也仅仅限于你和服务器有 IO 交互的情况下才会有感知，结合我的使用体验来说，是“几乎”感觉不到差异（当然也有可能我的网比较快）。 VSCode SSH 扩展允许你连接到远程的主机，虚拟机或者是容器。而你所需要做的仅仅是点击 SSH 面板，然后配置一下就好了，配置也极其简单，对于经常使用 SSH 的你来说千万不要错过了。 下面是官方提供的原理架构图： 地址： https://code.visualstudio.com/docs/remote/ssh 2019-09-23[好文]为什么一行 80 个字符是一个值得遵守的规范，即使你拥有 4k 显示器？ 我个人一直是 80 字符的践行者，不仅仅是因为是这大家都普遍采用的标准，更重要的是我个人更习惯多窗口平铺的方式来展示我的窗口，这样效率更高一点，因此太大肯定会影响窗口平铺，太小又不方便阅读，80 对我来说其实刚刚好，其他比较常见的还有 100 字符等， 现在就让我们来看下为什么一行 80 个字符是一个值得遵守的规范吧。 文章地址： https://nickjanetakis.com/blog/80-characters-per-line-is-a-standard-worth-sticking-to-even-today 2019-09-20[工具]我开启了个人博客，增加了评论，分类，统计，RSS，歌单等功能， 之后的文章会在博客首发。 感兴趣的可以 RSS 订阅我的博客。订阅方法我画了个图。 RSS 是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS 文件包含全文或是节录的文字，再加上发布者所订阅之网摘数据和授权的元数据。 简单来说只要提供了符合 RSS 格式的数据源，你就可以订阅，然后在 RSS 阅读器上进行查看更新内容。 关于 RSS 订阅，今天我推荐的就是一个 RSS 的聚合器 feedly。https://feedly.com Feedly 是一个 RSS 聚合器应用程序，支持各种网页浏览器和运行 iOS 或 Android 的移动设备，也是一个基于云端的服务。其从各种在线资源聚合用户自定的新闻订阅源，并可与他人分享。 后续有机会我会向大家推荐我的 RSS 订阅源。 2019-09-19[工具]今天给大家推荐一款 MarkDown 编辑器。 MarkDown 在程序员中的使用频率是非常高的，Github 是最早一批对 MarkDown 语法支持度比较好的平台之一。我日常写文档，记笔记等都采用 MarkDown 格式来书写。 它不仅书写方便，而且由于其格式比较规范，因此理论上可以通过一些“转换规则”将其转化为各种表现形式，市面上也有很多基于 Markdown 的渲染器，比如markdown-it，也有很多基于这些渲染器制作的产品，比如docsify。 早些时候，我使用的比较多的是MacDown和 VSCode 自带的 Markdown 功能。这两个功能非常简单，但是却能满足我当时的需求，之后我开始经常用 Markdown 更新文章之类的，因此这些就显得不太够用了，现在我用的是 Yu Writer， 算是一个值得推荐的国人开发的 MarkDown 编辑器，功能非常强大而且免费。 你可能听过 MWeb，但是它是收费的，功能和这个比起来也并不占优势。 下载地址：https://ivarptr.github.io/yu-writer.site/ 2019-09-18[工具]前天分享了我的 chrome 插件管理器，今天我们就来分享我的《娱乐插件》。 listen1 娱乐插件第一个要分享的是一个听歌的插件，各个平台都有一些独家的音乐，就像视频网站一样，这就可怜了我们这些消费者。如果想要听所有的音乐就要办理各个 APP 的会员，或者在多个音乐 APP 中切换。 这个插件能让我们听到所有国内几个主流大平台的所有音乐，足不出户畅享所有的音乐，并且值得称赞的是它支持会员系统，你可以保存你的歌单，甚至可以直接登陆你的 Github 账户同步多端的数据。 仓库地址：https://github.com/listen1/listen1 Video Downloader Professional 我主要用它来下载 Youtube 的视频，据说可以下载任何视频网站的视频，但是我亲测了几个网站不可以。 扩展下载地址：https://chrome.google.com/webstore/detail/jpaglkhbmbmhlnpnehlffkgaaapoicnk Bilibili 全家桶 经常看番的朋友怎么能少的了几个好用的插件护体呢？ 这几个插件的功能基本满足了我看番的所有需求，包括弹幕合并，查找弹幕，自动签到，一键直达，猜你喜欢等等，大家可以安装下自己体验。 bilibili 助手 pakku 哔哩哔哩弹幕过滤器 bilibili 猜你喜欢 2019-09-17[学习方法]很多人想要问我“你的成长史是怎么样的？能不能分享一下你的菜鸡成长史”。 开始我是抵触的，这种东西写的不好大家会骂你，写的“太好”也会骂你。 今天我就来做个“lucifer”系列的开篇吧，用图来描述“lucifer 的一天”。 lucifer 的早晨： lucifer 搬砖的一天开始了： lucifer 的晚上： 2019-09-16[工具]经常有同学问我“你的这个扩展看着不错，叫什么”， “有什么好用的扩展程序推荐么？”。 因此我打算出一个《工具推荐》专题， 然后细分一个类别《工具推荐 - chrome 插件》。 这个算是这个系列的开篇之作，我默默翻开自己的 chrome 插件列表来看，有什么好用的推荐给大家。突然灵机一动，干脆把这个“扩展插件管理器”安利给大家好了。之后我会向大家推荐更多好用好玩的插件，有“工具”，“效率”， “娱乐”，“前端”等等。 我的 chrome 插件差不多有 60 多个，插件多起来的时候，良好的分类，开启关闭，禁用，卸载等管理就变得非常重要了。毕竟谁也不想在众多插件中寻寻觅觅的感觉，也不想因为开启太多插件吃我们宝贵的内存吧？这个插件的名字是扩展管理器（Extension Manager) 对于没有梯子的同学，我还贴心地给大家准备了我从官方下载的扩展文件。 链接 2019-09-12[类库]今天给大家推荐的是一个在给 Git 提交记录增加 emojis 的仓库。 或许你知道AngularJS Git Commit Message Conventions , 现在很多开源项目和内部项目都在使用，是一道非常流行的 git commit message 规范。 它的好处就是你可以很轻松地通过提交信息，看出这次提交干的什么，影响范围等，比如是新特性，修复 bug，增加文档， 重构代码等。 这个项目可以说更进一步，通过图的形式，让你更快地感知到这些信息，可视化形式的沟通毫无疑问是最最有效的。因为人的大脑更擅长处理图像。 项目提供了几十种 emoji，几乎覆盖了所有的场景。 仓库地址： https://gitmoji.carloscuesta.me/ 2019-09-11[技能]Google 内部有很多通用的最佳实践，在这我推荐一个项目，这是挂在 google group 下的一套通用的工程实战指南，被各个项目广泛使用，覆盖全部的编程语言。 这个仓库分成两部分： 这部分是给 Code Reviewer（代码评审者）的指南 这部分是给 Change Author（CL 作者）的指南 代码评审者指南本来是一个完整的文档，一共分为 6 部分，读者可根据需要阅读。 修改列表（Change List/CL）制定者指南包括一些浏览代码评审的最佳方式，开发者可以快速处理评审结果。 项目地址： https://github.com/google/eng-practices 2019-09-10[类库]今天给大家推荐的是一个打包平台，不知道大家有没有听说过“polyfill.io”，用法有点像。 这个仓库是 fork 自 packed，并进行了魔改，你可以将多个包打包成一个单独的 ESM，支持多种 options， 仓库地址： https://github.com/webcomponents-dev/packd-es 2019-09-09[类库]一个可以将草稿转化 HTML 的工具，利用了机器学习来生成页面。 你可以手画一些东西，然后将其直接生成静态页面。缺点也很明显，一方面是静态的，因此没有什么交互，对于交互强的应用没什么用。其次就是生成的是 HTML，可维护性会比较差，如果生成类似 JSX 这样的中间产物可能会好一点。当然市面上其实已经有了生成 JSX 产物的开源框架了。 地址：https://github.com/ashnkumar/sketch-code 2019-09-06[学习方法, 好文]如何培养自己的程序员思维。- Problem-solving is the meta-skill. 文章地址： https://learnworthy.net/how-to-think-like-a-programmer/?utm_source=quora&amp;utm_medium=referral 2019-09-05[类库]这是微软开源的内部用来构建大型应用的工具库，包括接口管理，文档管理，代码仓库管理等。 地址： https://github.com/microsoft/web-build-tools 历史汇总 暂无历史汇总 关注我我重新整理了下自己的公众号，并且我还给它换了一个名字脑洞前端，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。 在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。 之后我的文章会同步到微信公众号 脑洞前端 ，你可以关注获取最新的文章，并和我进行交流。 另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。 贡献 如果有想法和创意，请提issue或者进群提 如果想贡献代码，请提PR 如果需要修改项目中图片，这里存放了项目中绘制图的源代码， 大家可以用draw.io打开进行编辑。 LicenseApache-2.0","categories":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/categories/每日一荐/"},{"name":"2019-09","slug":"每日一荐/2019-09","permalink":"https://lucifer.ren/blog/categories/每日一荐/2019-09/"}],"tags":[{"name":"每日一荐","slug":"每日一荐","permalink":"https://lucifer.ren/blog/tags/每日一荐/"}]},{"title":"一文看懂《最大子序列和问题》","slug":"LSS","date":"2019-12-11T04:35:19.039Z","updated":"2020-04-13T06:50:26.826Z","comments":true,"path":"2019/12/11/LSS/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/LSS/","excerpt":"最大子序列和是一道经典的算法题， leetcode 也有原题《53.maximum-sum-subarray》，今天我们就来彻底攻克它。","text":"最大子序列和是一道经典的算法题， leetcode 也有原题《53.maximum-sum-subarray》，今天我们就来彻底攻克它。 题目描述求取数组中最大连续子序列和，例如给定数组为 A = [1， 3， -2， 4， -5]， 则最大连续子序列和为 6，即 1 + 3 +（-2）+ 4 = 6。去 首先我们来明确一下题意。 题目说的子数组是连续的 题目只需要求和，不需要返回子数组的具体位置。 数组中的元素是整数，但是可能是正数，负数和 0。 子序列的最小长度为 1。 比如： 对于数组 [1, -2, 3, 5, -3, 2], 应该返回 3 + 5 = 8 对于数组 [0, -2, 3, 5, -1, 2], 应该返回 3 + 5 + -1 + 2 = 9 对于数组 [-9, -2, -3, -5, -3], 应该返回 -2 解法一 - 暴力法（超时法）一般情况下，先从暴力解分析，然后再进行一步步的优化。 思路我们来试下最直接的方法，就是计算所有的子序列的和，然后取出最大值。记 Sum[i,….,j]为数组 A 中第 i 个元素到第 j 个元素的和，其中 0 &lt;= i &lt;= j &lt; n，遍历所有可能的 Sum[i,….,j] 即可。 我们去枚举以 0,1,2…n-1 开头的所有子序列即可，对于每一个开头的子序列，我们都去枚举从当前开始到 n-1 的所有情况。 这种做法的时间复杂度为 O(N^2), 空间复杂度为 O(1)。 代码JavaScript: 12345678910111213141516function LSS(list) &#123; const len = list.length; let max = -Number.MAX_VALUE; let sum = 0; for (let i = 0; i &lt; len; i++) &#123; sum = 0; for (let j = i; j &lt; len; j++) &#123; sum += list[j]; if (sum &gt; max) &#123; max = sum; &#125; &#125; &#125; return max;&#125; Java： 123456789101112131415class MaximumSubarrayPrefixSum &#123; public int maxSubArray(int[] nums) &#123; int len = nums.length; int maxSum = Integer.MIN_VALUE; int sum = 0; for (int i = 0; i &lt; len; i++) &#123; sum = 0; for (int j = i; j &lt; len; j++) &#123; sum += nums[j]; maxSum = Math.max(maxSum, sum); &#125; &#125; return maxSum; &#125;&#125; Python 3: 12345678910111213import sysclass Solution: def maxSubArray(self, nums: List[int]) -&gt; int: n = len(nums) maxSum = -sys.maxsize sum = 0 for i in range(n): sum = 0 for j in range(i, n): sum += nums[j] maxSum = max(maxSum, sum) return maxSum 空间复杂度非常理想，但是时间复杂度有点高。怎么优化呢？我们来看下下一个解法。 解法二 - 分治法思路我们来分析一下这个问题， 我们先把数组平均分成左右两部分。 此时有三种情况： 最大子序列全部在数组左部分 最大子序列全部在数组右部分 最大子序列横跨左右数组 对于前两种情况，我们相当于将原问题转化为了规模更小的同样问题。 对于第三种情况，由于已知循环的起点（即中点），我们只需要进行一次循环，分别找出左边和右边的最大子序列即可。 所以一个思路就是我们每次都对数组分成左右两部分，然后分别计算上面三种情况的最大子序列和，取出最大的即可。 举例说明，如下图： (by snowan) 这种做法的时间复杂度为 O(N*logN), 空间复杂度为 O(1)。 代码JavaScript: 1234567891011121314151617181920212223242526function helper(list, m, n) &#123; if (m === n) return list[m]; let sum = 0; let lmax = -Number.MAX_VALUE; let rmax = -Number.MAX_VALUE; const mid = ((n - m) &gt;&gt; 1) + m; const l = helper(list, m, mid); const r = helper(list, mid + 1, n); for (let i = mid; i &gt;= m; i--) &#123; sum += list[i]; if (sum &gt; lmax) lmax = sum; &#125; sum = 0; for (let i = mid + 1; i &lt;= n; i++) &#123; sum += list[i]; if (sum &gt; rmax) rmax = sum; &#125; return Math.max(l, r, lmax + rmax);&#125;function LSS(list) &#123; return helper(list, 0, list.length - 1);&#125; Java: 12345678910111213141516171819202122232425262728class MaximumSubarrayDivideConquer &#123; public int maxSubArrayDividConquer(int[] nums) &#123; if (nums == null || nums.length == 0) return 0; return helper(nums, 0, nums.length - 1); &#125; private int helper(int[] nums, int l, int r) &#123; if (l &gt; r) return Integer.MIN_VALUE; int mid = (l + r) &gt;&gt;&gt; 1; int left = helper(nums, l, mid - 1); int right = helper(nums, mid + 1, r); int leftMaxSum = 0; int sum = 0; // left surfix maxSum start from index mid - 1 to l for (int i = mid - 1; i &gt;= l; i--) &#123; sum += nums[i]; leftMaxSum = Math.max(leftMaxSum, sum); &#125; int rightMaxSum = 0; sum = 0; // right prefix maxSum start from index mid + 1 to r for (int i = mid + 1; i &lt;= r; i++) &#123; sum += nums[i]; rightMaxSum = Math.max(sum, rightMaxSum); &#125; // max(left, right, crossSum) return Math.max(leftMaxSum + rightMaxSum + nums[mid], Math.max(left, right)); &#125;&#125; Python 3 : 123456789101112131415161718192021import sysclass Solution: def maxSubArray(self, nums: List[int]) -&gt; int: return self.helper(nums, 0, len(nums) - 1) def helper(self, nums, l, r): if l &gt; r: return -sys.maxsize mid = (l + r) // 2 left = self.helper(nums, l, mid - 1) right = self.helper(nums, mid + 1, r) left_suffix_max_sum = right_prefix_max_sum = 0 sum = 0 for i in reversed(range(l, mid)): sum += nums[i] left_suffix_max_sum = max(left_suffix_max_sum, sum) sum = 0 for i in range(mid + 1, r + 1): sum += nums[i] right_prefix_max_sum = max(right_prefix_max_sum, sum) cross_max_sum = left_suffix_max_sum + right_prefix_max_sum + nums[mid] return max(cross_max_sum, left, right) 解法三 - 动态规划思路我们来思考一下这个问题， 看能不能将其拆解为规模更小的同样问题，并且能找出递推关系。 我们不妨假设问题 Q(list, i) 表示 list 中以索引 i 结尾的情况下最大子序列和，那么原问题就转化为 Q(list, i), 其中 i = 0,1,2…n-1 中的最大值。 我们继续来看下递归关系，即 Q(list, i)和 Q(list, i - 1)的关系，即如何根据 Q(list, i - 1) 推导出 Q(list, i)。 如果已知 Q(list, i - 1)， 我们可以将问题分为两种情况，即以索引为 i 的元素终止，或者只有一个索引为 i 的元素。 如果以索引为 i 的元素终止， 那么就是 Q(list, i - 1) + list[i] 如果只有一个索引为 i 的元素，那么就是 list[i] 分析到这里，递推关系就很明朗了，即Q(list, i) = Math.max(0, Q(list, i - 1)) + list[i] 举例说明，如下图： (by snowan) 这种算法的时间复杂度 O(N), 空间复杂度为 O(1) 代码JavaScript: 12345678910function LSS(list) &#123; const len = list.length; let max = list[0]; for (let i = 1; i &lt; len; i++) &#123; list[i] = Math.max(0, list[i - 1]) + list[i]; if (list[i] &gt; max) max = list[i]; &#125; return max;&#125; Java: 1234567891011class MaximumSubarrayDP &#123; public int maxSubArray(int[] nums) &#123; int currMaxSum = nums[0]; int maxSum = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; currMaxSum = Math.max(currMaxSum + nums[i], nums[i]); maxSum = Math.max(maxSum, currMaxSum); &#125; return maxSum; &#125;&#125; Python 3: 123456789class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: n = len(nums) max_sum_ending_curr_index = max_sum = nums[0] for i in range(1, n): max_sum_ending_curr_index = max(max_sum_ending_curr_index + nums[i], nums[i]) max_sum = max(max_sum_ending_curr_index, max_sum) return max_sum 解法四 - 数学分析思路我们来通过数学分析来看一下这个题目。 我们定义函数 S(i) ，它的功能是计算以 0（包括 0）开始加到 i（包括 i）的值。 那么 S(j) - S(i - 1) 就等于 从 i 开始（包括 i）加到 j（包括 j）的值。 我们进一步分析，实际上我们只需要遍历一次计算出所有的 S(i), 其中 i 等于 0,1,2….,n-1。然后我们再减去之前的 S(k),其中 k 等于 0，1，i - 1，中的最小值即可。 因此我们需要用一个变量来维护这个最小值，还需要一个变量维护最大值。 这种算法的时间复杂度 O(N), 空间复杂度为 O(1)。 其实很多题目，都有这样的思想， 比如之前的《每日一题 - 电梯问题》。 代码JavaScript: 123456789101112131415function LSS(list) &#123; const len = list.length; let max = list[0]; let min = 0; let sum = 0; for (let i = 0; i &lt; len; i++) &#123; sum += list[i]; if (sum - min &gt; max) max = sum - min; if (sum &lt; min) &#123; min = sum; &#125; &#125; return max;&#125; Java: 12345678910111213141516class MaxSumSubarray &#123; public int maxSubArray3(int[] nums) &#123; int maxSum = nums[0]; int sum = 0; int minSum = 0; for (int num : nums) &#123; // prefix Sum sum += num; // update maxSum maxSum = Math.max(maxSum, sum - minSum); // update minSum minSum = Math.min(minSum, sum); &#125; return maxSum; &#125;&#125; Python 3: 1234567891011class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: n = len(nums) maxSum = nums[0] minSum = sum = 0 for i in range(n): sum += nums[i] maxSum = max(maxSum, sum - minSum) minSum = min(minSum, sum) return maxSum 总结我们使用四种方法解决了《最大子序列和问题》,并详细分析了各个解法的思路以及复杂度，相信下次你碰到相同或者类似的问题的时候也能够发散思维，做到一题多解，多题一解。 实际上，我们只是求出了最大的和，如果题目进一步要求出最大子序列和的子序列呢？如果要题目允许不连续呢？ 我们又该如何思考和变通？如何将数组改成二维，求解最大矩阵和怎么计算？这些问题留给读者自己来思考。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/categories/算法/"},{"name":"数组","slug":"数据结构/数组","permalink":"https://lucifer.ren/blog/categories/数据结构/数组/"},{"name":"子序列","slug":"算法/子序列","permalink":"https://lucifer.ren/blog/categories/算法/子序列/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/categories/LeetCode/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://lucifer.ren/blog/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"https://lucifer.ren/blog/tags/数组/"}]},{"title":"《数据结构与算法之美》-为工程师量身打造的数据结构与算法私教课","slug":"ad","date":"2019-12-11T04:35:19.039Z","updated":"2020-05-23T05:15:47.689Z","comments":true,"path":"2019/12/11/ad/","link":"","permalink":"https://lucifer.ren/blog/2019/12/11/ad/","excerpt":"很多人问我如何系统地学习数据结构与算法，是看书，刷题还是看视频？ 这个问题没有一个放之四海而皆准的答案，这是一个因人而异的东西，我之前给初学者推荐过邓俊辉老师免费的《数据结构与算法》课程，以及为《算法图解》这本书。 然而这些只是适合初学者，真正想要掌握数据结构与算法还是不够的，学习了基础之后如何进阶呢？像《算法导论》这些经典书籍，虽然很全面，但是过于缺乏重点。很多人学起来都非常困难。而市面很多在线课程或者线下课程，大多是为了“应试”，只讲一些看似通用，实则脱离真实开发场景的内容。因此这里给大家推荐一本书《数据结构与算法之美》。","text":"很多人问我如何系统地学习数据结构与算法，是看书，刷题还是看视频？ 这个问题没有一个放之四海而皆准的答案，这是一个因人而异的东西，我之前给初学者推荐过邓俊辉老师免费的《数据结构与算法》课程，以及为《算法图解》这本书。 然而这些只是适合初学者，真正想要掌握数据结构与算法还是不够的，学习了基础之后如何进阶呢？像《算法导论》这些经典书籍，虽然很全面，但是过于缺乏重点。很多人学起来都非常困难。而市面很多在线课程或者线下课程，大多是为了“应试”，只讲一些看似通用，实则脱离真实开发场景的内容。因此这里给大家推荐一本书《数据结构与算法之美》。 程序员必会的数据结构与算法 订阅量 TOP1这本书是订阅量 Top1，50000+程序员的算法课堂，整个专栏会涵盖 100 多个算法真实项目场景案例，更难得的是它跟市面上晦涩的算法书籍不同的是，还手绘了一些清晰易懂的详解图（总共有 300 多张），市面上的大多数的算法教程都看过，走心的说，这个专栏是市面上唯一一门真正适用于工程师的专栏，作者是前 Google 工程师王争，相信会开启你的趣味学习算法之旅。 作者简介本书作者王争，前 Google 工程师，从事 Google 翻译相关的开发工作，深入研究算法数十年。现任某金融公司资深系统架构师，核心业务接口平台负责人，负责公司核心业务的架构设计、开发，以及可用性、高性能等相关技术问题的解决。 你能获得什么？1、掌握数据结构与算法的核心知识 我根据自己研读数十本算法书籍和多年项目开发的经验，精选了 20 个最实用数据结构和算法结合具体的软件开发实例，由浅入深进行讲解背后的设计思想，并适时总结一些实用“宝典”，保证你印象深刻，并且能够迅速对应到实际工作场景中。 2、提升算法思维，训练解决实际开发工作难题的强能力 这部分我会讲一些不是那么常用的数据结构和算法。虽然不常用，但是并不是说他们没用。设置这一部分的目的，是为了让你开拓视野，强化训练算法思维、逻辑思维。如果说学完基础部分可以考 80 分，那掌握这一部分就能让你成为尖子生。再回过来说，不管是现在流行的区块链技术还是人工智能，核心代码实现中都会涉及到这些算法。 3、学习开源框架、底层系统的设计原理，提升工作实战技能 最后我会通过实战部分串讲一下前面讲到的数据结构和算法，并且结合 Redis、Disruptor 这样的开源项目，剖析它们背后的数据结构和算法，帮你提升读懂源码的能力（JDK 很多源码，不乏大量的数据结构，例如大家喜闻乐见的面试题 HashMap）。 我掰着指头数了下，整个专栏会涵盖 100 多个算法真实项目场景案例。我还手绘了一些清晰易懂的详解图，帮你理解核心概念和实现过程，展示每个知识点的框架逻辑，让晦涩难懂的算法变得轻松有趣。 课程目录 订阅福利扫描下方二维码订阅即可，新人立减 30 元，另外我本人提供返现 11 元（到手 88 元），直接加我微信DevelopeEngineer即可。另外再送你 199 元限时学习礼包，你可以先领券再购买，领券地址：http://gk.link/a/108qc","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/categories/数据结构/"},{"name":"算法","slug":"数据结构/算法","permalink":"https://lucifer.ren/blog/categories/数据结构/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"}]},{"title":"数据结构与算法在前端领域的应用 - 第四篇","slug":"algorthimn-fe-4","date":"2019-09-20T16:00:00.000Z","updated":"2020-04-13T06:47:57.639Z","comments":true,"path":"2019/09/21/algorthimn-fe-4/","link":"","permalink":"https://lucifer.ren/blog/2019/09/21/algorthimn-fe-4/","excerpt":"前一段时间我分享了几篇关于《数据结构与算法在前端领域的应用》的文章。 文章链接： 数据结构和算法在前端领域的应用(前菜) 数据结构和算法在前端领域的应用(进阶) 这一次我们顺着前面的内容，讲一些经典的数据结构与算法，本期我们来讲一下时下比较火热的React fiber。 这部分内容相对比较硬核和难以消化，否则 React 团队也不会花费两年的时间来搞这一个东西。建议大家多读几遍。","text":"前一段时间我分享了几篇关于《数据结构与算法在前端领域的应用》的文章。 文章链接： 数据结构和算法在前端领域的应用(前菜) 数据结构和算法在前端领域的应用(进阶) 这一次我们顺着前面的内容，讲一些经典的数据结构与算法，本期我们来讲一下时下比较火热的React fiber。 这部分内容相对比较硬核和难以消化，否则 React 团队也不会花费两年的时间来搞这一个东西。建议大家多读几遍。 fiber - 一个用于增量更新的数据结构前面我的文章提到过 fiber 是一种数据结构，并且是一种链式的数据结构。 fiber 是为了下一代调和引擎而引入的一种新的数据结构，而下一代调和引擎最核心的部分就是“增量渲染”。为了明白这个“增量渲染”，我们需要打一点小小的基础。 分片执行为了做到上面我提到的“增量渲染”，我们首先要能够停下来。之前 React 的更新 UI 的策略是自顶向下进行渲染，如果没有人工的干涉，React 实际上会更新到所有的子组件，这在大多数情况下没有问题。 然而随着项目越来越复杂，这种弊端就非常明显了。单纯看这一点，Vue 在这方面做的更好，Vue 提供了更加细粒度的更新组件的方式，甚至无需用户参与。 这是两者设计理念上的差异，不关乎好坏，只是适用场景不一样罢了。 值得一提的是，Vue 的这种细粒度监听和更新的方式，实际上是内存层面和计算层面的权衡。社区中一些新的优秀框架，也借鉴了 Vue 的这种模式，并且完成了进一步的进化，对不同的类型进行划分，并采取不同的监听更新策略，实际上是一种更加“智能“的取舍罢了。 言归正传，我们如何才能做到”增量更新“呢？ 首先你要能够在进行到中途的时候停下来 你能够继续刚才的工作，换句话说可以重用之前的计算结果 实现这两点靠的正是我们今天的主角 fiber，稍后我们再讲。 比如之前 React 执行了一个 100ms 的更新过程，对于新的调和算法，会将这个过程划分为多个过程，当然每一份时间很可能是不同的。 由于总时间不会减少，我们设置还增加了调度（上面我提到的两条）的代码，因此单纯从总时间上，甚至是一种倒退。但是为什么用户会感觉到更快了呢？这就是下面我们要讲的调度器。 三大核心组件 - Scheduler， Reconciliation， Renderer事实上， React 核心的算法包含了三个核心部分，分别是Scheduler，， Reconciliation，Renderer。 scheduler 用于决定何时去执行。 前面提到了，整个更新过程要比之前的做法要长。总时间变长的情况下，用户感觉性能更好的原因在于scheduler。 对于用户而言，界面交互，动画，界面更新的优先级实际上是不一样的。 通过保证高优先级的事件的执行，比如用户输入，动画。 可以让用户有性能很好的感觉。 做到这一点实际上原理很简单，即使前面提到的 chunks，再加上我们给每一个任务分配一个优先级，从而保证 chunks 的执行顺序中高优先级的在前面。 浏览器实际上自己也会对一些事件区分优先级。 Reconciliation 决定哪部分需要更新，以及如何“相对最小化”完成更新过程。这部分算法主要上衣基于VDOM这种数据结构来完成的。 这部分的算法实际上就是一个“阉割版的最小编辑树算法”。 renderer 使用 Reconciliation 的计算结果，然后将这部分差异，最小化更新到视图。可以是 DOM，也可以是native， 理论上可以是任何一种渲染容器。 在 DOM 中，这部分的工作由 React-DOM 来完成。它会生成一些 DOM 操作的 API，从而去完成一些副作用，这里指的是更新 DOM。 fiber - 一个虚拟调用栈实际上，fiber 做的事情就是将之前 react 更新策略进行了重构。 之前的更新策略是从顶向下，通过调用栈的形式保存已经更新的信息。这本身没有问题， 但是这和我们刚才想要实现的效果是不匹配的，我们需要 chunks 的效果。而之前的策略是从顶到下一口气执行完，不断 push stack，然后 pop stack，直到 stack 为空。 fiber 正是模拟了调用栈，并且通过链表来重新组织，一方面使得我们可以实现 chunks 的功能。另一方面可以和 VDOM 进行很好的对应和映射。 v = f(d)这是我从 React 官方介绍 fiber 的一个地方抄来的公式。 它想表达的是 react 是一个视图管理框架，并且是数据驱动的，唯一的数据会驱动产生唯一的视图。 我们可以把每一个组件都看成一个 view，然而我们的工作就是计算所有的组件的最新的 view。 那么 fiber 是如何完成“增量更新”呢？ 秘诀就是它相当于“重新实现了浏览器调用栈”。 我们来看一下，fiber 是如何实现传统调用栈的功能的。 fiber 和 传统调用栈的区别传统的调用栈，我们实际上将生成 view 的工作放到栈里面执行，浏览器的栈有一个特点就是“你给它一个任务，它必须一口气执行完”。 而 fiber 由于是自己设计的，因此可以没有这个限制。 具体来说，两者的对应关系如下： 1234567传统调用栈 fiber 子函数 component type 函数嵌套 child 参数 props 返回地址 parent 返回值 DOM elements 用图来表示的话，大概是这样： 其中具体的算法，我预计会在我的从零开始开发一个 React 中更新。 总结本篇文章介绍了fiber，fiber其实是一种用于增量更新的数据结构。是为了下一代调和引擎而引入的一种新的数据结构，而下一代调和引擎最核心的部分就是“增量渲染”。 我们介绍了几个基本概念和组件，包括分片执行， react三大核心组件 - Scheduler， Reconciliation， Renderer。 最后我们说了“fiber实际上就是一个虚拟调用栈”，并结合传统调用栈的特点和弊端，讲解了fiber是如何组织，从而改进了传统调用栈带来的问题的。","categories":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/categories/前端/"},{"name":"算法","slug":"前端/算法","permalink":"https://lucifer.ren/blog/categories/前端/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/tags/前端/"}]},{"title":"数据结构与算法在前端领域的应用 - 第三篇","slug":"algorthimn-fe-3","date":"2019-09-19T16:00:00.000Z","updated":"2020-04-13T06:51:58.233Z","comments":true,"path":"2019/09/20/algorthimn-fe-3/","link":"","permalink":"https://lucifer.ren/blog/2019/09/20/algorthimn-fe-3/","excerpt":"这是本系列文章的第三篇，这里我将带你从新的视角来看当前的前端应用，虽然这其中涉及到的道理很简单，但是这部分知识很少被人看到，更不要说推广和应用了。 这里新的视角指的是我们从进程和线程的角度来思考我们前端应用的运行，从而从更高的层次去审视和优化我们的应用，甚至整个前端生态。 希望你看完之后从思维上也好，工作应用中也好能够有所收获。 前一段时间我分享了几篇关于《数据结构与算法在前端领域的应用》的文章。 文章链接： 数据结构和算法在前端领域的应用(前菜) 数据结构和算法在前端领域的应用(进阶)","text":"这是本系列文章的第三篇，这里我将带你从新的视角来看当前的前端应用，虽然这其中涉及到的道理很简单，但是这部分知识很少被人看到，更不要说推广和应用了。 这里新的视角指的是我们从进程和线程的角度来思考我们前端应用的运行，从而从更高的层次去审视和优化我们的应用，甚至整个前端生态。 希望你看完之后从思维上也好，工作应用中也好能够有所收获。 前一段时间我分享了几篇关于《数据结构与算法在前端领域的应用》的文章。 文章链接： 数据结构和算法在前端领域的应用(前菜) 数据结构和算法在前端领域的应用(进阶) 关于我我是一个对技术充满兴趣的程序员, 擅长前端工程化，前端性能优化，前端标准化等。 做过.net， 搞过 Java，现在是一名前端工程师。 除了我的本职工作外，我会在开源社区进行一些输出和分享，GitHub 共计获得 1.5W star。比较受欢迎的项目有leetcode 题解 , 宇宙最强的前端面试指南 和我的第一本小书 浏览器的进程模型我们首先来看下浏览器的进程模型，我们以 chrome 为例。 Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。 (图来自 https://zhuanlan.zhihu.com/p/47407398) 这也是为什么 chrome 明明只打开了一个 tab，却出现了 4 个进程的原因。 这部分不是我们本节的主要内容，大家了解这么多就够了，接下来我们看下今天的主角 - 渲染进程。 浏览器的渲染进程渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。 渲染进程由以下四个线程组成：主线程 Main thread ， 工作线程 Worker thread，光栅线程 Raster thread和排版线程 Compositor thread。 我们的今天的主角是主线程 Main thread 和 工作线程 Worker thread。 主线程 Main thread主线程负责： 构建 DOM 和网络进程（上文提到的）通信获取资源 对资源进行解析 JS 代码的执行 样式和布局的计算 可以看出主线程非常繁忙，需要做很多事情。 主线程很容易成为应用的性能瓶颈。 当然除了主线程， 我们的其他进程和线程也可能成为我们的性能瓶颈，比如网络进程，解决网络进程瓶颈的方法有很多，可以使用浏览器本身缓存，也可以使用 ServiceWorker，还可以通过资源本身的优化等。这个不是我们本篇文章的讨论重点，这里只是让你有一个新的视角而已，因此不赘述。 工作线程 Worker thread工作线程能够分担主线程的计算压力，进而主线程可以获得更多的空闲时间，从而更快地响应用户行为。 工作线程主要有 Web Woker 和 Service Worker 两种。 Web Worker以下摘自MDN Web Worker 为 Web 内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。此外，他们可以使用 XMLHttpRequest 执行 I/O(尽管 responseXML 和 channel 属性总是为空)。一旦创建， 一个 worker 可以将消息发送到创建它的 JavaScript 代码, Service Worker以下摘自MDN Service workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。 重新思考我们的前端应用工作线程尤其是 Web Worker 的出现一部分原因就是为了分担主线程的压力。 整个过程就像主线程发布命令，然后工作线程执行，执行完毕将执行结果通过消息的形式传递给主线程。 我们以包工头包工程，然后将工作交给各个单位去做的角度来看的话，大概是这样的： 实际上工作工作进程，尤其是 WebWorker 已经出现很长时间了。但是很多时候我们并没有充分使用，甚至连使用都没使用。 下面以 Web Worker 为例， 我们来深度挖掘一下工作线程的潜力。 前面的文章，我们谈了很多前端领域的算法，有框架层面的也有应用层面的。 前面提到了 React 的调和算法，这部分代码耗时其实还是蛮大的，React16 重构了整个调和算法，但是总体的计算成本还是没有减少，甚至是增加的。 关于调和算法可以参考我的另外一篇文章前端领域的数据结构与算法解读 - fiber 我们有没有可能将这部分内容抽离出主线程，交给工作进程，就像上面的图展示的那样呢？我觉得可以， 另外我前面系列文章提到的所有东西，都可以放到工作线程中执行。比如状态机，时光机，自动完成，差异比对算法等等。 如果将这些抽离出我们主线程的话，我们的应用大概会是这样的： 这样做主线程只负责 UI 展示，以及事件分发处理等工作，这样就大大减轻了主线程的负担，我们就可以更快速地响应用户了。然后在计算结果完成之后，我们只需要通知主线程，主线程做出响应即可。可以看出，在项目复杂到一定程度，这种优化带来的效果是非常大的。 我们来开一下脑洞， 假如流行的前端框架比如 React 内置了这种线程分离的功能，即将调和算法交给 WebWorker 来处理，会给前端带来怎么样的变化？ 假如我们可以涉及一个算法，智能地根据当前系统的硬件条件和网络状态，自动判断应该将哪部分交给工作线程，哪部分代码交给主线程，会是怎么样的场景？ 这其实就是传说中的启发式算法， 大家有兴趣可以研究一下 挑战上述描述的场景非常美好，但是同样地也会有一些挑战。 第一个挑战就是操作繁琐，比如 webworker 只支持单独文件引入，再比如不支持函数序列化,以及反复序列化带来的性能问题， 还有和 webworker 通信是异步的等等。 但是这些问题都有很成熟的解决方案，比如对于操作比较繁琐这个问题我们就可以通过使用一些封装好 web worker 操作的库。comlink 就是一个非常不错的 web worker 的封装工具库。 对于不支持单文件引入，我们其实可以用Blob, createObjectURL的方式模拟，当然社区中其实也有了成熟的解决方案，如果你使用 webpack 构建的话，有一个worker-loader可以直接用。 对于函数序列化这个问题，我们无法传递函数给工作线程，其实上面提到的Comlink， 就很好地解决了这个问题，即使用 Comlink 提供的proxy,你可以将一个代理传递到工作线程。 对于反复序列化带来的性能问题，我们其实可以使用一种叫对象转移（Transferable Objects）的技术，幸运的是这个特性的浏览器兼容性也不错。 对于异步的问题，我们可以采取一定的取舍。 即我们本地每次保存一份最近一份的结果拷贝，我们只需要每次返回这个拷贝，然后在 webworker 计算结果返回的时候更新拷贝即可。 总结这篇文章的主要目的是让大家以新的视角来思考当前的前端应用，我们站在进程和线程的角度来看现在的前端应用，或许会有更多的不一样的理解和思考。 本文先是讲了浏览器的进程模型，然后讲了浏览器的渲染进程中的线程模型。 我们知道了渲染进程主要有四个线程组成，分别是主线程 Main thread ， 工作线程 Worker thread，光栅线程 Raster thread和排版线程 Compositor thread。 然后详细介绍了主线程和工作线程，并以 webworker 为例，讲述了如何利用工作线程为我们的主线程分担负担。为了消化这部分知识，建议你自己动手实践一下。 虽然我们的愿望很好，但是这其中在应用的过程之中还是有一些坑的，我这里列觉了一些常见的坑，并给出了解决方案。 我相信工作线程的潜力还没有被充分发挥出来，希望可以看到前端应用真正的挖掘各个进程和线程潜力的时候吧，这不但需要前端工程师的努力，也需要浏览器的配合支持，甚至需要标准化组织去推送一些东西。 关注我最近我重新整理了下自己的公众号，并且我还给他换了一个名字《脑洞前端》，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。 我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解前端是我的目标。 之后我的文章同步到微信公众号 脑洞前端 ，您可以关注获取最新的文章，或者和我进行交流。","categories":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/categories/前端/"},{"name":"算法","slug":"前端/算法","permalink":"https://lucifer.ren/blog/categories/前端/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/tags/前端/"}]},{"title":"数据结构与算法在前端领域的应用 - 第二篇","slug":"algorthimn-fe-2","date":"2019-09-18T16:00:00.000Z","updated":"2020-04-13T06:47:57.636Z","comments":true,"path":"2019/09/19/algorthimn-fe-2/","link":"","permalink":"https://lucifer.ren/blog/2019/09/19/algorthimn-fe-2/","excerpt":"这是一个我即将做的一个《数据结构与算法在前端领域的应用》主题演讲的一个主菜。如果你对这部分内容比较生疏，可以看我的数据结构和算法在前端领域的应用(前菜) 这里我会深入帮助大家如何根据业务抽离出纯粹的模型，从而转化为算法问题，","text":"这是一个我即将做的一个《数据结构与算法在前端领域的应用》主题演讲的一个主菜。如果你对这部分内容比较生疏，可以看我的数据结构和算法在前端领域的应用(前菜) 这里我会深入帮助大家如何根据业务抽离出纯粹的模型，从而转化为算法问题， 以上帝角度来看前端让我们以更高的层次来看一下，从大的范围上前端领域都在做什么？ 从业务上来说，我们会去做各个端的开发、网关、接口、工程化。从技术上说，则是基于 WEB、Node 的通用技术，以及各平台（最常见的就是安卓和 IOS）的专有技术。 在这里我以自己的标准总结了以下三点： 架构和平台 其实平台建设也是架构中的一环，之所以列出来单独讲是因为这块内容相对比较大。每个公司，部门，项目都有自己的架构设计和规范。它们环环相套组成了整个公司的架构体系。 很多公司在做工具链，在做跨端方案，在做底层融合等，这些都属于这个范畴。比如最近比较火的 Serverless 也是属于这个范畴。 规范和标准化 前端行业规范目前来看的话就两个，一个是 ECMA 的规范，一个是 W3C 的规范。前端行业规范是非常重要的，不然前端会非常混乱，想一下前端刚刚诞生出来的时候就知道了。 公司内部也会有一些规范，但是很难上升到标准层次。 目前国内没有一个行业认可的标准化组织，这算是一个遗憾吧。 好消息是国人在标准化组织的参与感越来越强，做了更多的事情。 其实这部分我们的感知是比较弱的，一个原因就是我们一直在努力对接行业的标准，很少去自己创造一些标准。原因有几点，一方面自己做标准，维护更新标准很难，另一方面自己做标准需要学习成本和转换成本。 但是这并不意味这做公司标准或者行业领域规范就没有用，相反非常有用。我之前做过一个《标准化能给我们带来什么》的分享，详细介绍了标准化对于我们的重要性。 生态体系 其实前端的工作就是人机交互，这其中涉及的东西很多，相关领域非常广泛。 比如智能手表、智能 TV、智能眼镜、头戴 AR，VR 等新的交互模式我们如何去融入现有开发体系中 ？人工智能在前端开发可以发挥怎么样的作用 ？ 这些其实很多公司已经在尝试，并且取得了非常不错的效果。 比如 IDE 是开发过程非常重要的工具，我们是否可以去做标准化的 IDE，甚至放到云端。 无处不在的算法上面我们从多个方面重新审视了一下前端，除了人工智能部分，其他部分根本没有提到算法。是不是算法在前端领域应用很少呢？ 不是的。 一方面就像上一节介绍的，我们日常开发中使用的很多东西都是经过数据结构和算法的精心封装，比如 DOM 和 VDOM，以及 JSON。 JSON的序列化和反序列化是我们无时无刻使用的方法，比如我们需要和后端进行数据交互，需要和其他线程（比如webworker）进行数据交互都要经过序列化和反序列化，如何减少数据传输，如何提高序列化和反序列化的效率，如何在两者之间寻求一种平衡都是我们需要研究的。 JSON 也是一种树结构 甚至还有很多框架以数据结构直接命名，比如 GraphQL，就是用图这种数据结构来命名，从而体现其强大的关联查询能力。 比如 tensorflow 以张量（tensor）来加深大家对上面两点的印象命名， TensorFlow™ 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。 上面提到的各个环节都或多或少会用到算法。首先网络部分就涉及到很多算法，比如有限状态机，滑动窗口，各种压缩算法，保障我们信息不泄漏的各种加密算法等等，简直不要太多。虽然这些网络部分很多都是现成的，但是也不排除有一些需要我们自己根据当前实际场景自己去搭建一套的可能。这在大公司之中是非常常见的。 我们再来看下执行我们代码的引擎，以 V8 为例，其本身涉及的算法不算在内。但是当我们基于 V8 去做一些事情，我们就需要了解一些编译相关的原理。这里我举个例子，下图是支付宝的小程序架构。 如果我们不懂一些算法的话，是很难像支付宝一样结合自己的业务去做一些突破的。 (图片来自 https://www.infoq.cn/article/ullETz7q_Ue4dUptKgKC) 另外一些高层的架构中也会有很多算法方面的东西，比如我需要在前端做增量更新的功能。增量更新在APP中早已不是新鲜的东西了，但是真正做JS等静态资源的实时增量更新还比较少，这里面会涉及非常复杂的交互和算法。 上面提到的更多的是高层面上，事实上即使是业务层面也有很多值得挖掘的算法模型。我们需要从复杂的业务中提炼出算法模型，才能得到实际应用。可惜的是很多时候我们缺乏这种抽象能力和意志。 除了上一节我讲述的常见场景之外，我还会在下一节介绍几个实际业务场景，从而加深大家的理解。希望大家看了之后，能够在自己的实际业务中有所帮助。 性能和优雅，我全都要从表象上看，使用合适的数据结构和算法有两方面的好处。 第一个是性能，这个比较好理解一点，我们追求更好的时间复杂度和空间复杂度，并且我们需要不断地在两者之间做合理的取舍。 第二点是优雅，使用合适的数据结构和算法。能让我们处理问题更加简洁优雅。 下面我会举几个我在实际业务场景中的例子，来加深大家对上面两点的印象。 权限系统假如你现在开发一款类似石墨文档的多人在线协作编辑文档系统。 这里面有一个小功能是权限系统。 用户可以在我们的系统中创建文件夹和文件，并且管理角色，不同的角色可以分配不同的文件权限。 比如查看，下载，编辑，审批等。 我们既可以给文件夹分配权限，又可以给文件分配权限，如果对应文件该角色没有权限，我们需要递归往上搜索，看有没有相应权限，如果有，则这个角色有文件的该操作权限。 如图，fileA 的权限就需要从 fileA 开始看有没有对应权限，如果有，则返回有权限。如果没有，则查找 app 文件夹的权限，重复这个过程，直到根节点。 如果你是这个系统的前端负责人，你会如何设计这个系统呢？ 其实做这个功能的方案有很多，我这里参考了 linux 的设计。我们使用一个二进制来标示一个权限有还是没有。 这样的话，一方面我们只需要 4 个 bit 就可以存储权限信息，存储已经是极限了。另一方面我们通过位运算即可算出有没有权限，二进制运算在计算性能上也是极限了。 另外代码写起来，也会非常简洁，感兴趣的可以自己试试。 扩展： 假如文件权限不是只有两种可能，比如有三个取值怎么办？ 状态机什么是状态机状态机表示若干个状态以及在这些状态之间的转移和动作等行为的数学模型。通俗的描述状态机就是定义了一套状态変更的流程：状态机包含一个状态集合，定义当状态机处于某一个状态的时候它所能接收的事件以及可执行的行为，执行完成后，状态机所处的状态。 我们以现实中广泛使用的有限状态机（以下简称 FSM）为例进行讲解 FSM 应用非常广泛， 比如正则表达式的引擎，编译器的词法和语法分析，网络协议，企业应用等很多领域都会用到。 其中正则中使用的是一种特殊的 FSM， 叫 DFA（Deterministic Finite Automaton）， 通过分裂树形式来运行。 为什么要使用状态机第一个原因，也是大家感触最深的一个原因就是通过状态机去控制系统内部的状态以及状态流转，逻辑会比较清晰，尤其在逻辑比较复杂的时候，这种作用越发明显。 第二个原因是通过状态机，我们可以实现数据以及系统的可视化。刚才我提到了正则表达式用到了状态机，那么正则是否可以可视化呢？ 答案是肯定的，这里我介绍一个可视化正则表达式的一个网站。 实际业务中如果使用状态机来设计系统也可以进行可视化。类似这样子： (图来自 https://statecharts.github.io/xstate-viz/) 可以看出，逻辑流转非常清晰，我们甚至可以基于此进行调试。当然，将它作为文档的一部分也是极好的，关于状态机的实际意义还有很多，我们接下来举几个例子说明。 状态机的实际应用场景匹配三的倍数实现一个功能，判断一个数字是否是三的倍数。 数字可以非常大，以至于超过 Number 的表示范围，因此我们需要用 string 来存储。 一个简单直观的做法是直接将每一位都加起来，然后看加起来的数字是否是三的倍数。但是如果数字大到一定程度，导致加起来的数字也超过了 Number 的表示范围呢？ 一个方法是使用状态机来解决。 我们发现一个数字除以 3 的余数一共有三种状态，即 0，1，2。 基于此我们可以构建一个 FSM。0，1，2 之间的状态流转也不难得出。 举个例子，假设当前我们是余数为 0 的状态，这时候再来一个字符。 如果这个字符是 0,3 或者 9，那么我们的余数还是 0 如果这个字符是 1,4 或者 7，那么我们的余数是 1 如果这个字符是 2,5 或者 8，那么我们的余数还是 2 用图大概是这个样子： 如果用代码大概是这样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374function createFSM() &#123; return &#123; initial: 0, states: &#123; 0: &#123; on: &#123; read(ch) &#123; return &#123; 0: 0, 3: 0, 9: 0, 1: 1, 4: 1, 7: 1, 2: 2, 5: 2, 8: 2 &#125;[ch]; &#125; &#125; &#125;, 1: &#123; on: &#123; read(ch) &#123; return &#123; 0: 1, 3: 1, 9: 1, 1: 2, 4: 2, 7: 2, 2: 0, 5: 0, 8: 0 &#125;[ch]; &#125; &#125; &#125;, 2: &#123; on: &#123; read(ch) &#123; return &#123; 0: 2, 3: 2, 9: 2, 1: 0, 4: 0, 7: 0, 2: 1, 5: 1, 8: 1 &#125;[ch]; &#125; &#125; &#125; &#125; &#125;;&#125;const fsm = createFSM();const str = \"281902812894839483047309573843389230298329038293829329\";let cur = fsm.initial;for (let i = 0; i &lt; str.length; i++) &#123; if (![\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"].includes(str[i])) &#123; throw new Error(\"非法数字\"); &#125; cur = fsm.states[cur].on.read(str[i]);&#125;if (cur === 0) &#123; console.log(\"可以被3整除\");&#125; else &#123; console.log(\"不可以被3整除\");&#125; 其实代码还可以简化，读者可以下去尝试一下。 可以看出，我们这种方式逻辑清晰，且内存占用很少，不会出现溢出的情况。 正则是基于自动机实现的，那么使用正则匹配会是怎么样的呢？大家可以自己试一下。 答题活动经过上面的热身，我们来一个真实的项目来练练手。 有这样一个业务场景，我们需要设计一款答题活动，让用户过来进行答题，我们预先设置 N 道题目。 规则如下： 初始状态用户会进入欢迎页面 答对之后可以直接进入下一个题目 答错了可以使用复活卡重新答，也可以使用过关卡，直接进入下一题 用户可以通过其他途径获取复活卡和过关卡 答对全部 N 道题之后用户过关，否则失败 不管是过关还是失败都展示结果页面，只不过展示不同的文字和图片 这其实是一个简化版本的真实项目。 如果要你设计这样的一个系统，你会如何设计？ 相信你肯定能想出很多种方法来完成这样的需求，接下来我会用 FSM 来实现。 我们很容易画出整理的流程图： 对于答题部分则稍微有一点麻烦，但是如果你用状态机的思维去思考就很容易,我们不难画出这样的图： JS 中有很多 FSM 的框架， 大家都可以直接拿过来使用。 笔者之前所在的项目也用到了这样的技术，但是笔者是自己手写的简化版本 FSM，基本思想是一致的。 其他事实上，还有很多例子可以举。 假设我们后端服务器是一主一备，我们将所有的数据都同时存储在两个服务器上。假如某一天，有一份数据丢失了，我们如何快速找到有问题的服务器。 这其实可以抽象成【Signle Number问题】。 因此很多时候，不是缺乏应用算法的场景，而是缺乏这种将现实业务进行抽象为纯算法问题的能力。我们会被各种细枝末节的问题遮蔽双眼，无法洞察隐藏在背后的深层次的规律。 编程最难是抽象能力，前几年我写了一篇文章《为什么我们的代码难以维护》，其中一个非常重要的原因就是缺乏抽象。 从现在开始，让我们来锻炼抽象能力吧。","categories":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/categories/前端/"},{"name":"算法","slug":"前端/算法","permalink":"https://lucifer.ren/blog/categories/前端/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/tags/前端/"}]},{"title":"数据结构与算法在前端领域的应用 - 第一篇","slug":"algorthimn-fe-1","date":"2019-09-17T16:00:00.000Z","updated":"2020-04-13T06:47:57.633Z","comments":true,"path":"2019/09/18/algorthimn-fe-1/","link":"","permalink":"https://lucifer.ren/blog/2019/09/18/algorthimn-fe-1/","excerpt":"这是一个我在公司内部做的一个《数据结构与算法在前端领域的应用》主题演讲的一个前菜。希望通过这个分享让大家认识到其实前端领域也有很多算法的，从而加深前端同学对算法的认识。","text":"这是一个我在公司内部做的一个《数据结构与算法在前端领域的应用》主题演讲的一个前菜。希望通过这个分享让大家认识到其实前端领域也有很多算法的，从而加深前端同学对算法的认识。 为什么大家觉得算法没用在我的职业生涯中，碰到很多非算法岗的研发同学吐槽“算法在实际业务中没什么用”，甚至在面试官也问过我这个问题。我们姑且不来判断这句话正确与否，我们先来看下为什么大家会有这样的想法。 我发现很多人喜欢用冰山这个图来表示这种只看到总体的一小部分的情况。我也来借用一下这个创意。 根据我的经验，我们写的业务代码通常不到总包体的 5%， 下面是我以前做过的一个实际项目的代码分布。 12$ du -sh node_modules # 429M$ du -sh src # 7.7M 大家可以拿自己的实际项目看一下，看是不是这样的。 其实不难看出业务代码在整个应用的比例是很小的，软件工程有一个至理名言，“软件开发的 90%的工作是由 10%的人完成的”，这句话很对，那么剩下的 10 的工作却由剩下的 90%来完成。 因此我们感觉算法没用，是因为我们没用深入剩下的“90%”很多场景我们接触不到，并且没有思考过，就很容易“井底之蛙”，到头来就变成“只会用别人造好的轮子组装代码”的“前端打字员”。 那剩下的 90% 究竟有哪些涉及到算法呢？是否可以举例说明呢？那接下来让我们来继续看一下。 前端中算法的应用场景都有哪些说实话，这部分内容实在太多啦，为了让大家有一个直观的感受，我画了一个图。 图中黄色的代表我自己实现过。 这些都是前端开发过程的一些东西， 他们多多少少涉及到了数据结构和算法的知识 下面我们来简单分析一下。 VDOM事实上 VDOM 就是一种数据结构，但是它并不是我们在《数据结构与算法》课程中学习到的一些现成的数据结构。 逻辑上 VDOM 就是用来抽象 DOM 的，底层上 VDOM 普遍实现是基于 hash table 这种数据结构的。 一个典型的 VDOM 可以是： 123456789101112&#123; type: 'div', props: &#123; name: 'lucifer' &#125;, children: [&#123; type: 'span', props: &#123;&#125;, children: [] &#125;]&#125; 不难看出，VDOM 是一种递归的数据结构，因此使用递归的方式来处理是非常直观和容易的。 我上面提到了 VDOM 是 DOM 的抽象（ye, a new level of abstraction）。根据 VDOM 我们可以创建一个对应的真实 DOM。 如果我们只是做了这一层抽象的话，我们相当于引入了一种编程模式，即从面向 DOM 编程，切换到面向 VDOM 编程，而现在 VDOM 又是由数据驱动的，因此我们的编程模式切换到了“数据驱动”。 事实上，VDOM 部分还有一个 VDOM diff 算法，相信大家都听说过。关于DOM diff 的算法，以及它是如何取舍和创新的，我之前在一个地方回答过，这里给一个链接地址:https://juejin.im/post/5d3d8cf15188256ac355a9f0 HooksHooks 是 React16 添加的一个新功能， 它要解决的问题是状态逻辑复用。 Hooks 逻辑上解决了纯函数无法持久化状态的“问题”，从而拓宽了纯函数组件的适用范围。 底层上 Hooks 使用数据来实现状态的对应关系，关于这部分可以参考我的[第一期]实现一个简化版的 React Hook - useState FiberFiber 也是 React16 添加的一个新功能。 事实上 Fiber 类似 VDOM，也是一个数据结构，而且同样也是一个递归的数据结构。 为了解决 React 之前一次全量更新的”问题”, React 引入了 fiber 这种数据结构，并重写了整个调和算法，并且划分了多个阶段。 关于这部分内容，我只推荐一篇文章,Inside Fiber: in-depth overview of the new reconciliation algorithm in React 其实之前我的从零开始实现 React 系列教程 也欠了 fiber 😄, 等我开心的时候补充上去哈。 Git我之前写过一个 Git 终端（代码被我 rm -rf 啦）。 这过程还是用到了很多数据结构和算法的，我也学到了很多东西， 甚至 React16 新的调和算法也有 Git 思想。 很直观的，Git 在推送本地仓库到远程的时候会进行压缩，其实这里就用到了最小编辑距离算法。Leetcode 有一个题目72. Edit Distance,官方难度hard, Git 的算法要是这个算法的复杂版本。 另外 Git 其实很多存储文件，数据的时候也用到了特殊的数据结构，我在这里进行了详细的描述，感兴趣的可以去看看。 WebpackWebpack 是众所周知的一个前端构建工具，我们可以用它做很多事情。至今在前端构建领域还是龙头老大 🐲 的位置。 Webpack 中最核心的 tapable 是什么，是如何配合插件系统的？ webpack 是如何对资源进行抽象的，webpack 是如何对依赖进行处理的？更复杂一点 Tree Shaking 如何做，分包怎么做，加速打包怎么做。 其实 webpack 的执行过程是基于事件驱动的，tapable 提供了一系列钩子，让 plugin 深入到这些过程之中去。听起来有点像事件总线，其实其中的设计思想和算法细节要复杂和精妙很多。 关于这部分细节，我在我的从零实现一个 Webpack 之后会加入更多特性，比如 tapable ASTAST（抽象语法树）是前端 编译（严格意义上是转义）的理论基础，你如果想深入前端编译，就一定不能不会这个知识点。 和 AST 相似的，其实还有 CST，prettier 等格式化工具会用到， 有兴趣可以搜一下。 这个网站 可以让你对 AST 有一个直观的认识。 AST 厉害就厉害在它本身不涉及到任何语法，因此你只要编写相应的转义规则，就可以将任何语法转义到任何语法。这就是babel， PostCSS, prettier， typescript 等的原理，除此之外，还有很多应用场景，比如编辑器。 之前自己写过一个小型的生成 AST 的程序，源代码忘记放哪了。😅 Browser History像浏览器中的历史页面，移动端 webview 的 view stack, 都用到了栈这种数据结构。 剩下的我就不一一说了。其实都是有很多数据结构和算法的影子的。 OK，说了那么多。 这些都是“大牛”们做的事情，好像和我日常开发没关系啊。我只要用他们做好的东西，调用一下，一样可以完成我的日常工作啊。让我们带着这个问题继续往下看。 算法在日常开发中的应用都有哪些123大神： “你可以先这样，再这样，然后就会抽象为纯算法问题了。”我： “哇，好厉害。” 其实就是你没有掌握，或者“再思考”，以至于不能融汇贯通。 比如你可以用 vue 组件写一个递归，实现一些递归的功能，也是可以的，但是大多数人都想不到。 接下来，我会举几个例子来说明“算法在日常开发中的应用”。注意，以下所有的例子均来自我的实际业务需求。 第一个例子 - 撤销与重做业务描述某一天，可(gai)爱(si)的产品提了一个需求，”我们的系统需要支持用户撤销和重做最近十次的操作。“ 让我们来回忆一下纯函数。 纯函数有一个特性是给定输入，输出总是一样的。 关于函数式编程可以参考我之前的几篇文章和一个分享 我们对问题进行一些简化，假设我们的应用是纯粹的数据驱动，也就是说满足纯的特性。 我们继续引入第二个知识点 - reducer. reducer 是一个纯函数，函数签名为(store1, action1) =&gt; store2。即给定 state 和 action，一定会返回确定的新的 state。 本质上 reducer 是 reduce 的空间版本。 假设我们的应用初始 state 为 state1， 我们按照时间先后顺序分别发送了三个 action，action1, action2, action3。 我们用一个图来表示就是这样的： 运用简单的数据知识，我们不难推导出如下关系： 如果对这部分知识点还比较迷茫，可以看下我之前的一篇文章，从零实现一个 Redux 解决方案基础知识铺垫完了，我们来看一下怎么解决这个问题。 第一种方案，我们可以将每次的store，即store1, store2, store3都存起来。比如我想回退到第二步，我们只需要将store2取出来，覆盖当前store，然后重新渲染即可。这种方案很直观，可以满足我们的业务需求。但是缺点也很明显，store在这里被存储了很多。 每次发送一个action都会有一个新的store被存起来。当我们应用比较大的时候，或者用户触发了很多action的时候，会占据大量内存。实际场景中性能上我们很难接受。 第二种方案，有了上面的铺垫，我们发现， 事实上我们没必要存储所有的store。因为store可以被计算出来。因此我们只要存储action即可。比如我们要回退到第二步，我们拿出来store1，然后和action运算一次，得到store2，然后将store2覆盖到当前的store即可。 这种做法，只需要存储一个store1， 以及若干个action。 action相对于store来说要小很多。这是这种做法相比与上一种的优势。同时由于每次都需要从头（store1）开始计算，因此是一种典型的“时间换空间”的优化手段。 实际上这种做法，我们可以进行小小的优化。比如我们设置多个snapshot，然后我们就不必每次从头开始计算，而是算出最近的一个snapshot，然后计算即可。 无疑这种做法可以减少很多计算量，但是会增加空间占用。这是典型的“空间换时间”， 如果根据实际业务进行取舍是关键。 第三种方案，我们可以用树来表示我们的store。每次修改store，我们不是将整个store销毁然后创建一个新的，而是重用可以重用的部分。 如图我要修改 store.user.age。我们只需要将root和user的引用进行修改，同时替换age节点即可。 如果大家对immutable研究比较深的话应该能发现，这其实就是immutable的原理 第二个例子 - 巨型Mapper的优化业务描述由于业务需要，我们需要在前端缓存一些HTTP请求。我们设计了如下的数据结构，其中key表示资源的URL，value会上次服务端的返回值。 现在我们的项目中已经有上千个接口，当接口多起来之后，缓存占用会比较大，我们如何对此进行优化？ 注： 我们的key中的前缀是有规律的，即有很多重复的数据在。 返回值也有可能是有很多重复的。 这是一个典型的数据压缩算法。数据压缩算法有很多，我这里就不介绍了，大家可以自行了解一下。 对数据压缩算法感兴趣的，可以看下我之前写的游程编码和哈夫曼编码 第三个例子 - 实现自动联想功能业务描述现在很多输入框都带了自动联想的功能， 很多组件库也实现了自动填充组件。 现在需要你完成这个功能，你会怎么做？ 我们可以用前缀树，很高效的完成这个工作。 对这部分原理感兴趣的可以看下我的这个题解 第四个例子 - 相似度检测业务描述由于业务需要，我们需要对字符串进行相似度检测。对于相似度超过一定阀值的数据，我们认为它是同一个数据。 关于相似度检测，我们其实可以借助“最小编辑距离”算法。对于两个字符串a和b，如果a和b的编辑距离越小，我们认为越相似，反之越不相似。 特殊情况，如果编辑距离为0表示是相同的字符串，相似度为100%。 我们可以加入自己的计算因子，将相似度离散在0 - 100%之间。 这部分的内容，我在介绍Git的时候介绍过了，这里不再重复。 其实我们可以进一步扩展一下，比如对于一些无意义的词不计入统计范围，我们可以怎么做？ 算法不好会怎么样这恐怕是很多人最关心的问题。 我虽然知道了算法有用，但是我不会怎么办？会有什么样的影响呢？ 这就回到了我们开头的问题，“为什么很多人觉得算法没用”。事实上，我们日常开发中真正用到算法的场景很少，大部分都被别人封装好了。即使真正需要用到一些算法，我们也可以通过一些“低劣”的手段完成，在很多对性能和质量要求不高的业务场景都是没有问题的。 这就是为什么“前端同学更加觉得算法没用”的原因之一。 那既然这么说，是不是真的算法就没用呢？ 或者说算法不好也不会怎么样了么？当然不是， 如果算法不好，会很难创新和突破。 想想如今前端框架，工具的演进，哪一个不是建立在无数的算法之上。 将视角聚焦到我们当下的业务上，如果算法不好，我们也同样很难让业务不断精进，不断赋能业务。 React框架就是一个非常典型的例子，它的出现改变了传统的编程模式。Redux的作者，React团队现任领导者 dan 最近发表了一篇个人博客 Algebraic Effects for the Rest of Us这里面也有很多算法相关的东西，大家有兴趣的可以读读看。 另外我最近在做的一个 stack-visualizer，一个用于跟踪浏览器堆栈信息，以便更好地调试地工具， 这个也是和算法有关系的。","categories":[{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/categories/前端/"},{"name":"算法","slug":"前端/算法","permalink":"https://lucifer.ren/blog/categories/前端/算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lucifer.ren/blog/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://lucifer.ren/blog/tags/算法/"},{"name":"前端","slug":"前端","permalink":"https://lucifer.ren/blog/tags/前端/"}]}]}