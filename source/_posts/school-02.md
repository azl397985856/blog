---
title: 春招冲冲冲(钉钉+腾讯)
tags: [数据结构, 算法, 春招]
date: 2021-03-11
categories:
  - [春招]
---

春招已经开始了。 你是不是已经开始准备了呢？为了帮助大家获得更好的 offer，lucifer 开辟了**春招冲冲冲**栏目。

今天我们的猎物是**钉钉和腾讯**。来看看这两家的算法题难度几何吧！

​<!-- more -->

视频地址：https://www.bilibili.com/video/BV1Qy4y187Em/

## 钉钉

1. 比较版本号（力扣题号 165.比较版本号）

一次遍历即可，唯一需要注意的是补全再比较（逻辑补全即可，并不一定需要物理上真的去补全），时间复杂度 $O(m + n)$，其中 m 和 n 分别为两个版本号的长度

2. 随机字符串生成（随机生成一个长度为 8 的字符串，要求只能是小写字母和数字，字母和数字可重复，但是生成的随机字符串不能重复）

随机生成一个长度为 8 的字符并将其存到哈希表中，下次生成后判断是否已经在哈希表中了。如果存在，说明之前生成过了，继续生成。注意这种算法存在一直拒绝的可能，代码会无限循环。

3. 日志上报（实现效果：没有数据不上报，有数据每 100ms 批量上报一次）

维护一个窗口，当窗口内有数据才触发请求批量上传，一个窗口的长度为 100m（可能大于） 内的所有请求

## 腾讯

1. 字符串反转

头尾双指针，不断交换两个指针的字符即可。

2. 链表的倒数第 k 个数

快慢双指针典型题目。

3. 设计求一个数的 n 次开方

典型的二分题目，不会的建议看下我的二分讲义。我的刷题仓库或者公众号搜 **二分** 就行。

4. LRU 算法

稍微有点难度了，这个题很常见，难度不小，建议刷。我之前写过题解了，直接甩给大家吧 [146. LRU 缓存机制](https://github.com/azl397985856/leetcode/blob/master/problems/146.lru-cache.md "146. LRU 缓存机制")

> 我给了 JS, Go, PHP, Python3 四种语言，有你的菜么？

5. 手撕一下，就是一个小车给定坐标位置，和当前面朝方向（NSWE），再输入前进转向情况和前进步数，输出小车的坐标位置和面朝方向。

没啥难度，直接模拟。

6. 链表相加

链表和数组本质没有不同，只是具体操作不一样。因此掌握链表基本操作就行了。链表基本操作有哪些？需要注意什么？我的[链表专题](https://mp.weixin.qq.com/s?__biz=MzI4MzUxNjI3OA==&mid=2247485582&idx=1&sn=eff845460e91be97026c937b229c2989&chksm=eb88c497dcff4d81e08ac30951b160f0083bc9fe5a2b64b8e1ea9e0988e14a9df2b56515f508&token=108537235&lang=zh_CN#rd "链表专题")都给大家总结好了，建议阅读。

7. leetcode 1567 乘积为正数的最长子数组长度。

题目是：给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。请你返回乘积为正数的最长子数组长度。

这道题是求**连续的**乘积为正数的**最长**子数组长度。这里需要一个小学知识，两个符号相同的相乘为正数，两个符号不同的数相乘为负数（先不考虑 0）。 于是直接使用一维 DP + 一层循环即可。

定义状态 positive[i] 为 nums[i] 结尾的**乘积为正数的最长子数组长度**，negative[i] 为 nums[i] 结尾的**乘积为负数的最长子数组长度**，于是答案就是 max(positive)。

接下来，遍历 nums，对 nums[i] 的不同取值分类讨论即可：

- nums[i] > 0

$$
positive[i]=positive[i−1]+1
$$

$$
  negative[i]=\left\{
  \begin{aligned}
  negative[i-1] + 1 &  & negative[i-1] > 0 \\
  0 & & negative[i-1] = 0 \\
  \end{aligned}
  \right.
$$

- nums[i] < 0

$$
negative[i]=positive[i−1]+1
$$

$$
  positive[i]=\left\{
  \begin{aligned}
  negative[i-1] + 1 &  & negative[i-1] > 0 \\
  0 & & negative[i-1] = 0 \\
  \end{aligned}
  \right.
$$

- nums[i] == 0

$$
negative[i]=positive[i] = 0
$$

状态定义一般两种套路：

- 使用一个二维数组，定义 dp[i][0] 和 定义 dp[i][1]
- 使用两个一维数组，定义 dp1[i] 和 dp2[i]

两种方式思路一样，只是实操不一样而已。我个人倾向于第二种。比如股票题，我就喜欢定义一个 buy 和 一个 sell 数组。再比如摆动数组，我就喜欢定义一个 up 和 一个 down 数组。

另外如果题目没有限定连续，则需要两层循环和一维 DP（滚动数组优化）。

## 总结

我个人觉得算法题难度是中等，都非常常规，没有什么难以读懂的题目或者冷门知识。

另外我组建了春招群，大家面试遇到不会的题都可以问哦。想进群的可在公众号力扣加加后台回复春招获取小秘书的微信，通过之后再次回复**春招**入群。

最后祝大家 offer 多多。
