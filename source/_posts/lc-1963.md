---
title: 亚信科技这波操作真是把“画饼艺术”玩到极致了！
tags: [题解]
categories:
  - [题解]
date: 2025-03-17
---

最近，亚信科技的操作真是让人瞠目结舌，全员取消年终奖的消息传得沸沸扬扬。年初取消1000元补贴、强制降薪的风波还未平息，如今又直接祭出“年终奖归零”的大招，打工人直呼：“这分明是职场PUA！”从补贴取消到裁员分期，再到年终奖清零，亚信科技这一系列操作，把“画饼艺术”演绎到了极致。员工们听着“同甘共苦”的口号，却在现实中被压得喘不过气。

<!-- more -->

## 事件经过

让我们来回顾一下这出“职场大戏”的精彩剧情：

1. **年初补贴变降薪，违法操作被锤**  
今年1月，亚信科技取消了每月1000元的所谓“综合补贴”，实则这是工资的一部分，取消后普通员工薪水直接缩水20% 到 30%。劳动仲裁结果明确：这是违法降薪！但公司似乎毫不在意，继续推进后续操作。

2. **春节前裁员，N+1还分期付款**  
春节前夕，裁员名单早早拟定，赔偿方案给出N+1，但这笔钱居然要分期支付。年关将至，员工们连个安稳年都过不上，真是“裁员一时爽，分期泪两行”。

3. **年终奖归零，高层降薪仅象征性**  
最新一击是年终奖直接取消，CEO高喊“同甘共苦”，但高层降薪幅度仅2%-5%，普通员工却要承担全部损失。基层吐槽：这哪里是共苦，分明是让我们独自咽下苦果！

4. **违法操作屡见不鲜，仲裁队伍再扩容**  
年初补贴取消已被判违法，年终奖归零又疑似“单方面毁约”，劳动仲裁的排队人数怕是要再创新高。员工们忙着维权，还要应对“优化名单”的恐吓，压力山大。

5. **业绩暴跌，基层背锅**  
财务数据显示，2024年上半年亏损 1.92 亿元。业绩不佳的锅全甩给基层员工，管理层却只象征性降薪5%，这“公平”程度令人咋舌。

6. **道德绑架+恐慌制造，PUA套路拉满**  
公司一边用“契约精神”绑架员工忠诚，一边用“优化名单”制造恐慌，职场PUA的套路玩得炉火纯青。员工们经济上受损，精神上被压迫，真是苦不堪言。

亚信科技这一系列操作，不仅让员工寒心，也让“画饼艺术”成了其新标签。降薪、裁员、取消年终奖，每一步都在挑战打工人的忍耐底线。面对劳动仲裁的接连失利，公司依旧我行我素，难怪有人调侃：“亚信科技的‘同甘共苦’，是不是翻译成‘员工苦上加苦，高层甘之如饴’更贴切？”希望公司能少些套路，多些实惠，别让“饼”画得太大，员工却一口都吃不上！

---

回归正题，我们来一道力扣的题目

## 1963.最小交换次数让括号字符串平衡

### 题目地址

https://leetcode.cn/problems/minimum-number-of-swaps-to-make-the-string-balanced/

### 题目描述
给你一个字符串 s ，下标从 0 开始 ，且长度为偶数 n 。字符串 恰好 由 n / 2 个开括号 '[' 和 n / 2 个闭括号 ']' 组成。

只有能满足下述所有条件的字符串才能称为 平衡字符串 ：

字符串是一个空字符串，或者
字符串可以记作 AB ，其中 A 和 B 都是 平衡字符串 ，或者
字符串可以写成 [C] ，其中 C 是一个 平衡字符串 。
你可以交换 任意 两个下标所对应的括号 任意 次数。

返回使 s 变成 平衡字符串 所需要的 最小 交换次数。

 
```
示例 1：

输入：s = "][]["
输出：1
解释：交换下标 0 和下标 3 对应的括号，可以使字符串变成平衡字符串。
最终字符串变成 "[[]]" 。
示例 2：

输入：s = "]]][[["
输出：2
解释：执行下述操作可以使字符串变成平衡字符串：
- 交换下标 0 和下标 4 对应的括号，s = "[]][][" 。
- 交换下标 1 和下标 5 对应的括号，s = "[[][]]" 。
最终字符串变成 "[[][]]" 。
示例 3：

输入：s = "[]"
输出：0
解释：这个字符串已经是平衡字符串。
 
```

```
提示：

n == s.length
2 <= n <= 10^6
n 为偶数
s[i] 为'[' 或 ']'
开括号 '[' 的数目为 n / 2 ，闭括号 ']' 的数目也是 n / 2
```

### 思路

#### 解法1：模拟栈 + 记录左括号位置


由于平衡的逻辑类似括号匹配。因此我们可以沿用括号匹配的基本思路。括号匹配在力扣里是简单题目，不熟悉的同学可以先完成[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)。

具体来说，我们可以从左到右匹配，如果**左括号多**没事，如果**右括号多**，则无法平衡，这个时候就需要交换。这里都是和 [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/) 一样的逻辑。

这道题不同的是需要交换，那么如何交换呢？交换的时候应该贪心地交换**没有被交换的的最靠右的 `[`**。代码上可以用栈模拟括号匹配的过程，同时记录所有`[`的位置，遇到不平衡时从最右的`[`交换。

```python
class Solution:
    def minSwaps(self, s: str) -> int:
        st = []
        lefts = []
        ans = 0
        s = list(s)
        for i, c in enumerate(s):
            if c == '[':
                lefts.append(i)
        for c in s:
            if c == '[':
                st.append(c)
            else:
                if not st:
                    i = lefts.pop()
                    s[i] = ']'
                    st.append('[')
                    ans += 1
                else:
                    st.pop()
        return ans
```
- **复杂度**：时间O(n)，空间O(n)，其中n是字符串长度。

#### 解法2：去掉栈，用计数器

栈其实可以用一个计数器`cnt`替代，来记录未匹配的`[`数量，优化空间复杂度。这点和 [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/) 一样。

```python
class Solution:
    def minSwaps(self, s: str) -> int:
        cnt = 0
        lefts = []
        ans = 0
        s = list(s)
        for i, c in enumerate(s):
            if c == '[':
                lefts.append(i)
        for c in s:
            if c == '[':
                cnt += 1
            else:
                if cnt == 0:
                    i = lefts.pop()
                    s[i] = ']'
                    cnt += 1
                    ans += 1
                else:
                    cnt -= 1
        return ans
```
- **复杂度**：用`cnt`代替栈，空间复杂度仍为O(n)，因为`lefts`列表还在。

#### 解法3：去掉左括号列表，用双指针

我们不需要显式记录所有`[`的位置，只需从右端找一个`[`交换即可。 我们可以利用**指针不回退技巧**，这样找最右侧的`[`时，总共也只需要 n 次，和前面的时间复杂度是一样，但是空间复杂度降低了。


```python
class Solution:
    def minSwaps(self, s: str) -> int:
        cnt = 0
        ans = 0
        s = list(s)
        j = len(s) - 1
        for c in s:
            if c == '[':
                cnt += 1
            else:
                if cnt == 0:
                    while s[j] != '[':
                        j -= 1
                    s[j] = ']'
                    cnt += 1
                    ans += 1
                else:
                    cnt -= 1
        return ans
```
- **复杂度**：时间仍是 O(n) 去掉`lefts`，空间复杂度降至O(1)

#### 解法4：完全去掉交换操作

上面的代码，其他地方不变，仅仅不进行交换会怎么样？

如果不交换，假如在下标 i 处遇到了**本该被交换的**左括号，在 `j>=i` 的位置中的左括号全部被换成了右括号，右括号保持不变，也就是说 `j>=i` 将都是 `]`。即此时该字符串已经是平衡的了，答案其实就是当前的 ans，但是即使不退出，继续遍历也不会导致 cnt < 0，自然不会累加答案，所以不交换并不会导致计算错误。

不交换的话，我们自然也不需要记录`lefts`，因为 lefts 的存在就是方便我们正确地交换`]`。

```python
class Solution:
    def minSwaps(self, s: str) -> int:
        cnt = 0  # 未匹配的'['数量
        ans = 0  # 交换次数
        for c in s:
            if c == '[':
                cnt += 1
            else:
                if cnt == 0:
                    cnt += 1  # 相当于交换了一个'['过来
                    ans += 1
                else:
                    cnt -= 1
        return ans
```
- **复杂度**：和解法3 一样，时间复杂度仍为O(n)，空间复杂度为O(1)。但是时间和空间的常数项会减少。


## 力扣专属折扣

力扣免费题目已经有了很多经典的了，也覆盖了所有的题型，只是很多公司的真题都是锁定的。个人觉得如果你准备找工作的时候，可以买一个会员。另外会员很多 leetbook 也可以看，结合学习计划，效率还是蛮高的。

现在力扣在每日一题基础上还搞了一个 plus 会员挑战，每天刷题可以获得积分，积分可以兑换力扣周边。

![](https://p.ipic.vip/saz963.png)

如果你要买力扣会员的话，这里有我的**专属力扣折扣：https://leetcode.cn/premium/?promoChannel=lucifer** (年度会员**多送两个月**会员，季度会员**多送两周**会员)
