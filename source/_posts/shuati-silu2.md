---
title: 来和大家聊聊我是如何刷题的（第二弹）
tags: [LeetCode, 刷题方法]
categories: [刷题方法]
date: 2020-12-04
---

上一篇的地址在这里，没有看过的同学建议先看第一篇 [来和大家聊聊我是如何刷题的（第一弹）](https://lucifer.ren/blog/2020/11/29/shuati-silu/)。

这次继续给大家聊聊怎么刷题， 预计分几篇文章来写，今天是第二篇。这次分享的内容是**代码书写技巧**以及**调试技巧**。

> 本系列旨在分享一些所有题目都适用的技巧以及一些刷题经验，帮助大家高效刷题。如果想重点突破某一类题目，可以关注我的专题系列。

话不多说，直接上干货。

<!-- more -->

## 先刷什么？刷多少？

我被问的比较多的两个问题是：

- 我该先刷什么算法？
- 每一种算法我该刷多少？

现在我们就来看下这两个问题。

这里贴一个 **91 天学算法** 中某一小节的讲义中的一部分内容：

- 递归（10）
- BFS & DFS（20）
- 双指针（20）
- 滑动窗口（6）
- 哈希表（20）
- 回溯（5）
- 动态规划（20）
- 排序（3）
- 分治（20）
- 堆（3）
- 贪心（5）
- 设计题（5）
- 图（5）
- 位运算（5）
- 并查集（3）

如果你不知道从何刷起，可以参考我的这个刷题顺序，其中括号是我推荐的最小刷题量，就是说再少不能少于这个数字。如果你想多刷，可以按照我的这个比例去刷。等到你自己有个概念，知道自己哪里薄弱了，再去针对加强即可。

具体题目太多了不列举了，给大家几个题目集合做参考：

1. [🔥 热题 HOT 100](https://leetcode-cn.com/problemset/leetcode-hot-100/)
2. [ 👨‍💻 精选 TOP 面试题](https://leetcode-cn.com/problemset/leetcode-top/)
3. 企业题库。 比如 [🐧 腾讯精选练习 50 题](https://leetcode-cn.com/problemset/50/)，[企业题库 - 字节跳动](https://leetcode-cn.com/company/bytedance/)（当你就想去某一家公司的时候可以用）
4. [剑指 Offer](https://leetcode-cn.com/problemset/lcof/)
5. 网友内幕（主要是面经）
6. 力扣的探索和标签

## 代码书写技巧

代码书写技巧，这次给大家带来两个技巧：

1. 改参数
2. zip 函数的妙用

### 改参数

力扣的参数是可以改名字的，如下图：

![](https://tva1.sinaimg.cn/large/0081Kckwly1glawz82w0fj310l0a4wgd.jpg)

你可以将名字改成一个短的或者你熟悉的。比如上面这道题，我写的时候就可以：

```py
class Solution:
    def findMedianSortedArrays(self, A: List[int], B: List[int]) -> float:
        # can use A and B now
```

这可以使得代码看起来**简洁**且具有**一致性**。

经常看我题解的小伙伴应该注意到我的代码比较简洁。一方面是因为我经常用 Python，另一方面就是因为这个技巧。

这里我顺便吐槽一下力扣。力扣的形参命名相当不规范。比如二维数组有时候是 mat，有时候是 nums，有时候是 matrix，有时候又是 grid 。。。 真心不舒服，不过有了这个技巧，大家就不要依赖官方了，自己统一一下就好。

就拿我来说，二维数组我就用 mat 或者 matrix，一维数组用 nums 或者 A 或者 A 和 B（两个一维数组的情况）。比如：

```py
# A 和  B 是两个一维的数组
def test(A, B):
    for a in A:
        # do something
    for b in B:
        # do something else
```

其实不仅仅是形参的命名要统一，我们内部的代码也是一样的。对于我来说：

- 堆我习惯叫 h
- 图我习惯叫 graph
- 队列我习惯叫 q
- 。。。

大家没有必要和我一样，但是一定要保持一致性，这样可以显著增加代码可读性，可读性高了，调试工作也会变得轻松。

### zip 函数的妙用

力扣有一些题目会给你两个或者三个一维数组，这两个一维数组的是有关联的。

比如给你两个一维数组 A 和 B，其中 A[i] 表示第 i 个人的体重，B[i] 表示第 i 个人的身高。也就是说都是表示第 i 个人，但是表示的东西不一样。

其实逻辑上就相当于结构体，而且如下结构体的形式在工作中更常见。

```ts
interface Person {
  weight: number;
  height: number;
}
```

但是力扣以两个数组的形式给你了，其实这样不难啊，不就是用一个索引记录么？

```java
for(int i= 0;i<A.length;i++) {
    int weight = A[i]
    int height = B[i]
}
```

但是如果我需要对重量排序呢？如果你仅仅对 A 排序了，B 也需要进行相应调整的，否则对应关系就乱了。那遇到这样的情况该怎么办呢？

这里介绍一个我经常使用的技巧 **zip**。

```py
    zipped = zip(A, B)
    # 下面我对其进行排序也不会改变相对顺序
    zipped.sort()
    # 比如 A 是 [1,2,3] B 是 [4,5,6]
    # 那么 zipped 就是 [[1,4], [2,5], [3,6]]
    # 那么 zipped[i][0] 就是第 i 个人的体重，zippd[i][1] 就是第 i 个人的身高
```

由于 A 和 B “捆绑”到一起了，因此排序也不会改变其相对顺序。

如下是我在力扣 1383 题中使用 zip 技巧的例子：

![](https://tva1.sinaimg.cn/large/0081Kckwly1glaxhfvp7fj311o0e3got.jpg)

另外 zip 还有一些其他用处。比如我想要获取当前数组位置的前一项。

不用 zip 可以这么做：

```py
for i in range(1, len(A)):
    pre = A[i - 1]
    cur = A[i]
```

如果使用 zip 可以这样：

```py
for pre, cur in zip(A, A[1:]):
    # do something
```

这里的原理也很简单。我举个例子你就懂了。比如有一个数组 A ：[1,2,3,4]。 那么 A[1:] 就是 [2,3,4]

我将如上两个数组 zip 起来就是 [[1,2], [2,3], [3,4]]，所以我对 zip 之后的结果进行遍历就可以方便地写代码了。

> 这个技巧用处不大，可以不必掌握，大家知道有这么回事就行

有的人可能想问，我的语言没有 zip 怎么办？ 我的答案是自行实现 zip。 比如 JavaScript 可以这样实现 zip：

```js
const zip = (rows) => rows[0].map((_, c) => rows.map((row) => row[c]));
```

你把它改造成自己的语言版本即可。

### 取模

力扣中有很多题目需要你对返回值取模，而且一般都是对 109 + 7 取模。

比如 [1680. 连接连续二进制数字](https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/)

题目描述：

```
给你一个整数 n ，请你将 1 到 n 的二进制表示连接起来，并返回连接结果对应的 十进制 数字对 109 + 7 取余的结果。
```

如果我忘记取模或者仅在返回的时候取模都可能会报错，正确的姿势是提前取模。

以上面的题目来说，代码这样写是可以过的。

```py
class Solution:
    def concatenatedBinary(self, n: int) -> int:
        ans = 0
        mod = 10 **9 + 7
        for i in range(1, n + 1):
            ans = (ans * pow(2, len(bin(i)[2:])) + i) % mod
        return ans % mod
```

而如果我这么写会超时(没有提前取模，只是在最后返回才取模)：

```py
class Solution:
    def concatenatedBinary(self, n: int) -> int:
        ans = 0
        mod = 10 **9 + 7
        for i in range(1, n + 1):
            ans = (ans * pow(2, len(bin(i)[2:])) + i)
        return ans % mod
```

如果不提前 mod， python 可能超时，其他语言可能溢出。

提前取 mod，会把数值限定在 int 能处理的范围，使用机器自身整数运算功能进行快速运算，而如果之后取 mod，由于 python 对大整数支持的特性，会将 ans 转换为大整数再进行运算，计算相对耗时

其他类似的技巧有：

- 判断奇偶

判断一个数是奇数还是偶数可以通过和 2 取模。 如果返回值是 0 则是偶数，否则是奇数。

需要注意的是和 2 取模为 1 奇数，但是反之不然。即**和 2 取模不是 1 也可能是奇数，比如负数**，因此还需要多个判断，不如用我上面的方法。

- 二分取中间值。比如：

```
mid = (l + r) // 2
```

> // 是地板除

上面代码在某些语言可能会大数溢出，一种解决方案是这样写：

```
mid = (r - l) // 2 + l
```

等等。。。

欢迎大家补充~

### 其他

尽量不要使用全局变量。

使用全局变量且没有及时清除，不仅可能有性能问题，更可能会在多个测试用例之间形成干扰，导致出错。

力扣设计题目通常是会多次调用某一个 api 的。这个时候更是如此，不要使用全局变量。

有一些朋友向我反馈“为啥本地好好的，放到力扣上提交就不行”，先检查下有没有使用全局变量。

## 调试技巧

调试技巧，我们这里先讲两个：

1. 批量测试
2. 数据结构可视化（树的可视化）

### 批量测试

力扣的测试用例其实是可以一次写多个的。

![](https://tva1.sinaimg.cn/large/0081Kckwly1glaxys6s2gj30pi0letcl.jpg)

如上图，该题目有两个参数。那两行其实就是**一个完整用例**。 我这里输入了六行，也就是三个用例。这个时候点击执行，就可以一次执行三个用例。

> 妈妈再也不用担心我提交太频繁啦~

执行成功后，我们可以一次查看所有的差异。

![](https://tva1.sinaimg.cn/large/0081Kckwly1glay1130cnj313j084q3r.jpg)

如果你老是考虑不到各种边界，那这个功能简直是福音。 另外如果你打比赛，你可以把题目给的测试用例批量复制到这里一次执行看结果，非常有用。

### 树的可视化

力扣支持大家对树进行可视化，只要点击这个**树结构可视化按钮**即可（只有树的题目才有这个按钮）。

![](https://tva1.sinaimg.cn/large/0081Kckwly1glay3e4j34j31450lq0uz.jpg)

如果你写了多个数组，也并不会生成多个树，貌似是以最后一次输入为准。

力扣暂时没有提供其他数据结构的可视化，比如数组，链表等。这可能对大部分人来说没什么，但是对于我这样经常写题解，画图的人就不一样了。如果可以快速画图，那么对我效率肯定有大幅度的提升。

> lucifer 建议大家也养成写题解的好习惯。

因此我打算在我的刷题插件里面加其他数据结构的可视化功能， 已经在规划啦~ 现在草稿了一些东西。

比如这样的树：

![](https://tva1.sinaimg.cn/large/0081Kckwly1glay88vsibj30yq0o9mz5.jpg)

和这样的树：

![](https://tva1.sinaimg.cn/large/0081Kckwly1glayb242idj30n509fmy9.jpg)

现在其实还有些问题，而且我想**多加几种数据结构**方便写题解，所以就之后再说好了。

## 絮叨

我们的刷题插件正式上架谷歌商店啦，赶紧用起来吧~

上次给大家说了要总结和记忆模板。还说了给我的插件加一个模板功能， 我果然很可靠！

![](https://tva1.sinaimg.cn/large/0081Kckwly1glawnsz0n9j306o06lgmx.jpg)

自古深情留不住，唯有套路得人心。 我的刷题插件给大家准备了几种常见的模板帮你快速高效解题。 比如下面这个 hard 题目， 就是一个 BFS 模板 + 状态压缩模板，类似的题目数不胜数，基本都是套个模板改几个地方就过了。

再比如，下面这个 1439 hard 题， 不就一个二分模板（最左满足条件） + 二维网格 DFS 么？

给大家提供多种刷题模板，可以直接复制使用。 各个模板都有都有的题目，大家可以直达题目进行”默写“。

![](https://tva1.sinaimg.cn/large/0081Kckwly1glawoq00uwj30pb09ogmo.jpg)

![](https://tva1.sinaimg.cn/large/0081Kckwly1glawp0t0vlj30mm0h2ta4.jpg)

插件地址：https://chrome.google.com/webstore/detail/leetcode-cheatsheet/fniccleejlofifaakbgppmbbcdfjonle?hl=en-US。

> 不能访问谷歌商店的朋友可以去我的公众号回复插件获取离线版。

另外我的插件后续计划增加更多功能，有消息我会通过公众号和大家同步。

## 预告

下期给大家讲**更加干货**的技巧，一定不要错过哦。

- 一看就会，一写就废， 如何克服？
- **如何锁定使用哪种算法**。比如我看到了这道题，我怎么知道该用什么解法呢？二分？动态规划？
