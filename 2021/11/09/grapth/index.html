<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>面试中图论都考什么？这篇文章告诉你！ | lucifer的网络博客</title>
  
  <meta name="keywords" content="前端 leetocde 数据结构 算法 lucifer 大前端 性能优化 前端架构 前端工程化">
  
  
  <meta name="description" content="lucifer的个人博客，用来记录LeeCode刷题过程和心得，以及构建大前端知识体系">
  

  
  <link rel="alternate" href="/blog/atom.xml" title="lucifer的网络博客">
  

  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css">
  

  
  <link rel="shortcut icon" type="image/x-icon" href="https://avatars0.githubusercontent.com/u/12479470?s=400&u=442571e44cbd0b67e3503e9551d4445c78f593f8&v=4">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9.9/css/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FVTTYT432Q"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-FVTTYT432Q');
    </script>
  
  
    <!-- ba -->
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?576ec211e11a69128667eb8c11a6cffe";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
  
</head>

  <script
    src="https://my.openwrite.cn/js/readmore.js"
    type="text/javascript"
  ></script>
  <script>
    var btw = new BTWPlugin();
    setTimeout(function () {
      window.btw.init({
        id: "container",
        blogId: "17446-1571644985832-648",
        name: "力扣加加",
        qrcode: "https://p.ipic.vip/n8gbxo.jpg",
        keyword: "more",
      });
    }, 100);
  </script>
  <body>
    
    
  <div class="cover-wrapper">
    <cover class='cover post half'>
      
        
  <h1 class='title'>lucifer</h1>


  <div class="m_search">
    <form name="searchform" class="form u-search-form">
      <input type="text" class="input u-search-input" placeholder="" />
      <i class="icon fas fa-search fa-fw"></i>
    </form>
  </div>

<div class='menu navgation'>
  <ul class='h-list'>
    
      
        <li>
          <a class="nav home" href="/blog/"
            
            
            id="blog">
            <i class='fas fa-home fa-fw'></i>&nbsp;主页
          </a>
        </li>
      
        <li>
          <a class="nav home" href="http://leetcode-solution.cn/"
            
            
            id="http:leetcode-solution.cn">
            <i class='fas fa-laptop-code fa-fw'></i>&nbsp;官网
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/blog/friends/"
            
            
            id="blogfriends">
            <i class='fas fa-link fa-fw'></i>&nbsp;友链
          </a>
        </li>
      
        <li>
          <a class="nav home" href="/blog/about/"
            
            
            id="blogabout">
            <i class='fas fa-id-card-alt fa-fw'></i>&nbsp;联系我
          </a>
        </li>
      
    
  </ul>
</div>

      
    </cover>
    <header class="l_header pure">
  <div id="loading-bar-wrapper">
    <div id="loading-bar" class="pure"></div>
  </div>

	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/blog/' >
        
          lucifer的网络博客
        
      </a>
			<div class='menu navgation'>
				<ul class='h-list'>
          
  					
  						<li>
								<a class="nav flat-box" href="/blog/"
                  
                  
                  id="blog">
									<i class='fas fa-grin fa-fw'></i>&nbsp;回到主页
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/categories/"
                  
                  
                  id="blogcategories">
									<i class='fas fa-folder-open fa-fw'></i>&nbsp;分类
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/tags/"
                  
                  
                  id="blogtags">
									<i class='fas fa-hashtag fa-fw'></i>&nbsp;标签
								</a>
							</li>
      			
  						<li>
								<a class="nav flat-box" href="/blog/archives/"
                  
                  
                  id="blogarchives">
									<i class='fas fa-archive fa-fw'></i>&nbsp;归档
								</a>
							</li>
      			
      		
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索" />
						<i class="icon fas fa-search fa-fw"></i>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
        
          <li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
        
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu navgation">
      <ul>
        
          
            <li>
							<a class="nav flat-box" href="/blog/"
                
                
                id="blog">
								<i class='fas fa-clock fa-fw'></i>&nbsp;近期文章
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/archives/"
                
                
                id="blogarchives">
								<i class='fas fa-archive fa-fw'></i>&nbsp;文章归档
							</a>
            </li>
          
            <li>
							<a class="nav flat-box" href="/blog/about/"
                
                
                id="blogabout">
								<i class='fas fa-info-circle fa-fw'></i>&nbsp;关于小站
							</a>
            </li>
          
       
      </ul>
		</nav>
    </header>
	</aside>
<script>setLoadingBarProgress(40);</script>

  </div>


    <div id="container" class="l_body">
      <div class="body-wrapper">
        <div class='l_main'>
  

  <article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost">
    


  <section class='meta'>
    
    
    <div class="meta" id="header-meta">
      
        
  
    <h1 class="title">
      <a href="/blog/2021/11/09/grapth/">
        面试中图论都考什么？这篇文章告诉你！
      </a>
    </h1>
  


      
      <div class='new-meta-box'>
        
          
        
          
            
  <div class='new-meta-item author'>
    
      <a href="https://lucifer.ren/blog" rel="nofollow">
        
          <img src="https://avatars0.githubusercontent.com/u/12479470?s=400&u=442571e44cbd0b67e3503e9551d4445c78f593f8&v=4">
        
        <p>lucifer</p>
      </a>
    
  </div>


          
        
          
            <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt" aria-hidden="true"></i>
    <p>2021-11-09</p>
  </a>
</div>

          
        
          
            
  
  <div class='new-meta-item category'>
    <a href='/blog/categories/图/' rel="nofollow">
      <i class="fas fa-folder-open" aria-hidden="true"></i>
      <p>图</p>
    </a>
  </div>


          
        
          
            
  


          
        
          
            

          
        
          
            
  
    <div style="margin-right: 10px;">
      <span class="post-time">
        <span class="post-meta-item-icon">
          <i class="fa fa-keyboard"></i>
          <span class="post-meta-item-text">  字数统计: </span>
          <span class="post-count">10.3k字</span>
        </span>
      </span>
      &nbsp; | &nbsp;
      <span class="post-time">
        <span class="post-meta-item-icon">
          <i class="fa fa-hourglass-half"></i>
          <span class="post-meta-item-text">  阅读时长≈</span>
          <span class="post-count">42分</span>
        </span>
      </span>
    </div>
  

          
        
      </div>
      
        <hr>
      
    </div>
  </section>


    <section class="article typo">
      <div class="article-entry" itemprop="articleBody">
        <p>图论〔Graph Theory〕是数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。</p>
<p> 如下就是一种逻辑上的图结构：</p>
<p><img src="https://p.ipic.vip/61dmay.jpg" alt="逻辑上的图结构"></p>
<p>图是一种最复杂的数据结构，前面讲的数据结构都可以看成是图的特例。那为什么不都用图就好了，还要分那么多种数据结构呢？</p>
<p>这是因为很多时候不需要用到那么复杂的功能，图的很多特性都不具备，如果笼统地都称为图那么非常不利于沟通。你想你和别人沟通总不至于说这道题是考察一种特殊的图，这种图。。。。 这未免太啰嗦了，因此给其他图的特殊的图起了特殊的名字，这样就方便沟通了。直到遇到了非常复杂的情况，我们才会用到 <strong>”真正“的图</strong>。</p>
<p>前面章节提到了<strong>数据结构就是为了算法服务的，数据结构就是存储数据用的，目的是为了更高效。</strong> 那么什么时候需要用图来存储数据，在这种情况图高效在哪里呢？答案很简单，那就是如果你用其他简单的数据结构无法很好地进行存储，就应该使用图了。 比如我们需要存储一种双向的朋友关系，并且这种朋友关系是多对多的，那就一定要用到图，因为其他数据结构无法模拟。</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="无向图-amp-有向图〔Undirected-Graph-amp-Deriected-Graph〕"><a href="#无向图-amp-有向图〔Undirected-Graph-amp-Deriected-Graph〕" class="headerlink" title="无向图 &amp; 有向图〔Undirected Graph &amp; Deriected Graph〕"></a>无向图 &amp; 有向图〔Undirected Graph &amp; Deriected Graph〕</h3><p>前面提到了二叉树完全可以实现其他树结构，类似地，有向图也完全可以实现无向图和混合图，因此有向图的研究一直是重点考察对象。</p>
<p><strong>本文讲的所有图都是有向图</strong>。</p>
<p>前面提到了我们用连接两点的线表示相应两个事物间具有这种关系。因此如果两个事物间的关系是有方向的，就是有向图，否则就是无向图。比如：A 认识 B，那么 B 不一定认识 A。那么关系就是单向的，我们需要用有向图来表示。因为如果用无向图表示，我们无法区分 A 和 B 的边表示的是 A 认识 B 还是 B 认识 A。</p>
<p>习惯上，我们画图的时候用带箭头的表示有向图，不带箭头的表示无向图。</p>
<h3 id="有权图-amp-无权图〔Weighted-Graph-amp-Unweighted-Graph〕"><a href="#有权图-amp-无权图〔Weighted-Graph-amp-Unweighted-Graph〕" class="headerlink" title="有权图 &amp; 无权图〔Weighted Graph &amp; Unweighted Graph〕"></a>有权图 &amp; 无权图〔Weighted Graph &amp; Unweighted Graph〕</h3><p>如果边是有权重的是有权图（或者带权图），否则是无权图（或不带权图）。那么什么是有权重呢？比如汇率就是一种有权重的逻辑图。1 货币 A 兑换 5 货币 B，那么我们 A 和 B 的边的权重就是 5。而像朋友这种关系，就可以看做一种不带权的图。</p>
<h3 id="入度-amp-出度〔Indegree-amp-Outdegree〕"><a href="#入度-amp-出度〔Indegree-amp-Outdegree〕" class="headerlink" title="入度 &amp; 出度〔Indegree &amp; Outdegree〕"></a>入度 &amp; 出度〔Indegree &amp; Outdegree〕</h3><p>有多少边指向节点 A，那么节点 A 的入度就是多少。同样地，有多少边从 A 发出，那么节点 A 的出度就是多少。</p>
<p>仍然以上面的图为例，这幅图的所有节点的入度和出度都为 1。</p>
<p><img src="https://p.ipic.vip/4fdl49.jpg" alt></p>
<h3 id="路径-amp-环〔路径：Path〕"><a href="#路径-amp-环〔路径：Path〕" class="headerlink" title="路径 &amp; 环〔路径：Path〕"></a>路径 &amp; 环〔路径：Path〕</h3><ul>
<li>有环图〔Cyclic Graph〕 上面的图就是一个有环图，因为我们从图中的某一个点触发，能够重新回到起点。这和现实中的环是一样的。</li>
<li>无环图〔Acyclic Graph〕</li>
</ul>
<p>我可以将上面的图稍加改造就变成了无环图，此时没有任何一个环路。</p>
<p><img src="https://p.ipic.vip/ta8mdh.jpg" alt></p>
<h3 id="连通图-amp-强连通图"><a href="#连通图-amp-强连通图" class="headerlink" title="连通图 &amp; 强连通图"></a>连通图 &amp; 强连通图</h3><p>在无向图中，若<strong>任意两个顶点</strong> i 与 j 都有路径<strong>相通</strong>，则称该无向图为连通图。</p>
<p>在有向图中，若<strong>任意两个顶点</strong> i 与 j 都有路径<strong>相通</strong>，则称该有向图为强连通图。</p>
<h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>一个连通图的生成树是指一个连通子图，它含有图中全部 n 个顶点，但只有足以构成一棵树的 n-1 条边。一颗有 n 个顶点的生成树有且仅有 n-1 条边，如果生成树中再添加一条边，则必定成环。在连通网的所有生成树中，所有边的<strong>代价和最小</strong>的生成树，称为最小生成树，其中<strong>代价和</strong>指的是所有边的权重和。</p>
<h2 id="图的建立"><a href="#图的建立" class="headerlink" title="图的建立"></a>图的建立</h2><p>一般图的题目都不会给你一个现成的图的数据结构。当你知道这是一个图的题目的时候，解题的第一步通常就是建图。</p>
<p>上面讲的都是图的逻辑结构，那么计算机中的图如何存储呢？</p>
<p>我们知道图是有点和边组成的。理论上，我们只要存储图中的所有的边关系即可，因为边中已经包含了两个点的关系。</p>
<p>这里我简单介绍两种常见的建图方式：邻接矩阵（常用，重要）和邻接表。</p>
<h3 id="邻接矩阵（常见）〔Adjacency-Matrixs〕"><a href="#邻接矩阵（常见）〔Adjacency-Matrixs〕" class="headerlink" title="邻接矩阵（常见）〔Adjacency Matrixs〕"></a>邻接矩阵（常见）〔Adjacency Matrixs〕</h3><p>第一种方式是使用数组或者哈希表来存储图，这里我们用二维数组来存储。</p>
<p>使用一个 n * n 的矩阵来描述图 graph，其就是一个二维的矩阵，其中 graph[i][j] 描述边的关系。</p>
<p>一般而言，对于无权图我都用 graph[i][j] = 1 来表示 顶点 i 和顶点 j 之间有一条边，并且边的指向是从 i 到 j。用 graph[i][j] = 0 来表示 顶点 i 和顶点 j 之间不存在一条边。 对于有权图来说，我们可以存储其他数字，表示的是权重。</p>
<p><img src="https://p.ipic.vip/0ctqfy.jpg" alt></p>
<p>可以看出上图是对角线对称的，这样我们只需看一半就好了，这就造成了一半的空间浪费。</p>
<p>这种存储方式的空间复杂度为 O(n ^ 2)，其中 n 为顶点个数。如果是稀疏图（图的边的数目远小于顶点的数目），那么会很浪费空间。并且如果图是无向图，始终至少会有 50 % 的空间浪费。下面的图也直观地反应了这一点。</p>
<p>邻接矩阵的优点主要有：</p>
<ol>
<li><p>直观，简单。</p>
</li>
<li><p>判断两个顶点是否连接，获取入度和出度以及更新度数，时间复杂度都是 O(1)</p>
</li>
</ol>
<p>由于使用起来比较简单， 因此我的所有的需要建图的题目基本都用这种方式。</p>
<p>比如力扣 743. 网络延迟时间。 题目描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">有 N 个网络节点，标记为 1 到 N。</span><br><span class="line"></span><br><span class="line">给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。</span><br><span class="line"></span><br><span class="line">现在，我们从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2</span><br><span class="line">输出：2</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">N 的范围在 [1, 100] 之间。</span><br><span class="line">K 的范围在 [1, N] 之间。</span><br><span class="line">times 的长度在 [1, 6000] 之间。</span><br><span class="line">所有的边 times[i] = (u, v, w) 都有 1 &lt;= u, v &lt;= N 且 0 &lt;= w &lt;= 100。</span><br></pre></td></tr></table></figure>
<p>这是一个典型的图的题目，对于这道题，我们如何用邻接矩阵建图呢？</p>
<p>一个典型的建图代码：</p>
<p>使用哈希表构建邻接矩阵：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph = collections.defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> fr, to, w <span class="keyword">in</span> times:</span><br><span class="line">    graph[fr - <span class="number">1</span>].append((to - <span class="number">1</span>, w))</span><br></pre></td></tr></table></figure>
<p>使用二维数组构建邻接矩阵：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="comment"># 新建一个 m * n 的二维矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fr, to, w <span class="keyword">in</span> times:</span><br><span class="line">    graph[fr<span class="number">-1</span>][to<span class="number">-1</span>] = w</span><br></pre></td></tr></table></figure>
<p>这就构造了一个临界矩阵，之后我们基于这个邻接矩阵遍历图即可。</p>
<h3 id="邻接表〔Adjacency-List〕"><a href="#邻接表〔Adjacency-List〕" class="headerlink" title="邻接表〔Adjacency List〕"></a>邻接表〔Adjacency List〕</h3><p>对于每个点，存储着一个链表，用来指向所有与该点直接相连的点。对于有权图来说，链表中元素值对应着权重。</p>
<p>例如在无向无权图中：</p>
<p><img src="https://p.ipic.vip/6cmkro.jpg" alt="graph-1"><br>（图片来自 <a href="https://zhuanlan.zhihu.com/p/25498681）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25498681）</a></p>
<p>可以看出在无向图中，邻接矩阵关于对角线对称，而邻接链表总有两条对称的边。</p>
<p>而在有向无权图中：</p>
<p><img src="https://p.ipic.vip/fkkcvv.jpg" alt="graph-2"></p>
<p>（图片来自 <a href="https://zhuanlan.zhihu.com/p/25498681）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25498681）</a></p>
<p>由于邻接表使用起来稍微麻烦一点，另外也不常用。为了减少初学者的认知负担，我就不贴代码了。</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>图建立好了，接下来就是要遍历了。</p>
<p>不管你是什么算法，肯定都要遍历的，一般有这两种方法：深度优先搜索，广度优先搜索（其他奇葩的遍历方式实际意义不大，没有必要学习）。</p>
<p>不管是哪一种遍历， 如果图有环，就一定要记录节点的访问情况，防止死循环。当然你可能不需要真正地使用一个集合记录节点的访问情况，比如使用一个数据范围外的数据原地标记，这样的空间复杂度会是 $O(1)$。</p>
<p>这里以有向图为例， 有向图也是类似，这里不再赘述。</p>
<blockquote>
<p>关于图的搜索，后面的搜索专题也会做详细的介绍，因此这里就点到为止。</p>
</blockquote>
<h3 id="深度优先遍历〔Depth-First-Search-DFS〕"><a href="#深度优先遍历〔Depth-First-Search-DFS〕" class="headerlink" title="深度优先遍历〔Depth First Search, DFS〕"></a>深度优先遍历〔Depth First Search, DFS〕</h3><p>深度优先遍历图的方法是，从图中某顶点 v 出发， 不断访问邻居， 邻居的邻居直到访问完毕。</p>
<p><img src="https://p.ipic.vip/duzk1f.jpg" alt></p>
<p>如上图， 如果我们使用 DFS，并且从 A 节点开始的话， <strong>一个可能的</strong>的访问顺序是： <strong>A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</strong>，当然也可能是 <strong>A -&gt; D -&gt; C -&gt; B -&gt; F -&gt; G -&gt; E</strong> 等，具体取决于你的代码，但他们都是深度优先的。</p>
<h3 id="广度优先搜索〔Breadth-First-Search-BFS〕"><a href="#广度优先搜索〔Breadth-First-Search-BFS〕" class="headerlink" title="广度优先搜索〔Breadth First Search, BFS〕"></a>广度优先搜索〔Breadth First Search, BFS〕</h3><p>广度优先搜索，可以被形象地描述为 “浅尝辄止”，它也需要一个队列以保持遍历过的顶点顺序，以便按出队的顺序再去访问这些顶点的邻接顶点。</p>
<p><img src="https://p.ipic.vip/ozy2ye.jpg" alt></p>
<p>如上图， 如果我们使用 BFS，并且从 A 节点开始的话， <strong>一个可能的</strong>的访问顺序是： <strong>A -&gt; B -&gt; C -&gt; F -&gt; E -&gt; G -&gt; D</strong>，当然也可能是 <strong>A -&gt; B -&gt; F -&gt; E -&gt; C -&gt; G -&gt; D</strong> 等，具体取决于你的代码，但他们都是广度优先的。</p>
<p>需要注意的是 DFS 和 BFS 只是一种算法思想，不是一种具体的算法。 因此其有着很强的适应性，而不是局限于特点的数据结构的，本文讲的图可以用，前面讲的树也可以用。实际上， 只要是<strong>非线性的数据结构都可以用</strong>。</p>
<h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><p>图的题目的算法比较适合套模板。</p>
<p>这里介绍几种常见的板子题。主要有：</p>
<ul>
<li>Dijkstra</li>
<li>Floyd-Warshall</li>
<li>最小生成树（Kruskal &amp; Prim） 目前此小节已经删除，觉得自己写的不够详细，之后补充完成会再次开放。</li>
<li>A 星寻路算法</li>
<li>二分图（染色法）〔Bipartitie〕</li>
<li>拓扑排序〔Topological Sort〕</li>
</ul>
<p>下面列举常见算法的模板。</p>
<blockquote>
<p>以下所有的模板都是基于邻接矩阵建图。</p>
</blockquote>
<p>强烈建议大家学习完专题篇的搜索之后再来学习下面经典算法。大家可以拿几道普通的搜索题目测试下，如果能够做出来再往下学习。推荐题目：<a href="https://leetcode-cn.com/problems/maximum-path-quality-of-a-graph/" title="最大化一张图中的路径价值" target="_blank" rel="noopener">最大化一张图中的路径价值</a></p>
<h3 id="最短距离，最短路径"><a href="#最短距离，最短路径" class="headerlink" title="最短距离，最短路径"></a>最短距离，最短路径</h3><h4 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h4><p>DIJKSTRA 基本思想是广度优先遍历。实际上搜索的最短路算法基本思想都是广度优先，只不过具体的扩展策略不同而已。</p>
<p>DIJKSTRA 算法主要解决的是图中<strong>任意一点</strong>到图中<strong>另外任意一个点</strong>的最短距离，即单源最短路径。</p>
<blockquote>
<p>Dijkstra 这个名字比较难记，大家可以简单记为<strong>DJ 算法</strong>，有没有好记很多？</p>
</blockquote>
<p>比如给你几个城市，以及城市之间的距离。让你规划一条最短的从城市 a 到城市 b 的路线。</p>
<p>这个问题，我们就可以先将城市间的距离用图建立出来，然后使用 dijkstra 来做。那么 dijkstra 究竟如何计算最短路径的呢？</p>
<p>dj 算法的基本思想是贪心。从起点 start 开始，每次都遍历所有邻居，并从中找到距离最小的，本质上是一种广度优先遍历。这里我们借助堆这种数据结构，使得可以在 $logN$ 的时间内找到 cost 最小的点。</p>
<blockquote>
<p>而如果使用普通的队列的话，其实是图中所有边权值都相同的特殊情况。</p>
</blockquote>
<p>比如我们要找从点 start 到点 end 的最短距离。我们期望 dj 算法是这样被使用的。</p>
<p>比如一个图是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E -- 1 --&gt; B -- 1 --&gt; C -- 1 --&gt; D -- 1 --&gt; F</span><br><span class="line"> \                                         /\</span><br><span class="line">  \                                        ||</span><br><span class="line">    -------- 2 ---------&gt; G ------- 1 ------</span><br></pre></td></tr></table></figure>
<p>我们使用邻接矩阵来构造：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">G = &#123;</span><br><span class="line">    <span class="string">"B"</span>: [[<span class="string">"C"</span>, <span class="number">1</span>]],</span><br><span class="line">    <span class="string">"C"</span>: [[<span class="string">"D"</span>, <span class="number">1</span>]],</span><br><span class="line">    <span class="string">"D"</span>: [[<span class="string">"F"</span>, <span class="number">1</span>]],</span><br><span class="line">    <span class="string">"E"</span>: [[<span class="string">"B"</span>, <span class="number">1</span>], [<span class="string">"G"</span>, <span class="number">2</span>]],</span><br><span class="line">    <span class="string">"F"</span>: [],</span><br><span class="line">    <span class="string">"G"</span>: [[<span class="string">"F"</span>, <span class="number">1</span>]],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shortDistance = dijkstra(G, <span class="string">"E"</span>, <span class="string">"C"</span>)</span><br><span class="line">print(shortDistance)  <span class="comment"># E -- 3 --&gt; F -- 3 --&gt; C == 6</span></span><br></pre></td></tr></table></figure>
<p>具体算法：</p>
<ol>
<li>初始化堆。堆里的数据都是 (cost, v) 的二元祖，其含义是“从 start 走到 v 的距离是 cost”。因此初始情况，堆中存放元组 (0, start)</li>
<li>从堆中 pop 出来一个 (cost, v)，第一次 pop 出来的一定是 (0, start)。 如果 v 被访问过了，那么跳过，防止环的产生。</li>
<li>如果 v 是 我们要找的终点，直接返回 cost，此时的 cost 就是从 start 到 该点的最短距离</li>
<li>否则，将 v 的邻居入堆，即将 (neibor, cost + c) 加入堆。其中 neibor 为 v 的邻居， c 为 v 到 neibor 的距离（也就是转移的代价）。</li>
</ol>
<p>重复执行 2 - 4 步</p>
<p>代码模板：</p>
<p>Python</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(graph, start, end)</span>:</span></span><br><span class="line">    <span class="comment"># 堆里的数据都是 (cost, i) 的二元祖，其含义是“从 start 走到 i 的距离是 cost”。</span></span><br><span class="line">    heap = [(<span class="number">0</span>, start)]</span><br><span class="line">    visited = set()</span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        (cost, u) = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">if</span> u <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        visited.add(u)</span><br><span class="line">        <span class="keyword">if</span> u == end:</span><br><span class="line">            <span class="keyword">return</span> cost</span><br><span class="line">        <span class="keyword">for</span> v, c <span class="keyword">in</span> graph[u]:</span><br><span class="line">            <span class="keyword">if</span> v <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            next = cost + c</span><br><span class="line">            heapq.heappush(heap, (next, v))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dijkstra = <span class="function">(<span class="params">graph, start, end</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">const</span> minHeap = <span class="keyword">new</span> MinPriorityQueue();</span><br><span class="line">  <span class="comment">//注：此处new MinPriorityQueue()用了LC的内置API，它的enqueue由两个部分组成：</span></span><br><span class="line">  <span class="comment">//element 和 priority。</span></span><br><span class="line">  <span class="comment">//堆会按照priority排序，可以用element记录一些内容。</span></span><br><span class="line">  minHeap.enqueue(startPoint, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!minHeap.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;element, priority&#125; = minHeap.dequeue();</span><br><span class="line">    <span class="comment">//下面这两个变量不是必须的，只是便于理解</span></span><br><span class="line">    <span class="keyword">const</span> curPoint = element;</span><br><span class="line">    <span class="keyword">const</span> curCost = priority;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(curPoint === end) <span class="keyword">return</span> curCost;</span><br><span class="line">    <span class="keyword">if</span>(visited.has(curPoint)) <span class="keyword">continue</span>;</span><br><span class="line">    visited.add(curPoint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!graph[curPoint]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> [nextPoint, nextCost] <span class="keyword">of</span> graph[curPoint])&#123;</span><br><span class="line">      <span class="keyword">if</span>(visited.has(nextPoint)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//注意heap里面的一定是从startPoint到某个点的距离；</span></span><br><span class="line">      <span class="comment">//curPoint到nextPoint的距离是nextCost；但curPoint不一定是startPoint。</span></span><br><span class="line">      <span class="keyword">const</span> accumulatedCost = nextCost + curCost;</span><br><span class="line">      minHeap.enqueue(nextPoint, accumulatedCost);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会了这个算法模板， 你就可以去 AC 743. 网络延迟时间 了。</p>
<p>这里提供完整代码供大家参考：  </p>
<p>Python</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(self, graph, start, end)</span>:</span></span><br><span class="line">        heap = [(<span class="number">0</span>, start)]</span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="keyword">while</span> heap:</span><br><span class="line">            (cost, u) = heapq.heappop(heap)</span><br><span class="line">            <span class="keyword">if</span> u <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            visited.add(u)</span><br><span class="line">            <span class="keyword">if</span> u == end:</span><br><span class="line">                <span class="keyword">return</span> cost</span><br><span class="line">            <span class="keyword">for</span> v, c <span class="keyword">in</span> graph[u]:</span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">in</span> visited:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                next = cost + c</span><br><span class="line">                heapq.heappush(heap, (next, v))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times: List[List[int]], N: int, K: int)</span> -&gt; int:</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> fr, to, w <span class="keyword">in</span> times:</span><br><span class="line">            graph[fr - <span class="number">1</span>].append((to - <span class="number">1</span>, w))</span><br><span class="line">        ans = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> to <span class="keyword">in</span> range(N):</span><br><span class="line">            dist = self.dijkstra(graph, K - <span class="number">1</span>, to)</span><br><span class="line">            <span class="keyword">if</span> dist == <span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            ans = max(ans, dist)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> networkDelayTime = <span class="function">(<span class="params">times, n, k</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//咳咳这个解法并不是Dijkstra在本题的最佳解法</span></span><br><span class="line">    <span class="keyword">const</span> graph = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> [<span class="keyword">from</span>, to, weight] <span class="keyword">of</span> times)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!graph[<span class="keyword">from</span>]) graph[<span class="keyword">from</span>] = [];</span><br><span class="line">        graph[<span class="keyword">from</span>].push([to, weight]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> to = <span class="number">1</span>; to &lt;= n; to++)&#123;</span><br><span class="line">        <span class="keyword">let</span> dist = dikstra(graph, k, to)</span><br><span class="line">        <span class="keyword">if</span>(dist === <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ans = <span class="built_in">Math</span>.max(ans, dist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dijkstra = <span class="function">(<span class="params">graph, startPoint, endPoint</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  <span class="keyword">const</span> minHeap = <span class="keyword">new</span> MinPriorityQueue();</span><br><span class="line">  <span class="comment">//注：此处new MinPriorityQueue()用了LC的内置API，它的enqueue由两个部分组成：</span></span><br><span class="line">  <span class="comment">//element 和 priority。</span></span><br><span class="line">  <span class="comment">//堆会按照priority排序，可以用element记录一些内容。</span></span><br><span class="line">  minHeap.enqueue(startPoint, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!minHeap.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;element, priority&#125; = minHeap.dequeue();</span><br><span class="line">    <span class="comment">//下面这两个变量不是必须的，只是便于理解</span></span><br><span class="line">    <span class="keyword">const</span> curPoint = element;</span><br><span class="line">    <span class="keyword">const</span> curCost = priority;</span><br><span class="line">    <span class="keyword">if</span>(visited.has(curPoint)) <span class="keyword">continue</span>;</span><br><span class="line">    visited.add(curPoint)</span><br><span class="line">    <span class="keyword">if</span>(curPoint === endPoint) <span class="keyword">return</span> curCost;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!graph[curPoint]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> [nextPoint, nextCost] <span class="keyword">of</span> graph[curPoint])&#123;</span><br><span class="line">      <span class="keyword">if</span>(visited.has(nextPoint)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">//注意heap里面的一定是从startPoint到某个点的距离；</span></span><br><span class="line">      <span class="comment">//curPoint到nextPoint的距离是nextCost；但curPoint不一定是startPoint。</span></span><br><span class="line">      <span class="keyword">const</span> accumulatedCost = nextCost + curCost;</span><br><span class="line">      minHeap.enqueue(nextPoint, accumulatedCost);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DJ 算法的时间复杂度为 $vlogv+e$，其中 v 和 e 分别为图中的点和边的个数。</p>
<p>最后给大家留一个思考题：如果是计算一个点到图中<strong>所有点</strong>的距离呢？我们的算法会有什么样的调整？</p>
<blockquote>
<p>提示：你可以使用一个 dist 哈希表记录开始点到每个点的最短距离来完成。想出来的话，可以用力扣 882 题去验证一下哦~</p>
</blockquote>
<p>值得注意的是， Dijkstra 无法处理边权值为负的情况。即如果出现负权值的边，那么答案可能不正确。而基于动态规划算法的最短路（下文会讲）则可以处理这种情况。</p>
<h4 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h4><p>Floyd-Warshall 可以<strong>解决任意两个点距离</strong>，即多源最短路径，这点和 dj 算法不一样。</p>
<p>除此之外，贝尔曼-福特算法也是解决最短路径的经典动态规划算法，这点和 dj 也是不一样的，dj 是基于贪心的。</p>
<p>相比上面的 dijkstra 算法， 由于其计算过程会把中间运算结果保存起来防止重复计算，因此其特别适合<strong>求图中任意两点的距离</strong>，比如力扣的 1462. 课程安排 IV。除了这个优点。下文要讲的贝尔曼-福特算法相比于此算法最大的区别在于本算法是多源最短路径，而贝尔曼-福特则是单源最短路径。不管是复杂度和写法， 贝尔曼-福特算法都更简单，我们后面给大家介绍。</p>
<blockquote>
<p>当然就不是说贝尔曼算法以及上面的 dijkstra 就不支持多源最短路径，你只需要加一个 for 循环枚举所有的起点罢了。</p>
</blockquote>
<p>还有一个非常重要的点是 Floyd-Warshall 算法由于使用了<strong>动态规划</strong>的思想而不是贪心，因此其<strong>可以处理负权重</strong>的情况，这点需要大家尤为注意。 动态规划的详细内容请参考之后的<strong>动态规划专题</strong>和<strong>背包问题</strong>。</p>
<p>算法也不难理解，简单来说就是： <strong>i 到 j 的最短路径 = i 到 k 的最短路径 + k 到 j 的最短路径</strong>的最小值。如下图：</p>
<p><img src="https://p.ipic.vip/mlyy8u.jpg" alt></p>
<p>u 到 v 的最短距离是 u 到 x 的最短距离 + x 到 v 的最短距离。上图 x 是 u 到 v 的必经之路，如果不是的话，我们需要多个中间节点的值，并取最小的。</p>
<p>算法的正确性不言而喻，因为从 i 到 j，要么直接到，要么经过图中的另外一个点 k，中间节点 k 可能有多个，经过中间点的情况取出最小的，自然就是 i 到 j 的最短距离。</p>
<blockquote>
<p>思考题： 最长无环路径可以用动态规划来解么？</p>
</blockquote>
<p>该算法的时间复杂度是 $O(N^3)$，空间复杂度是 $O(N^2)$，其中 N 为顶点个数。</p>
<p>代码模板：</p>
<p>Python</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># graph 是邻接矩阵，n 是顶点个数</span></span><br><span class="line"><span class="comment"># graph 形如： graph[u][v] = w</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floyd_warshall</span><span class="params">(graph, n)</span>:</span></span><br><span class="line">    dist = [[float(<span class="string">"inf"</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            dist[i][j] = graph[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># check vertex k against all other vertices (i, j)</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="comment"># looping through rows of graph array</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># looping through columns of graph array</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    dist[i][k] != float(<span class="string">"inf"</span>)</span><br><span class="line">                    <span class="keyword">and</span> dist[k][j] != float(<span class="string">"inf"</span>)</span><br><span class="line">                    <span class="keyword">and</span> dist[i][k] + dist[k][j] &lt; dist[i][j]</span><br><span class="line">                ):</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j]</span><br><span class="line">    <span class="keyword">return</span> dist</span><br></pre></td></tr></table></figure>
<p>JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> floydWarshall = <span class="function">(<span class="params">graph, v</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dist = <span class="keyword">new</span> <span class="built_in">Array</span>(v).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(v).fill(<span class="built_in">Number</span>.MAX_SAFE_INTEGER))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; v; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; v; j++)&#123;</span><br><span class="line">      <span class="comment">//两个点相同，距离为0</span></span><br><span class="line">      <span class="keyword">if</span>(i === j) dist[i][j] = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//i 和 j 的距离已知</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(graph[i][j]) dist[i][j] = graph[i][j];</span><br><span class="line">      <span class="comment">//i 和 j 的距离未知，默认是最大值</span></span><br><span class="line">      <span class="keyword">else</span> dist[i][j] = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查是否有一个点 k 使得 i 和 j 之间距离更短，如果有，则更新最短距离</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; v; k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; v; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; v; j++)&#123;</span><br><span class="line">        dist[i][j] = <span class="built_in">Math</span>.min(dist[i][j], dist[i][k] + dist[k][j])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> 看需要</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们回过头来看下如何套模板解决 力扣的 1462. 课程安排 IV，题目描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">你总共需要上 n 门课，课程编号依次为 0 到 n-1 。</span><br><span class="line"></span><br><span class="line">有的课会有直接的先修课程，比如如果想上课程 0 ，你必须先上课程 1 ，那么会以 [1,0] 数对的形式给出先修课程数对。</span><br><span class="line"></span><br><span class="line">给你课程总数 n 和一个直接先修课程数对列表 prerequisite 和一个查询对列表 queries 。</span><br><span class="line"></span><br><span class="line">对于每个查询对 queries[i] ，请判断 queries[i][0] 是否是 queries[i][1] 的先修课程。</span><br><span class="line"></span><br><span class="line">请返回一个布尔值列表，列表中每个元素依次分别对应 queries 每个查询对的判断结果。</span><br><span class="line"></span><br><span class="line">注意：如果课程 a 是课程 b 的先修课程且课程 b 是课程 c 的先修课程，那么课程 a 也是课程 c 的先修课程。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：n = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]</span><br><span class="line">输出：[false,true]</span><br><span class="line">解释：课程 0 不是课程 1 的先修课程，但课程 1 是课程 0 的先修课程。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：n = 2, prerequisites = [], queries = [[1,0],[0,1]]</span><br><span class="line">输出：[false,false]</span><br><span class="line">解释：没有先修课程对，所以每门课程之间是独立的。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：n = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]</span><br><span class="line">输出：[true,true]</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：n = 3, prerequisites = [[1,0],[2,0]], queries = [[0,1],[2,0]]</span><br><span class="line">输出：[false,true]</span><br><span class="line">示例 5：</span><br><span class="line"></span><br><span class="line">输入：n = 5, prerequisites = [[0,1],[1,2],[2,3],[3,4]], queries = [[0,4],[4,0],[1,3],[3,0]]</span><br><span class="line">输出：[true,false,true,false]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">2 &lt;= n &lt;= 100</span><br><span class="line">0 &lt;= prerequisite.length &lt;= (n * (n - 1) / 2)</span><br><span class="line">0 &lt;= prerequisite[i][0], prerequisite[i][1] &lt; n</span><br><span class="line">prerequisite[i][0] != prerequisite[i][1]</span><br><span class="line">先修课程图中没有环。</span><br><span class="line">先修课程图中没有重复的边。</span><br><span class="line">1 &lt;= queries.length &lt;= 10^4</span><br><span class="line">queries[i][0] != queries[i][1]</span><br></pre></td></tr></table></figure>
<p>这道题也可以使用 Floyd-Warshall 来做。 你可以这么想， 如果从 i 到 j 的距离大于 0，那不就是先修课么。而这道题数据范围 queries 大概是 10 ^ 4 ， 用上面的 dijkstra 算法肯定超时，，因此 Floyd-Warshall 算法是明智的选择。</p>
<p>我这里直接套模板，稍微改下就过了。完整代码：<br>Python</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Floyd</span>-<span class="title">Warshall</span><span class="params">(self, dist, v)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(v):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(v):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(v):</span><br><span class="line">                    dist[i][j] = dist[i][j] <span class="keyword">or</span> (dist[i][k] <span class="keyword">and</span> dist[k][j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dist</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkIfPrerequisite</span><span class="params">(self, n: int, prerequisites: List[List[int]], queries: List[List[int]])</span> -&gt; List[bool]:</span></span><br><span class="line">        graph = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        ans = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> to, fr <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[fr][to] = <span class="literal">True</span></span><br><span class="line">        dist = self.Floyd-Warshall(graph, n)</span><br><span class="line">        <span class="keyword">for</span> to, fr <span class="keyword">in</span> queries:</span><br><span class="line">            ans.append(bool(dist[fr][to]))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//咳咳这个写法不是本题最优</span></span><br><span class="line"><span class="keyword">var</span> checkIfPrerequisite = <span class="function"><span class="keyword">function</span>(<span class="params">numCourses, prerequisites, queries</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> graph = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> [course, pre] <span class="keyword">of</span> prerequisites)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!graph[pre]) graph[pre] = &#123;&#125;</span><br><span class="line">        graph[pre][course] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ans = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dist = Floyd-Warshall(graph, numCourses)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> [course, pre] <span class="keyword">of</span> queries)&#123;</span><br><span class="line">        ans.push(dist[pre][course])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Floyd-Warshall = <span class="function"><span class="keyword">function</span>(<span class="params">graph, n</span>)</span>&#123;</span><br><span class="line">    dist = <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: n + <span class="number">1</span>&#125;).map(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: n + <span class="number">1</span>&#125;).fill(<span class="literal">false</span>))</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(graph[i] &amp;&amp; graph[i][j]) dist[i][j] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">if</span>(graph[i] &amp;&amp; graph[k])&#123;</span><br><span class="line">                    dist[i][j] = (dist[i][j])|| (dist[i][k] &amp;&amp; dist[k][j])</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(graph[i])&#123;</span><br><span class="line">                    dist[i][j] = dist[i][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这道题你可以解决了，我再推荐一道题给你 <a href="https://leetcode-cn.com/problems/count-subtrees-with-max-distance-between-cities/" title="1617. 统计子树中城市之间最大距离" target="_blank" rel="noopener">1617. 统计子树中城市之间最大距离</a>，国际版有一个题解代码挺清晰，挺好理解的，只不过没有使用状态压缩性能不是很好罢了，地址：<a href="https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/discuss/1136596/Python-Floyd-Warshall-and-check-all-subtrees" target="_blank" rel="noopener">https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/discuss/1136596/Python-Floyd-Warshall-and-check-all-subtrees</a></p>
<p>图上的动态规划算法大家还可以拿这个题目来练习一下。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/" title="787. K 站中转内最便宜的航班" target="_blank" rel="noopener">787. K 站中转内最便宜的航班</a></li>
</ul>
<h4 id="贝尔曼-福特算法"><a href="#贝尔曼-福特算法" class="headerlink" title="贝尔曼-福特算法"></a>贝尔曼-福特算法</h4><p>和上面的算法类似。这种解法主要解决单源最短路径，即图中某一点到其他点的最短距离。</p>
<p>其基本思想也是动态规划。</p>
<p>核心算法为：</p>
<ul>
<li>初始化起点距离为 0</li>
<li>对图中的所有边进行<strong>若干次</strong>处理，直到稳定。处理的依据是：对于每一个有向边 (u,v)，如果 dist[u] + w 小于 dist[v]，那么意味着我们<strong>找到了一条到达 v 更近的路</strong>，更新之。</li>
<li>上面的若干次的上限是顶点 V 的个数，因此不妨直接进行 n 次处理。</li>
<li>最后检查一下是否存在负边引起的环。（注意）</li>
</ul>
<p>举个例子。对于如下的一个图，存在一个 B -&gt; C -&gt; D -&gt; B，这样 B 到 C 和 D 的距离理论上可以无限小。我们需要检测到这一种情况，并退出。</p>
<p><img src="https://p.ipic.vip/adhkw6.jpg" alt></p>
<p>此算法时间复杂度：$O(V*E)$， 空间复杂度：$O(V)$。</p>
<p>代码示例：<br>Python</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># return -1 for not exsit</span></span><br><span class="line"><span class="comment"># else return dis map where dis[v] means for point s the least cost to point v</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bell_man</span><span class="params">(edges, s)</span>:</span></span><br><span class="line">    dis = defaultdict(<span class="keyword">lambda</span>: math.inf)</span><br><span class="line">    dis[s] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> dis[u] + w &lt; dis[v]:</span><br><span class="line">                dis[v] = dis[u] + w</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> u, v, w <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> dis[u] + w &lt; dis[v]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dis</span><br></pre></td></tr></table></figure>
<p>JavaScript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BellmanFord = <span class="function">(<span class="params">edges, startPoint</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = edges.length;</span><br><span class="line">  <span class="keyword">const</span> dist = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="built_in">Number</span>.MAX_SAFE_INTEGER);</span><br><span class="line">  dist[startPoint] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> [u, v, w] <span class="keyword">of</span> edges)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">            dist[v] = dist[u] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> [u, v, w] <span class="keyword">of</span> edges)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dist[u] + w &lt; dist[v]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dist</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推荐阅读：</p>
<ul>
<li><a href="https://www.programiz.com/dsa/bellman-ford-algorithm" title="bellman-ford-algorithm" target="_blank" rel="noopener">bellman-ford-algorithm</a></li>
</ul>
<p>题目推荐：</p>
<ul>
<li><a href="https://binarysearch.com/problems/Best-Currency-Path" title="Best Currency Path" target="_blank" rel="noopener">Best Currency Path</a></li>
</ul>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>在计算机科学领域，有向图的拓扑排序是对其顶点的一种线性排序，使得对于从顶点 u 到顶点 v 的每个有向边 uv， u 在排序中都在之前。当且仅当图中没有定向环时（即有向无环图），才有可能进行拓扑排序。</p>
<p>典型的题目就是给你一堆课程，课程之间有先修关系，让你给出一种可行的学习路径方式，要求先修的课程要先学。任何有向无环图至少有一个拓扑排序。已知有算法可以在线性时间内，构建任何有向无环图的拓扑排序。</p>
<h4 id="Kahn-算法"><a href="#Kahn-算法" class="headerlink" title="Kahn 算法"></a>Kahn 算法</h4><p>简单来说，假设 L 是存放结果的列表，先找到那些入度为零的节点，把这些节点放到 L 中，因为这些节点没有任何的父节点。<strong>然后把与这些节点相连的边从图中去掉，再寻找图中的入度为零的节点。</strong>对于新找到的这些入度为零的节点来说，他们的父节点已经都在 L 中了，所以也可以放入 L。重复上述操作，直到找不到入度为零的节点。如果此时 L 中的元素个数和节点总数相同，说明排序完成；如果 L 中的元素个数和节点总数不同，说明原图中存在环，无法进行拓扑排序。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topologicalSort</span><span class="params">(graph)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Kahn's Algorithm is used to find Topological ordering of Directed Acyclic Graph</span></span><br><span class="line"><span class="string">    using BFS</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    indegree = [<span class="number">0</span>] * len(graph)</span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    topo = []</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> key, values <span class="keyword">in</span> graph.items():</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">            indegree[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(indegree)):</span><br><span class="line">        <span class="keyword">if</span> indegree[i] == <span class="number">0</span>:</span><br><span class="line">            queue.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        vertex = queue.popleft()</span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        topo.append(vertex)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> graph[vertex]:</span><br><span class="line">            indegree[x] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> indegree[x] == <span class="number">0</span>:</span><br><span class="line">                queue.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cnt != len(graph):</span><br><span class="line">        print(<span class="string">"Cycle exists"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(topo)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Adjacency List of Graph</span></span><br><span class="line">graph = &#123;<span class="number">0</span>: [<span class="number">1</span>, <span class="number">2</span>], <span class="number">1</span>: [<span class="number">3</span>], <span class="number">2</span>: [<span class="number">3</span>], <span class="number">3</span>: [<span class="number">4</span>, <span class="number">5</span>], <span class="number">4</span>: [], <span class="number">5</span>: []&#125;</span><br><span class="line">topologicalSort(graph)</span><br></pre></td></tr></table></figure>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>首先我们来看下什么是生成树。</p>
<p>首先生成树是原图的一个子图，它本质是一棵树，这也是为什么叫做生成树，而不是生成图的原因。其次生成树应该包括图中所有的顶点。 如下图由于没有包含所有顶点，换句话说所有顶点没有在同一个联通域，因此不是一个生成树。</p>
<p><img src="https://p.ipic.vip/17t28q.jpg" alt></p>
<blockquote>
<p>黄色顶点没有包括在内</p>
</blockquote>
<p>你可以将生成树看成是根节点不确定的多叉树，由于是一棵树，那么一定不包含环。如下图就不是生成树。</p>
<p><img src="https://p.ipic.vip/pu9ux9.jpg" alt></p>
<p>因此不难得出，最小生成树的边的个数是 n - 1，其中 n 为顶点个数。</p>
<p>接下来我们看下什么是最小生成树。</p>
<p>最小生成树是在生成树的基础上加了<strong>最小</strong>关键字，是最小权重生成树的简称。从这句话也可以看出，最小生成树处理正是有权图。生成树的权重是其所有边的权重和，那么<strong>最小生成树就是权重和最小的生成树</strong>，由此可看出，不管是生成树还是最小生成树都可能不唯一。</p>
<p>最小生成树在实际生活中有很强的价值。比如我要修建一个地铁，并覆盖 n 个站，这 n 个站要互相都可以到达（同一个联通域），如果建造才能使得花费最小？由于每个站之间的路线不同，因此造价也不一样，因此这就是一个最小生成树的实际使用场景，类似的例子还有很多。</p>
<p><img src="https://p.ipic.vip/kkhv6a.jpg" alt></p>
<p>（图来自维基百科）</p>
<p>不难看出，计算最小生成树就是从边集合中挑选 n - 1 个边，使得其满足生成树，并且权值和最小。</p>
<p>Kruskal 和 Prim 是两个经典的求最小生成树的算法，这两个算法又是如何计算最小生成树的呢？本节我们就来了解一下它们。</p>
<h4 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h4><p>Kruskal 相对比较容易理解，推荐掌握。</p>
<p>Kruskal 算法也被形象地称为<strong>加边法</strong>，每前进一次都选择权重最小的边，加入到结果集。为了防止环的产生（增加环是无意义的，只要权重是正数，一定会使结果更差），我们需要检查下当前选择的边是否和已经选择的边联通了。如果联通了，是没有必要选取的，因为这会使得环产生。因此算法上，我们可使用并查集辅助完成。关于并查集，我们会在之后的进阶篇进行讲解。</p>
<blockquote>
<p>下面代码中的 find_parent 部分，实际上就是并查集的核心代码，只是我们没有将其封装并使用罢了。</p>
</blockquote>
<p>Kruskal 具体算法：</p>
<ol>
<li>对边按照权值从小到大进行排序。</li>
<li>将 n 个顶点初始化为 n 个联通域</li>
<li>按照权值从小到大选择边加入到结果集，每次<strong>贪心地</strong>选择最小边。如果当前选择的边是否和已经选择的边联通了（如果强行加就有环了），则放弃选择，否则进行选择，加入到结果集。</li>
<li>重复 3 直到我们找到了一个联通域大小为 n 的子图</li>
</ol>
<p>代码模板：</p>
<p>其中 edge 是一个数组，数组每一项都形如： (cost, fr, to)，含义是 从 fr 到 to 有一条权值为 cost的边。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSetUnion</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.rank = [<span class="number">1</span>] * n</span><br><span class="line">        self.f = list(range(n))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.f[x] == x:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        self.f[x] = self.find(self.f[x])</span><br><span class="line">        <span class="keyword">return</span> self.f[x]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unionSet</span><span class="params">(self, x: int, y: int)</span> -&gt; bool:</span></span><br><span class="line">        fx, fy = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> fx == fy:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.rank[fx] &lt; self.rank[fy]:</span><br><span class="line">            fx, fy = fy, fx</span><br><span class="line">        </span><br><span class="line">        self.rank[fx] += self.rank[fy]</span><br><span class="line">        self.f[fy] = fx</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Kruskal</span><span class="params">(self, edges)</span> -&gt; int:</span></span><br><span class="line">        n = len(points)</span><br><span class="line">        dsu = DisjointSetUnion(n)</span><br><span class="line">        </span><br><span class="line">        edges.sort()</span><br><span class="line">        </span><br><span class="line">        ret, num = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> length, x, y <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> dsu.unionSet(x, y):</span><br><span class="line">                ret += length</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> num == n:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h4 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h4><p>Prim 算法也被形象地称为<strong>加点法</strong>，每前进一次都选择权重最小的点，加入到结果集。形象地看就像一个不断生长的真实世界的树。</p>
<p>Prim 具体算法：</p>
<ol>
<li>初始化最小生成树点集 MV 为图中任意一个顶点，最小生成树边集 ME 为空。我们的目标是将 MV 填充到 和 V 一样，而边集则根据 MV 的产生自动计算。</li>
<li>在集合 E 中 （集合 E 为原始图的边集）选取最小的边 <u, v> 其中 u 为 MV 中已有的元素，而 v 为 MV 中不存在的元素（像不像上面说的<strong>不断生长的真实世界的树</strong>），将 v 加入到 MV，将 <u, v> 加到 ME。</u,></u,></li>
<li>重复 2 直到我们找到了一个联通域大小为 n 的子图</li>
</ol>
<p>代码模板：</p>
<p>其中 dist 是二维数组，dist[i][j] = x 表示顶点 i 到顶点 j 有一条权值为 x 的边。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Prim</span><span class="params">(self, dist)</span> -&gt; int:</span></span><br><span class="line">        n = len(dist)</span><br><span class="line">        d = [float(<span class="string">"inf"</span>)] * n <span class="comment"># 表示各个顶点与加入最小生成树的顶点之间的最小距离.</span></span><br><span class="line">        vis = [<span class="literal">False</span>] * n <span class="comment"># 表示是否已经加入到了最小生成树里面</span></span><br><span class="line">        d[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="comment"># 寻找目前这轮的最小d</span></span><br><span class="line">            M = float(<span class="string">"inf"</span>) </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> vis[i] <span class="keyword">and</span> d[i] &lt; M:</span><br><span class="line">                    node = i</span><br><span class="line">                    M = d[i]</span><br><span class="line">            vis[node] = <span class="literal">True</span></span><br><span class="line">            ans += M</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> vis[i]:</span><br><span class="line">                    d[i] = min(d[i], dist[i][node])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="两种算法比较"><a href="#两种算法比较" class="headerlink" title="两种算法比较"></a>两种算法比较</h4><p>为了后面描述方便，我们令 V 为图中的顶点数， E 为图中的边数。那么 KruKal 的算法复杂度是 $O(ElogE)$，Prim 的算法时间复杂度为 $E + VlogV$。因此 Prim 适合适用于稠密图，而 KruKal 则适合稀疏图。</p>
<p>大家也可以参考一下 <a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91" title="维基百科 - 最小生成树" target="_blank" rel="noopener">维基百科 - 最小生成树</a> 的资料作为补充。 </p>
<p>另外这里有一份视频学习资料，其中的动画做的不错，大家可以作为参考，地址：<a href="https://www.bilibili.com/video/BV1Eb41177d1/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Eb41177d1/</a></p>
<p>大家可以使用 LeetCode 的 <a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/" title="1584. 连接所有点的最小费用" target="_blank" rel="noopener">1584. 连接所有点的最小费用</a> 来练习该算法。</p>
<h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><h4 id="A-星寻路算法"><a href="#A-星寻路算法" class="headerlink" title="A 星寻路算法"></a>A 星寻路算法</h4><p>A 星寻路解决的问题是在一个二维的表格中找出任意两点的最短距离或者最短路径。常用于游戏中的 NPC 的移动计算，是一种常用启发式算法。一般这种题目都会有障碍物。除了障碍物，力扣的题目还会增加一些限制，使得题目难度增加。</p>
<p>这种题目一般都是力扣的困难难度。理解起来不难， 但是要完整地没有 bug 地写出来却不那么容易。</p>
<p>在该算法中，我们从起点开始，检查其相邻的四个方格并尝试扩展，直至找到目标。A 星寻路算法的寻路方式不止一种，感兴趣的可以自行了解一下。</p>
<p>公式表示为： f(n)=g(n)+h(n)。</p>
<p>其中：</p>
<ul>
<li><p>f(n) 是从初始状态经由状态 n 到目标状态的估计代价，</p>
</li>
<li><p>g(n) 是在状态空间中从初始状态到状态 n 的实际代价，</p>
</li>
<li><p>h(n) 是从状态 n 到目标状态的最佳路径的估计代价。</p>
</li>
</ul>
<p>如果 g(n)为 0，即只计算任意顶点 n 到目标的评估函数 h(n)，而不计算起点到顶点 n 的距离，则算法转化为使用贪心策略的最良优先搜索，速度最快，但可能得不出最优解；<br>如果 h(n)不大于顶点 n 到目标顶点的实际距离，则一定可以求出最优解，而且 h(n)越小，需要计算的节点越多，算法效率越低，常见的评估函数有——欧几里得距离、曼哈顿距离、切比雪夫距离；<br>如果 h(n)为 0，即只需求出起点到任意顶点 n 的最短路径 g(n)，而不计算任何评估函数 h(n)，则转化为单源最短路径问题，即 Dijkstra 算法，此时需要计算最多的顶点；</p>
<p>这里有一个重要的概念是<strong>估价算法</strong>，一般我们使用 <strong>曼哈顿距离</strong>来进行估价，即 <code>H(n) = D * (abs ( n.x – goal.x ) + abs ( n.y – goal.y ) )</code>。</p>
<p><img src="https://p.ipic.vip/r79ust.gif" alt></p>
<p>（图来自维基百科 <a href="https://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95</a> ）</p>
<p>一个完整的代码模板：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">grid = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],  <span class="comment"># 0 are free path whereas 1's are obstacles</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">heuristic = [[9, 8, 7, 6, 5, 4],</span></span><br><span class="line"><span class="string">             [8, 7, 6, 5, 4, 3],</span></span><br><span class="line"><span class="string">             [7, 6, 5, 4, 3, 2],</span></span><br><span class="line"><span class="string">             [6, 5, 4, 3, 2, 1],</span></span><br><span class="line"><span class="string">             [5, 4, 3, 2, 1, 0]]"""</span></span><br><span class="line"></span><br><span class="line">init = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">goal = [len(grid) - <span class="number">1</span>, len(grid[<span class="number">0</span>]) - <span class="number">1</span>]  <span class="comment"># all coordinates are given in format [y,x]</span></span><br><span class="line">cost = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># the cost map which pushes the path closer to the goal</span></span><br><span class="line">heuristic = [[<span class="number">0</span> <span class="keyword">for</span> row <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> col <span class="keyword">in</span> range(len(grid))]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">        heuristic[i][j] = abs(i - goal[<span class="number">0</span>]) + abs(j - goal[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">            heuristic[i][j] = <span class="number">99</span>  <span class="comment"># added extra penalty in the heuristic map</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the actions we can take</span></span><br><span class="line">delta = [[<span class="number">-1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">-1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]]  <span class="comment"># go up  # go left  # go down  # go right</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># function to search the path</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(grid, init, goal, cost, heuristic)</span>:</span></span><br><span class="line"></span><br><span class="line">    closed = [</span><br><span class="line">        [<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> row <span class="keyword">in</span> range(len(grid))</span><br><span class="line">    ]  <span class="comment"># the reference grid</span></span><br><span class="line">    closed[init[<span class="number">0</span>]][init[<span class="number">1</span>]] = <span class="number">1</span></span><br><span class="line">    action = [</span><br><span class="line">        [<span class="number">0</span> <span class="keyword">for</span> col <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> row <span class="keyword">in</span> range(len(grid))</span><br><span class="line">    ]  <span class="comment"># the action grid</span></span><br><span class="line"></span><br><span class="line">    x = init[<span class="number">0</span>]</span><br><span class="line">    y = init[<span class="number">1</span>]</span><br><span class="line">    g = <span class="number">0</span></span><br><span class="line">    f = g + heuristic[init[<span class="number">0</span>]][init[<span class="number">0</span>]]</span><br><span class="line">    cell = [[f, g, x, y]]</span><br><span class="line"></span><br><span class="line">    found = <span class="literal">False</span>  <span class="comment"># flag that is set when search is complete</span></span><br><span class="line">    resign = <span class="literal">False</span>  <span class="comment"># flag set if we can't find expand</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> found <span class="keyword">and</span> <span class="keyword">not</span> resign:</span><br><span class="line">        <span class="keyword">if</span> len(cell) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"FAIL"</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># to choose the least costliest action so as to move closer to the goal</span></span><br><span class="line">            cell.sort()</span><br><span class="line">            cell.reverse()</span><br><span class="line">            next = cell.pop()</span><br><span class="line">            x = next[<span class="number">2</span>]</span><br><span class="line">            y = next[<span class="number">3</span>]</span><br><span class="line">            g = next[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> x == goal[<span class="number">0</span>] <span class="keyword">and</span> y == goal[<span class="number">1</span>]:</span><br><span class="line">                found = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(len(delta)):  <span class="comment"># to try out different valid actions</span></span><br><span class="line">                    x2 = x + delta[i][<span class="number">0</span>]</span><br><span class="line">                    y2 = y + delta[i][<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> x2 &gt;= <span class="number">0</span> <span class="keyword">and</span> x2 &lt; len(grid) <span class="keyword">and</span> y2 &gt;= <span class="number">0</span> <span class="keyword">and</span> y2 &lt; len(grid[<span class="number">0</span>]):</span><br><span class="line">                        <span class="keyword">if</span> closed[x2][y2] == <span class="number">0</span> <span class="keyword">and</span> grid[x2][y2] == <span class="number">0</span>:</span><br><span class="line">                            g2 = g + cost</span><br><span class="line">                            f2 = g2 + heuristic[x2][y2]</span><br><span class="line">                            cell.append([f2, g2, x2, y2])</span><br><span class="line">                            closed[x2][y2] = <span class="number">1</span></span><br><span class="line">                            action[x2][y2] = i</span><br><span class="line">    invpath = []</span><br><span class="line">    x = goal[<span class="number">0</span>]</span><br><span class="line">    y = goal[<span class="number">1</span>]</span><br><span class="line">    invpath.append([x, y])  <span class="comment"># we get the reverse path from here</span></span><br><span class="line">    <span class="keyword">while</span> x != init[<span class="number">0</span>] <span class="keyword">or</span> y != init[<span class="number">1</span>]:</span><br><span class="line">        x2 = x - delta[action[x][y]][<span class="number">0</span>]</span><br><span class="line">        y2 = y - delta[action[x][y]][<span class="number">1</span>]</span><br><span class="line">        x = x2</span><br><span class="line">        y = y2</span><br><span class="line">        invpath.append([x, y])</span><br><span class="line"></span><br><span class="line">    path = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(invpath)):</span><br><span class="line">        path.append(invpath[len(invpath) - <span class="number">1</span> - i])</span><br><span class="line">    print(<span class="string">"ACTION MAP"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(action)):</span><br><span class="line">        print(action[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = search(grid, init, goal, cost, heuristic)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line">    print(a[i])</span><br></pre></td></tr></table></figure>
<p>典型题目<a href="https://leetcode-cn.com/problems/minimum-moves-to-move-a-box-to-their-target-location/" title="1263. 推箱子" target="_blank" rel="noopener">1263. 推箱子</a></p>
<h4 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h4><p>二分图我在这两道题中讲过了，大家看一下之后把这两道题做一下就行了。其实这两道题和一道题没啥区别。</p>
<ul>
<li><a href="https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/medium/886.possible-bipartition" title="0886. 可能的二分法" target="_blank" rel="noopener">0886. 可能的二分法</a></li>
<li><a href="https://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/medium/785.is-graph-bipartite" title="0785. 判断二分图" target="_blank" rel="noopener">0785. 判断二分图</a></li>
</ul>
<p>推荐顺序为： 先看 886 再看 785。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>理解图的常见概念，我们就算入门了。接下来，我们就可以做题了。</p>
<p>一般的图题目有两种，一种是搜索题目，一种是动态规划题目。</p>
<p>对于搜索类题目，我们可以：</p>
<ul>
<li>第一步都是建图</li>
<li>第二步都是基于第一步的图进行遍历以寻找可行解</li>
</ul>
<blockquote>
<p>如果题目说明了是无环图，我们可以不使用 visited 数组，否则大多数都需要 visited 数组。当然也可以选择原地算法减少空间复杂度，具体的搜索技巧会在专题篇的搜索篇进行讨论。</p>
</blockquote>
<p>图的题目相对而言比较难，尤其是代码书写层面。但是就面试题目而言， 图的题目类型却不多。</p>
<ul>
<li>就搜索题目来说，很多题目都是套模板就可以解决。因此建议大家多练习模板，并自己多手敲，确保可以自己敲出来。</li>
<li>而对于动态规划题目，一个经典的例子就是<strong>Floyd-Warshall 算法</strong>，理解好了之后大家不妨拿 <code>787. K 站中转内最便宜的航班</code> 练习一下。当然这要求大家应该先学习动态规划，关于动态规划，我们会在后面的《动态规划》以及《背包问题》中进行深度讲解。</li>
</ul>
<p> 常见的图的板子题有以下几种：</p>
<ol>
<li>最短路。算法有 DJ 算法， floyd 算法 和 bellman 算法。这其中有的是单源算法，有的是多源算法，有的是贪心算法，有的是动态规划。</li>
<li>拓扑排序。拓扑排序可以使用 bfs ，也可以使用 dfs。相比于最短路，这种题目属于知道了就简单的类型。</li>
<li>最小生成树。最小生成树是这三种题型中出现频率最低的，可以最后突破。</li>
<li>A 星寻路和二分图题目比例非常低，大家可以根据自己的情况选择性掌握。</li>
</ol>

      </div>
      
        <br>
        


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2023-01-05T20:24:49+08:00">
  <a class='notlink'>
    <i class="fas fa-clock" aria-hidden="true"></i>
    <p>更新于 2023年1月5日</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/blog/tags/图/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>图</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/blog/tags/LeetCode/" rel="nofollow"><i class="fas fa-tag" aria-hidden="true"></i><p>LeetCode</p></a></div>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class='qrcode' rel="external nofollow noopener noreferrer" href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLElEQVR42u3aQW7DMAwEwP7/0y7QU4E0zq7YFog0OgWO43h0IEiRHx/xur5WcuVx3T/z+z3Jr0YLAwPjbRnX7Xp86fb+e3wOe7FBGBgYBzDu/zKBJb9NwvHidmBgYGDEgTLB55uCgYGBMQm4k9K0TUMxMDAw8qI0KWvzwvW3CmYMDIwTGG1j4D8//2F/AwMD400YV7nyJ6zdeS0tDAyMvRn5IMV9Cpg3MtsUM2+OYmBg7MpYC3l54domeffbVM+sYWBgbMRoA257iJa0MPOXfpoUYmBgHMNoByPal2sbAFETAgMD4xjG/HVbQBJYR2MWGBgYGzEmow+Twa98U158xsDA2JrRlo75lbZMbVPGp8/HwMA4krF2xDYPrIvJJQYGxgGMvECdHKut/S8GBsaZjEmpmQfBIrFbG1nDwMDYmlEfwZfX59SiSMbAwNiUkR++J38/H7yoxyzaHgIGBsbbMtp0LUnj1jYiH/v4oROLgYGxKWMSBCcHcEnTdLEAxsDA2I7RHnu1xWceOtsWQvRyGBgYGzHWGpC/dbiWg59uGQYGxtaMNuzmqV4SWNuC+QUVAwNjU8ZVrkkYXUNGm4WBgbE1Y3LonyeRyTPbBgMGBsZpjLaJmJegSTMgKVajjcDAwDiA0QbZyUBY28iMAjoGBgbG4PPk6L/AY2BgYAzGwvKQPSmhMTAwTmCsDXjdb0Hy7Vrr9MWMGwYGxnaMSQHZti3bsbM26GNgYGzH+AR+J2C+Rg1H6wAAAABJRU5ErkJggg=='>
        
          <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qrcode.png">
        
        </a>
      
    
      
        <a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://lucifer.ren/blog/2021/11/09/grapth/&title=面试中图论都考什么？这篇文章告诉你！ | lucifer的网络博客&pics=https://avatars0.githubusercontent.com/u/12479470?s=400&u=442571e44cbd0b67e3503e9551d4445c78f593f8&v=4&summary=图论〔Graph Theory〕是数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。
 如下就是一种逻辑上的图结构：

图是一种最复杂的数据结构，前面讲的数据结构都可以看成是图的特例。那为什么不都用图就好了，还要分那么多种数据结构呢？
这是因为很多时候不需要用到那么复杂的功能，图的很多特性都不具备，如果笼统地都称为图那么非常不利于沟通。你想你和别人沟通总不至于说这道题是考察一种特殊的图，这种图。。。。 这未免太啰嗦了，因此给其他图的特殊的图起了特殊的名字，这样就方便沟通了。直到遇到了非常复杂的情况，我们才会用到 ”真正“的图。
前面章节提到了数据结构就是为了算法服务的，数据结构就是存储数据用的，目的是为了更高效。 那么什么时候需要用图来存储数据，在这种情况图高效在哪里呢？答案很简单，那就是如果你用其他简单的数据结构无法很好地进行存储，就应该使用图了。 比如我们需要存储一种双向的朋友关系，并且这种朋友关系是多对多的，那就一定要用到图，因为其他数据结构无法模拟。"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://lucifer.ren/blog/2021/11/09/grapth/&title=面试中图论都考什么？这篇文章告诉你！ | lucifer的网络博客&pics=https://avatars0.githubusercontent.com/u/12479470?s=400&u=442571e44cbd0b67e3503e9551d4445c78f593f8&v=4&summary=图论〔Graph Theory〕是数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。
 如下就是一种逻辑上的图结构：

图是一种最复杂的数据结构，前面讲的数据结构都可以看成是图的特例。那为什么不都用图就好了，还要分那么多种数据结构呢？
这是因为很多时候不需要用到那么复杂的功能，图的很多特性都不具备，如果笼统地都称为图那么非常不利于沟通。你想你和别人沟通总不至于说这道题是考察一种特殊的图，这种图。。。。 这未免太啰嗦了，因此给其他图的特殊的图起了特殊的名字，这样就方便沟通了。直到遇到了非常复杂的情况，我们才会用到 ”真正“的图。
前面章节提到了数据结构就是为了算法服务的，数据结构就是存储数据用的，目的是为了更高效。 那么什么时候需要用图来存储数据，在这种情况图高效在哪里呢？答案很简单，那就是如果你用其他简单的数据结构无法很好地进行存储，就应该使用图了。 比如我们需要存储一种双向的朋友关系，并且这种朋友关系是多对多的，那就一定要用到图，因为其他数据结构无法模拟。"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://lucifer.ren/blog/2021/11/09/grapth/&title=面试中图论都考什么？这篇文章告诉你！ | lucifer的网络博客&pics=https://avatars0.githubusercontent.com/u/12479470?s=400&u=442571e44cbd0b67e3503e9551d4445c78f593f8&v=4&summary=图论〔Graph Theory〕是数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。
 如下就是一种逻辑上的图结构：

图是一种最复杂的数据结构，前面讲的数据结构都可以看成是图的特例。那为什么不都用图就好了，还要分那么多种数据结构呢？
这是因为很多时候不需要用到那么复杂的功能，图的很多特性都不具备，如果笼统地都称为图那么非常不利于沟通。你想你和别人沟通总不至于说这道题是考察一种特殊的图，这种图。。。。 这未免太啰嗦了，因此给其他图的特殊的图起了特殊的名字，这样就方便沟通了。直到遇到了非常复杂的情况，我们才会用到 ”真正“的图。
前面章节提到了数据结构就是为了算法服务的，数据结构就是存储数据用的，目的是为了更高效。 那么什么时候需要用图来存储数据，在这种情况图高效在哪里呢？答案很简单，那就是如果你用其他简单的数据结构无法很好地进行存储，就应该使用图了。 比如我们需要存储一种双向的朋友关系，并且这种朋友关系是多对多的，那就一定要用到图，因为其他数据结构无法模拟。"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
  </section>


      
      
          <div class="prev-next">
              
                  <section class="prev">
                      <span class="art-item-left">
                          <h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6>
                          <h4>
                              <a href="/blog/2021/11/10/chrome-recorder/" rel="prev" title="Chrome 新功能 - 录制小视频">
                                
                                    Chrome 新功能 - 录制小视频
                                
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/blog/tags/Chrome/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> Chrome</a>
                              </h6>
                          
                      </span>
                  </section>
              
              
                  <section class="next">
                      <span class="art-item-right" aria-hidden="true">
                          <h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6>
                          <h4>
                              <a href="/blog/2021/10/24/new-book/" rel="prev" title="《算法通关之路》邀请你来试读">
                                  
                                      《算法通关之路》邀请你来试读
                                  
                              </a>
                          </h4>
                          
                              
                              <h6 class="tags">
                                  <a class="tag" href="/blog/tags/《算法通关之路》/"><i class="fas fa-tag fa-fw" aria-hidden="true"></i> 《算法通关之路》</a>
                              </h6>
                          
                      </span>
                  </section>
              
          </div>
      
    </section>
  </article>



  <!-- 显示推荐文章和评论 -->



  <article class="post white-box comments">
    <section class="article typo">
      <h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4>
      
      
      
        <section id="comments">
          <div id="gitalk-container"></div>
        </section>
      
      
    </section>
  </article>






<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: '面试中图论都考什么？这篇文章告诉你！',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
    
    
      
      
        
          
          
            
              <section class='widget author'>
  <div class='content pure'>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="/blog/atom.xml"
              class="social fas fa-rss flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://www.zhihu.com/people/lu-xiao-13-70/activities"
              class="social fab fa-zhihu flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="mailto:azl397985856@gmail.com"
              class="social fas fa-envelope flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://github.com/azl397985856"
              class="social fab fa-github flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
          
            <a href="https://music.163.com/playlist?id=978545815&userid=632167080"
              class="social fas fa-headphones-alt flat-btn"
              target="_blank"
              rel="external nofollow noopener noreferrer">
            </a>
          
        
      </div>
    
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
            
              
  <section class='widget toc-wrapper'>
    
<header class='pure'>
  <div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div>
  
    <!-- <div class='wrapper'><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div> -->
  
</header>

    <div class='content pure'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#无向图-amp-有向图〔Undirected-Graph-amp-Deriected-Graph〕"><span class="toc-text">无向图 &amp; 有向图〔Undirected Graph &amp; Deriected Graph〕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有权图-amp-无权图〔Weighted-Graph-amp-Unweighted-Graph〕"><span class="toc-text">有权图 &amp; 无权图〔Weighted Graph &amp; Unweighted Graph〕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#入度-amp-出度〔Indegree-amp-Outdegree〕"><span class="toc-text">入度 &amp; 出度〔Indegree &amp; Outdegree〕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路径-amp-环〔路径：Path〕"><span class="toc-text">路径 &amp; 环〔路径：Path〕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#连通图-amp-强连通图"><span class="toc-text">连通图 &amp; 强连通图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生成树"><span class="toc-text">生成树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图的建立"><span class="toc-text">图的建立</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接矩阵（常见）〔Adjacency-Matrixs〕"><span class="toc-text">邻接矩阵（常见）〔Adjacency Matrixs〕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#邻接表〔Adjacency-List〕"><span class="toc-text">邻接表〔Adjacency List〕</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图的遍历"><span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#深度优先遍历〔Depth-First-Search-DFS〕"><span class="toc-text">深度优先遍历〔Depth First Search, DFS〕</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#广度优先搜索〔Breadth-First-Search-BFS〕"><span class="toc-text">广度优先搜索〔Breadth First Search, BFS〕</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见算法"><span class="toc-text">常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最短距离，最短路径"><span class="toc-text">最短距离，最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra-算法"><span class="toc-text">Dijkstra 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd-Warshall-算法"><span class="toc-text">Floyd-Warshall 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#贝尔曼-福特算法"><span class="toc-text">贝尔曼-福特算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序"><span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Kahn-算法"><span class="toc-text">Kahn 算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最小生成树"><span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal"><span class="toc-text">Kruskal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim"><span class="toc-text">Prim</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两种算法比较"><span class="toc-text">两种算法比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他算法"><span class="toc-text">其他算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-星寻路算法"><span class="toc-text">A 星寻路算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二分图"><span class="toc-text">二分图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
            
              <section class='widget grid'>
  
<header class='pure'>
  <div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;我的开源项目</div>
  
</header>

  <div class='content pure'>
    <ul class="grid navgation">
      
        <li><a class="flat-box" title="https://github.com/azl397985856/leetcode" href="https://github.com/azl397985856/leetcode"
          
          
          id="https:github.comazl397985856leetcode">
          
            <i class="fab fa-github fa-fw" aria-hidden="true"></i>
          
          算法刷题
        </a></li>
      
        <li><a class="flat-box" title="https://github.com/azl397985856/fe-interview" href="https://github.com/azl397985856/fe-interview"
          
          
          id="https:github.comazl397985856fe-interview">
          
            <i class="fab fa-github fa-fw" aria-hidden="true"></i>
          
          大前端
        </a></li>
      
        <li><a class="flat-box" title="https://github.com/azl397985856/daily-featured" href="https://github.com/azl397985856/daily-featured"
          
          
          id="https:github.comazl397985856daily-featured">
          
            <i class="fab fa-github fa-fw" aria-hidden="true"></i>
          
          每日一荐
        </a></li>
      
    </ul>
  </div>
</section>

            
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;全部分类</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
    href="/blog/categories/"
    title="categories/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/blog/categories/91天学算法/" href="/blog/categories/91天学算法/"><div class='name'>91天学算法</div><div class='badge'>(24)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/CD/" href="/blog/categories/CD/"><div class='name'>CD</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/Easy/" href="/blog/categories/Easy/"><div class='name'>Easy</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/Github/" href="/blog/categories/Github/"><div class='name'>Github</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/Hard/" href="/blog/categories/Hard/"><div class='name'>Hard</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/LeetCode/" href="/blog/categories/LeetCode/"><div class='name'>LeetCode</div><div class='badge'>(23)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/LeetCode/LeetCode题解书/" href="/blog/categories/LeetCode/LeetCode题解书/"><div class='name'>LeetCode题解书</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/LeetCode/刷题技巧/" href="/blog/categories/LeetCode/刷题技巧/"><div class='name'>刷题技巧</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/LeetCode/动态规划/" href="/blog/categories/LeetCode/动态规划/"><div class='name'>动态规划</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/Medium/" href="/blog/categories/Medium/"><div class='name'>Medium</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/React/" href="/blog/categories/React/"><div class='name'>React</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/TypeScript/" href="/blog/categories/TypeScript/"><div class='name'>TypeScript</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/devtool/" href="/blog/categories/devtool/"><div class='name'>devtool</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/vite/" href="/blog/categories/vite/"><div class='name'>vite</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/《算法通关之路》/" href="/blog/categories/《算法通关之路》/"><div class='name'>《算法通关之路》</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/中等/" href="/blog/categories/中等/"><div class='name'>中等</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/书/" href="/blog/categories/书/"><div class='name'>书</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/书/算法/" href="/blog/categories/书/算法/"><div class='name'>算法</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/书单/" href="/blog/categories/书单/"><div class='name'>书单</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/书摘/" href="/blog/categories/书摘/"><div class='name'>书摘</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/二分/" href="/blog/categories/二分/"><div class='name'>二分</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/二叉树/" href="/blog/categories/二叉树/"><div class='name'>二叉树</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/刷题技巧/" href="/blog/categories/刷题技巧/"><div class='name'>刷题技巧</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/刷题方法/" href="/blog/categories/刷题方法/"><div class='name'>刷题方法</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/前端/" href="/blog/categories/前端/"><div class='name'>前端</div><div class='badge'>(28)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/前端/TypeScript/" href="/blog/categories/前端/TypeScript/"><div class='name'>TypeScript</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/前端/TypeScript/泛型/" href="/blog/categories/前端/TypeScript/泛型/"><div class='name'>泛型</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/前端/css-in-js/" href="/blog/categories/前端/css-in-js/"><div class='name'>css-in-js</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/前端/eslint/" href="/blog/categories/前端/eslint/"><div class='name'>eslint</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/前端/web-component/" href="/blog/categories/前端/web-component/"><div class='name'>web-component</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/前端/webkit/" href="/blog/categories/前端/webkit/"><div class='name'>webkit</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/前端/测试/" href="/blog/categories/前端/测试/"><div class='name'>测试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/前端/浏览器/" href="/blog/categories/前端/浏览器/"><div class='name'>浏览器</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/前端/算法/" href="/blog/categories/前端/算法/"><div class='name'>算法</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/前端/组件化/" href="/blog/categories/前端/组件化/"><div class='name'>组件化</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/前缀和/" href="/blog/categories/前缀和/"><div class='name'>前缀和</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/前缀和/二维前缀和/" href="/blog/categories/前缀和/二维前缀和/"><div class='name'>二维前缀和</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/力扣加加/" href="/blog/categories/力扣加加/"><div class='name'>力扣加加</div><div class='badge'>(26)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/动态规划/" href="/blog/categories/动态规划/"><div class='name'>动态规划</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/命令行/" href="/blog/categories/命令行/"><div class='name'>命令行</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/图/" href="/blog/categories/图/"><div class='name'>图</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/堆/" href="/blog/categories/堆/"><div class='name'>堆</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/好未来/" href="/blog/categories/好未来/"><div class='name'>好未来</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/学习方法/" href="/blog/categories/学习方法/"><div class='name'>学习方法</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/工具/" href="/blog/categories/工具/"><div class='name'>工具</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/工具/Chrome/" href="/blog/categories/工具/Chrome/"><div class='name'>Chrome</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/工具/VSCODE/" href="/blog/categories/工具/VSCODE/"><div class='name'>VSCODE</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/年终总结/" href="/blog/categories/年终总结/"><div class='name'>年终总结</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/异议！/" href="/blog/categories/异议！/"><div class='name'>异议！</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/成长经历/" href="/blog/categories/成长经历/"><div class='name'>成长经历</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/技术大会/" href="/blog/categories/技术大会/"><div class='name'>技术大会</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/技术大会/D2/" href="/blog/categories/技术大会/D2/"><div class='name'>D2</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/技术大会/Google-IO/" href="/blog/categories/技术大会/Google-IO/"><div class='name'>Google IO</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/技术大会/JSConf/" href="/blog/categories/技术大会/JSConf/"><div class='name'>JSConf</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/技术大会/QCon/" href="/blog/categories/技术大会/QCon/"><div class='name'>QCon</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/技术大会/React-Conf/" href="/blog/categories/技术大会/React-Conf/"><div class='name'>React Conf</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/插件/" href="/blog/categories/插件/"><div class='name'>插件</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/插件/浏览器插件/" href="/blog/categories/插件/浏览器插件/"><div class='name'>浏览器插件</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/插件/算法/" href="/blog/categories/插件/算法/"><div class='name'>算法</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/搜索/" href="/blog/categories/搜索/"><div class='name'>搜索</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/数学/" href="/blog/categories/数学/"><div class='name'>数学</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/数学/算法/" href="/blog/categories/数学/算法/"><div class='name'>算法</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/数据结构/" href="/blog/categories/数据结构/"><div class='name'>数据结构</div><div class='badge'>(27)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/数据结构/hashtable/" href="/blog/categories/数据结构/hashtable/"><div class='name'>hashtable</div><div class='badge'>(6)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/数据结构/二叉搜索树/" href="/blog/categories/数据结构/二叉搜索树/"><div class='name'>二叉搜索树</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/数据结构/图/" href="/blog/categories/数据结构/图/"><div class='name'>图</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/数据结构/字符串/" href="/blog/categories/数据结构/字符串/"><div class='name'>字符串</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/数据结构/平衡二叉树/" href="/blog/categories/数据结构/平衡二叉树/"><div class='name'>平衡二叉树</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/数据结构/数组/" href="/blog/categories/数据结构/数组/"><div class='name'>数组</div><div class='badge'>(10)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/数据结构/算法/" href="/blog/categories/数据结构/算法/"><div class='name'>算法</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/数据结构/链表/" href="/blog/categories/数据结构/链表/"><div class='name'>链表</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/数据结构，二叉树/" href="/blog/categories/数据结构，二叉树/"><div class='name'>数据结构，二叉树</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/数据结构，单调栈/" href="/blog/categories/数据结构，单调栈/"><div class='name'>数据结构，单调栈</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/数据结构，字符串/" href="/blog/categories/数据结构，字符串/"><div class='name'>数据结构，字符串</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/数据结构，数组/" href="/blog/categories/数据结构，数组/"><div class='name'>数据结构，数组</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/日记/" href="/blog/categories/日记/"><div class='name'>日记</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/日记/技术/" href="/blog/categories/日记/技术/"><div class='name'>技术</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/春招/" href="/blog/categories/春招/"><div class='name'>春招</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/栈/" href="/blog/categories/栈/"><div class='name'>栈</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/树/" href="/blog/categories/树/"><div class='name'>树</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/校招/" href="/blog/categories/校招/"><div class='name'>校招</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/模拟面试/" href="/blog/categories/模拟面试/"><div class='name'>模拟面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/每日一荐/" href="/blog/categories/每日一荐/"><div class='name'>每日一荐</div><div class='badge'>(7)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/每日一荐/2019-09/" href="/blog/categories/每日一荐/2019-09/"><div class='name'>2019-09</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/每日一荐/2019-10/" href="/blog/categories/每日一荐/2019-10/"><div class='name'>2019-10</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/每日一荐/2019-11/" href="/blog/categories/每日一荐/2019-11/"><div class='name'>2019-11</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/每日一荐/2019-12/" href="/blog/categories/每日一荐/2019-12/"><div class='name'>2019-12</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/每日一荐/2020-01/" href="/blog/categories/每日一荐/2020-01/"><div class='name'>2020-01</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/每日一荐/2020-03/" href="/blog/categories/每日一荐/2020-03/"><div class='name'>2020-03</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/每日一荐/2022-04/" href="/blog/categories/每日一荐/2022-04/"><div class='name'>2022-04</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/浏览器/" href="/blog/categories/浏览器/"><div class='name'>浏览器</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/浏览器/webkit/" href="/blog/categories/浏览器/webkit/"><div class='name'>webkit</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/浏览器/事件/" href="/blog/categories/浏览器/事件/"><div class='name'>事件</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/电影/" href="/blog/categories/电影/"><div class='name'>电影</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/电影/观后感/" href="/blog/categories/电影/观后感/"><div class='name'>观后感</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/百度/" href="/blog/categories/百度/"><div class='name'>百度</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/算法/" href="/blog/categories/算法/"><div class='name'>算法</div><div class='badge'>(29)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/BFS/" href="/blog/categories/算法/BFS/"><div class='name'>BFS</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/DFS/" href="/blog/categories/算法/DFS/"><div class='name'>DFS</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/二分法/" href="/blog/categories/算法/二分法/"><div class='name'>二分法</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/位运算/" href="/blog/categories/算法/位运算/"><div class='name'>位运算</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/前端/" href="/blog/categories/算法/前端/"><div class='name'>前端</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/前端/面试/" href="/blog/categories/算法/前端/面试/"><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/前缀和/" href="/blog/categories/算法/前缀和/"><div class='name'>前缀和</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/动态规划/" href="/blog/categories/算法/动态规划/"><div class='name'>动态规划</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/双指针/" href="/blog/categories/算法/双指针/"><div class='name'>双指针</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/回文/" href="/blog/categories/算法/回文/"><div class='name'>回文</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/回溯/" href="/blog/categories/算法/回溯/"><div class='name'>回溯</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/子序列/" href="/blog/categories/算法/子序列/"><div class='name'>子序列</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/就地算法/" href="/blog/categories/算法/就地算法/"><div class='name'>就地算法</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/布隆过滤器/" href="/blog/categories/算法/布隆过滤器/"><div class='name'>布隆过滤器</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/循环移位/" href="/blog/categories/算法/循环移位/"><div class='name'>循环移位</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/数学/" href="/blog/categories/算法/数学/"><div class='name'>数学</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/概率/" href="/blog/categories/算法/概率/"><div class='name'>概率</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/母题/" href="/blog/categories/算法/母题/"><div class='name'>母题</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/滑动窗口/" href="/blog/categories/算法/滑动窗口/"><div class='name'>滑动窗口</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/状态压缩/" href="/blog/categories/算法/状态压缩/"><div class='name'>状态压缩</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/背包问题/" href="/blog/categories/算法/背包问题/"><div class='name'>背包问题</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/递归/" href="/blog/categories/算法/递归/"><div class='name'>递归</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/算法/链表反转/" href="/blog/categories/算法/链表反转/"><div class='name'>链表反转</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/算法比赛/" href="/blog/categories/算法比赛/"><div class='name'>算法比赛</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/算法，动态规划/" href="/blog/categories/算法，动态规划/"><div class='name'>算法，动态规划</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/算法，序列化/" href="/blog/categories/算法，序列化/"><div class='name'>算法，序列化</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/算法，滑动窗口/" href="/blog/categories/算法，滑动窗口/"><div class='name'>算法，滑动窗口</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/线段树/" href="/blog/categories/线段树/"><div class='name'>线段树</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/经验分享/" href="/blog/categories/经验分享/"><div class='name'>经验分享</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/编程之美/" href="/blog/categories/编程之美/"><div class='name'>编程之美</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/自动化/" href="/blog/categories/自动化/"><div class='name'>自动化</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/蓄水池抽样/" href="/blog/categories/蓄水池抽样/"><div class='name'>蓄水池抽样</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/虾皮/" href="/blog/categories/虾皮/"><div class='name'>虾皮</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/解题模板/" href="/blog/categories/解题模板/"><div class='name'>解题模板</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/谷歌/" href="/blog/categories/谷歌/"><div class='name'>谷歌</div><div class='badge'>(3)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/谷歌/软实力/" href="/blog/categories/谷歌/软实力/"><div class='name'>软实力</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/谷歌/面试/" href="/blog/categories/谷歌/面试/"><div class='name'>面试</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/贪婪/" href="/blog/categories/贪婪/"><div class='name'>贪婪</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/走出科学/" href="/blog/categories/走出科学/"><div class='name'>走出科学</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/软件工具/" href="/blog/categories/软件工具/"><div class='name'>软件工具</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/链表/" href="/blog/categories/链表/"><div class='name'>链表</div><div class='badge'>(1)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/面经/" href="/blog/categories/面经/"><div class='name'>面经</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box" title="/blog/categories/面试/" href="/blog/categories/面试/"><div class='name'>面试</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box child" title="/blog/categories/面试/字节跳动/" href="/blog/categories/面试/字节跳动/"><div class='name'>字节跳动</div><div class='badge'>(2)</div></a></li>
        
      </ul>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
            
              
  <section class='widget tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
    <a class="rightBtn"
    
      rel="external nofollow noopener noreferrer"
    
    
    href="/blog/tags/"
    title="tags/">
    <i class="fas fa-expand-arrows-alt fa-fw"></i></a>
  
</header>

    <div class='content pure'>
      <a href="/blog/tags/2022/" style="font-size: 14px; color: #999">2022</a> <a href="/blog/tags/91天学算法/" style="font-size: 20.25px; color: #6f6f6f">91天学算法</a> <a href="/blog/tags/AI/" style="font-size: 14px; color: #999">AI</a> <a href="/blog/tags/AST/" style="font-size: 14px; color: #999">AST</a> <a href="/blog/tags/BFS/" style="font-size: 14.63px; color: #959595">BFS</a> <a href="/blog/tags/BigPipe/" style="font-size: 14px; color: #999">BigPipe</a> <a href="/blog/tags/CD/" style="font-size: 14px; color: #999">CD</a> <a href="/blog/tags/CSS/" style="font-size: 14px; color: #999">CSS</a> <a href="/blog/tags/Canvas/" style="font-size: 14px; color: #999">Canvas</a> <a href="/blog/tags/Chrome/" style="font-size: 15.25px; color: #919191">Chrome</a> <a href="/blog/tags/D2/" style="font-size: 14px; color: #999">D2</a> <a href="/blog/tags/DFS/" style="font-size: 14px; color: #999">DFS</a> <a href="/blog/tags/Easy/" style="font-size: 14px; color: #999">Easy</a> <a href="/blog/tags/Floyd-Warshall/" style="font-size: 14px; color: #999">Floyd-Warshall</a> <a href="/blog/tags/GitHub/" style="font-size: 14px; color: #999">GitHub</a> <a href="/blog/tags/Github/" style="font-size: 14.63px; color: #959595">Github</a> <a href="/blog/tags/Google-IO/" style="font-size: 14px; color: #999">Google IO</a> <a href="/blog/tags/Hard/" style="font-size: 14px; color: #999">Hard</a> <a href="/blog/tags/JSConf/" style="font-size: 14px; color: #999">JSConf</a> <a href="/blog/tags/LeetCode/" style="font-size: 22.75px; color: #5e5e5e">LeetCode</a> <a href="/blog/tags/LeetCode日记/" style="font-size: 19.63px; color: #737373">LeetCode日记</a> <a href="/blog/tags/Mac/" style="font-size: 14px; color: #999">Mac</a> <a href="/blog/tags/Medium/" style="font-size: 14.63px; color: #959595">Medium</a> <a href="/blog/tags/PPT/" style="font-size: 14.63px; color: #959595">PPT</a> <a href="/blog/tags/QCon/" style="font-size: 14px; color: #999">QCon</a> <a href="/blog/tags/RFC/" style="font-size: 14px; color: #999">RFC</a> <a href="/blog/tags/React/" style="font-size: 14px; color: #999">React</a> <a href="/blog/tags/TypeScript/" style="font-size: 18.38px; color: #7b7b7b">TypeScript</a> <a href="/blog/tags/VSCODE/" style="font-size: 15.25px; color: #919191">VSCODE</a> <a href="/blog/tags/chrome/" style="font-size: 14px; color: #999">chrome</a> <a href="/blog/tags/css-in-js/" style="font-size: 14px; color: #999">css-in-js</a> <a href="/blog/tags/eslint/" style="font-size: 14px; color: #999">eslint</a> <a href="/blog/tags/immutable/" style="font-size: 14px; color: #999">immutable</a> <a href="/blog/tags/immutablejs/" style="font-size: 14px; color: #999">immutablejs</a> <a href="/blog/tags/k-问题/" style="font-size: 14px; color: #999">k 问题</a> <a href="/blog/tags/swc/" style="font-size: 14px; color: #999">swc</a> <a href="/blog/tags/vite/" style="font-size: 14px; color: #999">vite</a> <a href="/blog/tags/vue/" style="font-size: 14px; color: #999">vue</a> <a href="/blog/tags/web-component/" style="font-size: 14px; color: #999">web-component</a> <a href="/blog/tags/webkit/" style="font-size: 14px; color: #999">webkit</a> <a href="/blog/tags/webpack/" style="font-size: 14px; color: #999">webpack</a> <a href="/blog/tags/《算法通关之路》/" style="font-size: 14px; color: #999">《算法通关之路》</a> <a href="/blog/tags/中位数/" style="font-size: 14px; color: #999">中位数</a> <a href="/blog/tags/中等/" style="font-size: 14.63px; color: #959595">中等</a> <a href="/blog/tags/书/" style="font-size: 15.25px; color: #919191">书</a> <a href="/blog/tags/书单/" style="font-size: 14px; color: #999">书单</a> <a href="/blog/tags/书摘/" style="font-size: 14px; color: #999">书摘</a> <a href="/blog/tags/事件/" style="font-size: 14px; color: #999">事件</a> <a href="/blog/tags/事件循环/" style="font-size: 14px; color: #999">事件循环</a> <a href="/blog/tags/二分/" style="font-size: 15.25px; color: #919191">二分</a> <a href="/blog/tags/二分法/" style="font-size: 14px; color: #999">二分法</a> <a href="/blog/tags/二叉树/" style="font-size: 15.25px; color: #919191">二叉树</a> <a href="/blog/tags/位运算/" style="font-size: 14px; color: #999">位运算</a> <a href="/blog/tags/删除-k-个字符/" style="font-size: 14px; color: #999">删除 k 个字符</a> <a href="/blog/tags/刷题/" style="font-size: 15.25px; color: #919191">刷题</a> <a href="/blog/tags/刷题技巧/" style="font-size: 17.13px; color: #848484">刷题技巧</a> <a href="/blog/tags/刷题方法/" style="font-size: 15.25px; color: #919191">刷题方法</a> <a href="/blog/tags/前端/" style="font-size: 22.13px; color: #626262">前端</a> <a href="/blog/tags/前端，自动化，automator/" style="font-size: 14px; color: #999">前端，自动化，automator</a> <a href="/blog/tags/前缀和/" style="font-size: 15.88px; color: #8c8c8c">前缀和</a> <a href="/blog/tags/前缀表达式/" style="font-size: 14px; color: #999">前缀表达式</a> <a href="/blog/tags/力扣加加/" style="font-size: 21.5px; color: #666">力扣加加</a> <a href="/blog/tags/动态规划/" style="font-size: 19px; color: #777">动态规划</a> <a href="/blog/tags/单元测试/" style="font-size: 14px; color: #999">单元测试</a> <a href="/blog/tags/单调栈/" style="font-size: 14px; color: #999">单调栈</a> <a href="/blog/tags/命令行/" style="font-size: 14.63px; color: #959595">命令行</a> <a href="/blog/tags/回溯/" style="font-size: 14px; color: #999">回溯</a> <a href="/blog/tags/困难/" style="font-size: 14.63px; color: #959595">困难</a> <a href="/blog/tags/图/" style="font-size: 14.63px; color: #959595">图</a> <a href="/blog/tags/图片处理/" style="font-size: 14px; color: #999">图片处理</a> <a href="/blog/tags/堆/" style="font-size: 14.63px; color: #959595">堆</a> <a href="/blog/tags/好未来/" style="font-size: 14px; color: #999">好未来</a> <a href="/blog/tags/子数组/" style="font-size: 14px; color: #999">子数组</a> <a href="/blog/tags/字符串/" style="font-size: 14px; color: #999">字符串</a> <a href="/blog/tags/字节跳动/" style="font-size: 15.25px; color: #919191">字节跳动</a> <a href="/blog/tags/学习方法/" style="font-size: 14.63px; color: #959595">学习方法</a> <a href="/blog/tags/工具/" style="font-size: 16.5px; color: #888">工具</a> <a href="/blog/tags/年终总结/" style="font-size: 14px; color: #999">年终总结</a> <a href="/blog/tags/序列化/" style="font-size: 14px; color: #999">序列化</a> <a href="/blog/tags/异常处理/" style="font-size: 14.63px; color: #959595">异常处理</a> <a href="/blog/tags/异议！/" style="font-size: 14px; color: #999">异议！</a> <a href="/blog/tags/循环移位/" style="font-size: 14px; color: #999">循环移位</a> <a href="/blog/tags/微前端/" style="font-size: 14px; color: #999">微前端</a> <a href="/blog/tags/必备软件/" style="font-size: 14px; color: #999">必备软件</a> <a href="/blog/tags/成长经历/" style="font-size: 14.63px; color: #959595">成长经历</a> <a href="/blog/tags/扩展程序/" style="font-size: 14px; color: #999">扩展程序</a> <a href="/blog/tags/技术大会/" style="font-size: 14px; color: #999">技术大会</a> <a href="/blog/tags/技术调研/" style="font-size: 14px; color: #999">技术调研</a> <a href="/blog/tags/技能/" style="font-size: 14.63px; color: #959595">技能</a> <a href="/blog/tags/持续集成/" style="font-size: 14px; color: #999">持续集成</a> <a href="/blog/tags/插件/" style="font-size: 17.13px; color: #848484">插件</a> <a href="/blog/tags/搜索/" style="font-size: 14px; color: #999">搜索</a> <a href="/blog/tags/效率/" style="font-size: 14px; color: #999">效率</a> <a href="/blog/tags/数学/" style="font-size: 15.88px; color: #8c8c8c">数学</a> <a href="/blog/tags/数据结构/" style="font-size: 23.38px; color: #595959">数据结构</a> <a href="/blog/tags/数据结构，算法，LeetCode-日记，Hard/" style="font-size: 14.63px; color: #959595">数据结构，算法，LeetCode 日记，Hard</a> <a href="/blog/tags/数据结构，算法，LeetCode-日记，中等/" style="font-size: 14px; color: #999">数据结构，算法，LeetCode 日记，中等</a> <a href="/blog/tags/数组/" style="font-size: 14.63px; color: #959595">数组</a> <a href="/blog/tags/日记/" style="font-size: 14.63px; color: #959595">日记</a> <a href="/blog/tags/春招/" style="font-size: 15.25px; color: #919191">春招</a> <a href="/blog/tags/最大公约数/" style="font-size: 14px; color: #999">最大公约数</a> <a href="/blog/tags/最长上升子序列/" style="font-size: 14px; color: #999">最长上升子序列</a> <a href="/blog/tags/最长公共子序列/" style="font-size: 14px; color: #999">最长公共子序列</a> <a href="/blog/tags/栈/" style="font-size: 14px; color: #999">栈</a> <a href="/blog/tags/树/" style="font-size: 14px; color: #999">树</a> <a href="/blog/tags/校招/" style="font-size: 16.5px; color: #888">校招</a> <a href="/blog/tags/概率/" style="font-size: 14.63px; color: #959595">概率</a> <a href="/blog/tags/模块/" style="font-size: 14px; color: #999">模块</a> <a href="/blog/tags/模拟面试/" style="font-size: 14px; color: #999">模拟面试</a> <a href="/blog/tags/母题/" style="font-size: 14px; color: #999">母题</a> <a href="/blog/tags/每日一荐/" style="font-size: 17.75px; color: #808080">每日一荐</a> <a href="/blog/tags/沟通/" style="font-size: 14px; color: #999">沟通</a> <a href="/blog/tags/泛型/" style="font-size: 14.63px; color: #959595">泛型</a> <a href="/blog/tags/测试/" style="font-size: 14px; color: #999">测试</a> <a href="/blog/tags/浏览器/" style="font-size: 15.25px; color: #919191">浏览器</a> <a href="/blog/tags/滑动窗口/" style="font-size: 16.5px; color: #888">滑动窗口</a> <a href="/blog/tags/滤镜/" style="font-size: 14px; color: #999">滤镜</a> <a href="/blog/tags/状态压缩/" style="font-size: 14px; color: #999">状态压缩</a> <a href="/blog/tags/状态机/" style="font-size: 14px; color: #999">状态机</a> <a href="/blog/tags/电子书/" style="font-size: 14px; color: #999">电子书</a> <a href="/blog/tags/电影/" style="font-size: 14.63px; color: #959595">电影</a> <a href="/blog/tags/百度/" style="font-size: 14px; color: #999">百度</a> <a href="/blog/tags/监控/" style="font-size: 14px; color: #999">监控</a> <a href="/blog/tags/秋招/" style="font-size: 14px; color: #999">秋招</a> <a href="/blog/tags/算法/" style="font-size: 24px; color: #555">算法</a> <a href="/blog/tags/算法提高班/" style="font-size: 20.88px; color: #6a6a6a">算法提高班</a> <a href="/blog/tags/算法比赛/" style="font-size: 14px; color: #999">算法比赛</a> <a href="/blog/tags/算法系列/" style="font-size: 15.88px; color: #8c8c8c">算法系列</a> <a href="/blog/tags/算法通关之路/" style="font-size: 14px; color: #999">算法通关之路</a> <a href="/blog/tags/算法，最近公共祖先/" style="font-size: 14px; color: #999">算法，最近公共祖先</a> <a href="/blog/tags/线段树/" style="font-size: 14px; color: #999">线段树</a> <a href="/blog/tags/组件化/" style="font-size: 14px; color: #999">组件化</a> <a href="/blog/tags/经验分享/" style="font-size: 15.25px; color: #919191">经验分享</a> <a href="/blog/tags/编程之美/" style="font-size: 14px; color: #999">编程之美</a> <a href="/blog/tags/草稿/" style="font-size: 14.63px; color: #959595">草稿</a> <a href="/blog/tags/蓄水池抽样/" style="font-size: 14px; color: #999">蓄水池抽样</a> <a href="/blog/tags/虾皮/" style="font-size: 14px; color: #999">虾皮</a> <a href="/blog/tags/装机/" style="font-size: 14px; color: #999">装机</a> <a href="/blog/tags/解题模板/" style="font-size: 14px; color: #999">解题模板</a> <a href="/blog/tags/谷歌/" style="font-size: 15.25px; color: #919191">谷歌</a> <a href="/blog/tags/贪婪/" style="font-size: 14px; color: #999">贪婪</a> <a href="/blog/tags/贪心/" style="font-size: 14px; color: #999">贪心</a> <a href="/blog/tags/走出科学/" style="font-size: 14px; color: #999">走出科学</a> <a href="/blog/tags/逆向思维/" style="font-size: 14px; color: #999">逆向思维</a> <a href="/blog/tags/递归/" style="font-size: 14px; color: #999">递归</a> <a href="/blog/tags/链表/" style="font-size: 15.25px; color: #919191">链表</a> <a href="/blog/tags/陷阱题/" style="font-size: 14px; color: #999">陷阱题</a> <a href="/blog/tags/面经/" style="font-size: 15.88px; color: #8c8c8c">面经</a> <a href="/blog/tags/面试/" style="font-size: 16.5px; color: #888">面试</a>
    </div>
  </section>


            
          
        
          
          
        
          
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
            
              <section class='widget list'>
  
<header class='pure'>
  <div><i class="fas fa-thumbs-up fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;强烈推荐</div>
  
</header>

  <div class='content pure'>
    <ul class="entry">
      
        <li><a class="flat-box" title="https://lucifer.ren/blog/2022/04/26/books-2022/" href="https://lucifer.ren/blog/2022/04/26/books-2022/"
          
          
          >
          <div class='name'>
            
              <i class=" fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;西法的 2022 书单推荐
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="https://www.aliyun.com/daily-act/ecs/activity_selection?userCode=0iygwnzh" href="https://www.aliyun.com/daily-act/ecs/activity_selection?userCode=0iygwnzh"
          
          
          >
          <div class='name'>
            
              <i class=" fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;【阿里云】轻量应用服务器2核2G 低至60元/年起
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="https://leetcode-solution.cn/book-intro" href="https://leetcode-solution.cn/book-intro"
          
          
          >
          <div class='name'>
            
              <i class=" fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;《算法通关之路》
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="https://yasuotu.com" href="https://yasuotu.com"
          
          
          >
          <div class='name'>
            
              <i class=" fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;图片在线压缩
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="https://github.com/fe-lucifer/fanqiang" href="https://github.com/fe-lucifer/fanqiang"
          
          
          >
          <div class='name'>
            
              <i class=" fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;科学上网
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="https://mxclub.github.io/resume/" href="https://mxclub.github.io/resume/"
          
          
          >
          <div class='name'>
            
              <i class=" fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;简历主题
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

            
          
        
      
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
      
    

  
</aside>

<footer id="footer" class="clearfix">
   
  <div class="social-wrapper">
     
    <a
      href="/blog/atom.xml"
      class="social fas fa-rss flat-btn"
      target="_blank"
      rel="external nofollow noopener noreferrer"
    >
    </a>
      
    <a
      href="https://www.zhihu.com/people/lu-xiao-13-70/activities"
      class="social fab fa-zhihu flat-btn"
      target="_blank"
      rel="external nofollow noopener noreferrer"
    >
    </a>
      
    <a
      href="mailto:azl397985856@gmail.com"
      class="social fas fa-envelope flat-btn"
      target="_blank"
      rel="external nofollow noopener noreferrer"
    >
    </a>
      
    <a
      href="https://github.com/azl397985856"
      class="social fab fa-github flat-btn"
      target="_blank"
      rel="external nofollow noopener noreferrer"
    >
    </a>
      
    <a
      href="https://music.163.com/playlist?id=978545815&amp;userid=632167080"
      class="social fas fa-headphones-alt flat-btn"
      target="_blank"
      rel="external nofollow noopener noreferrer"
    >
    </a>
     
  </div>
  
  <br />
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>
    本站使用
    <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename"
      >Material X</a
    >
    作为主题  。
  </div>

  <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
  <script>
    var now = new Date();
    function createtime() {
      var grt = new Date("08/10/2018 17:38:00"); //在此处修改你的建站时间，格式：月/日/年 时:分:秒
      now.setTime(now.getTime() + 250);
      days = (now - grt) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
      hnum = Math.floor(hours);
      if (String(hnum).length == 1) {
        hnum = "0" + hnum;
      }
      minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
      mnum = Math.floor(minutes);
      if (String(mnum).length == 1) {
        mnum = "0" + mnum;
      }
      seconds =
        (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
      snum = Math.round(seconds);
      if (String(snum).length == 1) {
        snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML =
        "本站已安全运行 " + dnum + " 天 ";
      document.getElementById("times").innerHTML =
        hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    setInterval("createtime()", 250);
  </script>
</footer>
<script>
  setLoadingBarProgress(80);
</script>


        <script>
          setLoadingBarProgress(60);
        </script>
      </div>
      <a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/blog/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>

<script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script>


  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>





  
  
  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script>
    <script type="text/javascript">
      $(function(){
        if ('.cover') {
          $('.cover').backstretch(
          ["https://img.vim-cn.com/29/91197b04c13f512f734a76d4ac422d89dbe229.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        } else {
          $.backstretch(
          ["https://img.vim-cn.com/29/91197b04c13f512f734a76d4ac422d89dbe229.jpg"],
          {
            duration: "6000",
            fade: "2500"
          });
        }
      });
    </script>
  







  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: "aea1377036afe4cd0343",
      clientSecret: "815c638dea8644b7a4b97905707cf72b45555f6d",
      repo: "blog",
      owner: "azl397985856",
      admin: "azl397985856",
      
        id: location.pathname,      // Ensure uniqueness and length less than 50
      
      distractionFreeMode: false  // Facebook-like distraction free mode
    });
    gitalk.render('gitalk-container');
  </script>





  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/app.js"></script>


  <script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/search.js"></script>




<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





    <script>
      setLoadingBarProgress(100);
    </script>
  </body>
</html>
