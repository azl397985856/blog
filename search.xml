<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【LeetCode日记】 50. Pow(x, n)</title>
      <link href="/blog/2020/01/29/50.powx-n/"/>
      <url>/blog/2020/01/29/50.powx-n/</url>
      
        <content type="html"><![CDATA[<p>这是一道让我们实现系统函数的造轮子题目，我们来看下。</p><p>​<a id="more"></a></p><p>原题地址：<a href="https://leetcode-cn.com/problems/powx-n/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/powx-n/description/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">实现 pow(x, n) ，即计算 x 的 n 次幂函数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 = 1/22 = 1/4 = 0.25</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</span><br></pre></td></tr></table></figure><h2 id="解法零-遍历法"><a href="#解法零-遍历法" class="headerlink" title="解法零 - 遍历法"></a>解法零 - 遍历法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题是让我们实现数学函数<code>幂</code>，因此直接调用系统内置函数是不被允许的。</p><p>符合直觉的做法是<code>将x乘以n次</code>，这种做法的时间复杂度是$O(N)$。</p><p>经实际测试，这种做法果然超时了。测试用例通过 291/304，在 <code>0.00001\n2147483647</code>这个测试用例挂掉了。如果是面试，这个解法可以作为一种兜底解法。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>语言支持: Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            res *= x</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="解法一-普通递归（超时法）"><a href="#解法一-普通递归（超时法）" class="headerlink" title="解法一 - 普通递归（超时法）"></a>解法一 - 普通递归（超时法）</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先我们要知道：</p><ul><li>如果想要求 x ^ 4，那么我们可以求 (x^2)^2</li><li>如果是奇数，会有一点不同。 比如 x ^ 5 就等价于 x * (x^2)^2。</li></ul><blockquote><p>当然 x ^ 5 可以等价于 (x ^ 2) ^ 2.5, 但是这不相当于直接调用了幂函数了么。对于整数，我们可以很方便的模拟，但是小数就不方便了。</p></blockquote><p>我们的思路就是：</p><ul><li>将 n 地板除 2，我们不妨设结果为 a</li><li>那么 myPow(x, n) 就等价于 <code>myPow(x, a) * myPow(x, n - a)</code></li></ul><p>很可惜这种算法也会超时，原因在于重复计算会比较多，你可以试一下缓存一下计算看能不能通过。</p><blockquote><p>如果你搞不清楚有哪些重复计算，建议画图理解一下。</p></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>语言支持: Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">        <span class="keyword">return</span> self.myPow(x, n // <span class="number">2</span>) * self.myPow(x, n - n // <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="解法二-优化递归"><a href="#解法二-优化递归" class="headerlink" title="解法二 - 优化递归"></a>解法二 - 优化递归</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>上面的解法每次直接 myPow 都会调用两次自己。我们不从缓存计算角度，而是从减少这种调用的角度来优化。</p><p>我们考虑 myPow 只调用一次自身可以么？ 没错，是可以的。</p><p>我们的思路就是：</p><ul><li>如果 n 是偶数，我们将 n 折半，底数变为 x^2</li><li>如果 n 是奇数， 我们将 n 减去 1 ，底数不变，得到的结果再乘上底数 x</li></ul><p>这样终于可以 AC。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>语言支持: Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">        <span class="keyword">return</span> self.myPow(x _ x, n // <span class="number">2</span>) <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> x _ self.myPow(x, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="解法三-位运算"><a href="#解法三-位运算" class="headerlink" title="解法三 - 位运算"></a>解法三 - 位运算</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们来从位（bit）的角度来看一下这道题。如果你经常看我的题解和文章的话，可能知道我之前写过几次相关的“从位的角度思考分治法”，比如 LeetCode <a href="https://leetcode-cn.com/problems/poor-pigs/description/" target="_blank" rel="noopener">458.可怜的小猪</a>。</p><p>以 x 的 10 次方举例。10 的 2 进制是 1010，然后用 2 进制转 10 进制的方法把它展成 2 的幂次的和。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbdseolzbmj30t802mjrk.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbdssrrsh6j30xp0u040e.jpg" alt></p><p>因此我们的算法就是：</p><ul><li>不断的求解 x 的 2^0 次方，x 的 2^1 次方，x 的 2^2 次方等等。</li><li>将 n 转化为二进制表示</li><li>将 n 的二进制表示中<code>1的位置</code>pick 出来。比如 n 的第 i 位为 1，那么就将 x^i pick 出来。</li><li>将 pick 出来的结果相乘</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbdtiky90rj30vq0hcab4.jpg" alt></p><p>这里有两个问题：</p><p>第一个问题是<code>似乎我们需要存储 x^i 以便后续相乘的时候用到</code>。实际上，我们并不需要这么做。我们可以采取一次遍历的方式来完成，具体看代码。</p><p>第二个问题是，如果我们从低位到高位计算的时候，我们如何判断最高位置是否为 1？我们需要一个 bitmask 来完成，这种算法我们甚至需要借助一个额外的变量。 然而我们可以 hack 一下，直接从高位到低位进行计算，这个时候我们只需要判断最后一位是否为 1 就可以了，这个就简单了，我们直接和 1 进行一次<code>与运算</code>即可。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>语言支持: Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>超时分析</li><li>hashtable</li><li>数学分析</li><li>位运算</li><li>二进制转十进制</li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode-cn.com/problems/poor-pigs/description/" target="_blank" rel="noopener">458.可怜的小猪</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbdrfn9n2wj30wn0u0dp2.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 数学 </category>
          
          <category> hashtable </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 874. 模拟行走机器人</title>
      <link href="/blog/2020/01/29/874.walking-robot-simulation/"/>
      <url>/blog/2020/01/29/874.walking-robot-simulation/</url>
      
        <content type="html"><![CDATA[<p>这是一道 LeetCode 难度为 easy 的题目，没有高深的算法，有的只是套路，我们来看下。</p><p>​<a id="more"></a></p><p>原题地址：<a href="https://leetcode-cn.com/problems/walking-robot-simulation/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/walking-robot-simulation/submissions/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：</span><br><span class="line"></span><br><span class="line">-2：向左转 90 度</span><br><span class="line">-1：向右转 90 度</span><br><span class="line">1 &lt;= x &lt;= 9：向前移动 x 个单位长度</span><br><span class="line">在网格上有一些格子被视为障碍物。</span><br><span class="line"></span><br><span class="line">第 i 个障碍物位于网格点  (obstacles[i][0], obstacles[i][1])</span><br><span class="line"></span><br><span class="line">如果机器人试图走到障碍物上方，那么它将停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。</span><br><span class="line"></span><br><span class="line">返回从原点到机器人的最大欧式距离的平方。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: commands = [4,-1,3], obstacles = []</span><br><span class="line">输出: 25</span><br><span class="line">解释: 机器人将会到达 (3, 4)</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]</span><br><span class="line">输出: 65</span><br><span class="line">解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;= commands.length &lt;= 10000</span><br><span class="line">0 &lt;= obstacles.length &lt;= 10000</span><br><span class="line">-30000 &lt;= obstacle[i][0] &lt;= 30000</span><br><span class="line">-30000 &lt;= obstacle[i][1] &lt;= 30000</span><br><span class="line">答案保证小于 2 ^ 31</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题之所以是简单难度，是因为其没有什么技巧。你只需要看懂题目描述，然后把题目描述转化为代码即可。</p><p>唯一需要注意的是查找障碍物的时候如果你采用的是<code>线形查找</code>会很慢，很可能会超时。</p><blockquote><p>我实际测试了一下，确实会超时</p></blockquote><ul><li>一种方式是使用排序，然后二分查找，如果采用基于比较的排序算法，那么这种算法的瓶颈在于排序本身，也就是$O(NlogN)$。</li><li>另一种方式是使用集合，将 obstacles 放入集合，然后需要的时候进行查询，查询的时候的时间复杂度为$O(1)$。</li></ul><p>这里我们采用第二种方式。</p><p>接下来我们来“翻译”一下题目。</p><ul><li>由于机器人只能往前走。因此机器人往东西南北哪个方向走取决于它的<code>朝向</code>。</li><li>我们使用枚举来表示当前机器人的<code>朝向</code>。</li><li>题目只有两种方式改变<code>朝向</code>，一种是左转（-2），另一种是右转（-1）。</li><li>题目要求的是机器人在<code>运动过程中距离原点的最大值</code>，而不是最终位置距离原点的距离。</li></ul><p>为了代码书写简单，我建立了一个直角坐标系。用<code>机器人的朝向和 x 轴正方向的夹角度数</code>来作为枚举值，并且这个度数是 <code>0 &lt;= deg &lt; 360</code>。我们不难知道，其实这个取值就是<code>0</code>, <code>90</code>,<code>180</code>,<code>270</code> 四个值。那么当 0 度的时候，我们只需要不断地 x+1，90 度的时候我们不断地 y + 1 等等。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbdnsywx97j31020r8gmt.jpg" alt></p><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>理解题意，这道题容易理解错题意，求解为<code>最终位置距离原点的距离</code></li><li>建立坐标系</li><li>使用集合简化线形查找的时间复杂度。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码支持： Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robotSim</span><span class="params">(self, commands: List[int], obstacles: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        pos = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        deg = <span class="number">90</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        obstaclesSet = set(map(tuple, obstacles))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> command <span class="keyword">in</span> commands:</span><br><span class="line">            <span class="keyword">if</span> command == <span class="number">-1</span>:</span><br><span class="line">                deg = (deg + <span class="number">270</span>) % <span class="number">360</span></span><br><span class="line">            <span class="keyword">elif</span> command == <span class="number">-2</span>:</span><br><span class="line">                deg = (deg + <span class="number">90</span>) % <span class="number">360</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> deg == <span class="number">0</span>:</span><br><span class="line">                    i = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; command <span class="keyword">and</span> <span class="keyword">not</span> (pos[<span class="number">0</span>] + <span class="number">1</span>, pos[<span class="number">1</span>]) <span class="keyword">in</span> obstaclesSet:</span><br><span class="line">                        pos[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> deg == <span class="number">90</span>:</span><br><span class="line">                    i = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; command <span class="keyword">and</span> <span class="keyword">not</span> (pos[<span class="number">0</span>], pos[<span class="number">1</span>] + <span class="number">1</span>) <span class="keyword">in</span> obstaclesSet:</span><br><span class="line">                        pos[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> deg == <span class="number">180</span>:</span><br><span class="line">                    i = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; command <span class="keyword">and</span> <span class="keyword">not</span> (pos[<span class="number">0</span>] - <span class="number">1</span>, pos[<span class="number">1</span>]) <span class="keyword">in</span> obstaclesSet:</span><br><span class="line">                        pos[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> deg == <span class="number">270</span>:</span><br><span class="line">                    i = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; command <span class="keyword">and</span> <span class="keyword">not</span> (pos[<span class="number">0</span>], pos[<span class="number">1</span>] - <span class="number">1</span>) <span class="keyword">in</span> obstaclesSet:</span><br><span class="line">                        pos[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                ans = max(ans, pos[<span class="number">0</span>] ** <span class="number">2</span> + pos[<span class="number">1</span>] ** <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> hashtable </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一行代码就可以通过 LeetCode？来看下我是怎么做到的！</title>
      <link href="/blog/2020/01/18/1227.airplane-seat-assignment-probability/"/>
      <url>/blog/2020/01/18/1227.airplane-seat-assignment-probability/</url>
      
        <content type="html"><![CDATA[<p>这是一道 LeetCode 为数不多的概率题，我们来看下。</p><p>​<a id="more"></a></p><p>原题地址：<a href="https://leetcode-cn.com/problems/airplane-seat-assignment-probability/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/airplane-seat-assignment-probability/description/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</span><br><span class="line"></span><br><span class="line">剩下的乘客将会：</span><br><span class="line"></span><br><span class="line">如果他们自己的座位还空着，就坐到自己的座位上，</span><br><span class="line"></span><br><span class="line">当他们自己的座位被占用时，随机选择其他座位</span><br><span class="line">第 n 位乘客坐在自己的座位上的概率是多少？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 1</span><br><span class="line">输出：1.00000</span><br><span class="line">解释：第一个人只会坐在自己的位置上。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: n = 2</span><br><span class="line">输出: 0.50000</span><br><span class="line">解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= n &lt;= 10^5</span><br></pre></td></tr></table></figure><h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><p>这是一道 LeetCode 为数不多的概率题，我们来看下。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们定义原问题为 f(n)。对于第一个人来说，他有 n 中选择，就是分别选择 n 个座位中的一个。由于选择每个位置的概率是相同的，那么选择每个位置的概率应该都是 1 / n。</p><p>我们分三种情况来讨论：</p><ul><li>如果第一个人选择了第一个人的位置（也就是选择了自己的位置），那么剩下的人按照票上的座位做就好了，这种情况第 n 个人一定能做到自己的位置</li><li>如果第一个人选择了第 n 个人的位置，那么第 n 个人肯定坐不到自己的位置。</li><li>如果第一个人选择了第 i (1 &lt; i &lt; n)个人的位置，那么第 i 个人就相当于变成了“票丢的人”，此时问题转化为 f(n - i + 1)。</li></ul><p>此时的问题转化关系如图：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gb12n0omuuj31bc0ju405.jpg" alt><br>（红色表示票丢的人）</p><p>整个过程分析：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gb12nhestaj318u0bg76f.jpg" alt></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">        res = <span class="number">1</span> / n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            res += self.nthPersonGetsNthSeat(n - i + <span class="number">1</span>) * <span class="number">1</span> / n</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>上述代码会栈溢出。</p><h2 id="暴力递归-hashtable"><a href="#暴力递归-hashtable" class="headerlink" title="暴力递归 + hashtable"></a>暴力递归 + hashtable</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们考虑使用记忆化递归来减少重复计算，虽然这种做法可以减少运行时间，但是对减少递归深度没有帮助。还是会栈溢出。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    seen = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> self.seen:</span><br><span class="line">            <span class="keyword">return</span> self.seen[n]</span><br><span class="line">        res = <span class="number">1</span> / n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            res += self.nthPersonGetsNthSeat(n - i + <span class="number">1</span>) * <span class="number">1</span> / n</span><br><span class="line">        self.seen[n] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>上面做法会栈溢出。其实我们根本不需要运行就应该能判断出栈溢出，题目已经给了数据规模是 1 &lt;= n &lt;= 10 ** 5。 这个量级不管什么语言，除非使用尾递归，不然一般都会栈溢出，具体栈深度大家可以查阅相关资料。</p><p>既然是栈溢出，那么我们考虑使用迭代来完成。 很容易想到使用动态规划来完成。其实递归都写出来，写一个朴素版的动态规划也难不到哪去，毕竟动态规划就是记录子问题，并建立子问题之间映射而已，这和递归并无本质区别。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span>, <span class="number">.5</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = <span class="number">1</span> / n</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, i):</span><br><span class="line">                dp[i] += dp[i - j + <span class="number">1</span>] * <span class="number">1</span> / n</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>这种思路的代码超时了，并且仅仅执行了 35/100 testcase 就超时了。</p><h2 id="数学分析"><a href="#数学分析" class="headerlink" title="数学分析"></a>数学分析</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们还需要进一步优化时间复杂度，我们需要思考是否可以在线性的时间内完成。</p><p>我们继续前面的思路进行分析, 不难得出，我们不妨称其为等式 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n)</span><br><span class="line">= 1/n + 0 + 1/n * (f(n-1) + f(n-2) + ... + f(2))</span><br><span class="line">= 1/n * (f(n-1) + f(n-2) + ... + f(2) + 1)</span><br><span class="line">= 1/n * (f(n-1) + f(n-2) + ... + f(2) + f(1))</span><br></pre></td></tr></table></figure><p>似乎更复杂了？没关系，我们继续往下看，我们看下 f(n - 1)，我们不妨称其为等式 2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n-1) = 1/(n-1) * (f(n-2) + f(n-3) + ... + f(1))</span><br></pre></td></tr></table></figure><p>我们将等式 1 和等式 2 两边分别同时乘以 n 和 n - 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n * f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(1)</span><br><span class="line">(n-1) * f(n-1) = f(n-2) + f(n-3) + ... + f(1)</span><br></pre></td></tr></table></figure><p>我们将两者相减：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n * f(n) - (n-1)*f(n-1) = f(n-1)</span><br></pre></td></tr></table></figure><p>我们继续将 (n-1)*f(n-1) 移到等式右边，得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n * f(n) = n * f(n-1)</span><br></pre></td></tr></table></figure><p>也就是说:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n - 1)</span><br></pre></td></tr></table></figure><p>当然前提是 n 大于 2。</p><p>既然如此，我们就可以减少一层循环， 我们用这个思路来优化一下上面的 dp 解法。这种解法终于可以 AC 了。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span>, <span class="number">.5</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = <span class="number">1</span>/n+(n<span class="number">-2</span>)/n * dp[n<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="优化数学分析"><a href="#优化数学分析" class="headerlink" title="优化数学分析"></a>优化数学分析</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>上面我们通过数学分析，得出了当 n 大于 2 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n - 1)</span><br></pre></td></tr></table></figure><p>那么是不是意味着我们随便求出一个 n 就好了？ 比如我们求出 n = 2 的时候的值，是不是就知道 n 为任意数的值了。 我们不难想出 n = 2 时候，概率是 0.5，因此只要 n 大于 1 就是 0.5 概率，否则就是 1 概率。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">else</span> <span class="number">.5</span></span><br></pre></td></tr></table></figure><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>概率分析</li><li>数学推导</li><li>动态规划</li><li>递归 + mapper</li><li>栈限制大小</li><li>尾递归</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
          <category> 概率 </category>
          
          <category> 递归 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 概率 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原来状态机也可以用来刷 LeetCode？</title>
      <link href="/blog/2020/01/12/1262.greatest-sum-divisible-by-three/"/>
      <url>/blog/2020/01/12/1262.greatest-sum-divisible-by-three/</url>
      
        <content type="html"><![CDATA[<p>什么？ 状态机还可以用来刷 LeetCode？ 如果你还不知道，那么就快进来看看吧！</p><a id="more"></a><p>题目地址： <a href="https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/description/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,6,5,1,8]</span><br><span class="line">输出：18</span><br><span class="line">解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [4]</span><br><span class="line">输出：0</span><br><span class="line">解释：4 不能被 3 整除，所以无法选出数字，返回 0。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,3,4,4]</span><br><span class="line">输出：12</span><br><span class="line">解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= nums.length &lt;= 4 * 10^4</span><br><span class="line">1 &lt;= nums[i] &lt;= 10^4</span><br></pre></td></tr></table></figure><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一种方式是找出所有的能够被 3 整除的子集，然后挑选出和最大的。由于我们选出了所有的子集，那么时间复杂度就是 $O(2^N)$ ， 毫无疑问会超时。这里我们使用回溯法找子集，如果不清楚回溯法，可以参考我之前的题解，很多题目都用到了，比如<a href="https://github.com/azl397985856/leetcode/blob/master/problems/78.subsets.md" target="_blank" rel="noopener">78.subsets</a>。</p><p>更多回溯题目，可以访问上方链接查看（可以使用一套模板搞定）：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gatuu0yfh8j30f60c4ab3.jpg" alt></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(temp, start)</span>:</span></span><br><span class="line">            total = sum(temp)</span><br><span class="line">            <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                self.res = max(self.res, total)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">                temp.append(nums[i])</span><br><span class="line">                backtrack(temp, i + <span class="number">1</span>)</span><br><span class="line">                temp.pop(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        backtrack([], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h2 id="减法-排序"><a href="#减法-排序" class="headerlink" title="减法 + 排序"></a>减法 + 排序</h2><p>减法的核心思想是，我们求出总和。如果总和不满足题意，我们尝试减去最小的数，使之满足题意。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这种算法的思想，具体来说就是：</p><ul><li>我们将所有的数字加起来，我们不妨设为 total</li><li>total 除以 3，得到一个余数 mod， mod 可能值有 0，1，2.</li><li>同时我们建立两个数组，一个是余数为 1 的数组 one，一个是余数为 2 的数组 two</li><li>如果 mod 为 0，我们直接返回即可。</li><li>如果 mod 为 1，我们可以减去 one 数组中最小的一个（如果有的话），或者减去两个 two 数组中最小的（如果有的话），究竟减去谁取决谁更小。</li><li>如果 mod 为 2，我们可以减去 two 数组中最小的一个（如果有的话），或者减去两个 one 数组中最小的（如果有的话），究竟减去谁取决谁更小。</li></ul><p>由于我们需要取 one 和 two 中最小的一个或者两个，因此对数组 one 和 two 进行排序是可行的，如果基于排序的话，时间复杂度大致为 $O(NlogN)$，这种算法可以通过。</p><p>以题目中的例 1 为例：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gatvdy1zb1j30u00x2wgx.jpg" alt></p><p>以题目中的例 2 为例：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gatvem1xm4j30u00xvq59.jpg" alt></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        one = []</span><br><span class="line">        two = []</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            total += num</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">                one.append(num)</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">                two.append(num)</span><br><span class="line">        one.sort()</span><br><span class="line">        two.sort()</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> total</span><br><span class="line">        <span class="keyword">elif</span> total % <span class="number">3</span> == <span class="number">1</span> <span class="keyword">and</span> one:</span><br><span class="line">            <span class="keyword">if</span> len(two) &gt;= <span class="number">2</span> <span class="keyword">and</span> one[<span class="number">0</span>] &gt; two[<span class="number">0</span>] + two[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> total - two[<span class="number">0</span>] - two[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> total - one[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> total % <span class="number">3</span> == <span class="number">2</span> <span class="keyword">and</span> two:</span><br><span class="line">            <span class="keyword">if</span> len(one) &gt;= <span class="number">2</span> <span class="keyword">and</span> two[<span class="number">0</span>] &gt; one[<span class="number">0</span>] + one[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> total - one[<span class="number">0</span>] - one[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> total - two[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="减法-非排序"><a href="#减法-非排序" class="headerlink" title="减法 + 非排序"></a>减法 + 非排序</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>上面的解法使用到了排序。 我们其实观察发现，我们只是用到了 one 和 two 的最小的两个数。因此我们完全可以在线形的时间和常数的空间完成这个算法。我们只需要分别记录 one 和 two 的最小值和次小值即可，在这里，我使用了两个长度为 2 的数组来表示，第一项是最小值，第二项是次小值。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        one = [float(<span class="string">'inf'</span>)] * <span class="number">2</span></span><br><span class="line">        two = [float(<span class="string">'inf'</span>)] * <span class="number">2</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            total += num</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> num &lt; one[<span class="number">0</span>]:</span><br><span class="line">                    t = one[<span class="number">0</span>]</span><br><span class="line">                    one[<span class="number">0</span>] = num</span><br><span class="line">                    one[<span class="number">1</span>] = t</span><br><span class="line">                <span class="keyword">elif</span> num &lt; one[<span class="number">1</span>]:</span><br><span class="line">                    one[<span class="number">1</span>] = num</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> num &lt; two[<span class="number">0</span>]:</span><br><span class="line">                    t = two[<span class="number">0</span>]</span><br><span class="line">                    two[<span class="number">0</span>] = num</span><br><span class="line">                    two[<span class="number">1</span>] = t</span><br><span class="line">                <span class="keyword">elif</span> num &lt; two[<span class="number">1</span>]:</span><br><span class="line">                    two[<span class="number">1</span>] = num</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> total</span><br><span class="line">        <span class="keyword">elif</span> total % <span class="number">3</span> == <span class="number">1</span> <span class="keyword">and</span> one:</span><br><span class="line">            <span class="keyword">if</span> len(two) &gt;= <span class="number">2</span> <span class="keyword">and</span> one[<span class="number">0</span>] &gt; two[<span class="number">0</span>] + two[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> total - two[<span class="number">0</span>] - two[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> total - one[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> total % <span class="number">3</span> == <span class="number">2</span> <span class="keyword">and</span> two:</span><br><span class="line">            <span class="keyword">if</span> len(one) &gt;= <span class="number">2</span> <span class="keyword">and</span> two[<span class="number">0</span>] &gt; one[<span class="number">0</span>] + one[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> total - one[<span class="number">0</span>] - one[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> total - two[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我在<a href="https://lucifer.ren/blog/2019/09/19/algorthimn-fe-2/">数据结构与算法在前端领域的应用 - 第二篇</a> 中讲到了有限状态机。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gatub3vftxj30eq0bfta0.jpg" alt></p><p>状态机表示若干个状态以及在这些状态之间的转移和动作等行为的数学模型。通俗的描述状态机就是定义了一套状态変更的流程：状态机包含一个状态集合，定义当状态机处于某一个状态的时候它所能接收的事件以及可执行的行为，执行完成后，状态机所处的状态。</p><p>状态机使用非常广泛，比如正则表达式的引擎，编译器的词法和语法分析，网络协议，企业应用等很多领域都会用到。</p><p>拿本题中来说，我们从左到右扫描数组的过程，将会不断改变状态机的状态。</p><p>我们使用 state 数组来表示本题的状态：</p><ul><li>state[0] 表示 mod 为 0 的 最大和</li><li>state[1] 表示 mod 为 1 的 最大和</li><li>state[2] 表示 mod 为 1 的 最大和</li></ul><p>我们的状态转移方程就会很容易。说到状态转移方程，你可能会想到动态规划。没错！这种思路可以直接翻译成动态规划，算法完全一样。如果你看过我上面提到的文章，那么状态转移方程对你来说就会很容易。如果你不清楚，那么请往下看：</p><ul><li>我们从左往右不断读取数字，我们不妨设这个数字为 num。</li><li>如果 num % 3 为 0。 那么我们的 state[0], state[1], state[2] 可以直接加上 num（题目限定了 num 为非负）， 因为任何数字加上 3 的倍数之后，mod 3 的值是不变的。</li><li>如果 num % 3 为 1。 我们知道 state[2] + num 会变成一个能被三整除的数，但是这个数字不一定比当前的 state[0]大。 代码表示就是<code>max(state[2] + num, state[0])</code>。同理 state[1] 和 state[2] 的转移逻辑类似。</li><li>同理 num % 3 为 2 也是类似的逻辑。</li><li>最后我们返回 state[0]即可。</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        state = [<span class="number">0</span>, float(<span class="string">'-inf'</span>), float(<span class="string">'-inf'</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                state = [state[<span class="number">0</span>] + num, state[<span class="number">1</span>] + num, state[<span class="number">2</span>] + num]</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">                a = max(state[<span class="number">2</span>] + num, state[<span class="number">0</span>])</span><br><span class="line">                b = max(state[<span class="number">0</span>] + num, state[<span class="number">1</span>])</span><br><span class="line">                c = max(state[<span class="number">1</span>] + num, state[<span class="number">2</span>])</span><br><span class="line">                state = [a, b, c]</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">                a = max(state[<span class="number">1</span>] + num, state[<span class="number">0</span>])</span><br><span class="line">                b = max(state[<span class="number">2</span>] + num, state[<span class="number">1</span>])</span><br><span class="line">                c = max(state[<span class="number">0</span>] + num, state[<span class="number">2</span>])</span><br><span class="line">                state = [a, b, c]</span><br><span class="line">        <span class="keyword">return</span> state[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当然这个代码还可以简化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        state = [<span class="number">0</span>, float(<span class="string">'-inf'</span>), float(<span class="string">'-inf'</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            temp = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                temp[(i + num) % <span class="number">3</span>] = max(state[(i + num) % <span class="number">3</span>], state[i] + num)</span><br><span class="line">            state = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> state[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>贪婪法</li><li>状态机</li><li>数学分析</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>实际上，我们可以采取加法（贪婪策略），感兴趣的可以试一下。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态机 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode一道令人发指的陷阱题</title>
      <link href="/blog/2020/01/10/1297.maximum-number-of-occurrences-of-a-substring/"/>
      <url>/blog/2020/01/10/1297.maximum-number-of-occurrences-of-a-substring/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 有一些题目会给你设置陷阱，给你一些干扰信息。这个时候你需要小心，不要被他们带跑偏了。那么是什么样的陷阱呢？让我们来看一下！</p><a id="more"></a><h1 id="题目地址（1297-子串的最大出现次数）"><a href="#题目地址（1297-子串的最大出现次数）" class="headerlink" title="题目地址（1297. 子串的最大出现次数）"></a>题目地址（1297. 子串的最大出现次数）</h1><p><a href="https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：</span><br><span class="line"></span><br><span class="line">子串中不同字母的数目必须小于等于 maxLetters 。</span><br><span class="line">子串的长度必须大于等于 minSize 且小于等于 maxSize 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;aababcaab&quot;, maxLetters = 2, minSize = 3, maxSize = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：子串 &quot;aab&quot; 在原字符串中出现了 2 次。</span><br><span class="line">它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;aaaa&quot;, maxLetters = 1, minSize = 3, maxSize = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：子串 &quot;aaa&quot; 在原字符串中出现了 2 次，且它们有重叠部分。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;aabcabcab&quot;, maxLetters = 2, minSize = 2, maxSize = 3</span><br><span class="line">输出：3</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;abcde&quot;, maxLetters = 2, minSize = 3, maxSize = 3</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= s.length &lt;= 10^5</span><br><span class="line">1 &lt;= maxLetters &lt;= 26</span><br><span class="line">1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length)</span><br><span class="line">s 只包含小写英文字母。</span><br></pre></td></tr></table></figure><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>题目给的数据量不是很大，为 1 &lt;= maxLetters &lt;= 26，我们试一下暴力法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力法如下：</p><ul><li>先找出所有满足长度大于等于 minSize 且小于等于 maxSize 的所有子串。（平方的复杂度）</li><li>对于 maxLetter 满足题意的子串，我们统计其出现次数。时间复杂度为 O(k),其中 k 为子串长度</li><li>返回最大的出现次数</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Pythpn Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxFreq</span><span class="params">(self, s: str, maxLetters: int, minSize: int, maxSize: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        letters = set()</span><br><span class="line">        cnts = dict()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - minSize + <span class="number">1</span>):</span><br><span class="line">            length = minSize</span><br><span class="line">            <span class="keyword">while</span> i + length &lt;= n <span class="keyword">and</span> length &lt;= maxSize:</span><br><span class="line">                t = s[i:i + length]</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">                    <span class="keyword">if</span> len(letters) &gt; maxLetters:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    letters.add(c)</span><br><span class="line">                <span class="keyword">if</span> len(letters) &lt;= maxLetters:</span><br><span class="line">                    cnts[t] = cnts.get(t, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    res = max(res, cnts[t])</span><br><span class="line">                letters.clear()</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>上述代码会超时。我们来利用剪枝来优化。</p><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>还是暴力法的思路，不过我们在此基础上进行一些优化。首先我们需要仔细阅读题目，如果你足够细心或者足够有经验，可能会发现其实题目中 maxSize 没有任何用处，属于干扰信息。</p><p>也就是说我们没有必要统计<code>长度大于等于 minSize 且小于等于 maxSize 的所有子串</code>，而是统计长度为 minSize 的所有字串即可。原因是，如果一个大于 minSize 长度的字串若是满足条件，那么该子串其中必定有至少一个长度为 minSize 的字串满足条件。因此一个大于 minSize 长度的字串出现了 n 次，那么该子串其中必定有一个长度为 minSize 的子串出现了 n 次。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3，Java：</p><p>Python Code：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">maxFreq</span><span class="params">(self, s: str, maxLetters: int, minSize: int, maxSize: int)</span> -&gt; int:</span></span><br><span class="line">        counter, res = &#123;&#125;, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s) - minSize + <span class="number">1</span>):</span><br><span class="line">            sub = s[i : i + minSize]</span><br><span class="line">            <span class="keyword">if</span> len(set(sub)) &lt;= maxLetters:</span><br><span class="line">                counter[sub] = counter.get(sub, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                res = max(res, counter[sub])</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure><p>Java Code：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxFreq</span><span class="params">(String s, <span class="keyword">int</span> maxLetters, <span class="keyword">int</span> minSize, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; counter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - minSize + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        String substr = s.substring(i, i + minSize);</span><br><span class="line">        <span class="keyword">if</span> (checkNum(substr, maxLetters)) &#123;</span><br><span class="line">            <span class="keyword">int</span> newVal = counter.getOrDefault(substr, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            counter.put(substr, newVal);</span><br><span class="line">            res = Math.max(res, newVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkNum</span><span class="params">(String substr, <span class="keyword">int</span> maxLetters)</span> </span>&#123;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; substr.length(); i++)</span><br><span class="line">        set.add(substr.charAt(i));</span><br><span class="line">    <span class="keyword">return</span> set.size() &lt;= maxLetters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>滑动窗口</li><li>识别题目干扰信息</li><li>看题目限制条件，对于本题有用的信息是<code>1 &lt;= maxLetters &lt;= 26</code></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>我们也可以使用滑动窗口来解决，感兴趣的可以试试看。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 陷阱题 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>掌握前缀表达式真的可以为所欲为！</title>
      <link href="/blog/2020/01/09/1310.xor-queries-of-a-subarray/"/>
      <url>/blog/2020/01/09/1310.xor-queries-of-a-subarray/</url>
      
        <content type="html"><![CDATA[<p>前缀表达式是一种非常常见和重要的知识点，如果你还不知道，那就赶紧点进来看看吧！</p><a id="more"></a><h1 id="题目地址（1310-子数组异或查询）"><a href="#题目地址（1310-子数组异或查询）" class="headerlink" title="题目地址（1310. 子数组异或查询）"></a>题目地址（1310. 子数组异或查询）</h1><p><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xor-queries-of-a-subarray</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。</span><br><span class="line"></span><br><span class="line">对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。</span><br><span class="line"></span><br><span class="line">并返回一个包含给定查询 queries 所有结果的数组。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]</span><br><span class="line">输出：[2,7,14,8]</span><br><span class="line">解释：</span><br><span class="line">数组中元素的二进制表示形式是：</span><br><span class="line">1 = 0001</span><br><span class="line">3 = 0011</span><br><span class="line">4 = 0100</span><br><span class="line">8 = 1000</span><br><span class="line">查询的 XOR 值为：</span><br><span class="line">[0,1] = 1 xor 3 = 2</span><br><span class="line">[1,2] = 3 xor 4 = 7</span><br><span class="line">[0,3] = 1 xor 3 xor 4 xor 8 = 14</span><br><span class="line">[3,3] = 8</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]</span><br><span class="line">输出：[8,0,4,4]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= arr.length &lt;= 3 * 10^4</span><br><span class="line">1 &lt;= arr[i] &lt;= 10^9</span><br><span class="line">1 &lt;= queries.length &lt;= 3 * 10^4</span><br><span class="line">queries[i].length == 2</span><br><span class="line">0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length</span><br></pre></td></tr></table></figure><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最直观的思路是双层循环即可，果不其然超时了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xorQueries</span><span class="params">(self, arr: List[int], queries: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line"> res = []</span><br><span class="line">        <span class="keyword">for</span> (L, R) <span class="keyword">in</span> queries:</span><br><span class="line">            i = L</span><br><span class="line">            xor = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= R:</span><br><span class="line">                xor ^= arr[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            res.append(xor)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>比较常见的是前缀和，这个概念其实很容易理解，即一个数组中，第 n 位存储的是数组前 n 个数字的和。</p><p>对 [1,2,3,4,5,6] 来说，其前缀和可以是 pre=[1,3,6,10,15,21]。我们可以使用公式 pre[𝑖]=pre[𝑖−1]+nums[𝑖]得到每一位前缀和的值，从而通过前缀和进行相应的计算和解题。其实前缀和的概念很简单，但困难的是如何在题目中使用前缀和以及如何使用前缀和的关系来进行解题。</p><p>这道题是前缀对前缀异或，我们利用了异或的性质 <code>x ^ y ^ x = y</code>。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqll5r048j30fm0bfglz.jpg" alt></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3，Java，C++：</p><p>Python Code：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @lc app=leetcode.cn id=1218 lang=python3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [1218] 最长定差子序列</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=start</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xorQueries</span><span class="params">(self, arr: List[int], queries: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">pre = [<span class="number">0</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            pre.append(pre[i] ^ arr[i])</span><br><span class="line">        <span class="keyword">for</span> (L, R) <span class="keyword">in</span> queries:</span><br><span class="line">            res.append(pre[L] ^ pre[R + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure><p>Java Code：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] xorQueries(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span>[] preXor = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">      preXor[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)</span><br><span class="line">          preXor[i] = preXor[i - <span class="number">1</span>] ^ arr[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[queries.length];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> left = queries[i][<span class="number">0</span>], right = queries[i][<span class="number">1</span>];</span><br><span class="line">          res[i] = arr[right] ^ preXor[right] ^ preXor[left];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>C++ Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xorQueries(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            arr[i]^=arr[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp :queries)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                res.push_back(arr[temp[<span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(arr[temp[<span class="number">0</span>]<span class="number">-1</span>]^arr[temp[<span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>异或的性质 x ^ y ^ x = y</li><li>前缀表达式</li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaql7eqyg6j30u00ft0vx.jpg" alt></p><ul><li><a href="https://lucifer.ren/blog/2019/12/11/leetcode-1186/">1186.删除一次得到子数组最大和</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 前缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构快速盘点</title>
      <link href="/blog/2020/01/03/basic-data-structure/"/>
      <url>/blog/2020/01/03/basic-data-structure/</url>
      
        <content type="html"><![CDATA[<p>这篇文章不是讲解数据结构的文章，而是结合现实的场景帮助大家<code>理解和复习</code>数据结构与算法，<br>如果你的数据结构基础很差，建议先去看一些基础教程，再转过来看。</p><p>本篇文章的定位是侧重于前端的，通过学习前端中实际场景的数据结构，从而加深大家对数据结构的理解和认识。</p><a id="more"></a><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><p>数据结构我们可以从逻辑上分为线性结构和非线性结构。线性结构有<br>数组，栈，链表等， 非线性结构有树，图等。</p><blockquote><p>其实我们可以称树为一种半线性结构。</p></blockquote><p>需要注意的是，线性和非线性不代表存储结构是线性的还是非线性的，这两者没有任何关系，它只是一种逻辑上的划分。<br>比如我们可以用数组去存储二叉树。</p><p>一般而言，有前驱和后继的就是线性数据结构。比如数组和链表。其实一叉树就是链表。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是最简单的数据结构了，很多地方都用到它。 比如有一个数据列表等，用它是再合适不过了。<br>其实后面的数据结构很多都有数组的影子。</p><p>我们之后要讲的栈和队列其实都可以看成是一种<code>受限</code>的数组, 怎么个受限法呢？我们后面讨论。</p><p>我们来讲几个有趣的例子来加深大家对数组这种数据结构的理解。</p><h4 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h4><p>Hooks 的本质就是一个数组， 伪代码：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji13k55rj30m80bsq3j.jpg" alt></p><p>那么为什么 hooks 要用数组？ 我们可以换个角度来解释，如果不用数组会怎么样？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. Use the name state variable</span></span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">"Mary"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. Use an effect for persisting the form</span></span><br><span class="line">  useEffect(<span class="function"><span class="keyword">function</span> <span class="title">persistForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    localStorage.setItem(<span class="string">"formData"</span>, name);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. Use the surname state variable</span></span><br><span class="line">  <span class="keyword">const</span> [surname, setSurname] = useState(<span class="string">"Poppins"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. Use an effect for updating the title</span></span><br><span class="line">  useEffect(<span class="function"><span class="keyword">function</span> <span class="title">updateTitle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = name + <span class="string">" "</span> + surname;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于数组的方式，Form 的 hooks 就是 [hook1, hook2, hook3, hook4],<br>我们可以得出这样的关系， hook1 就是[name, setName] 这一对，<br>hook2 就是 persistForm 这个。</p><p>如果不用数组实现，比如对象，Form 的 hooks 就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'key1'</span>: hook1,</span><br><span class="line">  <span class="string">'key2'</span>: hook2,</span><br><span class="line">  <span class="string">'key3'</span>: hook3,</span><br><span class="line">  <span class="string">'key4'</span>: hook4,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题是 key1，key2，key3，key4 怎么取呢？</p><p>关于 React hooks 的本质研究，更多请查看<a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a></p><p>React 将<code>如何确保组件内部hooks保存的状态之间的对应关系</code>这个工作交给了<br>开发人员去保证，即你必须保证 HOOKS 的顺序严格一致，具体可以看 React 官网关于 Hooks Rule 部分。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种受限的序列，它只能够操作队尾和队首，并且只能只能在队尾添加元素，在队首删除元素。</p><p>队列作为一种最常见的数据结构同样有着非常广泛的应用， 比如消息队列</p><blockquote><p>“队列”这个名称,可类比为现实生活中排队（不插队的那种）</p></blockquote><p>在计算机科学中, 一个 队列(queue) 是一种特殊类型的抽象数据类型或集合。集合中的实体按顺序保存。</p><p>队列基本操作有两种:</p><ul><li>向队列的后端位置添加实体，称为入队</li><li>从队列的前端位置移除实体，称为出队。</li></ul><p>队列中元素先进先出 FIFO (first in, first out)的示意：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji2c8g4uj30b107lmxa.jpg" alt></p><p>(图片来自 <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/queue/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/queue/README.zh-CN.md</a>)</p><p>我们前端在做性能优化的时候，很多时候会提到的一点就是“HTTP 1.1 的队头阻塞问题”，具体来说<br>就是 HTTP2 解决了 HTTP1.1 中的队头阻塞问题，但是为什么 HTTP1.1 有队头阻塞问题，HTTP2 究竟怎么解决的很多人都不清楚。</p><p>其实“队头阻塞”是一个专有名词，不仅仅这里有，交换器等其他都有这个问题，引起这个问题的根本原因是使用了<code>队列</code>这种数据结构。</p><p>对于同一个 tcp 连接，所有的 http1.0 请求放入队列中，只有前一个<code>请求的响应</code>收到了，然后才能发送下一个请求，这个阻塞主要发生在客户端。</p><p>这就好像我们在等红绿灯，即使旁边绿灯亮了，你的这个车道是红灯，你还是不能走，还是要等着。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji2whipnj30gf0e2dgm.jpg" alt></p><p><code>HTTP/1.0</code> 和 <code>HTTP/1.1</code>:<br>在<code>HTTP/1.0</code> 中每一次请求都需要建立一个 TCP 连接，请求结束后立即断开连接。<br>在<code>HTTP/1.1</code> 中，每一个连接都默认是长连接(persistent connection)。对于同一个 tcp 连接，允许一次发送多个 http1.1 请求，也就是说，不必等前一个响应收到，就可以发送下一个请求。这样就解决了 http1.0 的客户端的队头阻塞，而这也就是<code>HTTP/1.1</code>中<code>管道(Pipeline)</code>的概念了。<br>但是，<code>http1.1规定，服务器端的响应的发送要根据请求被接收的顺序排队</code>，也就是说，先接收到的请求的响应也要先发送。这样造成的问题是，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送。也会造成队头阻塞。<br>可见，http1.1 的队首阻塞发生在服务器端。</p><p>如果用图来表示的话，过程大概是：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji30r665j31210d83zr.jpg" alt></p><p><code>HTTP/2</code> 和 <code>HTTP/1.1</code>:</p><p>为了解决<code>HTTP/1.1</code>中的服务端队首阻塞，<code>HTTP/2</code>采用了<code>二进制分帧</code> 和 <code>多路复用</code> 等方法。<br><code>二进制分帧</code>中，帧是<code>HTTP/2</code>数据通信的最小单位。在<code>HTTP/1.1</code>数据包是文本格式，而<code>HTTP/2</code>的数据包是二进制格式的，也就是二进制帧。采用帧可以将请求和响应的数据分割得更小，且二进制协议可以更高效解析。<code>HTTP/2</code>中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。<br><code>多路复用</code>用以替代原来的序列和拥塞机制。在<code>HTTP/1.1</code>中，并发多个请求需要多个 TCP 链接，且单个域名有 6-8 个 TCP 链接请求限制。在<code>HHTP/2</code>中，同一域名下的所有通信在单个链接完成，仅占用一个 TCP 链接，且在这一个链接上可以并行请求和响应，互不干扰。</p><blockquote><p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">此网站</a>可以直观感受<code>HTTP/1.1</code>和<code>HTTP/2</code>的性能对比。</p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈也是一种受限的序列，它只能够操作栈顶，不管入栈还是出栈，都是在栈顶操作。</p><p>在计算机科学中, 一个 栈(stack) 是一种抽象数据类型,用作表示元素的集合,具有两种主要操作:</p><p>push, 添加元素到栈的顶端(末尾);<br>pop, 移除栈最顶端(末尾)的元素.<br>以上两种操作可以简单概括为“后进先出(LIFO = last in, first out)”。</p><p>此外,应有一个 peek 操作用于访问栈当前顶端(末尾)的元素。（只返回不弹出）</p><blockquote><p>“栈”这个名称,可类比于一组物体的堆叠(一摞书,一摞盘子之类的)。</p></blockquote><p>栈的 push 和 pop 操作的示意:</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji3d1m8oj30lh0f074v.jpg" alt></p><p>(图片来自 <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/stack/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/stack/README.zh-CN.md</a>)</p><p>栈在很多地方都有着应用，比如大家熟悉的浏览器就有很多栈，其实浏览器的执行栈就是一个基本的栈结构，从数据结构上说，它就是一个栈。<br>这也就解释了，我们用递归的解法和用循环+栈的解法本质上是差不多。</p><p>比如如下 JS 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>真正执行的时候，内部大概是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji3jo8ozj30v70hi0u8.jpg" alt></p><blockquote><p>我画的图没有画出执行上下文中其他部分（this 和 scope 等）， 这部分是闭包的关键，而我这里不是将闭包的，是为了讲解栈的。</p></blockquote><blockquote><p>社区中有很多“执行上下文中的 scope 指的是执行栈中父级声明的变量”说法，这是完全错误的， JS 是词法作用域，scope 指的是函数定义时候的父级，和执行没关系</p></blockquote><p>栈常见的应用有进制转换，括号匹配，栈混洗，中缀表达式（用的很少），后缀表达式（逆波兰表达式）等。</p><blockquote><p>合法的栈混洗操作，其实和合法的括号匹配表达式之间存在着一一对应的关系，<br>也就是说 n 个元素的栈混洗有多少种，n 对括号的合法表达式就有多少种。感兴趣的可以查找相关资料</p></blockquote><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种最基本数据结构，熟练掌握链表的结构和常见操作是基础中的基础。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji3xxu0kj30bm01lglg.jpg" alt></p><p>(图片来自： <a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/linked-list/traversal" target="_blank" rel="noopener">https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/linked-list/traversal</a>)</p><h4 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h4><p>很多人都说 fiber 是基于链表实现的，但是为什么要基于链表呢，可能很多人并没有答案，那么我觉得可以把这两个点（fiber 和链表）放到一起来讲下。</p><p>fiber 出现的目的其实是为了解决 react 在执行的时候是无法停下来的，需要一口气执行完的问题的。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji494wa9j30rc0c0wez.jpg" alt></p><p>图片来自 Lin Clark 在 ReactConf 2017 分享</p><p>上面已经指出了引入 fiber 之前的问题，就是 react 会阻止优先级高的代码（比如用户输入）执行。因此 fiber<br>打算自己自建一个<code>虚拟执行栈</code>来解决这个问题，这个虚拟执行栈的实现是链表。</p><p>Fiber 的基本原理是将协调过程分成小块，一次执行一块，然乎将运算结果保存起来，并判断是否有时间（react 自己实现了一个类似 requestIdleCallback 的功能）继续执行下一块。<br>如果有时间，则继续。 否则跳出，让浏览器主线程歇一会，执行别的优先级高的代码。</p><p>当协调过程完成（所有的小块都运算完毕）， 那么就会进入提交阶段， 真正的进行副作用（side effect）操作，比如更新 DOM，这个过程是没有办法取消的，原因就是这部分有副作用。</p><p>问题的关键就是将协调的过程划分为一块块的，最后还可以合并到一起，有点像 Map／Reduce。</p><p>React 必须重新实现遍历树的算法，从依赖于<code>内置堆栈的同步递归模型</code>，变为<code>具有链表和指针的异步模型</code>。</p><blockquote><p>Andrew 是这么说的： 如果你只依赖于[内置]调用堆栈，它将继续工作直到堆栈为空。。。</p></blockquote><p>如果我们可以随意中断调用堆栈并手动操作堆栈帧，那不是很好吗？<br>这就是 React Fiber 的目的。 <code>Fiber 是堆栈的重新实现，专门用于 React 组件</code>。 你可以将单个 Fiber 视为一个<code>虚拟堆栈帧</code>。</p><p>react fiber 大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fiber = &#123;</span><br><span class="line">  tag: HOST_COMPONENT,</span><br><span class="line">  type: <span class="string">"div"</span>,</span><br><span class="line">  <span class="keyword">return</span>: parentFiber,</span><br><span class="line">  children: childFiber,</span><br><span class="line">  sibling: childFiber,</span><br><span class="line">  alternate: currentFiber,</span><br><span class="line">  stateNode: <span class="built_in">document</span>.createElement(<span class="string">"div"</span>),</span><br><span class="line">  props: &#123; <span class="attr">children</span>: [], <span class="attr">className</span>: <span class="string">"foo"</span> &#125;,</span><br><span class="line">  partialState: <span class="literal">null</span>,</span><br><span class="line">  effectTag: PLACEMENT,</span><br><span class="line">  effects: []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从这里可以看出 fiber 本质上是个对象，使用 parent，child，sibling 属性去构建 fiber 树来表示组件的结构树，<br>return, children, sibling 也都是一个 fiber，因此 fiber 看起来就是一个链表。</p><blockquote><p>细心的朋友可能已经发现了， alternate 也是一个 fiber， 那么它是用来做什么的呢？<br>它其实原理有点像 git， 可以用来执行 git revert ,git commit 等操作，这部分挺有意思，我会在我的《从零开发 git》中讲解</p></blockquote><p>想要了解更多的朋友可以看<a href="https://github.com/dawn-plex/translate/blob/master/articles/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree.md" target="_blank" rel="noopener">这个文章</a></p><p>如果可以翻墙， 可以看<a href="https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">英文原文</a></p><p><a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec" target="_blank" rel="noopener">这篇文章</a>也是早期讲述 fiber 架构的优秀文章</p><p>我目前也在写关于《从零开发 react 系列教程》中关于 fiber 架构的部分，如果你对具体实现感兴趣，欢迎关注。</p><h2 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h2><p>那么有了线性结构，我们为什么还需要非线性结构呢？ 答案是为了高效地兼顾静态操作和动态操作。大家可以对照各种数据结构的各种操作的复杂度来直观感受一下。</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树的应用同样非常广泛，小到文件系统，大到因特网，组织架构等都可以表示为树结构，而在我们前端眼中比较熟悉的 DOM 树也是一种树结构，而 HTML 作为一种 DSL 去描述这种树结构的具体表现形式。如果你接触过 AST，那么 AST 也是一种树，XML 也是树结构。。。树的应用远比大多数人想象的要得多。</p><p>树其实是一种特殊的<code>图</code>，是一种无环连通图，是一种极大无环图，也是一种极小连通图。</p><p>从另一个角度看，树是一种递归的数据结构。而且树的不同表示方法，比如不常用的<code>长子 + 兄弟</code>法，对于<br>你理解树这种数据结构有着很大用处， 说是一种对树的本质的更深刻的理解也不为过。</p><p>树的基本算法有前中后序遍历和层次遍历，有的同学对前中后这三个分别具体表现的访问顺序比较模糊，其实当初我也是一样的，后面我学到了一点，你只需要记住：<code>所谓的前中后指的是根节点的位置，其他位置按照先左后右排列即可</code>。比如前序遍历就是<code>根左右</code>, 中序就是<code>左根右</code>，后序就是<code>左右根</code>， 很简单吧？</p><p>我刚才提到了树是一种递归的数据结构，因此树的遍历算法使用递归去完成非常简单，幸运的是树的算法基本上都要依赖于树的遍历。 但是递归在计算机中的性能一直都有问题，因此掌握不那么容易理解的”命令式地迭代”遍历算法在某些情况下是有用的。如果你使用迭代式方式去遍历的话，可以借助上面提到的<code>栈</code>来进行，可以极大减少代码量。</p><blockquote><p>如果使用栈来简化运算，由于栈是 FILO 的，因此一定要注意左右子树的推入顺序。</p></blockquote><p>树的重要性质：</p><ul><li>如果树有 n 个顶点，那么其就有 n - 1 条边，这说明了树的顶点数和边数是同阶的。</li><li>任何一个节点到根节点存在<code>唯一</code>路径, 路径的长度为节点所处的深度</li></ul><p>实际使用的树有可能会更复杂，比如使用在游戏中的碰撞检测可能会用到四叉树或者八叉树。以及 k 维的树结构 <code>k-d 树</code>等。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gajhqov8pjj306y06mweo.jpg" alt><br>（图片来自 <a href="https://zh.wikipedia.org/wiki/K-d%E6%A0%91）" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/K-d%E6%A0%91）</a></p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树是节点度数不超过二的树，是树的一种特殊子集，有趣的是二叉树这种被限制的树结构却能够表示和实现所有的树，<br>它背后的原理正是<code>长子 + 兄弟</code>法，用邓老师的话说就是<code>二叉树是多叉树的特例，但在有根且有序时，其描述能力却足以覆盖后者</code>。</p><blockquote><p>实际上， 在你使用<code>长子 + 兄弟</code>法表示树的同时，进行 45 度角旋转即可。</p></blockquote><p>一个典型的二叉树：</p><p>标记为 7 的节点具有两个子节点, 标记为 2 和 6; 一个父节点,标记为 2,作为根节点, 在顶部,没有父节点。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaji4vav1hj308m07baa6.jpg" alt></p><p>(图片来自 <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/README.zh-CN.md</a>)</p><p>对于一般的树，我们通常会去遍历，这里又会有很多变种。</p><p>下面我列举一些二叉树遍历的相关算法:</p><ul><li><a href="../problems/94.binary-tree-inorder-traversal.md">94.binary-tree-inorder-traversal</a></li><li><a href="../problems/102.binary-tree-level-order-traversal.md">102.binary-tree-level-order-traversal</a></li><li><a href="../problems/103.binary-tree-zigzag-level-order-traversal.md">103.binary-tree-zigzag-level-order-traversal</a></li><li><a href="../problems/144.binary-tree-preorder-traversal.md">144.binary-tree-preorder-traversal</a></li><li><a href="../problems/145.binary-tree-postorder-traversal.md">145.binary-tree-postorder-traversal</a></li><li><a href="../problems/199.binary-tree-right-side-view.md">199.binary-tree-right-side-view</a></li></ul><p>相关概念：</p><ul><li>真二叉树 （所有节点的度数只能是偶数，即只能为 0 或者 2）</li></ul><p>另外我也专门开设了<a href="./binary-tree-traversal.md">二叉树的遍历</a>章节, 具体细节和算法可以去那里查看。</p><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆其实是一种优先级队列，在很多语言都有对应的内置数据结构，很遗憾 javascript 没有这种原生的数据结构。<br>不过这对我们理解和运用不会有影响。</p><p>堆的特点：</p><ul><li>在一个 最小堆(min heap) 中, 如果 P 是 C 的一个父级节点, 那么 P 的 key(或 value)应小于或等于 C 的对应值.<br>正因为此，堆顶元素一定是最小的，我们会利用这个特点求最小值或者第 k 小的值。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji593urzj30ca07yjro.jpg" alt></p><ul><li>在一个 最大堆(max heap) 中, P 的 key(或 value)大于 C 的对应值。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaji5rurzpj30ct0abgm4.jpg" alt></p><p>需要注意的是优先队列不仅有堆一种，还有更复杂的，但是通常来说，我们会把两者做等价。</p><p>相关算法：</p><ul><li><a href="../problems/295.find-median-from-data-stream.md">295.find-median-from-data-stream</a></li></ul><h5 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h5><p>二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</p><p>二叉查找树具有下列性质的二叉树：</p><ul><li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点。</li></ul><p>对于一个二叉查找树，常规操作有插入，查找，删除，找父节点，求最大值，求最小值。</p><p>二叉查找树，之所以叫查找树就是因为其非常适合查找，举个例子，<br>如下一颗二叉查找树，我们想找节点值小于且最接近 58 的节点，搜索的流程如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji6etgvwj30rs0mudhi.jpg" alt><br>（图片来自 <a href="https://www.geeksforgeeks.org/floor-in-binary-search-tree-bst/）" target="_blank" rel="noopener">https://www.geeksforgeeks.org/floor-in-binary-search-tree-bst/）</a></p><p>另外我们二叉查找树有一个性质是： <code>其中序遍历的结果是一个有序数组</code>。<br>有时候我们可以利用到这个性质。</p><p>相关题目：</p><ul><li><a href="../problems/98.validate-binary-search-tree.md">98.validate-binary-search-tree</a></li></ul><h5 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h5><p>平衡树是计算机科学中的一类数据结构，为改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了平衡树。</p><p>在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。</p><p>一些数据库引擎内部就是用的这种数据结构，其目标也是将查询的操作降低到 logn（树的深度），可以简单理解为<code>树在数据结构层面构造了二分查找算法</code>。</p><p>基本操作：</p><ul><li><p>旋转</p></li><li><p>插入</p></li><li><p>删除</p></li><li><p>查询前驱</p></li><li><p>查询后继</p></li></ul><h6 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h6><p>是最早被发明的自平衡二叉查找树。在 AVL 树中，任一节点对应的两棵子树的最大高度差为 1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是 {\displaystyle O(\log {n})} O(\log{n})。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL 树得名于它的发明者 G. M. Adelson-Velsky 和 Evgenii Landis，他们在 1962 年的论文 An algorithm for the organization of information 中公开了这一数据结构。 节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子 1、0 或 -1 的节点被认为是平衡的。带有平衡因子 -2 或 2 的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p><h6 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h6><p>在 1972 年由鲁道夫·贝尔发明，被称为”对称二叉 B 树”，它现代的名字源于 Leo J. Guibas 和 Robert Sedgewick 于 1978 年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在 {\displaystyle O(\log {n})} O(\log{n})时间内完成查找，插入和删除，这里的 n 是树中元素的数目</p><h4 id="字典树-前缀树"><a href="#字典树-前缀树" class="headerlink" title="字典树(前缀树)"></a>字典树(前缀树)</h4><p>又称 Trie 树，是一种树形结构。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gajj0g78e6j30al06qwfc.jpg" alt></p><p>(图来自 <a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin</a>)<br>它有 3 个基本性质：</p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符；</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><h5 id="immutable-与-字典树"><a href="#immutable-与-字典树" class="headerlink" title="immutable 与 字典树"></a>immutable 与 字典树</h5><p><code>immutableJS</code>的底层就是<code>share + tree</code>. 这样看的话，其实和字典树是一致的。</p><p>相关算法：</p><ul><li><a href="../problems/208.implement-trie-prefix-tree.md">208.implement-trie-prefix-tree</a></li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>前面讲的数据结构都可以看成是图的特例。 前面提到了二叉树完全可以实现其他树结构，<br>其实有向图也完全可以实现无向图和混合图，因此有向图的研究一直是重点考察对象。</p><p>图论〔Graph Theory〕是数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。</p><h4 id="图的表示方法"><a href="#图的表示方法" class="headerlink" title="图的表示方法"></a>图的表示方法</h4><ul><li>邻接矩阵(常见)</li></ul><p>空间复杂度 O(n^2),n 为顶点个数。</p><p>优点：</p><ol><li><p>直观，简单。</p></li><li><p>适用于稠密图</p></li><li><p>判断两个顶点是否连接，获取入度和出度以及更新度数，时间复杂度都是 O(1)</p></li></ol><ul><li>关联矩阵</li><li>邻接表</li></ul><p>对于每个点，存储着一个链表，用来指向所有与该点直接相连的点<br>对于有权图来说，链表中元素值对应着权重</p><p>例如在无向无权图中：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaji793gchj30k00akq48.jpg" alt><br>（图片来自 <a href="https://zhuanlan.zhihu.com/p/25498681）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25498681）</a></p><p>可以看出在无向图中，邻接矩阵关于对角线对称，而邻接链表总有两条对称的边<br>而在有向无权图中：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaji7giyerj30k00aq0ux.jpg" alt></p><p>（图片来自 <a href="https://zhuanlan.zhihu.com/p/25498681）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25498681）</a></p><h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><p>图的遍历就是要找出图中所有的点，一般有以下两种方法：</p><ol><li>深度优先遍历：(Depth First Search, DFS)</li></ol><p>深度优先遍历图的方法是，从图中某顶点 v 出发， 不断访问邻居， 邻居的邻居直到访问完毕。</p><ol start="2"><li>广度优先搜索：(Breadth First Search, BFS)</li></ol><p>广度优先搜索，可以被形象地描述为 “浅尝辄止”，它也需要一个队列以保持遍历过的顶点顺序，以便按出队的顺序再去访问这些顶点的邻接顶点。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一荐 2019-12 汇总</title>
      <link href="/blog/2020/01/01/daily-featured-2019-12/"/>
      <url>/blog/2020/01/01/daily-featured-2019-12/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8d0sktqrwj30hs07maae.jpg" alt></p><p>每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。</p><p>项目主页维护当前月份的内容，想看往期内容，可以去<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">每日一荐主仓库</a>翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。</p><a id="more"></a><h2 id="2019-12"><a href="#2019-12" class="headerlink" title="2019-12"></a>2019-12</h2><h3 id="2019-12-31-见闻"><a href="#2019-12-31-见闻" class="headerlink" title="2019-12-31[见闻]"></a>2019-12-31[见闻]</h3><p>今天是我的生日，祝我生日快乐 🎂 ～～～～</p><p>一般公司的卫生间贴的都是公司信息或心灵鸡汤，但是谷歌卫生间贴的是<code>如何找到代码 Bug</code>，不得不感叹“这实在是太硬核了”！</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gab8f97lcej30ci0m8dhh.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gab8ffahw3j30ek0hlmyg.jpg" alt></p><h3 id="2019-12-24-技巧"><a href="#2019-12-24-技巧" class="headerlink" title="2019-12-24[技巧]"></a>2019-12-24[技巧]</h3><p>今天是平安夜，苹果 🍎 和圣诞礼物 🎁 都收到了么？</p><p>今天给大家推荐的是一个 linux 中非常常见的命令 <code>grep</code> 的常用用法。</p><p>图版本：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga81dnom82j30xc0l0afr.jpg" alt></p><p>文字版本：</p><p>Matches patterns in input text.Supports simple patterns and regular expressions.</p><ul><li><p>Search for an exact string:<br>grep search_string path/to/file</p></li><li><p>Search in case-insensitive mode:<br>grep -i search_string path/to/file</p></li><li><p>Search recursively (ignoring non-text files) in current directory for an exact string:<br>grep -RI search_string .</p></li><li><p>Use extended regular expressions (supporting ?, +, {}, () and |):<br>grep -E ^regex$ path/to/file</p></li><li><p>Print 3 lines of [C]ontext around, [B]efore, or [A]fter each match:<br>grep -C|B|A 3 search_string path/to/file</p></li><li><p>Print file name with the corresponding line number for each match:<br>grep -Hn search_string path/to/file</p></li><li><p>Use the standard input instead of a file:<br>cat path/to/file | grep search_string</p></li><li><p>Invert match for excluding specific strings:<br>grep -v search_string</p></li></ul><h3 id="2019-12-23-学习方法"><a href="#2019-12-23-学习方法" class="headerlink" title="2019-12-23[学习方法]"></a>2019-12-23[学习方法]</h3><p>很多人问我如何保持高效率。 首先要说的是我的效率并不是很高，这也就是我为什么还在不断学习提高效率的原因之一。那么既然有人问了我就班门弄斧回答一下，大家有什么好的方法和技巧欢迎提出来交流。</p><p>为了让自己保持高效率，我自己开了一个仓库记录了自己保持“高效率”的方式。希望可以给大家启发，本仓库内容持续更新～</p><p>仓库大纲：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6fqk9vrpj30ar09tgmp.jpg" alt></p><p>仓库截图：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6fr6o5gkj30fz0qm77n.jpg" alt></p><p>仓库地址：<a href="https://github.com/azl397985856/To-Be-Productive" target="_blank" rel="noopener">https://github.com/azl397985856/To-Be-Productive</a></p><h3 id="2019-12-20-新闻"><a href="#2019-12-20-新闻" class="headerlink" title="2019-12-20[新闻]"></a>2019-12-20[新闻]</h3><p>Facebook 发布 Hermes， 一个新的专门用于 React Native 的 JS 引擎。</p><p>文章地址：<a href="https://facebook.github.io/react-native/blog/2019/07/17/hermes" target="_blank" rel="noopener">https://facebook.github.io/react-native/blog/2019/07/17/hermes</a></p><h3 id="2019-12-19-好文"><a href="#2019-12-19-好文" class="headerlink" title="2019-12-19[好文]"></a>2019-12-19[好文]</h3><p>很多高级语言有自动的垃圾回收器，比如 JS，JAVA，Go 等。其会自动地进行垃圾回收工作，而不必像诸如 C 和 C++那样手动分配和清除内存。</p><p>对于 old space 的垃圾回收算法有一个是标记清除，从一个根对象开始对于所有可达的对象进行标记，剩下的就是不可达的，我们将其进行清除，本文讲解了三色标记法（黑色，白色和灰色），三色标记法本质上进行一次 DFS，并将内存对象分到三个部分，DFS 完成之后清除不可达的内存（白色）。这篇文章以动画形式讲解了三色标记法的具体过程。</p><p>文章（《一张图了解三色标记法》）地址：<a href="http://idiotsky.top/2017/08/16/gc-three-color/" target="_blank" rel="noopener">http://idiotsky.top/2017/08/16/gc-three-color/</a></p><h3 id="2019-12-18-教程"><a href="#2019-12-18-教程" class="headerlink" title="2019-12-18[教程]"></a>2019-12-18[教程]</h3><p>哈弗大学 CS50 系列，内容持续更新，现在最新的是 2019 年。 你可以跟着教程来重新学习 CS 基础。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9zz364qkfj308d0c2dgk.jpg" alt></p><p>地址：<a href="https://cs50.harvard.edu/college/" target="_blank" rel="noopener">https://cs50.harvard.edu/college/</a></p><h3 id="2019-12-17-网站"><a href="#2019-12-17-网站" class="headerlink" title="2019-12-17[网站]"></a>2019-12-17[网站]</h3><p>Learn Git Branching 是一个交互式学习 Git 的网站。沙盒里你能执行相应的命令，还能看到每个命令的执行情况； 通过一系列刺激的关卡挑战，逐步深入的学习 Git 的强大功能，在这个过程中你可能还会发现一些有意思的事情。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9yvse4btrj30z80hhjua.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9yvtbimcaj30zf0ppq51.jpg" alt></p><p>地址： <a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a></p><h3 id="2019-12-16-新闻"><a href="#2019-12-16-新闻" class="headerlink" title="2019-12-16[新闻]"></a>2019-12-16[新闻]</h3><p>最新版本的 Chrome 和 Firefo 浏览器取消 EV 证书的显示。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ybrc3mf7j30mp09a0ty.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ybrl2cyuj30mp09agmz.jpg" alt></p><p>只有用户点击了锁 🔒，才会显示出 EV 证书的信息。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ybutylm2j30ep0ant9k.jpg" alt></p><p>为什么会这样？想要知道答案的可以点击原文阅读。</p><p>原文地址：<a href="https://www.bleepingcomputer.com/news/software/chrome-and-firefox-changes-spark-the-end-of-ev-certificates/" target="_blank" rel="noopener">Chrome and Firefox Changes Spark the End of EV Certificates</a></p><h3 id="2019-12-13-类库"><a href="#2019-12-13-类库" class="headerlink" title="2019-12-13[类库]"></a>2019-12-13[类库]</h3><p>loki 是一个 React Storybook 组件回归测试工具。React Storybook 是一个我 15 年就开始关注的一个工具，本身的设计思想我比较喜欢。现在除了支持 React，也支持 React Native，Vue，Angular 等，甚至最新的 Svelte 也支持。</p><p>loki Github 地址： <a href="https://github.com/oblador/loki" target="_blank" rel="noopener">https://github.com/oblador/loki</a></p><h3 id="2019-12-12-技巧"><a href="#2019-12-12-技巧" class="headerlink" title="2019-12-12[技巧]"></a>2019-12-12[技巧]</h3><p>Angular 的 Commit Message Conventions 是一套很流行的 Commit Message 规约。简单方便，一目了然，更重要的是这种约定化如果形成一种默契，不管对于之后查看，还是生成各种外部资料（比如 CHNAGELOG）都是非常方便的。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9sr6iuanij30hs0rhacw.jpg" alt></p><p>详细信息： <a href="https://gist.github.com/stephenparish/9941e89d80e2bc58a153" target="_blank" rel="noopener">https://gist.github.com/stephenparish/9941e89d80e2bc58a153</a></p><p>相关工具也有很多，我个人使用的是<a href="https://github.com/commitizen?type=source" title="Commitizen" target="_blank" rel="noopener">Commitizen</a></p><h3 id="2019-12-11-好文"><a href="#2019-12-11-好文" class="headerlink" title="2019-12-11[好文]"></a>2019-12-11[好文]</h3><p>文章标题 《花椒前端基于 WebAssembly 的 H.265 播放器研发》，本文从背景介绍，技术调研，实际方案到最后的实践效果，完整地讲述了通过 <code>wasm</code> 将 H.265 应用到不支持其的浏览器的过程。干货满满，其架构图画的也是我比较喜欢的风格。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9rmc1qkp1j30k00co0tx.jpg" alt></p><p>文章地址： <a href="https://zhuanlan.zhihu.com/p/73772711" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73772711</a></p><h3 id="2019-12-10-技巧"><a href="#2019-12-10-技巧" class="headerlink" title="2019-12-10[技巧]"></a>2019-12-10[技巧]</h3><p>我们有时候需要在终端访问一些国外的资源。我目前采取的措施主要是给终端设置 proxy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias proxy=&apos;export all_proxy=socks5://127.0.0.1:1086&apos;</span><br><span class="line">alias unproxy=&apos;unset all_proxy&apos;</span><br></pre></td></tr></table></figure><p>其中<code>socks5://127.0.0.1:1086</code>是我的本机的正向代理地址。</p><p>如下是使用效果：<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pep3a663j30nc0nek3l.jpg" alt></p><p>如图显示我们代理成功了，而且我们可以方便的在不想要代理的时候去掉代理。</p><h3 id="2019-12-09-类库"><a href="#2019-12-09-类库" class="headerlink" title="2019-12-09[类库]"></a>2019-12-09[类库]</h3><p>对于前端，我们经常需要将组件进行可视化的展示。在 Vue 中，我们通常会用 <a href="https://github.com/docsifyjs/docsify" title="docsify" target="_blank" rel="noopener">docsify</a> 或者 <a href="https://github.com/vuejs/vuepress" title="vuepress" target="_blank" rel="noopener">vuepress</a> 等。而对于 react 比较有名的有 <a href="https://github.com/storybookjs/storybook" title="storybook" target="_blank" rel="noopener">storybook</a> 和 <a href="https://github.com/doczjs/docz" title="docz" target="_blank" rel="noopener">docz</a>。</p><p>当然这并不是绝对的，比如 storybook 也在支持 vue 和 webcomponents。</p><h3 id="2019-12-06-技能"><a href="#2019-12-06-技能" class="headerlink" title="2019-12-06[技能]"></a>2019-12-06[技能]</h3><p>在分析 CPU、内存、磁盘等的性能指标时，有几种工具是高频出现的，如 top、vmstat、pidstat，这里稍微总结一下:</p><p>CPU：top、vmstat、pidstat、sar、perf、jstack、jstat；<br>内存：top、free、vmstat、cachetop、cachestat、sar、jmap；<br>磁盘：top、iostat、vmstat、pidstat、du/df；<br>网络：netstat、sar、dstat、tcpdump；<br>应用：profiler、dump 分析。<br>排查 Java 应用的线上异常或者分析应用代码瓶颈，可以使用阿里开源的 Arthas ，nodejs 应用可以使用 alinode</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9jphsv3t0j30u01b5tbj.jpg" alt></p><h3 id="2019-12-05-好文"><a href="#2019-12-05-好文" class="headerlink" title="2019-12-05[好文]"></a>2019-12-05[好文]</h3><p>如果你想做微前端，一定要能够回答出这 10 个问题。</p><ol><li>微应用的注册、异步加载和生命周期管理；</li><li>微应用之间、主从之间的消息机制；</li><li>微应用之间的安全隔离措施；</li><li>微应用的框架无关、版本无关；</li><li>微应用之间、主从之间的公共依赖的库、业务逻辑(utils)以及版本怎么管理；</li><li>微应用独立调试、和主应用联调的方式，快速定位报错（发射问题）；</li><li>微应用的发布流程；</li><li>微应用打包优化问题；</li><li>微应用专有云场景的出包方案；</li><li>渐进式升级：用微应用方案平滑重构老项目。</li></ol><p>今天推荐的这个文档，区别与别的微前端文章的点在于其更加靠近规范层面，而不是结合自己的业务场景做的探索。这篇文章来自于阿里团队。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9kuat53elj30u00lgdhe.jpg" alt></p><p>文章地址： <a href="https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw</a></p><h3 id="2019-12-04-工具"><a href="#2019-12-04-工具" class="headerlink" title="2019-12-04[工具]"></a>2019-12-04[工具]</h3><p>相信大家使用 shell 的时候，会经常碰到忘记的 option，或者某一个用法记不清楚。遇到这种问题通常我们会用 man 或者命令提供的–help 查看用法。 这里给大家介绍另外一种工具<code>tldr</code>, 它是一个将 man page 进行简化，将大家常用的用法总结出来的工具。</p><p>安全也非常简单，只需要 <code>npm install -g</code>(前提是你必须安装 node)， 如果你不想安装也没有关系，它还提供了<a href="https://tldr.ostera.io/" target="_blank" rel="noopener">web 版</a>。另外你也可以参考这里<a href="https://github.com/tldr-pages/tldr-node-client#configuration" target="_blank" rel="noopener">定制你的主题</a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9jmo8sh8jj30ic0ei3zt.jpg" alt></p><p>仓库地址： <a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">https://github.com/tldr-pages/tldr</a></p><h3 id="2019-12-03-技巧"><a href="#2019-12-03-技巧" class="headerlink" title="2019-12-03[技巧]"></a>2019-12-03[技巧]</h3><p>今天给大家介绍的是<code>Google高级搜索技巧</code>。我们经常使用搜索引擎搜索一些东西，不管是遇到问题想寻求解决方案也好，想学习一些新东西也好，掌握一定的搜索技巧是可以让你搜索的过程事半功倍，尤其是常用的技巧一定要记住。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9dy1kml11j30u02pkdsk.jpg" alt></p><h3 id="2019-12-02-软件"><a href="#2019-12-02-软件" class="headerlink" title="2019-12-02[软件]"></a>2019-12-02[软件]</h3><p>我们公司在使用的一个完全开源的堡垒机，是符合 4A 的专业运维审计系统。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9i8em5x8sj31ht0u0td1.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9i8et0f9hj31mk0u0ten.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9i8ey12vhj31i60u0taw.jpg" alt></p><p>地址： <a href="https://github.com/jumpserver/jumpserver" target="_blank" rel="noopener">https://github.com/jumpserver/jumpserver</a></p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>我重新整理了下自己的公众号，并且我还给它换了一个名字<code>脑洞前端</code>，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。</p><p>之后我的文章会同步到微信公众号 <code>脑洞前端</code> ，你可以关注获取最新的文章，并和我进行交流。</p><p>另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。</p><img width="300" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7he9xdtmyj30by0byaac.jpg"><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul><li>如果有想法和创意，请提<a href="https://github.com/azl397985856/daily-featured/issues" target="_blank" rel="noopener">issue</a>或者进群提</li><li>如果想贡献代码，请提<a href="https://github.com/azl397985856/daily-featured/pulls" target="_blank" rel="noopener">PR</a></li><li>如果需要修改项目中图片，<a href="./assets/">这里</a>存放了项目中绘制图的源代码， 大家可以用<a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a>打开进行编辑。</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="./LICENSE">Apache-2.0</a></p>]]></content>
      
      
      <categories>
          
          <category> 每日一荐 </category>
          
          <category> 2019-12 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致作者</title>
      <link href="/blog/2019/12/11/to-author/"/>
      <url>/blog/2019/12/11/to-author/</url>
      
        <content type="html"><![CDATA[<p>写给我敬爱的作者们，关于“云写书”的初衷，愿景，规划以及具体细节。</p><a id="more"></a><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>建立作者群，让大家参与进来的目的有三个。</p><ol><li>缩短写作的周期</li></ol><p>我希望这本书尽快与大家见面，毕竟时间就是金钱，一个人的力量还是很有限的，目前计划作者控制在2-10个人，参与人数不限制。</p><ol start="2"><li>结识志同道合的朋友，将来可以继续合作</li></ol><p>本来计划写别的书的，只是突然觉得LeetCode题解这块受众更大，大家普遍希望有这么一本书，因此才决定先写这本。我也希望之后写别的书的时候大家也可以在一起合作。</p><ol start="3"><li>更好地推广</li></ol><p>作者们也可以起到很好地宣传作用，毕竟是自己深度参与的书，大家宣传的意愿很会有的。</p><h2 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h2><p>背靠着 Github LeetCode排名第一的项目，再加上多个媒体平台的宣传推广，我个人觉得市场还是有的，另外市面上的多是以数据结构和算法为基础进行讲解，而不是LeetCode题解方面，这方面我认为是一个缺口。</p><p>另外我看了很多相关的资料，包括电子书，实体书以及博客，官方articles等，决定要不就是不够系统，要不就是不够通俗易懂。</p><p><code>我的受众群体是想找工作的LeetCode新手，帮助他们攻克一些高频题目，掌握解题技巧，更加有效率地刷题</code></p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><ul><li>2019-10 建立初步的成员名单，制定写作规范，联系LeetCode官方授权</li><li>2019-11 分配章节给大家，大家分别书写</li><li>2019-12 汇总大家的文章，进行审阅 &amp; 校验</li></ul><h2 id="Code-Style"><a href="#Code-Style" class="headerlink" title="Code Style"></a>Code Style</h2><p>TODO</p><h2 id="文章格式"><a href="#文章格式" class="headerlink" title="文章格式"></a>文章格式</h2><p>TODO</p><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>这个是我之前写的大纲，需要微调， 大家可以先大概看一下 <a href="https://lucifer.ren/blog/2019/10/03/draft/">https://lucifer.ren/blog/2019/10/03/draft/</a></p><h2 id="样张"><a href="#样张" class="headerlink" title="样张"></a>样张</h2><ul><li><p><a href="https://lucifer.ren/blog/2019/09/22/reverseList/">一文搞懂《链表反转》</a></p></li><li><p><a href="https://lucifer.ren/blog/2019/09/21/rotate-list/">文科生都能看懂的循环移位算法</a></p></li><li><p><a href="https://lucifer.ren/blog/2019/09/20/LSS/">一文看懂《最大子序列和问题》</a></p></li></ul><h2 id="如何参与"><a href="#如何参与" class="headerlink" title="如何参与"></a>如何参与</h2><p>要参加写作的， 给出你写过的文章，最好LeetCode或者算法相关，然后等待我审核，写文章的时候语言要求python，不会的可以花几个小时学习一下。</p><p>另外需要提供三种语言(分别是JS，Java和Python)的代码到我新建的一个<a href="https://github.com/leetcode-book/leetcode-solutions/tree/master/ch01" target="_blank" rel="noopener">仓库</a>中，专门给这本书放源码，按照语言和章节划分一下。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88ad0upwwj30ta08pwfv.jpg" alt></p><p>作者们别忘记让我拉你进组织，我们的组织是<code>https://github.com/leetcode-book</code></p><p>如果语言有什么困难，直接群里沟通，我相信语言不是问题。 另外大家写题解的时候，一定少用语言特有的东西。</p><blockquote><p>有能力的欢迎提供其他语言的代码实现</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> LeetCode题解书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用web-component搭建企业级组件库</title>
      <link href="/blog/2019/12/11/web-components-enterprize/"/>
      <url>/blog/2019/12/11/web-components-enterprize/</url>
      
        <content type="html"><![CDATA[<p>前端目前比较主流的框架有react，vuejs，angular等。 我们通常去搭建组件库的时候都是基于某一种框架去搭建，比如ant-design是基于react搭建的UI组件库，而elementUI则是基于vuejs搭建的组件库。</p><p>虽然目前社区有相关工具，提供框架之间的转化服务，比如讲vuejs组件转化为react组件。但是毕竟是不同的框架，有不同的标准。因此框架api发生变动，那么你就需要重写转化逻辑，显然是不灵活的，因此我们暂不讨论这种情况。作为公司而言，就需要为不同的框架写不同的组件库，尽管逻辑都是一样的。</p><p>另外如果框架升级，比如从1.x升级到2.x，那么对应组件库就需要升级，如果公司的组件库有很多（vuejs，react，angular等），那么这种升级的概率就会更大。</p><a id="more"></a><h2 id="什么是web-component？"><a href="#什么是web-component？" class="headerlink" title="什么是web-component？"></a>什么是web-component？</h2><p>那么有没有更好的方案，一次编写，到处使用呢？</p><p>答案就是借助web component。</p><p>Web Components 是一系列加入<code>w3c</code>的HTML和DOM的特性，使得开发者可以创建可复用的组件。</p><p>由于web components是由w3c组织去推动的，因此它很有可能在不久的将来成为浏览器的一个标配。</p><p>Web Components 主要由以下四个部分组成：</p><ul><li>Custom Elements – 定义新html元素的api</li><li>Shadow DOM – Encapsulated DOM and styling, with composition</li><li>HTML Imports – Declarative methods of importing HTML documents into other documents</li><li>HTML Templates – The <code>&lt;template&gt;</code> element, which allows documents to contain inert chunks of DOM</li></ul><h2 id="web-component有什么优点"><a href="#web-component有什么优点" class="headerlink" title="web-component有什么优点"></a>web-component有什么优点</h2><p>使用web components搭建组件库能够带来什么好处呢？<br>前面说了，web components 是w3c推动的一系列的规范，它是一个标准。</p><p>如果我们使用web components的api 开发一个组件，这个组件是脱离框架存在的，也就是说<br>你可以在任何框架中使用它，当然也可以直接在原生js中使用。</p><p>我们无须为不同的框架编写不同的组件库。</p><p>使用web components编写的组件库的基本使用方法大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"/build/duiba.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 运营位组件 --&gt;</span><br><span class="line">&lt;operation-list&gt;<span class="xml"><span class="tag">&lt;/<span class="name">operation-list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>毫不夸张地说， <code>web components</code> 就是未来。</p><p>但是web components的api还是相对复杂的，因此用原生的api开发web components还是<br>相对比较复杂的，就好像你直接用原生canvas api去开发游戏一样。</p><p>下面我们介绍下用于简化web components开发的库。</p><h2 id="polymer"><a href="#polymer" class="headerlink" title="polymer"></a>polymer</h2><p>polymer是我接触的第一个web componment开发库，那已经是很多年前的往事了。</p><blockquote><p>Build modern apps using web components</p></blockquote><p>更多介绍<a href="https://github.com/Polymer/polymer" target="_blank" rel="noopener">polymer</a></p><h2 id="stencil"><a href="#stencil" class="headerlink" title="stencil"></a>stencil</h2><p>stencil是在polymer之后出现的一个库。<br>第一次接触时在Polymer Summit 2017的分享上，这里贴下地址<a href="https://youtu.be/UfD-k7aHkQE" target="_blank" rel="noopener">Using Web Components in Ionic - Polymer Summit 2017</a>。</p><blockquote><p>Stencil is a tool developers use to create Web Components with some powerful features baked in, but it gets out of the way at runtime.</p></blockquote><p>那么powerful features具体指的是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Virtual DOM</span><br><span class="line">Async rendering (inspired by React Fiber)</span><br><span class="line">Reactive data-binding</span><br><span class="line">TypeScript</span><br><span class="line">JSX</span><br></pre></td></tr></table></figure><p>它也是一个用于生成web compoennt的tool。 不同的是她提供了更多的特性(Reactive data-binding,TypeScript,JSX, virtual dom)以及更强的性能(virtual dom, Async rendering).</p><p>细心的人可能已经发现了，我将Virtual DOM既归为特性，又归为性能，没错！ Virtual DOM提供了一种到真实dom的映射，使得开发者不必关心真实dom，从这个层面讲它是特性。 </p><p>从虚拟dom之间的diff，并将diff info patch到real dom（调和）的过程来看，它是性能。</p><p>用stencil开发web components体验大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Prop, State &#125; <span class="keyword">from</span> <span class="string">'@stencil/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  tag: <span class="string">'my-component'</span>,</span><br><span class="line">  styleUrl: <span class="string">'my-component.scss'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Indicate that name should be a property on our new component</span></span><br><span class="line">  @Prop() first: string;</span><br><span class="line"></span><br><span class="line">  @Prop() last: string;</span><br><span class="line"></span><br><span class="line">  @State() isVisible: boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        Hello, my name is &#123;<span class="keyword">this</span>.first&#125; &#123;<span class="keyword">this</span>.last&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>这是我基于<a href="https://github.com/ionic-team/stencil" target="_blank" rel="noopener">stenciljs</a> + <a href="https://github.com/storybooks/storybook" target="_blank" rel="noopener">storybook</a>写的一个小例子。大家可以clone，并运行查看效果。</p><p><a href="https://github.com/azl397985856/duiba-components" target="_blank" rel="noopener">duiba-components</a></p><p>通过这样搭建的企业级组件库，就可以轻松地为不同业务线提供基础组件库，而不必担心使用者（各个业务方）的技术栈。</p><p>将来业务方的框架升级（比如vue1升级到vue2），我们的组件库照样可以使用。</p><p>可以想象，如果es标准发展地够好，web components 等规范也足够普及，无框架时代将会到来。</p><blockquote><p>无框架，不代表不使用库。</p></blockquote><p>只需要借助工具库就可以开发足够通用的组件，也不需要babel这样的转换器，更不需要各种polyfill。<br>那么开发者大概会非常幸福吧，可惜这样的日子不可能存在，但是离这个目标足够近也是极好的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 组件化 </category>
          
          <category> web-component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 组件化 </tag>
            
            <tag> web-component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>累死累活干不过一个写PPT的</title>
      <link href="/blog/2019/12/11/ppt-data/"/>
      <url>/blog/2019/12/11/ppt-data/</url>
      
        <content type="html"><![CDATA[<p>无论是身处什么行业什么领域，数据分析越来越成为一向必不可少的技能，<br>而运用数据思维进行决策更能产生形成高质量的决策结果。</p><p>随着互联网的不断发展和物联网设备的不断普及，我们日常生活中的各种数据被存储下来，让我们可以通过定量分析数据，利用数据实现更好的决策制定。</p><a id="more"></a><p>现在越来越多的公司开始注重这一块，一方面自建数据体系，一方面去买一些数据。而对于我们个人似乎还没有意识到或者开始挖掘数据对我们的价值。</p><p>笔者最近的工作大都是做一些基础设施搭建和流程优化相关的工作。<br>这部分工作对很多人来说都是“隐形”的，对上层使用者来说很难有很大的感知。<br>对于领导来说，如果你只是闷头去做事情，他们也是很难知道你干的怎么样，如果这之间再加上<br>你没有什么反馈，就会给同事和领导一种“不靠谱”的感觉。</p><p>因此给予反馈和直观展示自己劳动成果的能力就显得非常重要。<br>然而如果你能很好展示自己的劳动成果，那么只需要将这个给老板看就是一种很好很直观的反馈。</p><p>这篇文章，我们来谈一下，如何量化我们的工作，如何将我们的工作成果展示出来。<br>如何让同事，让领导体会到我们工作的成果。我会通过几个例子来帮助大家快速理解，以及掌握这门“技术”<br>。</p><p>《让数据开口说话》是我给这篇文章的标题，让数据开口说话，你就可以少说一点，并且摆数据就是摆事实，<br>数据带来的说服力要比你说的话强很多。</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是一个对技术充满兴趣的程序员, 擅长前端工程化，前端性能优化，前端标准化等。</p><p>做过.net， 搞过Java，现在是一名前端工程师。</p><p>除了我的本职工作外，我会在开源社区进行一些输出和分享，GitHub 共计获得1.5W star。比较受欢迎的项目有<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">leetcode题解</a> , <a href="https://github.com/azl397985856/fe-interview" target="_blank" rel="noopener">宇宙最强的前端面试指南</a> 和<br><a href="https://github.com/azl397985856/automate-everything" target="_blank" rel="noopener">我的第一本小书</a></p><h2 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h2><p>如果让数据开头说话，那么首先第一步你要有数据。</p><p>因此我们的第一步就是收集数据，那么在这之前你需要知道你需要什么数据。<br>这部分的内容随着每个人任务不同肯定是不一样的。因此有着很大的灵活性，</p><p>有一个指导思想就是对关键指标分解。<br>比如我现在要做打包时间进行优化，那么打包时间由哪些时间决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打包时间 =  阶段1 时间 + 阶段2 时间 + 阶段3 时间</span><br></pre></td></tr></table></figure><p>我们减少打包时间肯定要减少其中一个或多个。</p><p>有时候我们无法找到这种简单的分解，那就教大家另外一个技巧：运用对比。</p><p>一方面可以基于时间进行对比，比如环比增长，同比增长等数据都是这么来的。</p><p>另一方面我们可以基于用户属性进行对比，比如用户年龄，性别，偏好，操作系统类型，<br>地域属性等。</p><p>下面我举几个例子。</p><h3 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h3><p>假如你被分配了一个任务。让你对项目的打包过程进行优化。</p><ul><li><p>你需要对打包时间进行优化，减少打包的时间</p></li><li><p>你需要对打包的最终产物进行优化，减少打出的包的包体大小。</p></li><li><p>将打包变得尽可能的简单，也就说尽量减少人为的操作过程。</p></li></ul><p>你接到了这样一个任务，你会如何去做？</p><p>这里我们不考虑具体的具体思路和细节。 假设你的架构思路，方案规划，各种fallback已经想好了。<br>我们如何通过上面提到的让数据说话的角度来收集数据呢？ 换句话说，我们需要收集哪些数据？</p><h4 id="打包时间"><a href="#打包时间" class="headerlink" title="打包时间"></a>打包时间</h4><p>对于打包时间的数据，最简单的我们计算一下总体的打包时间。</p><p>最后我们只需要对比优化前后的总体打包时间差异即可。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075808.png" alt></p><p>这对于老板来说可能已经够了，但是这缺乏一些精确性，我们无法知道通过优化了哪个环节进行<br>减少了打包时间。 因此一种简单的改进是将打包划分为多个阶段，每个阶段分别进行统计计时⌛️ 。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075810.png" alt></p><h4 id="包的大小"><a href="#包的大小" class="headerlink" title="包的大小"></a>包的大小</h4><p>包的大小的数据其实和上面讲的打包时间思路类似。</p><p>我们当然可以只统计总体包大小。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-75811.png" alt></p><p>但是为了获得更加灵活的定制和更加精确的范围我们可以对包进行一定的划分。<br>这个划分可以是业务纬度，也可以是纯技术纬度。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075811.png" alt></p><h4 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h4><p>这部分比较简单，我们只需要简单地统计手动操作的次数即可。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075813.png" alt></p><p>通过收集以上的数据，我们就可以用数据来表示我们的成果，让数据说话，关于如何<br>使用这些数据，我们稍后讨论。</p><h3 id="页面加载性能优化"><a href="#页面加载性能优化" class="headerlink" title="页面加载性能优化"></a>页面加载性能优化</h3><p>假如你被分配了一个任务。让你对项目的页面加载速度进行优化。<br>你会怎么做？</p><p>这个任务有点太宽泛了，更多的时候会有一些更精确的指标，<br>比如将网络状态为<code>fast 3G</code>的<code>中端机型</code>的白屏时间降低到<code>3s以内</code>。</p><h4 id="timing"><a href="#timing" class="headerlink" title="timing"></a>timing</h4><p>性能优化的第一步就是测量，没有测量就没有优化。我们不能为了优化而优化， 而是看到了某些点需要优化才去优化的。 而发现这个点一个重要的方式就是要靠测量。</p><p>说到测量，普遍接受的方式是，在浏览器中进行打点，将浏览器打开网页的过程看作是一个旅行。<br>那么我们每到一个地方就拍张带有时间的照片（事件），最后我们对这些照片按照时间进行排列， 然后分析哪部分是我们的瓶颈点等。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-75814.png" alt="performance-api"></p><p>有了这些timing 我们可以很方便的计算各项性能指标。我们还可以自定义一些我们关心的指标，比如请求时间（成功和失败分开统计），较长js操作时间，或者比较重要的功能等。</p><p>总之收集到这些数据之后，我们只需要根据我们的需求去定制一些指标即可。</p><p>这样我们就很容易展示出这样的画面：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075814.png" alt="render-perf"></p><h3 id="人效提升"><a href="#人效提升" class="headerlink" title="人效提升"></a>人效提升</h3><p>假如你是一个项目的管理者，上级分配给你一个任务，要在未来几个季度去做“研发效率提升”，<br>也就是提高“交付速度”。 你会怎么做这件事？</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>这个事情是比较主观的了，因此我们切实需要一些可以量化的东西来辅助我们。</p><p>我们考虑将需求进行拆分，变成一个个任务。一个需求可能有多个任务。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075816.png" alt></p><p>我们考虑对每一个任务进行计时，而不是需求，因为需求有太大的差异。<br>我们可以针对任务进行分类，然后我们的目标就可以变成“减少同类任务的交付时长”。</p><p>但是这种粒度似乎还是有点大。我们可以采取标签的形式，对任务进行交叉分类。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-75817.png" alt></p><p>任务纬度可能还是有点太大，我们可以采取更小的粒度划分，比如模块和组件。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075817.png" alt></p><p>这样我们的统计纬度就丰富起来了，我们不仅可以总体进行统计分析，我们还可以根据tag和tag的组合进行汇总。</p><p>比如一个典型的统计结果大概是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- task1 (tagA)</span><br><span class="line"> - module1 (tagA)</span><br><span class="line">   - component1 (tagB)</span><br><span class="line">   - component2 (tagA)</span><br><span class="line"> - module2 (tagB)</span><br><span class="line"> - module3 (tagB)</span><br><span class="line">- task2 (tagA)</span><br><span class="line">- task3 (tagC)</span><br></pre></td></tr></table></figure><p> 比如这里有一种tag叫“是否复用了以前的代码”，<br> 那么我们就很容易统计出组件复用率，也就很容易很直观地知道前后的差距了。</p><h3 id="用户拉新和留存"><a href="#用户拉新和留存" class="headerlink" title="用户拉新和留存"></a>用户拉新和留存</h3><p>再比如我们需要做“用户拉新和留存”，我们应该怎么做？</p><p>这个留做思考题，大家可以思考一下。</p><p>我这里抛砖引玉一下，比如我们的统计纬度可以是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 用户访问时长 (tagA)</span><br><span class="line">- 跳出率 (tagB)</span><br><span class="line">- 新用户 (tagA)</span><br><span class="line">- 流失的老用户 (tagB)</span><br><span class="line">- 地址位置 (tagA)</span><br></pre></td></tr></table></figure><p>假如我的tag有两个分别是 用户id和时间， 我们就可以方便地统计每个用户的活动数据趋势。</p><h2 id="让数据说话"><a href="#让数据说话" class="headerlink" title="让数据说话"></a>让数据说话</h2><p>有了数据，我们如何通过数据来增强表现力呢？</p><p>一种非常有效的措施是可视化。现在的可视化引擎和工具有很多，功能也非常复杂。</p><p>但是我发现我个人需要的就那么几个，可能大家每个人需要的种类不大一样，<br>但是我相信作为个人，你需要的种类不会很多。因此自己根据自身的实际情况，<br>挑选适合自己的几种类型，做到迎刃有余就足够了。</p><p>对于我而言，我常用的是饼图，用来表示分布关系。  曲线图用来表示趋势。<br>用柱状图表示对比+趋势。用热度图表示离散的数据分布等等。</p><p>我们可以使用一些现有的成熟的产品来帮助我们将刚才我们收集到的数据转化为各种图表，<br>比如 <a href="https://www.canva.com/" target="_blank" rel="noopener">画布</a></p><blockquote><p>这个网站能做的图表种类比较少。</p></blockquote><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075819.png" alt></p><p>当然作为一名前端我们也可以自己写代码去更灵活地展示我们的数据，比如<a href="https://d3js.org/" target="_blank" rel="noopener">D3</a><br>或者百度的<a href="https://echarts.baidu.com/" target="_blank" rel="noopener">echarts</a></p><blockquote><p>任何类型的图表都可以做，只有你想不到，没有它做不到。</p></blockquote><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-75820.png" alt></p><p>相对折中一点，我们可以选择支持代码定制的一些产品，在特殊情况我们可以自定义。</p><h2 id="累死累活干不过做-PPT-的"><a href="#累死累活干不过做-PPT-的" class="headerlink" title="累死累活干不过做 PPT 的"></a>累死累活干不过做 PPT 的</h2><p>有了这些数据图表，是时候写一份PPT来秀一下了。</p><p>一种方式是使用你电脑的办公软件或者一些在线的幻灯片制作工具做，<br>比如<a href="https://slides.com/" target="_blank" rel="noopener">slides</a> 。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075821.png" alt></p><p>另一种方式通过写代码的方式实现，作为程序员我推荐使用第二种。<br>这里推荐一款<code>nodejs cli 工具</code> <a href="https://github.com/ksky521/nodeppt" target="_blank" rel="noopener">nodeppt</a>,<br>还有另外一个<code>JS 框架</code> <a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">reveal.js</a> 。<br>上面提到的slides背后的原理就是它。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075822.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章我主要讲述了如何量化我们的工作，并将我们的工作成果展示出来。<br>从而摆脱“干了很多事情，却说不出来，甚至功劳被人无情拿走的尴尬局面”。</p><p>首先我们将了如何收集数据，收集数据的一些技巧，这里通过几个实际工作的例子，分别是“打包优化”，“性能优化”，“人效提升”，<br>“用户留存” ，来帮助大家理解这个<br>过程，掌握这个技巧。</p><p>有了数据之后，我们需要通过一些手段将其数据展示出来，给人直观的感受，最好有视觉冲击感。<br>这里我推荐了几个工具和平台，大家可以根据自己的情况选择。</p><p>最后结合我们实际情况，PPT是一个很好的展示自己的东西，不管是晋升还是宣传都是很好的方式，<br>这里我也推荐了几个产品，帮助大家更快更好地将图表展示出来。</p><p>让数据开口说话，你就可以少说一点，并且摆数据就是摆事实，<br>数据带来的说服力要比你说的话强很多。</p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>最近我重新整理了下自己的公众号，并且我还给他换了一个名字《脑洞前端》，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解前端是我的目标。</p><p>之后我的文章同步到微信公众号 脑洞前端 ，您可以关注获取最新的文章，或者和我进行交流。</p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-085421.jpg" width="50%" height="50%" alt="gongzhonghao" align="center"><h2 id="交流群"><a href="#交流群" class="headerlink" title="交流群"></a>交流群</h2><p>现在还是初级阶段，需要大家的意见和反馈，为了减少沟通成本，我组建了交流群。大家可以扫码进入</p><h3 id="QQ-群"><a href="#QQ-群" class="headerlink" title="QQ 群"></a>QQ 群</h3><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-75823.png" alt="qq-group-chat"></p><h3 id="微信群"><a href="#微信群" class="headerlink" title="微信群"></a>微信群</h3><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-085457.jpg" width="50%" height="50%" alt="JavaScript" align="center"><p>(由于微信的限制，100 个人以上只能邀请加入， 你可以添加我的机器人回复“大前端”拉你进群)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技能 </tag>
            
            <tag> PPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂《链表反转》</title>
      <link href="/blog/2019/12/11/reverseList/"/>
      <url>/blog/2019/12/11/reverseList/</url>
      
        <content type="html"><![CDATA[<p>翻转链表一直都是热门题目，笔者就在某大型互联网公司的面试题中碰到过这种题目，这种题目很常常见，相对应的变形和扩展也很多，今天我们就来攻克它吧。</p><a id="more"></a><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>反转链表是这个系列中最简单的了，没有别的要求，就是将一个链表从头到尾进行反转，最后返回反转后的链表即可。</p><p>我们来看一个 LeetCode 题目, <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a>, 官方难度为 Easy。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">反转一个单链表。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line">进阶:</span><br><span class="line">你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>链表的翻转过程，初始化一个为 null 的 previous node（prev），然后遍历链表的同时，当前 node （curr）的下一个（next）指向前一个 node（prev）， 在改变当前 node 的指向之前，用一个临时变量记录当前 node 的下一个 node（curr.next). 即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListNode temp = curr.next;</span><br><span class="line">curr.next = prev;</span><br><span class="line">prev = curr;</span><br><span class="line">curr = temp;</span><br></pre></td></tr></table></figure><p>举例如图：翻转整个链表 1-&gt;2-&gt;3-&gt;4-&gt;null -&gt; 4-&gt;3-&gt;2-&gt;1-&gt;null</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-22-101950.jpg" alt></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我们直接来看下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="keyword">const</span> next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不再赘述，如果不理解，想看更多更详细内容，请参考我的<a href="https://github.com/azl397985856/leetcode/blob/master/problems/206.reverse-linked-list.md" target="_blank" rel="noopener">LeetCode 题解 - 206.reverse-linked-list</a></p><h2 id="分组反转"><a href="#分组反转" class="headerlink" title="分组反转"></a>分组反转</h2><p>这个题目和上面的有点类似，只不过我们并不是从头到尾反转，而是每 k 个为一组进行反转。LeetCode 同样有原题<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a>官方难度为 Hard。</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</span><br><span class="line"></span><br><span class="line">k 是一个正整数，它的值小于或等于链表的长度。</span><br><span class="line"></span><br><span class="line">如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span><br><span class="line"></span><br><span class="line">示例 :</span><br><span class="line"></span><br><span class="line">给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line"></span><br><span class="line">当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">说明 :</span><br><span class="line"></span><br><span class="line">你的算法只能使用常数的额外空间。</span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们的思路还是一样的，我们把每 k 位的位置当成是尾节点即可。 我们的任务就是每次反转头尾之间的所有节点，<br>然后将链表重新拼起来即可。 我们先来写一下<code>反转头尾之间的所有节点</code>这个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 翻转head到tail之间的部分，不包括head和tail</span></span><br><span class="line"><span class="comment">// 返回原链表的第一个元素，也就是翻转后的最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head, tail</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">let</span> cur = head.next;</span><br><span class="line">  first = cur;</span><br><span class="line">  <span class="keyword">let</span> pre = head; <span class="comment">// 这里就是翻转不包括head的原因，否则就是head.pre了（当然我们没有pre指针）</span></span><br><span class="line">  <span class="comment">// 这里就是翻转不包括tail的原因，否则就是tail.next了。</span></span><br><span class="line">  <span class="keyword">while</span> (cur !== tail) &#123;</span><br><span class="line">    <span class="keyword">const</span> next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拼接</span></span><br><span class="line">  head.next = pre;</span><br><span class="line">  first.next = cur;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的反转不包括 head 和 tail，并不是我一开始的思路，但是在慢慢想的过程，发现这样写代码会更优雅。</p><p>上面的代码如果是 head 是我们的头节点，tail 是 null，那么就等效于上面的那道题。也就是说我们的这个 k 分组是上面题目的一般形式，当 k 为链表长度的时候，就会变成上面那道题了。</p><p>还有一点不同的是，我们每次反转之后都要对链表进行拼接，这是上面那个反转所没有的，这里要注意一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head.next = pre;</span><br><span class="line">first.next = cur;</span><br></pre></td></tr></table></figure><p>这里是对每一组（<code>k个nodes</code>）进行翻转，</p><ol><li><p>先分组，用一个<code>count</code>变量记录当前节点的个数</p></li><li><p>用一个<code>start</code> 变量记录当前分组的起始节点位置的前一个节点</p></li><li><p>用一个<code>end</code>变量记录要翻转的最后一个节点位置</p></li><li><p>翻转一组（<code>k个nodes</code>）即<code>(start, end) - start and end exclusively</code>。</p></li><li><p>翻转后，<code>start</code>指向翻转后链表, 区间<code>（start，end）</code>中的最后一个节点, 返回<code>start</code> 节点。</p></li><li><p>如果不需要翻转，<code>end</code> 就往后移动一个（<code>end=end.next</code>)，每一次移动，都要<code>count+1</code>.</p></li></ol><p>如图所示 步骤 4 和 5： 翻转区间链表区间<code>（start， end）</code></p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-22-102105.jpg" alt="reverse linked list range in (start, end)"></p><p>举例如图，<code>head=[1,2,3,4,5,6,7,8], k = 3</code></p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-22-102124.jpg" alt="reverse k nodes in linked list"></p><blockquote><p><strong>NOTE</strong>: 一般情况下对链表的操作，都有可能会引入一个新的<code>dummy node</code>，因为<code>head</code>有可能会改变。这里<code>head 从1-&gt;3</code>,<br><code>dummy (List(0))</code>保持不变。</p></blockquote><p>这种做法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseKGroupsLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="keyword">null</span> || k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">      &#125;</span><br><span class="line">      ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">      dummy.next = head;</span><br><span class="line"></span><br><span class="line">      ListNode start = dummy;</span><br><span class="line">      ListNode end = head;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (end != <span class="keyword">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// group</span></span><br><span class="line">        <span class="keyword">if</span> (count % k == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// reverse linked list (start, end]</span></span><br><span class="line">          start = reverse(start, end.next);</span><br><span class="line">          end = start.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          end = end.next;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reverse linked list from range (start, end), return last node.</span></span><br><span class="line"><span class="comment">     * for example:</span></span><br><span class="line"><span class="comment">     * 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8</span></span><br><span class="line"><span class="comment">     * |           |</span></span><br><span class="line"><span class="comment">     * start       end</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * After call start = reverse(start, end)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0-&gt;3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8</span></span><br><span class="line"><span class="comment">     *          |  |</span></span><br><span class="line"><span class="comment">     *       start end</span></span><br><span class="line"><span class="comment">     *       first</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode start, ListNode end)</span> </span>&#123;</span><br><span class="line">      ListNode curr = start.next;</span><br><span class="line">      ListNode prev = start;</span><br><span class="line">      ListNode first = curr;</span><br><span class="line">      <span class="keyword">while</span> (curr != end)&#123;</span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      start.next = prev;</span><br><span class="line">      first.next = curr;</span><br><span class="line">      <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python3 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        start = dummy</span><br><span class="line">        end = head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count % k == <span class="number">0</span>:</span><br><span class="line">                start = self.reverse(start, end.next)</span><br><span class="line">                end = start.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = end.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        prev, curr = start, start.next</span><br><span class="line">        first = curr</span><br><span class="line">        <span class="keyword">while</span> curr != end:</span><br><span class="line">            temp = curr.next</span><br><span class="line">            curr.next = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = temp</span><br><span class="line">        start.next = prev</span><br><span class="line">        first.next = curr</span><br><span class="line">        <span class="keyword">return</span> first</span><br></pre></td></tr></table></figure><p>JavaScript 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转head到tail之间的部分，不包括head和tail</span></span><br><span class="line"><span class="comment">// 返回原链表的第一个元素，也就是翻转后的最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head, tail</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">let</span> cur = head.next;</span><br><span class="line">  first = cur;</span><br><span class="line">  <span class="keyword">let</span> pre = head; <span class="comment">// 这里就是翻转不包括head的原因</span></span><br><span class="line">  <span class="keyword">while</span> (cur !== tail) &#123;</span><br><span class="line">    <span class="comment">// 这里就是翻转不包括tail的原因</span></span><br><span class="line">    <span class="keyword">const</span> next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拼接</span></span><br><span class="line">  head.next = pre;</span><br><span class="line">  first.next = cur;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseKGroup = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || k === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> dummy = &#123;</span><br><span class="line">    next: head,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> start = dummy;</span><br><span class="line">  <span class="keyword">let</span> end = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (end !== <span class="literal">null</span>) &#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span> (cnt % k !== <span class="number">0</span>) &#123;</span><br><span class="line">      end = end.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      start = reverseList(start, end.next);</span><br><span class="line">      end = start.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里不再赘述，如果不理解，想看更多更详细内容，请参考我的<a href="https://github.com/azl397985856/leetcode/blob/master/problems/25.reverse-nodes-in-k-groups-cn.md" target="_blank" rel="noopener">LeetCode 题解 - 25.reverse-nodes-in-k-groups-cn</a></p><h2 id="分组反转-增强版"><a href="#分组反转-增强版" class="headerlink" title="分组反转 - 增强版"></a>分组反转 - 增强版</h2><p>这道题目来自字节跳动面试题。</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>要求从后往前以k个为一组进行翻转。</p><p>例子，1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8, k = 3,</p><p>从后往前以k=3为一组，</p><p>6-&gt;7-&gt;8 为一组翻转为8-&gt;7-&gt;6，<br>3-&gt;4-&gt;5为一组翻转为5-&gt;4-&gt;3.<br>1-&gt;2只有2个nodes少于k=3个，不翻转。<br>最后返回： 1-&gt;2-&gt;5-&gt;4-&gt;3-&gt;8-&gt;7-&gt;6</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这里的思路跟从前往后以<code>k</code>个为一组进行翻转类似，可以进行预处理：</p><ol><li><p>翻转链表</p></li><li><p>对翻转后的链表进行从前往后以k为一组翻转。</p></li><li><p>翻转步骤2中得到的链表。</p></li></ol><p>例子：<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8, k = 3</code></p><ol><li><p>翻转链表得到：<code>8-&gt;7-&gt;6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1</code></p></li><li><p>以k为一组翻转： <code>6-&gt;7-&gt;8-&gt;3-&gt;4-&gt;5-&gt;2-&gt;1</code></p></li><li><p>翻转步骤#2链表： <code>1-&gt;2-&gt;5-&gt;4-&gt;3-&gt;8-&gt;7-&gt;6</code></p></li></ol><h2 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h2><ul><li><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> LeetCode </category>
          
          <category> 链表反转 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 字节跳动 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RFC】XXX 公司监控体系需求与技术调研</title>
      <link href="/blog/2019/12/11/rfc-monitor/"/>
      <url>/blog/2019/12/11/rfc-monitor/</url>
      
        <content type="html"><![CDATA[<p>线上问题回溯困难，无法快速准确重现问题，导致客户满意度下降，影响团队交付效率和质量，建立完善的监控体系可以很好的解决这个问题。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>线上问题回溯困难，无法快速准确重现问题，导致客户满意度下降，影响团队交付效率和质量。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>期望有一套工具，系统或者平台，可以满足：</p><ol><li>在收到用户反馈的时候能够快速重现问题并解决。</li><li>测试同学发现问题，不需要花费大量事件和开发人员重现，沟通，以及记录问题重现路径等</li><li>线上发现问题可以进行告警，防止大规模用户有问题，并且不能及时感知和解决。</li><li>缩短团队内部 BUG 修复的闭环流程，减少非本质复杂度问题的干扰，快速将问题聚焦到具体的代码。</li></ol><p>带着上面的需求，我们来看下市面上已有的经典方案， 在这里挑选几个具有代表性的。</p><h2 id="市面上已有的方案对比"><a href="#市面上已有的方案对比" class="headerlink" title="市面上已有的方案对比"></a>市面上已有的方案对比</h2><h3 id="LogRocket"><a href="#LogRocket" class="headerlink" title="LogRocket"></a>LogRocket</h3><p>一句话概括： 用看录像的方式重现问题。</p><p>官网地址： <a href="https://logrocket.com/" target="_blank" rel="noopener">https://logrocket.com/</a></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8nsefw6j31ji0braaj.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8mp9lp5j31bc0qr410.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8myz28pj31su0u0ta3.jpg" alt></p><p>更多功能： <a href="https://docs.logrocket.com/docs" target="_blank" rel="noopener">https://docs.logrocket.com/docs</a></p><h4 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8kqmquvj313k0opwfb.jpg" alt></p><h4 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8lgqwlgj30rg0n3wf0.jpg" alt></p><h3 id="Sentry"><a href="#Sentry" class="headerlink" title="Sentry"></a>Sentry</h3><p>一句话概括： 开源，强大的监控平台。</p><p>官网地址： <a href="https://sentry.io/" target="_blank" rel="noopener">https://sentry.io/</a></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>功能较多，提供了较多的概念和功能，比如 Context，ENvironments，Breadcrumbs 等。另外其和 CI，CD 集成地也非常好。 详细内容： <a href="https://docs.sentry.io/workflow/releases/?platform=node" target="_blank" rel="noopener">https://docs.sentry.io/workflow/releases/?platform=node</a></p><p>另外其支持的平台和扩展功能非常多，如果对这部分有特殊要求，Sentry 无疑是优先考虑的选择。</p><h4 id="接入方式-1"><a href="#接入方式-1" class="headerlink" title="接入方式"></a>接入方式</h4><ul><li>Sign up for an account</li><li>Install your SDK</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using yarn</span></span><br><span class="line">$ yarn add @sentry/node@5.8.0</span><br></pre></td></tr></table></figure><ul><li>Configure it</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sentry = <span class="built_in">require</span>(<span class="string">"@sentry/node"</span>);</span><br><span class="line">Sentry.init(&#123; <span class="attr">dsn</span>: <span class="string">"https://&lt;key&gt;@sentry.io/&lt;project&gt;"</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="价格-1"><a href="#价格-1" class="headerlink" title="价格"></a>价格</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8qipkskj30x10jt758.jpg" alt></p><h3 id="FunDebug"><a href="#FunDebug" class="headerlink" title="FunDebug"></a>FunDebug</h3><p>一句话概括：国内知名度较高的监控工具，国内业务这块很有竞争力。</p><p><a href="https://www.fundebug.com/" target="_blank" rel="noopener">https://www.fundebug.com/</a></p><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>支持小程序，小游戏。多种现成的报警方式，支持 WebHook，智能报警（同样的代码产生的同一个错误，在不同浏览器上的报错信息是各不相同的），内置团队协作工具。</p><h4 id="接入方式-2"><a href="#接入方式-2" class="headerlink" title="接入方式"></a>接入方式</h4><p>这里以 Vue 项目为例。</p><ol><li><p>免费注册</p></li><li><p>创建项目</p></li><li><p>配置</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install fundebug-javascript fundebug-vue --save</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fundebug <span class="keyword">from</span> <span class="string">"fundebug-javascript"</span>;</span><br><span class="line"><span class="keyword">import</span> fundebugVue <span class="keyword">from</span> <span class="string">"fundebug-vue"</span>;</span><br><span class="line">fundebug.init(&#123;</span><br><span class="line">  apikey: <span class="string">"API-KEY"</span></span><br><span class="line">&#125;);</span><br><span class="line">fundebugVue(fundebug, Vue);</span><br></pre></td></tr></table></figure><h4 id="价格-2"><a href="#价格-2" class="headerlink" title="价格"></a>价格</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w9mhtq44j30x60mb3z3.jpg" alt></p><h2 id="其他后期可能功能点"><a href="#其他后期可能功能点" class="headerlink" title="其他后期可能功能点"></a>其他后期可能功能点</h2><ol><li><p>性能监控</p></li><li><p>用户行为监控（已经有埋点，不不确定是否可以 Cover 这个需求）</p></li></ol><h2 id="自研"><a href="#自研" class="headerlink" title="自研"></a>自研</h2><p>假设我们已经做好了我们自己的监控平台，我们需要对公司内部甚至外部宣传我们的监控平台，我们会怎么进行宣传。</p><p>然后带着这些东西，我们进行规划，技术选型，排期，写代码，测试，上线。</p><h3 id="宣传语"><a href="#宣传语" class="headerlink" title="宣传语"></a>宣传语</h3><ol><li>接入方便，侵入性小</li><li>支持多端，扩展性强（支持多种框架定制接入），完美契合业务发展</li><li>打通客服系统，开发直接对接到客户，免去了中间对接的信息缺失和时间损耗。</li><li>重现率高，能够准确重现用户的现场情况</li><li>打通报警系统</li><li>打通调试平台<br>…</li></ol><h3 id="优劣分析"><a href="#优劣分析" class="headerlink" title="优劣分析"></a>优劣分析</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>完美契合我们自身的业务，后期好维护和增添功能</p><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><p>如果功能需要做的超出市面，需要耗费巨大的人力和财力。</p><p>如果市面上不断发展，功能不能断完善，内部如果想要这样的功能要么继续追赶，要不买一套商用的，但是之前的努力岂不是白费了。除非内部两套系统，但是这种模式未免太反直觉。</p><h3 id="架构与选型"><a href="#架构与选型" class="headerlink" title="架构与选型"></a>架构与选型</h3><p>对外都宣传完了，我们需要具体开始进行架构与选型了。</p><h4 id="定义对外接口"><a href="#定义对外接口" class="headerlink" title="定义对外接口"></a>定义对外接口</h4><p>我们对外宣传的目标是<code>接入方便，侵入性小</code>。因此一定要简洁，这里参考了以上几个平台的写法，其实这几个平台的都是大同小异。</p><ol><li>注册应用获取 AppId</li><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save @lucifer/monitor</span><br></pre></td></tr></table></figure><ol start="3"><li>引用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> monitor <span class="keyword">from</span> <span class="string">"@lucifer/monitor"</span>;</span><br><span class="line">monitor.init(&#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    name: <span class="string">""</span>,</span><br><span class="line">    email: <span class="string">""</span>,</span><br><span class="line">    mobile: <span class="string">""</span>,</span><br><span class="line">    isVIP: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  appId: <span class="string">"lucifer520"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>多端和多框架支持</li></ol><p>Vue：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue form <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> monitor <span class="keyword">from</span> <span class="string">'@lucifer/connectors/vue'</span>;</span><br><span class="line">monitor.init(&#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">        name: <span class="string">''</span>,</span><br><span class="line">        email: <span class="string">''</span>,</span><br><span class="line">        mobile: <span class="string">''</span>,</span><br><span class="line">        isVIP: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    appId: <span class="string">'lucifer520'</span></span><br><span class="line">&#125;)</span><br><span class="line">monitor.use(Vue)</span><br></pre></td></tr></table></figure><p>Wechat：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> monitor <span class="keyword">from</span> <span class="string">"@lucifer/connectors/wechat"</span>;</span><br><span class="line">monitor.init(&#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    name: <span class="string">""</span>,</span><br><span class="line">    email: <span class="string">""</span>,</span><br><span class="line">    mobile: <span class="string">""</span>,</span><br><span class="line">    isVIP: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  appId: <span class="string">"lucifer520"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="定义内部接口"><a href="#定义内部接口" class="headerlink" title="定义内部接口"></a>定义内部接口</h4><p>架构图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xj6xnibej30xd0hzgo5.jpg" alt></p><p>接口系统交互图会在详细设计中给出，这里只给出大致范围：</p><ul><li>logs 服务器和告警平台的交互接口</li><li>rules 的规则解析</li><li>logs 的解析</li><li>构建系统对接</li><li>调试系统对接</li><li>…</li></ul><h4 id="业务形态特点"><a href="#业务形态特点" class="headerlink" title="业务形态特点"></a>业务形态特点</h4><ul><li>数据量会随着采集规模增大而增加，因此预估用户数量以及增长速度对系统架构设计有很大影响</li><li>终端的上报策略对影响很大，断网，弱网等情况如何上报也对结果有影响</li></ul><h4 id="框架选型-amp-规范-amp-约定"><a href="#框架选型-amp-规范-amp-约定" class="headerlink" title="框架选型 &amp; 规范 &amp; 约定"></a>框架选型 &amp; 规范 &amp; 约定</h4><p>暂无</p>]]></content>
      
      
      
        <tags>
            
            <tag> RFC </tag>
            
            <tag> 技术调研 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文科生都能看懂的循环移位算法</title>
      <link href="/blog/2019/12/11/rotate-list/"/>
      <url>/blog/2019/12/11/rotate-list/</url>
      
        <content type="html"><![CDATA[<p>循环移位问题真的是一个特别经典的问题了，今天我们就来攻克它。</p><p>循环移位的表现形式有很多种，就数据结构来说包括<code>数组</code>，<code>字符串</code>，<code>链表</code>等。就算法来说，有<code>包含问题</code>，<code>直接移动问题</code>，还有<code>查找问题</code>等。</p><p>虽然表现形式有很多，但是本质都是一样的，因为从逻辑上来讲其实他们都是线性数据结构，那么让我们来看一下吧。</p><a id="more"></a><h2 id="数组循环移位"><a href="#数组循环移位" class="headerlink" title="数组循环移位"></a>数组循环移位</h2><p>LeetCode 和 编程之美等都有这道题目，题目难度为 Easy。<a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">LeeCode 链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</span><br><span class="line">要求使用空间复杂度为 O(1) 的 原地 算法。</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga4j21nsctj30o8048glq.jpg" alt></p><h3 id="不符合题意的解法"><a href="#不符合题意的解法" class="headerlink" title="不符合题意的解法"></a>不符合题意的解法</h3><p>如果你拿到这道题没有思路，不要紧张，因为你不是一个人。</p><p>让我们先不要管题目的时间和空间复杂度的限制， 来用最最普通的方式实现它，看能不能得出一点思路。</p><p>最简单的做法就是新开辟一个完全一样的数组，然后每次移动的时候从 copy 的数组中取即可，由于新开辟的数组不会被改变，因此这种做法可行，我们直接看下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RShift</span>(<span class="params">list, k</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 空间复杂度O(n)</span></span><br><span class="line">  <span class="comment">// 时间复杂度O(n)</span></span><br><span class="line">  <span class="keyword">const</span> copy = [...list];</span><br><span class="line">  <span class="keyword">const</span> n = list.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    list[(k + i) % n] = copy[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们还可以优化一下，如果 k 是 N 的倍数，实际上是不需要做任何移动的，因此直接返回即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RShift</span>(<span class="params">list, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = list.length;</span><br><span class="line">  <span class="keyword">if</span> (k % n === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 剩下代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们需要覆盖原来的数组，那么原来的数组中的数据就会缺失，因此我们最简单的就是开辟一个<br>完全一样的数组，这样就避免了问题，但是这样的空间复杂度是 N。我们有没有办法优化这个过程呢？</p><p>而且如果 k 是负数呢？ 这其实在考察我们思考问题的严谨性。</p><p>除此之外，我们还应该思考：</p><ul><li>k 的范围是多少？如果很大，我的算法还有效么？</li><li>n 的范围是多少？如果很大，我的算法还有效么?</li></ul><p>上面两个问题的答案都是<code>有效</code>。 因为 k 就算再大，我们只需要求模，求模的值当成新的 k 即可。<br>因此 k 最大不过就是 n。 如果 n 很大，由于我们的算法是 O(N)的复杂度，也就是线性，这个复杂度还是比较理想的。</p><h3 id="时间换空间"><a href="#时间换空间" class="headerlink" title="时间换空间"></a>时间换空间</h3><p>我们来试一下常数空间复杂度的解法，这种做法思路很简单，我们只需要每次移动一位，移动 k 次即可，移动一次的时间复杂度是 1，k 次共用一个变量即可，因此总的空间复杂度可以降低到 1。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga4ieydb7ij30pw0bejsa.jpg" alt></p><p>我们来看下代码，这次我们把上面提到的 k 为负数的情况考虑进去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RShift</span>(<span class="params">list, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = list.length;</span><br><span class="line">  <span class="keyword">if</span> (k % n === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="built_in">Math</span>.abs(k &gt; <span class="number">0</span> ? k % n : n + (k % n));</span><br><span class="line">  <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">    t = list[n - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 右移一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      list[i] = list[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    list[<span class="number">0</span>] = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面的解法是常数空间复杂度，但是时间复杂度是 O(N * K)，K 取值不限制的话，就是 O(N^2)，<br>还是不满足题意。不过没关系，我们继续思考。</p><p>我们再来看一种空间换时间的做法，这种做法的思路是拼接一个完全一样的数组到当前数组的尾部，然后问题就转化为<code>截取数组使之满足右移的效果</code>，这样的时间复杂度 O(N),空间复杂度是 O(N).</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-21-163458.png" alt></p><p>我们看下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RShift</span>(<span class="params">list, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = list.length;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="built_in">Math</span>.abs(k &gt; <span class="number">0</span> ? k % n : n + (k % n));</span><br><span class="line">  <span class="keyword">return</span> list.concat([...list]).slice(n - i, n * <span class="number">2</span> - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈，虽然离题目越来越远了，但是扩展了思路，也不错，这就是刷题的乐趣。</p><h3 id="三次翻转法"><a href="#三次翻转法" class="headerlink" title="三次翻转法"></a>三次翻转法</h3><p>我们来看下另外一种方法 - 经典的<code>三次翻转法</code>，我们可以这么做：</p><ul><li>先把[0, n - k - 1]翻转</li><li>然后把[n - k, n - 1]翻转</li><li>最后把[0, n - 1]翻转</li></ul><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-22-095115.png" alt></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">list, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    t = list[start];</span><br><span class="line">    list[start] = list[end];</span><br><span class="line">    list[end] = t;</span><br><span class="line">    start++;</span><br><span class="line">    end--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RShift</span>(<span class="params">list, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = list.length;</span><br><span class="line">  <span class="keyword">if</span> (k % n === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  reverse(list, <span class="number">0</span>, n - k - <span class="number">1</span>);</span><br><span class="line">  reverse(list, n - k, n - <span class="number">1</span>);</span><br><span class="line">  reverse(list, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给一个简单的数学证明：</p><ul><li><p>对于[0, n - k - 1] 部分，我们翻转一次后新的坐标 y 和之前的坐标 x 的关系可以表示为<code>y = n - 1 - k - x</code></p></li><li><p>对于[n - k, n -1] 部分，我们翻转一次后新的坐标 y 和之前的坐标 x 的关系可以表示为<code>y = 2 * n - 1 - k - x</code></p></li><li><p>最后我们整体进行翻转的时候，新的坐标 y 和之前的坐标 x 的关系可以表示为</p><ol><li><code>y = n - 1 - (n - 1 - k - x)</code> 即 <code>y = k + x</code> (0 &lt;= x &lt;= n - k - 1)</li><li><code>y = n - 1 - (2 * n - 1 - k - x)</code> 即 <code>y = k + x - n</code> (n - k &lt;= x &lt;= n - 1)</li></ol></li></ul><p>正好满足我们的位移条件。</p><p>这种做法时间复杂度是 O(N)空间复杂度 O(1)，终于满足了我们的要求。</p><h2 id="字符串循环移位"><a href="#字符串循环移位" class="headerlink" title="字符串循环移位"></a>字符串循环移位</h2><p>字符串和数组真的是一模一样，因为字符串也可以看成是字符序列，因此字符串就是数组。本质上来说，它和数组循环移位题目没有任何区别， 现在让我们来通过一道题来感受下。</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 s1 和 s2，要求判定 s2 是否能被 s1 循环移位得到的字符串包含。比如，给定 s1 = AABCD 和 s2 = CDAA，返回 true 。 给定 s1 = ABCD，s2 = ACBD， 则返回 false。</p><blockquote><p>题目来自《编程之美》</p></blockquote><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>s1 我们每次移动一位，然后判断逐一判断以每一个位置开头的字符串是否包含 s2，如果包含则返回 true，否则继续匹配。</p><p>这种做法很暴力，时间复杂度 O(n^2)，在 n 特别大的时候不是很有效。</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RIncludes</span>(<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = s1.length;</span><br><span class="line">  <span class="keyword">const</span> m = s2.length;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> p1; <span class="comment">// s1的指针</span></span><br><span class="line">  <span class="keyword">let</span> p2; <span class="comment">// s2的指针</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    t = s1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      s1[j] = s1[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s1[n - <span class="number">1</span>] = t;</span><br><span class="line">    p1 = <span class="number">0</span>;</span><br><span class="line">    p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; n &amp;&amp; p2 &lt; m) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s1[p1] === s2[p2]) &#123;</span><br><span class="line">        p1++;</span><br><span class="line">        p2++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p2 === m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="巧用模运算"><a href="#巧用模运算" class="headerlink" title="巧用模运算"></a>巧用模运算</h3><p>另外一种方法就是上面那种空间换时间的方式，我们将两个 s1 连接到一起，然后直接双指针即可，这里不再赘述。</p><p>这种方法虽然巧妙，但是我们花费了额外的 N 的空间，能否不借助额外的空间呢？答案是可以的，我们可以假想已经存在了另外一个相同的 s1，并且我们将它连接到 s1 的末尾。注意这里是假想，实际不存在，因此时间复杂度是 O(1)。那么如何实现呢？</p><p>答案还是利用求模。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RIncludes</span>(<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = s1.length;</span><br><span class="line">  <span class="keyword">const</span> m = s2.length;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> p1; <span class="comment">// s1的指针</span></span><br><span class="line">  <span class="keyword">let</span> p2; <span class="comment">// s2的指针</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    p1 = i; <span class="comment">// 这一行代码变了</span></span><br><span class="line">    p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; <span class="number">2</span> * n &amp;&amp; p2 &lt; m) &#123;</span><br><span class="line">      <span class="comment">// 不需要循环移动一位了，也就是说省了一个N的循环</span></span><br><span class="line">      <span class="keyword">if</span> (s1[p1 % n] === s2[p2]) &#123;</span><br><span class="line">        <span class="comment">// 这一行代码变了</span></span><br><span class="line">        p1++;</span><br><span class="line">        p2++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p2 === m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，这道题就告一段落了，大家如果有别的方法，也欢迎在评论区留言。</p><h2 id="链表循环移位"><a href="#链表循环移位" class="headerlink" title="链表循环移位"></a>链表循环移位</h2><p>链表不同于前面的数组和字符串，我们来个题目感受一下。</p><p>这里出一个 LeetCode 题目，官方难度为中等难度的一个题 - <a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">61. 旋转链表</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4</span><br><span class="line">输出: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>其实这个思路简单，就是先找到<code>断点</code>，然后重新拼接链表即可。这个断点其实就是第<code>n - k % n</code>个节点， 其中 k 为右移的位数，n 为链表长度。这里取模的原因和上面一样，为了防止 k 过大做的无谓运算。但是这道题目限定了 k 是非负数，那么我们就不需要做这个判断了。</p><p>如图所示：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-21-164709.png" alt></p><p>代码也很简单，我们来看下。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotateRight = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">let</span> p1 = head;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p1 &amp;&amp; p1.next) &#123;</span><br><span class="line">    p1 = p1.next;</span><br><span class="line">    n++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cur = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> p2 = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur &lt; n - (k % n)) &#123;</span><br><span class="line">    p2 = p2.next;</span><br><span class="line">    cur++;</span><br><span class="line">  &#125;</span><br><span class="line">  p1.next = head;</span><br><span class="line">  res = p2.next;</span><br><span class="line">  p2.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>循环移位的有序数组，查找某一个值，要求时间复杂度为 O(logn)<blockquote><p>这道题我在<a href="https://github.com/azl397985856/fe-interview/blob/master/docs/topics/algorthimn/cycle-sorted-array.md" target="_blank" rel="noopener">《每日一题》</a>出过</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 数组 </category>
          
          <category> LeetCode </category>
          
          <category> 循环移位 </category>
          
          <category> 链表 </category>
          
          <category> 字符串 </category>
          
          <category> 编程之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 循环移位 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 编程之美 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值得关注的技术类大会</title>
      <link href="/blog/2019/12/11/tech-conf/"/>
      <url>/blog/2019/12/11/tech-conf/</url>
      
        <content type="html"><![CDATA[<p>作为一个技术人，怎么能不参加和关注几场技术大会呢？让我们来看下那些你不能错过的技术大会吧。</p><a id="more"></a><h2 id="JSConf"><a href="#JSConf" class="headerlink" title="JSConf"></a>JSConf</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7d50s2862j30r10iwjrx.jpg" alt><br><a href="https://jsconf.com/" target="_blank" rel="noopener">地址</a></p><h2 id="React-Conf"><a href="#React-Conf" class="headerlink" title="React Conf"></a>React Conf</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wabkh6lyj31gk0a5jrl.jpg" alt><br><a href="https://conf.reactjs.org/" target="_blank" rel="noopener">地址</a></p><h2 id="Google-IO"><a href="#Google-IO" class="headerlink" title="Google IO"></a>Google IO</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7d51qe2drj31200h674i.jpg" alt><br><a href="https://events.google.com/io/" target="_blank" rel="noopener">地址</a></p><h2 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7d52bgjgpj30sm0hr76u.jpg" alt><br><a href="http://d2forum.alibaba-inc.com/#/index?_k=ug35gm" target="_blank" rel="noopener">地址</a></p><h2 id="QCon"><a href="#QCon" class="headerlink" title="QCon"></a>QCon</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7d52uctmoj31110hiwhd.jpg" alt><br><a href="https://www.infoq.com/qcon/" target="_blank" rel="noopener">地址</a></p><h2 id="更多技术大会"><a href="#更多技术大会" class="headerlink" title="更多技术大会"></a>更多技术大会</h2><ul><li><a href="https://juejin.im/events" target="_blank" rel="noopener">https://juejin.im/events</a></li><li><a href="https://segmentfault.com/events" target="_blank" rel="noopener">https://segmentfault.com/events</a></li><li><a href="https://www.huodongxing.com" target="_blank" rel="noopener">https://www.huodongxing.com</a></li><li><a href="https://www.bagevent.com" target="_blank" rel="noopener">https://www.bagevent.com</a></li><li><a href="https://www.hdb.com" target="_blank" rel="noopener">https://www.hdb.com</a></li><li><a href="https://www.meetup.com" target="_blank" rel="noopener">https://www.meetup.com</a></li><li>…</li></ul><p>欢迎大家补充～</p>]]></content>
      
      
      <categories>
          
          <category> 技术大会 </category>
          
          <category> JSConf </category>
          
          <category> React Conf </category>
          
          <category> Google IO </category>
          
          <category> D2 </category>
          
          <category> QCon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术大会 </tag>
            
            <tag> JSConf </tag>
            
            <tag> Google IO </tag>
            
            <tag> D2 </tag>
            
            <tag> QCon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纪念LeetCode项目Star突破2W</title>
      <link href="/blog/2019/12/11/thanksGaving-2/"/>
      <url>/blog/2019/12/11/thanksGaving-2/</url>
      
        <content type="html"><![CDATA[<p>假期这几天我买了《逆转裁判 123》合集，面对着这香喷喷的冷饭吃了半天。从 GBA 玩到 NDS，从 NDS 玩到 3DS, 现在 NS 虽然没有出新作有点遗憾。不过有了高清重制，也当是个回忆和收藏了 🎉🎉</p><a id="more"></a><p>目前打通了第一第二关，剩下的过一段时间再玩好啦 😁<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppozhetbj30u01ppdjp.jpg" alt></p><p>回到正题，就在今天，我的《leetcode 题解》项目成功突破 2w star， 并且现在 Github 搜索关键字”LeetCode”我的项目已经排名第一啦，这是继 1W star 之后的第二个巨大突破，非常感谢大家一路以来的支持和陪伴。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7q10kli5lj310m0fm74y.jpg" alt></p><p>最近在写一本关于LeetCode题解的书，有很多人表示想买，这无形之中给了我很大的压力，名字还没定，暂时给它取一个代号《攻克 LeetCode》。 </p><h2 id="新书《攻克-LeetCode》"><a href="#新书《攻克-LeetCode》" class="headerlink" title="新书《攻克 LeetCode》"></a>新书《攻克 LeetCode》</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppnnvb7yj305i04b744.jpg" alt></p><p>这里是<a href="https://lucifer.ren/blog/2019/10/03/draft/">《攻克 LeetCode》的草稿目录</a>，目前有 20 章的内容，本书要讲的内容就是 LeetCode 上反复出现的算法，经过我进一步提炼，抽取数百道题目在这里进行讲解，帮助大家理清整体思绪，从而高效率地刷题，做到事半功倍。我这里总结了 7 个常见的数据结构和 7 个常见的算法以及 5 个常见的算法思想。</p><p>7 个数据结构分别是： <code>数组，栈，队列，链表，二叉树，散列表，图</code></p><p>7 个算法分别是：<code>二分法，递归，回溯法，排序，双指针，滑动窗口，并查集</code></p><p>5 个算法思想分别是：<code>分治，贪心，深度优先遍历，广度优先遍历，动态规划</code></p><p>只有掌握了这些基础的数据结构和算法，更为复杂的算法才能得心应手，事半功倍。而 LeetCode 的题目虽然不断出新，但是最终用到的算法永远是那几个，很多题目都是穿着新的衣服的老面孔了。大家学好这些基础套路之后会更加明白这个道理。</p><p>后期可能会有大幅度修改，希望大家提出宝贵意见，以特别的方式参与到这本书的编写中来。</p><h2 id="2W-star截图"><a href="#2W-star截图" class="headerlink" title="2W star截图"></a>2W star截图</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7r4ef4fwej30rm0ld75g.jpg" alt></p><h2 id="Star-曲线"><a href="#Star-曲线" class="headerlink" title="Star 曲线"></a>Star 曲线</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pom0rbu6j30p00f1glo.jpg" alt></p><p>(star 增长曲线图)</p><h2 id="知乎引流"><a href="#知乎引流" class="headerlink" title="知乎引流"></a>知乎引流</h2><p><a href="https://github.com/azl397985856/leetcode/blob/master/thanksGiving.md" target="_blank" rel="noopener">上次</a>主要讲了项目从开始建立到拥有 1W star 的经历，本次书接前文，继续讲一下后面的故事。</p><p>上回提到知乎上的“量子位”在帮我做宣传，引入了不小的流量。 我就想为什么不自己去拉流量呢？我自己以作者的角度去回答一些问题岂不是更好，更受欢迎么？于是我就开始在知乎上回答问题，很开心其中一个还获得了专业认可。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7poxozmrmj30jw0gl0tp.jpg" alt></p><p>事实上并没有我想的那么好，我回答了两个 LeetCode 话题的内容，虽然也有几百的点赞和感谢，但是这离我的目标还差很远。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pox4k95zj309q0b1mxa.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7poz07qsrj30jk0h4q3y.jpg" alt></p><p>但是转念一想，我知乎刚起步，也没什么粉丝，并且写答案的时间也就一个月左右，这样想就好多了。 我相信将来会有更多的人看到我的答案，然后加入进来。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pozi8bfrj308907w747.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppnep24xj30to0pwaar.jpg" alt></p><h2 id="建立自己的博客"><a href="#建立自己的博客" class="headerlink" title="建立自己的博客"></a>建立自己的博客</h2><p>现在我发表的文章都是在各大平台。这有一个很大的问题就是各个平台很难满足你的需求，比如按照标签，按照日期进行归档。 甚至很多平台的阅读体验很差，比如没有导航功能，广告太多等。因此我觉得自己搭建一个博客还是很有必要的，这个渠道也为我吸引了少部分的流量，目前添加的主要内容大概有：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pp2i0818j308m07awej.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pp2vru72j30800hct8p.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pp34fjowj307z08za9y.jpg" alt></p><p>总体上来说效果还是不错的，之后的文章会在博客首发，各个平台也会陆续更新，感兴趣的可以来个 RSS 订阅，订阅方式已经在<a href="https://lucifer.ren/blog/2019/09/30/daily-featured-2019-09/">《每日一荐 - 九月刊》</a>里面介绍了。</p><h2 id="GithubDaily-的-推荐"><a href="#GithubDaily-的-推荐" class="headerlink" title="GithubDaily 的 推荐"></a>GithubDaily 的 推荐</h2><p>GithubDaily 转载了量子位的文章也为我的仓库涨了至少几百的 star，非常感谢。GithubDaily 是一个拥有 3W 多读者的公众号，大家有兴趣的可以关注一波。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pp8r6isnj30kl0eq3yo.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pp9drlz0j30j90arq31.jpg" alt></p><h2 id="其他自媒体的推荐"><a href="#其他自媒体的推荐" class="headerlink" title="其他自媒体的推荐"></a>其他自媒体的推荐</h2><p>一些其他自媒体也会帮忙推广我的项目</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppmlm7gyj30u00y10v5.jpg" alt></p><h2 id="口耳相传"><a href="#口耳相传" class="headerlink" title="口耳相传"></a>口耳相传</h2><p>我后来才知道竟然有海外华侨和一些华人社区都能看到我了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppm3upr0j30ky0mmmxv.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppk0hlauj30ss1bmq5d.jpg" alt><br>（一亩三分地是一个集中讨论美国加拿大留学的论坛）</p><p>另外通过朋友之间口耳相传的介绍也变得越来越多。</p><p>非常感谢大家一直以来的陪伴和支持，我们一起努力，加油 💪。</p><p>如果你还没有加入我们，看了这篇文章想加入，那么可以访问我的项目主页 <a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">leetcode 题解</a><br>我在这里等着你。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是如何刷 LeetCode 的？</title>
      <link href="/blog/2019/12/11/how-am-I-conque-leetcode/"/>
      <url>/blog/2019/12/11/how-am-I-conque-leetcode/</url>
      
        <content type="html"><![CDATA[<p>我就是那个 @量子位 答案里面提到的“lucifer 小哥哥”。</p><p>我本人从开始准备算法以来，大概经过了几个月的时间，这期间自己成长了很多，从刷题菜鸡，到现在对刷题套路，题型有了自己的理解，感受还是蛮多的。我本人不是算法高手，算是勤能补拙类型。不过经过几个月的学习和练习，不仅面试变得更加得心应手，而且在工作中写更容易写出干净优雅，性能好的代码。</p><a id="more"></a><p>我将自己这几个月的刷题经历都整理了下来，除了给出思路和关键点，还横向地对知识点进行整理，尽量做到<code>一题多解，多题同解</code>。 现在GitHub仓库有18k+的✨ ， 欢迎大家关注。仓库地址： <a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">azl397985856/leetcode</a></p><p>那么今天我就来回答一下这个问题，谈一下<code>我是怎么刷leetcode的</code>。</p><p>对于我来说，<code>刷题的过程其实就是学习数据结构和算法的过程</code>， 不仅仅是为了刷题而刷题，这样你才能感受到<code>刷题的乐趣</code>。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075756.png" alt></p><h2 id="第一遍按tag刷，第二遍一题多解，多题同解"><a href="#第一遍按tag刷，第二遍一题多解，多题同解" class="headerlink" title="第一遍按tag刷，第二遍一题多解，多题同解"></a>第一遍按tag刷，第二遍一题多解，多题同解</h2><p>个人建议，第一遍刷的时候可以先快速按照tag过一遍，快速感受一下常见数据结构和算法的套路，这样自己有一个感性的认识。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075757.png" alt></p><p>第二遍我们就不能像第一遍那样了，这个阶段我们需要多个角度思考问题，尽量做到<code>一题多解，多题同解</code>。我们需要对问题的本质做一些深度的理解，将来碰到类似的问题我们才能够触类旁通。</p><p>但是很多人做了几遍，碰到新题还是没有任何头绪，这是一个常见的问题，这怎么办呢？ 我们继续往下看。</p><h2 id="艾宾浩斯记忆曲线"><a href="#艾宾浩斯记忆曲线" class="headerlink" title="艾宾浩斯记忆曲线"></a>艾宾浩斯记忆曲线</h2><p>总结并记忆是学习以及刷题过程中非常重要的一环，<br>不管哪个阶段，我们都需要做对应的总结，这样将来我们再回过头看的时候，才能够快读拾起来。</p><p>信息输入大脑后，遗忘也就随之开始了。遗忘率随时间的流逝而先快后慢，特别是在刚刚识记的短时间里，遗忘最快，这就是著名的艾宾浩斯遗忘曲线。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075758.png" alt></p><p>anki就是根据<code>艾宾浩斯记忆曲线</code>开发的一个软件，它是一个使记忆变得容易的学习软件。因为它是一个自定义多功能的记忆方式，可以大大减少你的学习时间，也可以大大提高 你的学习容量。 对于我本人而言，我在anki里面写了很多leetcode题目和套路的Card，然后anki会自动帮我安排复习时间，大大减少我的认知负担，提高了我的复习效率。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-75759.png" alt></p><p>这个是我的<a href="https://github.com/azl397985856/leetcode/blob/master/assets/anki/leetcode.apkg" target="_blank" rel="noopener">anki card</a> 大家可以直接导入使用，但是还是建议大家自己制作卡片，毕竟每个人情况不一样，并且制作卡片的过程也是记忆的过程。</p><p>使用方法：</p><p>anki - 文件 - 导入 - 下拉格式选择“打包的 anki集合”，然后选中你下载好的文件，确定即可。</p><p>更多关于anki使用方法的请查看<a href="https://apps.ankiweb.net/" target="_blank" rel="noopener">anki官网</a></p><p>目前已更新卡片一览（仅列举正面）</p><ul><li>二分法解决问题的关键点是什么，相关问题有哪些?</li><li>如何用栈的特点来简化操作， 涉及到的题目有哪些？</li><li>双指针问题的思路以及相关题目有哪些？</li><li>滑动窗口问题的思路以及相关题目有哪些？</li><li>回溯法解题的思路以及相关题目有哪些？</li><li>数论解决问题的关键点是什么，相关问题有哪些?</li><li>位运算解决问题的关键点是什么，相关问题有哪些?</li></ul><h2 id="殊途同归"><a href="#殊途同归" class="headerlink" title="殊途同归"></a>殊途同归</h2><p>大家刷了很多题之后，就会发现来来回回，题目就那么几种类型，因此掌握已有题目类型是多么重要。那样leetcode出题的老师，很多也是在原有的题目基础上做了适当<code>扩展</code>（比如two-sum,two-sum2,three-sum, four-sum等等）或者<code>改造</code>（使得不那么一下子看出问题的本质，比如猴子吃香蕉问题）。</p><p>其中算法，主要是以下几种：</p><ul><li>基础技巧：分治、二分、贪心</li><li>排序算法：快速排序、归并排序、计数排序</li><li>搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等</li><li>图论：最短路径、最小生成树</li><li>动态规划：背包问题、最长子序列</li></ul><p>数据结构，主要有如下几种：</p><ul><li>数组与链表：单 / 双向链表</li><li>栈与队列</li><li>哈希表</li><li>堆：最大堆 ／ 最小堆</li><li>树与图：最近公共祖先、并查集</li><li>字符串：前缀树（字典树） ／ 后缀树</li></ul><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075800.png" alt><br>(图片来自leetcode)</p><h2 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h2><p>做到了以上几点，我们还需要坚持。这个其实是最难的，不管做什么事情，坚持都是最重要也是最难的。</p><p>为了督促自己，同时帮助大家成长，我在群里举办《每日一题》活动，每日一题是在交流群（包括微信和qq）里进行的一种活动，大家一起 解一道题，这样讨论问题更加集中，会得到更多的反馈。而且 这些题目可以被记录下来，日后会进行筛选添加到仓库的题解模块。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075801.png" alt></p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075802.png" alt></p><p>大家如果发现自己很难坚持下去，也可以加入我的群聊，我们互相监督。 另外我还专门组建了slack群，有兴趣的可以加群后在群里喊即可。</p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>大家可以关注我的公众号《脑洞前端》，公众号后台回复“大前端”，拉你进《大前端面试宝典 - 图解前端群》。回复“leetcode”，拉你进《leetcode题解交流群》</p><p>最后祝大家刷题愉快，拿到自己心仪的offer。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 学习方法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零基础的前端开发初学者应如何系统地学习？</title>
      <link href="/blog/2019/12/11/how-am-I-learn-fe/"/>
      <url>/blog/2019/12/11/how-am-I-learn-fe/</url>
      
        <content type="html"><![CDATA[<p>回想四年前我刚入行的时候，那时候很多人对于前端的看法是“切图，画页面，有个编辑器+浏览器就能干，门槛低”，现在已经完全不是那样了，可以说现在的前端这个职业的门槛虽然还是没怎么变，但是整个行业的门槛提升了，换句话说就是整个行业对于前端这个职位要求更高了，对于前端小白的需求量降低，对于高级前端的需求量还在上升，甚至是供小于求的局面。从市场经济学角度上讲你只有进入到高级级别，才能真正吃到行业的红利。  因此想要入行的朋友要先想清楚，不要头脑发热，如果你想清楚了，那么请继续往下看。<br>说实话，现在的前端大环境对初学者来说实在有点不友好，学习资料鱼龙混杂，良莠不齐，有质量很高的学习资料，也有谬论，前后不一，观点错误，或者讲述不清晰的。 更可怕的是质量低下的文章有时候更受欢迎，因此需要大家有很好的甄别能力，但这对于初学者来说实在有些困难，我在这里就来谈一下 <code>初学者如何少走弯路，并且系统性地学习前端</code>。</p><a id="more"></a><h2 id="兴趣是最好的老师"><a href="#兴趣是最好的老师" class="headerlink" title="兴趣是最好的老师"></a>兴趣是最好的老师</h2><p>兴趣不管对于学习什么来说都是最好的老师。当然前端也不例外，如果你对这一门感兴趣，绝对会对你有很大的帮助。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075824.png" alt></p><p>关于如何培养兴趣，我提一点，你可以尝试去做一些小的“发明创造”，从而激发自己内心的“成就感”。这些小发明可以是一些小工具，小页面。你可以从开源社区，比如Github或者一些论坛，甚至自己的生活中收集一些创作素材。对于我来说，我就做过一个“前端开发工作流”的软件，“siri”， “小门神”等，从而带来成就感，提升自己的兴趣。</p><h2 id="权威，权威，还是权威"><a href="#权威，权威，还是权威" class="headerlink" title="权威，权威，还是权威"></a>权威，权威，还是权威</h2><p>其实技术越往上走，越会关注标准，关注协议等更上层和抽象的东西。而制定这些协议和标准的人往往都是世界上的“殿堂级”程序员，因此关注这些东西对于他们来说就是权威，对他们来说就非常很重要，但是这对于初学者来说似乎还比较遥远。那么初学者如何对接“权威”呢？<br>刚才提到了网上的学习资料参差不齐，这其实对于入门学习来说是很不利的，就像童年时期对于整个人生的影响一样，入门阶段对于整个前端开发生涯的影响也是巨大的。关于如何初学者如何对接权威，我这里总结了以下三点：<br>看一些权威的书籍，包括前端基础，软件工程以及算法等。这里不太建议看太老的，毕竟技术的发展是很快的，以前非常经典的书并一定适合看了，尤其是初学者而言。这里前端方面我重点推荐两本书，一本是《你不知道的JS》，一本是《JavaScript语言精粹》。除了前端，你还可以看一些软工类的书，我个人比较喜欢的有《程序员修炼之道》等，算法类的有《图解算法》，《编程之美》等。其他的我就不一一赘述了，想要更多书单的可以私信我。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075825.png" alt></p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075828.png" alt></p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075830.png" alt></p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075833.png" alt></p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075836.png" alt></p><ul><li>查权威资料。 这里我推荐两个，一个是<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a>的文章，真的是又全面又专业，绝对是前端开发必备神器，哪里不会点哪里。 另外推荐一个<a href="https://developers.google.com/web/fundamentals/" target="_blank" rel="noopener">Google开发者</a> ， 里面干货很多，绝对权威。<br>这里顺便再安利一个软件，用来查文档什么的，简直如虎添翼，这个软件的名字是Dash，大家可以把自己常用的框架，类库等导进去，想用的时候直接查询即可，比去网上搜更快更高效，这个软件对于定制的支持度也是蛮高的，谁用谁知道。</li></ul><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075837.png" alt><br>（大家可以看到我下载了很多documentation）</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-75838.png" alt><br>（你可以直达某一个documentation搜索，也可以全局搜索，甚至可以搜goole和stackoverflow，是不是很贴心？）</p><ul><li>关注一些圈内权威人士。 我一般会关注几个圈内比较知名的人的知乎，微博和twitter。这是我关注的<a href="https://github.com/azl397985856?tab=following" target="_blank" rel="noopener">Github的权威人士列表</a>。其实这些都是公开的，你也可以点开我的知乎，微博资料看我或者大佬们关注了谁。</li></ul><h2 id="做一些完整的简单项目"><a href="#做一些完整的简单项目" class="headerlink" title="做一些完整的简单项目"></a>做一些完整的简单项目</h2><p>大家可以尝试做一些简单的项目，不要嫌简单。 在做的过程往往能发现很多问题，如果有问题那这正好是自己提高的机会。 如果你觉得很简单，也没有关系，你可以思考一下，我有没有可能做的更好？我能不能把这些东西封装起来，建立更高一层的抽象（A New Level of Abstraction），做到DRY(Don’t Repeat Yourself)。<br>接下来就是关于怎么找项目。 你可以找个正式工作或者实习来做，也可以自己找一些小项目来练手， 比较常见的练手项目有模仿某个网站，APP或者搭建自己的个人主页，博客系统等。做好了不仅可以当敲门砖，说不定会收益很长时间呢。实在没有什么项目练手，这里再推荐一个网站，你可以再上面打怪升级。<a href="https://user-gold-cdn.xitu.io/2019/9/15/16d34514876b8c4d" target="_blank" rel="noopener">freecodecamp</a><br>现在你已经掌握了前端开发的基本概念和技能，那么如何做到更进一步，持续成长，做到高级呢？我相信这是很多人的疑问，下面我们就来看一下。</p><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p>你可能已经听过过大前端这个词，我这里不是劝退你哦。以下内容很高能，不过很多知识点不知道没关系，因为就算是工作了很多年了老手也很难了解其中的大半知识点。<br>我个人为了让自己巩固知识，同时也为了帮助他人，总结了大前端下的30多个主题内容，内容覆盖大前端的方方面面，虽然是从面试角度出发，但是你用来提升自己，查缺补漏也是很有用的。</p><p>多图预警：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075842.png" alt></p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075843.png" alt></p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075844.png" alt></p><p>拿《编程题》主题来说，我总结了各大公司常考的几十道题目。<br><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075847.png" alt></p><p>对于其他主题也是一样，我都会尽可能地深度讲解和剖析，并且从多方面理解，我相信这是在市面上很少见的。</p><p>而且我还画了很多图，来帮助大家理解一些抽象的知识点。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075850.png" alt></p><p>项目地址： <a href="https://lucifer.ren/fe-interview/#/">https://lucifer.ren/fe-interview/#/</a>   欢迎围观。</p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075854.png" alt></p><p>实话实说，很多优秀的思想，规范，写法我都是从优秀的开源项目中学来的。 我会不定期阅读一些优秀的开源项目源码，也会参与到开源的工作中去，这给我自己带来了很大的提升。 不仅技术得到了提升，团队协作，规范化等方面也有了质的提高，另外还认识了一些优秀的人。四年来，我阅读了很多优秀的源码，也尝试自己去造一些轮子，并开源出去，回馈社区。</p><h2 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入 + 输出"></a>输入 + 输出</h2><p>前面重点讲述的是输入。 其实学习的过程不仅仅是输入，输出也是很好的学习方法。 输出的形式有很多，比如写博客，讲给别人，开源出去让别人用等。 这其实是很好的学习机会，这种学习方法可以让你的成长速度呈指数型增长，因此千万不要小看它。 我会通过以练代学的方式来学习，比如我学习React，我会迅速看文档，然后写demo，最后我会自己<a href="https://github.com/azl397985856/mono-react" target="_blank" rel="noopener">《从零实现React》</a>来内化它。</p><p>我还会定期做总结，写文章，写开源项目，做分享等，目的一方面是影响他人，另一方面是成长自己。</p><h2 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h2><p>选择了技术这条路，就要做好持续学习，每日精进的准备，跟上时代潮流是很有必要的。</p><ul><li>日报周报。 大家可以订阅一些前端方面的日报周报，这方面其实有很多，这里只推荐一个我常看的一个<a href="https://javascriptweekly.com" target="_blank" rel="noopener">JavaScript周刊</a>。我自己也出了一款<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">《每日一荐》</a>, 每天推荐一个优秀的开源项目，优秀文章， 周一到周五我们不见不散。</li></ul><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075855.png" alt></p><ul><li>深度参与开源项目。 关于如何参与开源项目其实可以另起一篇文章了，这里不再赘述，感性的话，我会再写一篇文章，大家记得关注我就好。</li><li>定期总结，技术输出。 我的习惯是对于学习的内容定期和不定期地进行总结。 比如最近我在总结的[《leetcode题解》]（现在有18k+ ✨了）(<a href="https://github.com/azl397985856/leetcode)，[《大前端面试宝典》](https://github.com/azl397985856/fe-interview)" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode)，[《大前端面试宝典》](https://github.com/azl397985856/fe-interview)</a></li></ul><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075856.png" alt></p><blockquote><p>千万不要觉得算法对前端不重要，算法，网络，操作系统属于基础，从事相关工作的都应该认真学习，打好基础才行。</p></blockquote><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>大家可以关注我的公众号《脑洞前端》，公众号后台回复“大前端”，拉你进《大前端面试宝典 - 图解前端群》。回复“leetcode”，拉你进《leetcode题解交流群》</p><p>最后祝大家在前端的路上越走越远。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog/2019/12/11/ibinhouse/"/>
      <url>/blog/2019/12/11/ibinhouse/</url>
      
        <content type="html"><![CDATA[<p>信息输入大脑后，遗忘也就随之开始了。遗忘率随时间的流逝而先快后慢，特别是在刚刚识记的短时间里，遗忘最快，这就是著名的艾宾浩斯遗忘曲线。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>从老鼠试毒问题来看二分法</title>
      <link href="/blog/2019/12/11/laoshushidu/"/>
      <url>/blog/2019/12/11/laoshushidu/</url>
      
        <content type="html"><![CDATA[<p>很多人对于二分法的理解比较片面，之前碰到一个题目，从一个先升序后降序的数列中，比如 1 2 3 7 4 3 2 中运用二分法去查找一个给定的元素，很多人说根本不能二分，因为没有排序。其实 这道题完全可以使用二分查找进行解答， 如果你觉得不可以的话，很可能对二分法理解还比较片面。  这里以另外一个更加有趣（至少我认为）的例子来讲解一下二分法。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>面试题： 有1000个一模一样的瓶子，其中有1瓶是毒药，老鼠喝了有毒的会在24h之后死亡。求最少需要多少老鼠才能在24h里找到有毒的那瓶。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这道题的解法有很多，今天我们来聊下用二分法来解这道题。 这道题似乎和我们看的的常见的二分法有很大的区别，但是仔细想一下， 二分法本质是将问题的规模缩小到原有的一半，带着这样的思想我们再来看一下。类似的，三分法就是将问题规模缩小为原来的1/3. </p><p>我们先对1000个瓶子进行编号，从1-1000这样子。 不过我们不是通过我们大家平时生活中使用的十进制，而是使用再计算机中使用的二进制， 同时让大家感受一下二进制的魅力。</p><p>为了方便讲解，我们假设不是1000个瓶子，而是4个。</p><p>我们来编一下号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 // #1</span><br><span class="line">01 // #2</span><br><span class="line">10 // #3</span><br><span class="line">11 // #4</span><br></pre></td></tr></table></figure><p>我们的目标是找到哪个瓶子有毒，换句话说我们目标是找到有毒瓶子的编号，再换句话说我们的目标是<br>找到有毒瓶子的3个bit分别是什么，是0还是1.</p><p>比如有毒的是3号瓶子，那么我们就是想确认第一个bit是0，第二个bit是1，第三个bit是1，即011，转化为10进制就是3号。</p><p>那么如何确定每一个bit是什么呢？   回想一下，我们手上有老鼠，老鼠有两个state，alive 或者 died，这就是我们拥有的全部。</p><p>接下来我们逐一对瓶子进行分组，分组的依据就是每一个bit的值。</p><p>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 00 01     #g1:1  第一个bit是0</span><br><span class="line">// 10 11     #g1:2  第一个bit是1</span><br><span class="line">// 00 10     #g2:1  第二个bit是0</span><br><span class="line">// 01 11     #g2:2  第二个bit是1</span><br></pre></td></tr></table></figure><p>我们来找第一个老鼠#1 来喝g:1:1, 如果他死了，那么毒就在这一组，也就是说毒的第一个bit是0，否则是1</p><p>我们来找第二个老鼠#2 来喝g:2:1, 如果他死了，那么毒就在这一组，也就是说毒的第二个bit是0，否则是1</p><p>所以我们可以看出, 两只老鼠就搞定了，我们按照这个思路，可以推到出1000个瓶子只需要10个瓶子, 即  log2 1000， 2的10次方是1024，因此10个老鼠够了，如果1025个瓶子的话，就需要11个老鼠了。</p><p>如果你仔细思考的话，不难看出，我们是在用老鼠喝了水之后的反应（生或死）来进行判断每一个bit的数字，不管生死，我们总能得出这个bit的值，是0还是1.  因此每使用一只老鼠我们都将问题规模缩小为原来的1／2. 这是典型的二分法。</p><h3 id="这是最优解么"><a href="#这是最优解么" class="headerlink" title="这是最优解么"></a>这是最优解么</h3><p>是的，这是最优解，如果你愿意用严格的数学来证明的话，你可以试一下数学归纳法。  如果你想感性的判断一下的话，可以继续往下读。</p><p>什么是最优解？  最优解就是要让未知世界无机可乘，也就是说在最坏的情况下得到最优（现实世界都是未知的）。上面的例子，不管小老鼠是生还是死，我们都可以将问题规模缩小到1/2. 也就是说最坏的情况就是最好的情况，也就是说没有最坏情况。</p><p>那么我们是否可以将问题规模缩小的1／3 或者更小呢？</p><h3 id="我们可以三分么"><a href="#我们可以三分么" class="headerlink" title="我们可以三分么"></a>我们可以三分么</h3><p>简单来说，不可以， 因为老鼠只有两种observable state， 即alive， died. 假如我们有10个小球，其中有一个是异常的，其他9个都是一样的，我们怎么才能通过最少的称量来确定是哪一个异常，是重还是轻？ 这个时候我们就可以使用三分法了，为什么？因为天平有三个state， 平衡，左倾，右倾，使得我们”有可能“ 将问题规模缩小为1/3， 事实上，确实可以实现将问题规模缩小到1/3。</p><p>我会在之后的文章中进行讲解小球的问题最优策略， 并解释为什么这是最优策略。 </p><h3 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h3><p>基于比较的排序都无法逃脱nlogn时间复杂度的命运，这是为什么？能否利用本篇文章的思想进行解释？</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode题解】1186.删除一次得到子数组最大和</title>
      <link href="/blog/2019/12/11/leetcode-1186/"/>
      <url>/blog/2019/12/11/leetcode-1186/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1186题，最大子数组的进阶版本。</p><a id="more"></a><h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。</span><br><span class="line"></span><br><span class="line">换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</span><br><span class="line"></span><br><span class="line">注意，删除一个元素后，子数组 不能为空。</span><br><span class="line"></span><br><span class="line">请看示例：</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：arr = [1,-2,0,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：arr = [1,-2,-2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们直接选出 [3]，这就是最大和。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：arr = [-1,-1,-1,-1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。</span><br><span class="line">     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= arr.length &lt;= 10^5</span><br><span class="line">-10^4 &lt;= arr[i] &lt;= 10^4</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>符合知觉的做法是求出所有的情况，然后取出最大的。 我们只需要两层循环接口，外循环用于确定我们丢弃的元素，内循环用于计算subArraySum。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">maximumSum</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">      res = arr[<span class="number">0</span>]</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">maxSubSum</span><span class="params">(arr, skip)</span>:</span></span><br><span class="line">          res = maxSub = float(<span class="string">"-inf"</span>)</span><br><span class="line">         </span><br><span class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">              <span class="keyword">if</span> i == skip:</span><br><span class="line">                  <span class="keyword">continue</span></span><br><span class="line">              maxSub = max(arr[i], maxSub + arr[i])</span><br><span class="line">              res = max(res, maxSub)</span><br><span class="line">          <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 这里循环到了len(arr)项，表示的是一个都不删除的情况</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr) + <span class="number">1</span>):</span><br><span class="line">          res = max(res, maxSubSum(arr, i))</span><br><span class="line">      <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h3><p>上面的做法在LC上会TLE， 因此我们需要换一种思路，既然超时了，我们是否可以从空间换时间的角度思考呢？我们可以分别从头尾遍历，建立两个subArraySub的数组l和r。 其实这个不难想到，很多题目都用到了这个技巧。</p><p>具体做法：</p><ul><li>一层遍历， 建立l数组，l[i]表示从左边开始的以arr[i]结尾的subArraySum的最大值</li><li>一层遍历， 建立r数组，r[i]表示从右边开始的以arr[i]结尾的subArraySum的最大值</li><li>一层遍历， 计算 l[i - 1] + r[i + 1] 的最大值 <blockquote><p>l[i - 1] + r[i + 1]的含义就是删除arr[i]的子数组最大值</p></blockquote></li><li>上面的这个步骤得到了删除一个的子数组最大值， 不删除的只需要在上面循环顺便计算一下即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumSum</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        l = [arr[<span class="number">0</span>]] * n</span><br><span class="line">        r = [arr[n - <span class="number">1</span>]] * n</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">        res = arr[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            l[i] = max(l[i - <span class="number">1</span>] + arr[i], arr[i])</span><br><span class="line">            res = max(res, l[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            r[i] = max(r[i + <span class="number">1</span>] + arr[i], arr[i])</span><br><span class="line">            res = max(res, r[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            res = max(res, l[i - <span class="number">1</span>] + r[i + <span class="number">1</span>])</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>上面的算法虽然时间上有所改善，但是正如标题所说，空间复杂度是O(n),有没有办法改进呢？答案是使用动态规划。</p><p>具体过程：</p><ul><li>定义max0，表示以arr[i]结尾且一个都不漏的最大子数组和</li><li>定义max1，表示以arr[i]或者arr[i - 1]结尾，可以漏一个的最大子数组和</li><li>遍历数组，更新max1和max0（注意先更新max1，因为max1用到了上一个max0）</li><li>其中<code>max1 = max(max1 + arr[i], max0)</code>, 即删除arr[i - 1]或者删除arr[i]</li><li>其中<code>max0 = max(max0 + arr[i], arr[i])</code>， 一个都不删除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @lc app=leetcode.cn id=1186 lang=python3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [1186] 删除一次得到子数组最大和</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=start</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumSum</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># DP</span></span><br><span class="line">        max0 = arr[<span class="number">0</span>]</span><br><span class="line">        max1 = arr[<span class="number">0</span>]</span><br><span class="line">        res = arr[<span class="number">0</span>]</span><br><span class="line">        n = len(arr)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> max0</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 先更新max1，再更新max0，因为max1用到了上一个max0</span></span><br><span class="line">            max1 = max(max1 + arr[i], max0)</span><br><span class="line">            max0 = max(max0 + arr[i], arr[i])</span><br><span class="line">            res = max(res, max0, max1)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>空间换时间</li><li>头尾双数组</li><li>动态规划</li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://github.com/azl397985856/leetcode/blob/master/problems/42.trapping-rain-water.md" target="_blank" rel="noopener">42.trapping-rain-water</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零打造一个舒服的Mac开发环境 - 装机篇</title>
      <link href="/blog/2019/12/11/mac-setup-for-fe/"/>
      <url>/blog/2019/12/11/mac-setup-for-fe/</url>
      
        <content type="html"><![CDATA[<p>前两天新买的16寸mac pro到手了。 本来想直接将旧电脑的数据做一个迁移，但是有同学反应想看“如何从零打造一个舒适的开发环境”，于是就有了这篇文章。</p><a id="more"></a><h2 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g994m51omoj30u01ppn1d.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g994ny143uj30p40nctad.jpg" alt></p><h2 id="配置和价格"><a href="#配置和价格" class="headerlink" title="配置和价格"></a>配置和价格</h2><p>在正式开始之前，我们先来介绍下主机的配置。</p><ul><li>2.3GHz 8-core 9th-generation Intel Core i9 processor</li><li>Turbo Boost up to 4.8GHz</li><li>AMD Radeon Pro 5500M with 4GB of GDDR6 memory</li><li>32GB 2666MHz DDR4 memory</li><li>1TB SSD storage¹</li><li>16-inch Retina display with True Tone</li><li>Touch Bar and Touch ID</li><li>Four Thunderbolt 3 ports</li></ul><p>这个电脑要比15寸的pro重100多克，扬声器，显卡要比15寸的更加好一点，touch bar重也将ESC和TouchID做成了实体键，最关键的是和15寸价格一样，我这个配置下来价格是<code>RMB 25,135</code> 。</p><h2 id="如何从零打造一个舒适的开发环境"><a href="#如何从零打造一个舒适的开发环境" class="headerlink" title="如何从零打造一个舒适的开发环境"></a>如何从零打造一个舒适的开发环境</h2><ul><li><a href="https://github.com/azl397985856/mac-setup" target="_blank" rel="noopener">文字版</a></li><li><a href="https://www.bilibili.com/video/av76756338" target="_blank" rel="noopener">视频版P1&amp;P2</a></li></ul><blockquote><p>视频录制的声音比较小</p></blockquote><h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>本期视频只是一个简单的装机，以及系统配置。并不涉及到软件的深度使用，如果感兴趣可以给我留言，我会在之后给大家带来相关的攻略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 装机 </tag>
            
            <tag> 必备软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一荐 2019-11 汇总</title>
      <link href="/blog/2019/12/11/daily-featured-2019-11/"/>
      <url>/blog/2019/12/11/daily-featured-2019-11/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8d0sktqrwj30hs07maae.jpg" alt></p><p>每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。</p><p>项目主页维护当前月份的内容，想看往期内容，可以去<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">每日一荐主仓库</a>翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。</p><a id="more"></a><h2 id="2019-11"><a href="#2019-11" class="headerlink" title="2019-11"></a>2019-11</h2><h3 id="2019-11-29-网站"><a href="#2019-11-29-网站" class="headerlink" title="2019-11-29[网站]"></a>2019-11-29[网站]</h3><p>之前我在每日一题出了一道题<a href="https://github.com/azl397985856/fe-interview/issues/16" target="_blank" rel="noopener"> 2019-08-16 - 怎么在浏览器中操作本地的文件</a>。 一个可行的思路就是在本地创建一个服务器，比如 node 服务器，浏览器操作发送请求到服务器，然后 node 去操作本地文件。</p><p>现在 Chrome 支持 native fs api，使得这个过程原生支持，想要体验的可以访问这里 <a href="https://labs.vaadin.com/native-fs/" target="_blank" rel="noopener">https://labs.vaadin.com/native-fs/</a> ， 如果你愿意，你可以将它添加为 Chrome APP。</p><h3 id="2019-11-28-工具"><a href="#2019-11-28-工具" class="headerlink" title="2019-11-28[工具]"></a>2019-11-28[工具]</h3><p>今天给大家推荐的工具是效率类软件 Alfred 的灵魂 workflows（工作流）。</p><p>以下是我使用频率比较高的 workflow，使用频率低的会被我定期清理掉。</p><blockquote><p>我自己制作的工作流不在这里展示和推荐</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dintchy7j30950ay74e.jpg" alt></p><p>下载地址：</p><ul><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/ChromeBookmarks.alfredworkflow" target="_blank" rel="noopener">Chrome Bookmarks</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/Colors.alfredworkflow" target="_blank" rel="noopener">Colors</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11Dash.alfredworkflow" target="_blank" rel="noopener">Dash</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/KillProcess.alfredworkflow" target="_blank" rel="noopener">Kill Process</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/RamdaDocs.alfredworkflow" target="_blank" rel="noopener">RamdaDocs</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/TerminalFinder.alfredworkflow" target="_blank" rel="noopener">TerminalFinder</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/YosemiteiOSSimulator.alfredworkflow" target="_blank" rel="noopener">Yosemite iOS Simulator</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/Youdao.alfredworkflow" target="_blank" rel="noopener">Youdao</a></p></li></ul><h3 id="2019-11-27-软件"><a href="#2019-11-27-软件" class="headerlink" title="2019-11-27[软件]"></a>2019-11-27[软件]</h3><p>mac 端不能右键新建文件，这在某些时候不是很方便。 没有这个软件的时候，我是在编辑器中新建或者是使用 touch 命令。 使用了这个<code>New File Menu</code>软件之后多了一种更方便的选择，你可以直接右键新建，Just Like Windows Users。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9b8meuak2j30gu04yaa8.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9b8k1tqqdj30od0f7n3b.jpg" alt></p><p>地址： <a href="https://apps.apple.com/cn/app/new-file-menu/id1064959555?l=en&amp;mt=12" target="_blank" rel="noopener">https://apps.apple.com/cn/app/new-file-menu/id1064959555?l=en&amp;mt=12</a></p><h3 id="2019-11-26-网站"><a href="#2019-11-26-网站" class="headerlink" title="2019-11-26[网站]"></a>2019-11-26[网站]</h3><p>一个网站，可以分析的 Github 仓库，采用手绘风格，对于厌倦了标准图形的我来说简直是耳目一新的感觉。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9aj5o2tu5j30qv0pmgmq.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9aj7mseg4j30qr0cyjrn.jpg" alt></p><p>项目地址： <a href="https://repo-analytics.github.io/" target="_blank" rel="noopener">https://repo-analytics.github.io/</a></p><h3 id="2019-11-25-技巧"><a href="#2019-11-25-技巧" class="headerlink" title="2019-11-25[技巧]"></a>2019-11-25[技巧]</h3><p>Chrome 开发者工具有非常好用但是却鲜为人知的功能。今天给大家介绍一个功能 - 代码覆盖率。 指的是你下载的代码有多少是被执行了的，这在做性能优化的时候很有用。如果一些代码根本没执行，就可以延迟加载。</p><p>使用方法：</p><ul><li><code>Ctrl+Shift+P</code> for windows <code>CMD+Shift+P</code> for mac</li><li>输入 coverage， 选择如图的选项，并确定。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9a2gz99paj30f504hglj.jpg" alt></p><p>然后你就能看到检测结果了：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9a2h750eij30fk0563yl.jpg" alt></p><h3 id="2019-11-22-工具"><a href="#2019-11-22-工具" class="headerlink" title="2019-11-22[工具]"></a>2019-11-22[工具]</h3><p>Github Large File Storage （简称 git-lfs）, 可以用来存储大文件，比如上 GB 的大文件，相比于传统的 Github 存储，这种方式空间更大，速度更快，并且工作流程和传统 Git flow 并无二致。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g95pqj3vo9j30rs0gowec.jpg" alt></p><p>地址：<a href="https://git-lfs.github.com/" target="_blank" rel="noopener">https://git-lfs.github.com/</a></p><h3 id="2019-11-21-娱乐"><a href="#2019-11-21-娱乐" class="headerlink" title="2019-11-21[娱乐]"></a>2019-11-21[娱乐]</h3><p>文章标题 【The skeptic’s guide to interpreting developer marketing speak 🗺️】 - 暂翻译为【如何翻译开发人员的营销术语】</p><p>里面讲了各种开发人员常用的营销术语，以及对应我们应该怎么去解读 ta。比如：</p><ul><li><code>现代化</code> 就是说<code>刚刚git init</code></li><li><code>AI加持</code> 就是说<code>无数的if else switch case语句</code></li><li><code>最小化</code> 就是说<code>没有测试用例，没有例子</code></li><li><code>跨平台</code> 就是说<code>我听说Electron可以跨平台，于是我就用它写了</code></li><li>…</li></ul><p>文章地址： <a href="https://changelog.com/posts/the-skeptics-guide-to-interpreting-developer-marketing-speak" target="_blank" rel="noopener">https://changelog.com/posts/the-skeptics-guide-to-interpreting-developer-marketing-speak</a></p><h3 id="2019-11-20-工具"><a href="#2019-11-20-工具" class="headerlink" title="2019-11-20[工具]"></a>2019-11-20[工具]</h3><p>微信的一个插件，功能有很多。 不过目前已经不再维护了。</p><ul><li>消息自动回复</li><li>消息防撤回</li><li>远程控制(已支持语音)</li><li>微信多开</li><li>第二次登录免认证</li><li>聊天置底功能(类似置顶)</li><li>微信窗口置顶</li><li>会话多选删除</li><li>自动登录开关</li><li>通知中心快捷回复</li><li>聊天窗口表情包复制 &amp; 存储<br>…</li></ul><p>我用的比较多的功能恐怕就是双开和防撤回了。</p><ul><li><p>消息防撤回<br><img src="http://upload-images.jianshu.io/upload_images/965383-30cbea645661e627.gif?imageMogr2/auto-orient/strip" alt="消息防撤回.gif"></p></li><li><p>微信多开<br><img src="http://upload-images.jianshu.io/upload_images/965383-51d8eae02d48fda9.gif?imageMogr2/auto-orient/strip" alt="微信多开.gif"></p></li></ul><p>仓库地址：<a href="https://github.com/TKkk-iOSer/WeChatPlugin-MacOS/tree/master" target="_blank" rel="noopener">https://github.com/TKkk-iOSer/WeChatPlugin-MacOS/tree/master</a></p><h3 id="2019-11-19-工具"><a href="#2019-11-19-工具" class="headerlink" title="2019-11-19[工具]"></a>2019-11-19[工具]</h3><p>JS 依赖检测工具，可以用来生成图片，可视化程度很高，还可以做成自动化，集成到 CI CD ，支持 CommonJS，AMD 和 ES Module。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g92f3pun36j30h90awt8w.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g92f3yps0zj30a905g745.jpg" alt></p><p>项目地址： <a href="https://github.com/pahen/madge" target="_blank" rel="noopener">https://github.com/pahen/madge</a></p><h3 id="2019-11-18-娱乐"><a href="#2019-11-18-娱乐" class="headerlink" title="2019-11-18[娱乐]"></a>2019-11-18[娱乐]</h3><p>今天给大家推荐一个在线 nokia 短信图片生成器，可以自己输入短语，一键生成。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91bohz6xyj30hc0j9di2.jpg" alt></p><p>网站地址： <a href="https://zzkia.noddl.me:8020/" target="_blank" rel="noopener">https://zzkia.noddl.me:8020/</a></p><h3 id="2019-11-15-网站"><a href="#2019-11-15-网站" class="headerlink" title="2019-11-15[网站]"></a>2019-11-15[网站]</h3><p>有的什么我们需要在 Google Play 上下载软件，但是苦于没有通畅的网络(关于如何获取畅通的网络我在 2019-11-01 讲到，感兴趣可以翻过去看看)。因此一个 Google Play 镜像就很重要了。 这就如同我们 npm 和 cnpm 的关系。我们可以在这里直接下载 apkx。</p><blockquote><p>apkx 需要特殊的安装工具，或者一些小技巧才能安装。</p></blockquote><p>网站地址： <a href="https://apkpure.com/" target="_blank" rel="noopener">https://apkpure.com/</a></p><h3 id="2019-11-14-技巧"><a href="#2019-11-14-技巧" class="headerlink" title="2019-11-14[技巧]"></a>2019-11-14[技巧]</h3><p>很多时候我们会看到一些英文的简写。比如邮件，IM 等，这些简称能够帮我们提高沟通效率，如果你不知道一些常见的简写，沟通的时候就难免有障碍，以下是一些常见的简写，欢迎补充。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wp5bq01zj30hs18xn0d.jpg" alt></p><h3 id="2019-11-13-技巧"><a href="#2019-11-13-技巧" class="headerlink" title="2019-11-13[技巧]"></a>2019-11-13[技巧]</h3><p>今天要分享的是关于 Bash 中历史记录那些事。</p><ul><li>第一个要介绍的是<code>history</code>, history is an alias for fc -l 1,你可以通过这个命令来查看最近你使用的命令。 然后你可以用!n(n 指的是 history 命令返回的命令编号)再次执行。其中有许多缩写，最有用的就是 !$， 用于指代上次键入的参数，!! 可以指代上次键入的命令。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8vi04t5qnj307j02baa0.jpg" alt></p><ul><li><p>第二个要介绍的是历史搜索<code>ctrl + r</code>, 然后输入你想搜索的关键字即可</p></li><li><p>第三个要介绍的是<code>上下方向键</code>，你可以通过他在历史记录中上下移动。即按下上返回当前上一个命名，按下下返回当前下一个命令。</p></li><li><p>还有一个小插曲，似乎和历史有那么一点点关系。 就是<code>cd -</code>,切换到上一次的工作路径</p></li></ul><p>如果你还知道什么和历史记录相关的命令，欢迎大家补充。</p><h3 id="2019-11-12-技巧"><a href="#2019-11-12-技巧" class="headerlink" title="2019-11-12[技巧]"></a>2019-11-12[技巧]</h3><p>dig 命令是常用的域名查询工具，可以用来测试域名系统工作是否正常。</p><p>如下<code>dig lucifer.ren</code>， 可以发现很多信息，包括域名最终解析到了到了另外一个域名<code>azl397985856.github.io</code>, IP 是<code>185.199.108.153</code>.</p><p>这个工具在很多情况下非常有用，尤其是对于喜欢命令行的你来说。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ugp99e01j30hj0d8mxo.jpg" alt></p><p>其实 dig 是<code>usr/bin</code>下的一个可执行文件，更多用法请<code>man dig</code>查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="built_in">type</span> dig</span><br><span class="line"><span class="comment"># dig is /usr/bin/dig</span></span><br></pre></td></tr></table></figure><h3 id="2019-11-11-分享"><a href="#2019-11-11-分享" class="headerlink" title="2019-11-11[分享]"></a>2019-11-11[分享]</h3><p>今天是双十一，大家剁手快乐。</p><p>今天给大家分享一下前一段时间刚刚举行的大会<code>React Conf 2019</code>，这个是 React 最高规模的技术会议。喜欢 React 的小伙伴千万不要错过了，这里有全套视频。</p><p>地址：<a href="https://www.youtube.com/playlist?list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh</a></p><h3 id="2019-11-08-好文"><a href="#2019-11-08-好文" class="headerlink" title="2019-11-08[好文]"></a>2019-11-08[好文]</h3><p>前几天读了一篇文章《Scaling webapps for newbs &amp; non-techies》，文章从最简单的单体应用，逐步讲到大型应用架构，不仅讲的通俗易懂，并且图画的也非常好，是我喜欢的风格。 很期待他的第二篇《the cloud for newbs and non-techies》。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pr18vd6ij30jg0bu74f.jpg" alt><br>（A single server + database）<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pr1kkny7j30jg0al74f.jpg" alt><br>（Adding a Reverse Proxy）</p><p>文章地址： <a href="https://arcentry.com/blog/scaling-webapps-for-newbs-and-non-techies/" target="_blank" rel="noopener">https://arcentry.com/blog/scaling-webapps-for-newbs-and-non-techies/</a></p><h3 id="2019-11-07-学习方法"><a href="#2019-11-07-学习方法" class="headerlink" title="2019-11-07[学习方法]"></a>2019-11-07[学习方法]</h3><p>前一段时间看了一篇文章 -《如何构建自己的产品知识库》。这篇文章的亮点在于其所提到的技巧能够横向类比到任何领域。换句话说你可以按照它将的方法构建你自己的知识库。</p><p>里面有一句话<code>产品知识体系是对产品知识搜集、筛选、整理后形成的知识组合，并且这些知识能够用于解决实际遇到的问题。</code> 学习任何知识又何尝不是呢？很多人问我学习方法，其实这个东西非常地系统，很难通过几个技巧完成，也很难在短期内看到很明显的效果。大家可以看一下，说不定对你的学习和生活所有启发，即便你不是一个产品经理。</p><p>文章地址: <a href="https://www.toutiao.com/a6738596936057618951/" target="_blank" rel="noopener">https://www.toutiao.com/a6738596936057618951/</a></p><blockquote><p>后期如果有机会的话，我也会分享一下自己的学习方法</p></blockquote><h3 id="2019-11-06-工具"><a href="#2019-11-06-工具" class="headerlink" title="2019-11-06[工具]"></a>2019-11-06[工具]</h3><p>像 PS 和 Sketch 一样，figma 也是一个设计工具，和其他相比团队显得更简单，这点有点像蓝湖。做设计的同学要了解起来了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nh14xlj6j30tn0fbdhb.jpg" alt></p><p>地址： <a href="https://www.figma.com/" target="_blank" rel="noopener">https://www.figma.com/</a></p><h3 id="2019-11-05-观点"><a href="#2019-11-05-观点" class="headerlink" title="2019-11-05[观点]"></a>2019-11-05[观点]</h3><p>VSCode 和 MDN 进行了官方联动，<a href="https://code.visualstudio.com/updates/v1_38#_mdn-reference-for-html-and-css" target="_blank" rel="noopener">详情</a>.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8mx8cmd5vj30lh0eo0vr.jpg" alt></p><p>再也不用跳出 IDE 用 Dash 查了。 用 Alfred + Dash 虽然方便，但是不免有一种<code>应用跳出</code>的感觉。现在就很方便了，如果之后有更多的联动支持，相信体验会越来越好。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8mxbj2wh4j30fn0dfaah.jpg" alt></p><h3 id="2019-11-04-好文"><a href="#2019-11-04-好文" class="headerlink" title="2019-11-04[好文]"></a>2019-11-04[好文]</h3><p>最近几年啊，我本人也看了很多关于微服务的介绍，理念，落地等技术文章，今天给大家推荐一篇阿里飞冰团队发布的技术文，这或许是最简单的微服务落地技术文章。这篇文章详细讲述了业务场景，并详细记录了解决问题的过程以及对比了业界的一些解决方案，管中窥豹，让读者慢慢走进微服务，从这篇文章可以学习到<code>icestark</code>这个微服务的解决方案是怎么从从到有再到落地产生实际业务价值的。</p><p>文章地址： <a href="https://zhuanlan.zhihu.com/p/88449415#h5o-9" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88449415#h5o-9</a></p><h3 id="2019-11-01-工具"><a href="#2019-11-01-工具" class="headerlink" title="2019-11-01[工具]"></a>2019-11-01[工具]</h3><p>身为一个程序员，科学上网是标配。市面上免费的软件大多不稳定，出了问题很难及时解决。 自建服务器虽然好，但是还是有一点繁琐的，尤其是碰到了“开会”，IP 端口就会被封锁，自己处理就比较麻烦了。</p><p>今天给大家推荐一下 SSNG 的订阅功能，有了这个订阅地址就相当于有了无数的<code>自建服务器</code>，然后你可以在不同的节点之间进行切换。一般而言，我会对服务器进行测速，然后选择速度最快，如果某一个服务器挂了，我只需要一键切换到另外一个即可，无需额外操作。</p><p>市面上有很多这种订阅服务，这里推荐一个付费的服务 <a href="https://my.kynetwork.asia/aff.php?aff=12225&gid=8" target="_blank" rel="noopener">KyCloud</a>，挺便宜的，我订阅的是 45／季度，平均一个月 15，50G 流量，基本对于我来说非常够用了。</p><p>使用方式也非常简单，只需要以下三步即可。</p><ol><li>下载对应客户端</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8icx1bv11j30980bcgls.jpg" alt></p><ol start="2"><li>点击复制订阅地址</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8icwarcwmj30a70a0wef.jpg" alt></p><ol start="3"><li>将地址粘贴到客户端</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8icygoun8j30ec058aag.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8icz2pwwuj30d704vjr9.jpg" alt></p><p>提示： 你也可以像我一样测速，然后根据速度选择节点。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iczzsgq4j308s05ot8s.jpg" alt></p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>我重新整理了下自己的公众号，并且我还给它换了一个名字<code>脑洞前端</code>，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。</p><p>之后我的文章会同步到微信公众号 <code>脑洞前端</code> ，你可以关注获取最新的文章，并和我进行交流。</p><p>另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。</p><img width="300" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7he9xdtmyj30by0byaac.jpg">]]></content>
      
      
      <categories>
          
          <category> 每日一荐 </category>
          
          <category> 2019-11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《LeetCode题解攻略》 - 草稿目录</title>
      <link href="/blog/2019/12/11/draft/"/>
      <url>/blog/2019/12/11/draft/</url>
      
        <content type="html"><![CDATA[<p>这个我为自己的新书写的一个目录，计划在一星期左右定下来大体目录，然后投入完善，希望大家多提意见，你的意见很可能会影响到这本书的内容，期待你以特别的方式参与进来，此致敬礼。</p><a id="more"></a><h2 id="1-准备知识"><a href="#1-准备知识" class="headerlink" title="1. 准备知识"></a>1. 准备知识</h2><h3 id="1-1-学习这本书之前需要什么基础"><a href="#1-1-学习这本书之前需要什么基础" class="headerlink" title="1.1 学习这本书之前需要什么基础"></a>1.1 学习这本书之前需要什么基础</h3><p>很多人觉得算法很难，需要很多公式以及数学知识。 其实并不是这样的，除非你是做算法岗位，否则并不会要求你对数学，几何学，概率学有多深的造诣，其实更看重的是分析问题，解决问题的能力和基础编码能力。</p><p>但是我们不排除LeetCode有一些数学题目，我们会在后面的章节中讲到，但是说实话LeetCode的数学题目不会涉及很难的数学知识。而且通常我们也可以通过变通的方式解决，比如LeetCode有一道水壶倒水的问题，以下是题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个装满水的 8 升满壶和两个分别是 5 升、3 升的空壶，请想个优雅的办法，使得其中一个水壶恰好装 4 升水，每一步的操作只能是倒空或倒满。</span><br></pre></td></tr></table></figure><p>这道题我们可以用GCD（最大公约数）解决，如果你不知道这个数学知识点也没问题。 我们可以通过BFS来解决，其实学习算法尤其是刷LeetCode只需要我们掌握简单的数学知识，高中的数学知识通常来说就足够了。</p><p>另外一个大家需要掌握的数学知识是关于后面要讲的复杂度分析，这里需要一点简单的数学知识，不过不要担心，非常简单，不会有高等数学的内容。</p><p>学习本书最好你对一种编程语言比较熟悉，出于读者的受众群体和代码简洁性，我选取了Python作为本书的主要编程语言，如果大家对Python不熟悉也没有关系，我会尽量少使用语言特有的语法糖，从而减少大家对于语言层面的认知负担。 另外Python被誉为最容易入门的语言之一也是实至名归，大家可以放心。 退一步讲，语言不应该成为我们学习算法的障碍，不是么？那让我们一起进入LeetCode的世界吧！</p><h3 id="1-2-基础数据结构和算法"><a href="#1-2-基础数据结构和算法" class="headerlink" title="1.2 基础数据结构和算法"></a>1.2 基础数据结构和算法</h3><p>在真正的刷题之前，我们一定要先打好基础，学好基本的数据结构和算法，然后以练代学进行提升和消化。</p><p>从广义上来说，数据结构其实就是数据的存储结构，算法就是操作数据的方法。而平时以及本书所探讨的其实是更为狭义角度的数据结构和算法。其实指的是某些非常典型的数据结构和算法，比如数组，链表，栈，队列，树，图等数据结构，以及二分法，动态规划，快速排序等经典的算法。</p><p>数据结构是为算法所服务的，而算法是要建立在某一种或者几种数据结构之上才可以发挥作用，这两个是相辅相成的关系。某些算法一定要建立在某种数据结构之上才行，相信你读完这本书会对这句话产生更为深刻的印象。</p><p>本书要讲的内容就是在LeetCode上反复出现的算法，经过进一步提炼，抽取近百道题目在这里进行讲解，帮助大家理清整体结构，从而高效率地刷题。</p><p>我这里总结了 7 个常见的数据结构和 7 个常见的算法以及 5 个常见的算法思想。</p><p>7 个数据结构分别是： <code>数组，栈，队列，链表，二叉树，散列表，图</code></p><p>7 个算法分别是：<code>二分法，递归，回溯法，排序，双指针，滑动窗口，并查集</code></p><p>5 个算法思想分别是：<code>分治，贪心，深度优先遍历，广度优先遍历，动态规划</code></p><p>只有掌握了这些基础的数据结构和算法，更为复杂的算法才能得心应手，刷题才会事半功倍。而LeetCode的题目虽然不断出新，但是最终用到的算法永远是那几个，很多题目都是穿着新衣服的老面孔了。大家学好这些基础套路之后会更加明白这个道理。</p><h3 id="1-3-如何刷LeetCode"><a href="#1-3-如何刷LeetCode" class="headerlink" title="1.3 如何刷LeetCode"></a>1.3 如何刷LeetCode</h3><h4 id="Leetcode网站使用方法"><a href="#Leetcode网站使用方法" class="headerlink" title="Leetcode网站使用方法"></a>Leetcode网站使用方法</h4><p>LeetCode官网收录了许多互联网公司的算法题目，一度被称为刷题神器，今天我们就来介绍下如何使用LeetCode网站，以下所讲述的内容都是以力扣中国为例。</p><p>LeetCode目前有1000多道题目，并且一直持续更新，其中有一些是带锁的，需要会员才能查看。 最上面标签栏的Problems，给出了四个分类：Algorithms、Database、Shell和Concurrency，分别表示算法题、数据库题、Shell和并发题，第一个就是我们所需要刷的算法题，并发是2019年才添加的新的模块。</p><p>点开Algorithms后，我们可以看到一列题目的列表，每个题目都有一个序号，后面的接受率（Acceptance）表示提交的正确率，Difficulty表示难易程度。这里有个小技巧，衡量一道题目难不难除了看难度之外，还可以看下接受率，接受率越低代表题目越难，这个指标有时候比难度更靠谱。</p><p>LeetCode按难易程度分成了三个级别，分别是Easy、Medium和Hard。</p><ul><li>Easy 通常不需要太多思考和也不会有复杂的细节，比较特别适合新手或者拿来热身。</li><li>Medium级别就会有些难度，一般都会涉及到经典的算法，需要一定的思考。</li><li>Hard级别是最难的，有些时候是算法本身的难度，有些时候特别需要你考虑到各种细节。</li></ul><p>你可以对题目进行筛选和排序。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ueyinaxij30oy0c6wet.jpg" alt></p><p>如果我们只想要找某一类型的题，可以通过Tags或Company来筛选。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8uez7f9tsj30aj0pggm3.jpg" alt></p><p>另外我们在做某一题时，觉得还想再做一个类似的，可以点击题目描述下方Show Similar Problems或Tags来找到相似的问题。</p><p>每个题目都有各自的Discuss区域。在这里，许多人都把自己的思路和代码放到了上面，你可以发贴提问，也可以回复别人，里面大神很多，题解质量都很高，如果实在没有思路或者想看下有没有更好的思路可以来逛一下。通常来说我建议你优先看Post或者投票最多的。</p><p>点开某一个题目，会跳转到具体题目详情页面，你可以在右侧的代码区切换选择自己需要的编程语言。</p><p>代码编写完了之后，不要急着提交，先可以测试运行下（Run Code），你可以多写几个测试用力跑一下，没有问题再提交，要知道比赛的时候错误提交要加时间的。 我们可以点开More Details查看详细运行结果信息。</p><p>每道题旁边的My Submissions可以找到自己的对于该题的提交情况，这里可以看到自己过去所有的提交，点Accepted 或 Wrong Answer就可以查看自己过去提交的代码情况，包括代码是什么，跑的时间以及时间分布图等。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8uf5vjtkuj30yj0hfjrm.jpg" alt></p><p>以上就是LeetCode的主要功能，希望通过这一节内容能让你对LeetCode网站有所了解，从而更快地进行刷题。</p><h4 id="应该怎么刷LeetCode"><a href="#应该怎么刷LeetCode" class="headerlink" title="应该怎么刷LeetCode"></a>应该怎么刷LeetCode</h4><p>我本人从开始准备算法以来刷了很多题，自己成长了很多，从刷题菜鸡，到现在对刷题套路，题型有了自己的理解，感受还是蛮多的。我本人不是算法高手，算是勤能补拙类型。不过经过几个月的学习和练习，不仅面试变得更加得心应手，而且在工作中写更容易写出干净优雅，性能好的代码。</p><p>对于我来说，刷题的过程其实就是学习数据结构和算法的过程， 不仅仅是为了刷题而刷题，这样你才能感受到刷题的乐趣。刷题至少要刷两遍，理想情况是根据自己的遗忘曲线刷多次，这个我后面也会讲到。</p><ol><li>第一遍按tag刷</li></ol><p>建议第一遍刷的时候可以先快速按照tag过一遍，快速感受一下常见数据结构和算法的套路，这样自己有一个感性的认识。</p><ol start="2"><li>第二遍一题多解，多题同解</li></ol><p>第二遍我们就不能像第一遍那样了，这个阶段我们需要多个角度思考问题，尽量做到一题多解，多题同解。我们需要对问题的本质做一些深度的理解，将来碰到类似的问题我们才能够触类旁通。</p><p>但是很多人做了几遍，碰到新题还是没有任何头绪，这是一个常见的问题，这怎么办呢？ </p><p>总结并记忆是学习以及刷题过程中非常重要的一环， 不管哪个阶段，我们都需要做对应的总结，这样将来我们再回过头看的时候，才能够快读拾起来。</p><p>anki就是根据<a href="./ibinhouse.md">艾宾浩斯记忆曲线</a>开发的一个软件，它是一个使记忆变得更容易的学习软件。支持深度自定义。 对于我本人而言，我在anki里面写了很多LeetCode题目和套路的Card，然后anki会自动帮我安排复习时间，大大减少我的认知负担，提高了我的复习效率。大家可以在书后的附录中下载anki卡片。</p><p>目前已更新卡片一览（仅列举正面）</p><ul><li>二分法解决问题的关键点是什么，相关问题有哪些?</li><li>如何用栈的特点来简化操作， 涉及到的题目有哪些？</li><li>双指针问题的思路以及相关题目有哪些？</li><li>滑动窗口问题的思路以及相关题目有哪些？</li><li>回溯法解题的思路以及相关题目有哪些？</li><li>数论解决问题的关键点是什么，相关问题有哪些?</li><li>位运算解决问题的关键点是什么，相关问题有哪些?</li></ul><p>大家刷了很多题之后，就会发现来来回回，题目就那么几种类型，因此掌握已有题目类型是多么重要。那样LeetCode出题的老师，很多也是在原有的题目基础上做了适当扩展（比如two-sum,two-sum2,three-sum, four-sum等等）或者改造（使得不那么一下子看出问题的本质，比如猴子吃香蕉问题）。</p><p>其中算法，主要是以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基础技巧：分治、二分、贪心</span><br><span class="line">排序算法：快速排序、归并排序、计数排序</span><br><span class="line">搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等</span><br><span class="line">图论：最短路径、最小生成树</span><br><span class="line">动态规划：背包问题、最长子序列</span><br></pre></td></tr></table></figure><p>数据结构，主要有如下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数组与链表：单 / 双向链表</span><br><span class="line">栈与队列</span><br><span class="line">哈希表</span><br><span class="line">堆：最大堆 ／ 最小堆</span><br><span class="line">树与图：最近公共祖先、并查集</span><br><span class="line">字符串：前缀树（字典树） ／ 后缀树</span><br></pre></td></tr></table></figure><p>做到了以上几点，我们还需要坚持。这个其实是最难的，不管做什么事情，坚持都是最重要也是最难的。</p><p>为了督促自己，同时帮助大家成长，我在群里举办《每日一题》活动，每日一题是在交流群（包括微信和qq）里进行的一种活动，大家一起 解一道题，这样讨论问题更加集中，会得到更多的反馈。而且 这些题目可以被记录下来，日后会进行筛选添加到仓库的题解模块， 感兴趣的可以到书后的附录部分进群交流。</p><h3 id="1-4-复杂度分析"><a href="#1-4-复杂度分析" class="headerlink" title="1.4 复杂度分析"></a>1.4 复杂度分析</h3><p>想学算法，首先要学的第一件事就是如何判断一个算法的好坏。 好的程序有很多的评判标准，包括但不限于可读性，扩展性性能等。 这里我们来看其中一种 - 性能。 坏的程序可能性能也很好，但是好的程序通常性能都比较好。那么如何分析一个算法的性能好坏呢？这就是我们要讲的复杂度分析，所有的数据结构教程都会把这个放在前面来讲，不仅仅是因为他们是基础，更因为他们真的非常重要。学会了复杂度分析，你才能够对你的算法进行分析，从而帮助你写出复杂度更优的算法。</p><p>那么怎么样才能衡量一个算法代码的执行效率呢？</p><p>如下是一个从1加到n的一个算法，这个算法用了一层循环来完成，并且借助了一个变量res来完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(n)</span>:</span></span><br><span class="line">  res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    res += i</span><br><span class="line">  <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>我们将这个方法从更微观的角度来进行分析，上述代码会执行n次循环体的内容，每一次执行都是常数时间，我们不妨假设执行的时间是x。我们假设赋值语句<code>res = 0</code>和<code>return res</code>的时间分别为y和z   那么执行的总时间我们约等于 n * x + y + z, 我们<code>粗略</code>将x，y和z都看成一样的，我们得出总时间为 (n + 2) * x 换句话说算法的时间和数据的规模成正比。</p><p>实际上，这更是一种叫做大O表示法的基本思想, 它是一种描述算法性能的记法，这种描述和编译系统、机器结构、处理器的快慢等因素无关。 这种描述的参数是n，表示数据的规模。 这里的O表示量级（order），比如说“二分查找是$O(logN)$的”，也就是说它需要“通过 logn量级的操作去查找一个规模为n的数据结构（通常是数组）”。这种渐进地估计对算法的理论分析和大致比较是非常有价值，可以很快地对算法进行一个大致地估算。例如，一个拥有较小常数项的 $O(N^2)$算法在规模n较小的情况下可能比一个高常数项的$O(N)$算法运行得更快。但是随着n足够大以后，具有较慢上升函数的算法必然工作得更快，因此在采用大O标记复杂度的时候，可以忽略系数。</p><p>我们还应该区分算法的最好情况，最坏情况和平均情况，但是这不在本书的讨论范畴，本书的所有复杂度均指的是平均复杂度。</p><p>那么如何分析一个算法的复杂度呢？下面我们介绍几种常见时间复杂度，几乎所有的算法的复杂度都是以下中的一种</p><p>我对时间复杂度进行了一个小的分类。</p><ul><li>第一类是常数阶。</li></ul><p>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cnt = <span class="number">1</span></span><br><span class="line">l = <span class="number">0</span></span><br><span class="line">r = len(list) - <span class="number">1</span></span><br><span class="line"><span class="comment"># 不管这种代码有多少行，都是常数复杂度，即$O(1)$,因此系数是被忽略的。</span></span><br></pre></td></tr></table></figure><ul><li>第二类是 n,n^2,n^3 …</li></ul><p>一个简单的方法是<code>关注循环执行次数最多的那一段代码就好了</code>，这段执行次数最多的代码执行次数的n的量级，就是整个算法的时间复杂度。即如果是一层N的循环，那么时间复杂度就是$O(N)$, 如果嵌套了两层N的循环，那么时间复杂度就是$O(N^2)$，依次类推。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        mapper = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i] <span class="keyword">in</span> mapper):</span><br><span class="line">                <span class="keyword">return</span> [mapper[target - nums[i]], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mapper[nums[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>如上代码，我们进行了一层的循环，那么时间复杂度就是$O(N^2)$</p><ul><li>第三类是对数阶。 logn  nlogn</li></ul><p>这同样是一种非常常见的复杂度，多见于二分查找和一些排序算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numRescueBoats</span><span class="params">(self, people: List[int], limit: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(people) - <span class="number">1</span></span><br><span class="line">        people.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            total = people[l] + people[r]</span><br><span class="line">            <span class="keyword">if</span> total &gt; limit:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (l == r):</span><br><span class="line">            <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>上面的代码是一个典型的二分查找，其时间复杂度是logn</p><ul><li>第四类是指数阶 2^n</li></ul><p>指数的增长已经非常恐怖了，一个典型的例子是fabnicca数列的递归实现版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>如果你把上述的计算过程看成树的一个节点，那么整个计算过程就像是一颗很大的树。这棵树有很多的重复计算，大致算下来的话，是2^n。</p><ul><li>第五类是对数阶 n！</li></ul><p>我们知道n个不相同的数字的全排列有n!个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorrail</span><span class="params">(n)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> n * factorrail(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>很明显上面的代码就是n!</p><p>下面给出上面列举的几种常见的时间复杂度的趋势图对比，大家直观感受一下。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8o458x4cvj311e0u00tk.jpg" alt><br>（各种复杂度的渐进趋势对比）</p><p>从算法可以分析出时间复杂度，相反题目的时间复杂度要求，我们甚至可以猜测出可能用到的算法，比如算法要求logn，那么就有可能是二分法。</p><p>空间复杂度分析比时间复杂度分析要简单地多,常见的空间复杂度有$O(1)$、$O(N)$、$O(N^2)$、$O(logN)$、$O(logN)$、$O(N!)$这样的对数阶复杂度基本不会有，关于空间复杂度这里不做更多介绍了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>时间复杂度是算法的基石，学习它对于我们学习后面的章节有很大的帮助。 我们引入了大O表示法来衡量算法的好坏。接着通过若干实例了解了各种时间复杂度，其实对于复杂度，掌握上面提到的几种常见的就已经够应付绝大多数场合了。</p><p>通过上面的学习，相信你对评估一个算法的时间复杂度有了初步的了解。随着学习的深入，相信你会对复杂度分析有着更为深入的理解。</p><h2 id="2-数学之美"><a href="#2-数学之美" class="headerlink" title="2. 数学之美"></a>2. 数学之美</h2><p>LeetCode中有很多数学问题，截止到本书出版，LeetCode中有数学标签的题目一共是159，在所有标签的分类中排名第3。这些题目中有些是包着数学外衣的伪数学问题，还有一些是真正数学问题。这需要大家有着极强的分辨能力。不要被数学两个字吓住了，本章不会讲非常复杂的数学概念和公式，实际上你只需要一些高中数学知识即可。</p><p>除非是面试算法岗位，笔试和面试题才会涉及到一些比较复杂度的数学知识，比如微积分，线性代数，概率论，信息论等。</p><p>虽然有的题目可以用数学公式轻松解决，但是这并不意味你需要对数学有很深的造诣。举例来说，LeetCode 69.实现开方，就是一道可以使用纯数学方法 - <code>牛顿迭代法</code>来解决的一道题，但是你完全可以使用二分法解决，尽管效率远远不及<code>牛顿迭代法</code>，实际上现在的计算器计算开方也不是二分法计算的。但是这通常是一个加分项，如果你可以通过别的方法解决，也未尝不可。</p><p>很多题目一眼看上去就是个数学问题，如果你尝试使用数学的角度没有什么思路或者解不出来的时候，可以考虑换最常规，最符合直觉的做法，当然做之前要估算一下数据范围和时间，不要写完才发现超时。</p><p>有些题目只是涉及到一些数学名词，并且会在题目中详细地进行解释。 比如关于质数性质，阶乘性质的题目，还有一些造轮子题目，比如实现Pow等。还有一些干脆定义一个数学概念，让你去做。比如开心数，回文数，丑数等。</p><p>我们这章主要讲解纯数学问题，需要用到一些数学的性质类的题目，这或许是大家更想要看的。</p><h3 id="2-1-N-SUM-题目"><a href="#2-1-N-SUM-题目" class="headerlink" title="2.1 N-SUM 题目"></a>2.1 N-SUM 题目</h3><p>LeetCode上有很多经典的系列问题，今天我们就来看一下N-SUM系列问题。</p><h3 id="2-2-连续整数和"><a href="#2-2-连续整数和" class="headerlink" title="2.2 连续整数和"></a>2.2 连续整数和</h3><p>这是一个非常经典，被各种收录的一个题目，这道题好在虽然简单，但是却可以从多个纬度进行解决，非常适合用来查考一个人的真实水平，一些比较大的公司也会用它来进行算法面试的第一道题。</p><h3 id="2-3-最大数"><a href="#2-3-最大数" class="headerlink" title="2.3 最大数"></a>2.3 最大数</h3><h3 id="2-4-分数到小数"><a href="#2-4-分数到小数" class="headerlink" title="2.4 分数到小数"></a>2.4 分数到小数</h3><h3 id="2-5-最大整除子集"><a href="#2-5-最大整除子集" class="headerlink" title="2.5 最大整除子集"></a>2.5 最大整除子集</h3><h3 id="2-6-质数排列"><a href="#2-6-质数排列" class="headerlink" title="2.6 质数排列"></a>2.6 质数排列</h3><ol><li>质数</li></ol><ol start="2"><li>全排列</li></ol><h3 id="2-8-快乐数"><a href="#2-8-快乐数" class="headerlink" title="2.8 快乐数"></a>2.8 快乐数</h3><blockquote><p>这类题目是给定一个定义（情景），让你实现算法找出满足特定条件的数字</p></blockquote><h2 id="3-回文的艺术"><a href="#3-回文的艺术" class="headerlink" title="3. 回文的艺术"></a>3. 回文的艺术</h2><p>回文是很多教材中被提到的一个题目，通常是用来学习栈的一个练习题，LeetCode中有关回文的题目也是蛮多的，单从数据结构上来看就有字符串，数字和链表。今天我们就结合几个LeetCode题目来攻克它。</p><h3 id="3-1-回文字符串"><a href="#3-1-回文字符串" class="headerlink" title="3.1 回文字符串"></a>3.1 回文字符串</h3><h3 id="3-2-回文链表"><a href="#3-2-回文链表" class="headerlink" title="3.2 回文链表"></a>3.2 回文链表</h3><h3 id="3-3-回文数字"><a href="#3-3-回文数字" class="headerlink" title="3.3 回文数字"></a>3.3 回文数字</h3><h3 id="3-4-回文总数"><a href="#3-4-回文总数" class="headerlink" title="3.4 回文总数"></a>3.4 回文总数</h3><h2 id="4-游戏之乐"><a href="#4-游戏之乐" class="headerlink" title="4. 游戏之乐"></a>4. 游戏之乐</h2><p>我很喜欢玩游戏，实际上很多游戏背后都是有很多算法存在的，我们通过LeetCode上一些关于游戏的题目来一窥究竟吧，虽然这里的题目和实际游戏用到的算法难度差很多，但是这里的基本思想是一样的。</p><h3 id="4-1-生命游戏"><a href="#4-1-生命游戏" class="headerlink" title="4.1 生命游戏"></a>4.1 生命游戏</h3><h3 id="4-2-报数"><a href="#4-2-报数" class="headerlink" title="4.2 报数"></a>4.2 报数</h3><h3 id="4-3-数独游戏"><a href="#4-3-数独游戏" class="headerlink" title="4.3 数独游戏"></a>4.3 数独游戏</h3><h2 id="5-BFS-amp-DFS"><a href="#5-BFS-amp-DFS" class="headerlink" title="5. BFS &amp; DFS"></a>5. BFS &amp; DFS</h2><p>这是LeetCode后期新增的一个板块，题目还比较少。</p><h2 id="6-二分法"><a href="#6-二分法" class="headerlink" title="6. 二分法"></a>6. 二分法</h2><p>二分法真的是一个非常普遍的算法了，更严格的说其实是一种思想，如果把二改成N其实就是一种分治思想。LeetCode关于二分法的题目实在太多了，我们挑选几个代表性的来感受一下，LeetCode到底是如何考察我们二分法的。</p><h3 id="6-1-你真的了解二分法么？"><a href="#6-1-你真的了解二分法么？" class="headerlink" title="6.1 你真的了解二分法么？"></a>6.1 你真的了解二分法么？</h3><h3 id="6-2-一些显然的二分"><a href="#6-2-一些显然的二分" class="headerlink" title="6.2 一些显然的二分"></a>6.2 一些显然的二分</h3><h3 id="6-3-隐藏的二分法"><a href="#6-3-隐藏的二分法" class="headerlink" title="6.3 隐藏的二分法"></a>6.3 隐藏的二分法</h3><p>二进制和二分法？</p><blockquote><p>744 吃香蕉 循环数组 数学开方  等等</p></blockquote><h3 id="6-4-寻找峰值"><a href="#6-4-寻找峰值" class="headerlink" title="6.4 寻找峰值"></a>6.4 寻找峰值</h3><h2 id="7-神奇的比特"><a href="#7-神奇的比特" class="headerlink" title="7. 神奇的比特"></a>7. 神奇的比特</h2><p>前菜： 如何将一个IP地址用一个字节存储，支持序列化和反序列化操作。</p><p>计算机是用过二进制来表示信息的，有时候我们从二进制思考问题，会发现一个全新的世界。</p><h3 id="7-1-那些特立独行的数字"><a href="#7-1-那些特立独行的数字" class="headerlink" title="7.1 那些特立独行的数字"></a>7.1 那些特立独行的数字</h3><h3 id="7-2-桶中摸黑白球"><a href="#7-2-桶中摸黑白球" class="headerlink" title="7.2 桶中摸黑白球"></a>7.2 桶中摸黑白球</h3><h3 id="7-3-实现加法"><a href="#7-3-实现加法" class="headerlink" title="7.3 实现加法"></a>7.3 实现加法</h3><h3 id="7-4-二进制-1-的个数"><a href="#7-4-二进制-1-的个数" class="headerlink" title="7.4 二进制 1 的个数"></a>7.4 二进制 1 的个数</h3><h3 id="7-5-悲惨的老鼠"><a href="#7-5-悲惨的老鼠" class="headerlink" title="7.5 悲惨的老鼠"></a>7.5 悲惨的老鼠</h3><h2 id="8-设计题"><a href="#8-设计题" class="headerlink" title="8. 设计题"></a>8. 设计题</h2><p>有时候我们面对的不是一个算法题，而是一个设计题目，这种题目比较开放，让你自己设计数据结构和算法。这比限定数据结构和算法更能考察一个人综合运用知识的能力，是一个经常被拿来进行面试的一类题目。</p><h3 id="8-1-设计-LRU"><a href="#8-1-设计-LRU" class="headerlink" title="8.1 设计 LRU"></a>8.1 设计 LRU</h3><h3 id="8-2-设计-LFU"><a href="#8-2-设计-LFU" class="headerlink" title="8.2 设计 LFU"></a>8.2 设计 LFU</h3><h3 id="8-3-最小栈"><a href="#8-3-最小栈" class="headerlink" title="8.3 最小栈"></a>8.3 最小栈</h3><h3 id="8-4-队列实现栈"><a href="#8-4-队列实现栈" class="headerlink" title="8.4 队列实现栈"></a>8.4 队列实现栈</h3><h3 id="8-5-设计-Trie-树"><a href="#8-5-设计-Trie-树" class="headerlink" title="8.5 设计 Trie 树"></a>8.5 设计 Trie 树</h3><h2 id="9-双指针"><a href="#9-双指针" class="headerlink" title="9. 双指针"></a>9. 双指针</h2><p>双指针的题目真的非常多，可以看出这个是一个重要重要的知识点。在实际使用过程中，我将双指针问题分为两种，一种是头尾双指针，一种是快慢双指针。</p><h3 id="9-1-头尾指针"><a href="#9-1-头尾指针" class="headerlink" title="9.1 头尾指针"></a>9.1 头尾指针</h3><h4 id="9-1-1-盛水问题"><a href="#9-1-1-盛水问题" class="headerlink" title="9.1.1 盛水问题"></a>9.1.1 盛水问题</h4><h4 id="9-1-2-两数相加-2"><a href="#9-1-2-两数相加-2" class="headerlink" title="9.1.2 两数相加 2"></a>9.1.2 两数相加 2</h4><h3 id="9-2-快慢指针"><a href="#9-2-快慢指针" class="headerlink" title="9.2 快慢指针"></a>9.2 快慢指针</h3><h4 id="9-2-1-删除有序数组的重复元素"><a href="#9-2-1-删除有序数组的重复元素" class="headerlink" title="9.2.1 删除有序数组的重复元素"></a>9.2.1 删除有序数组的重复元素</h4><h4 id="9-2-2-链表中的快慢指针"><a href="#9-2-2-链表中的快慢指针" class="headerlink" title="9.2.2 链表中的快慢指针"></a>9.2.2 链表中的快慢指针</h4><h2 id="10-查表与动态规划"><a href="#10-查表与动态规划" class="headerlink" title="10. 查表与动态规划"></a>10. 查表与动态规划</h2><p>如果说递归是从问题的结果倒推，直到问题的规模缩小到寻常。 那么动态规划就是从寻常入手， 逐步扩大规模到最优子结构。 这句话需要一定的时间来消化, 如果不理解，可以过一段时间再来看。</p><p>递归的解决问题非常符合人的直觉，代码写起来比较简单。但是我们通过分析（可以尝试画一个递归树），可以看出递归在缩小问题规模的同时可能会 重复计算。 279.perfect-squares 中 我通过递归的方式来解决这个问题，同时内部维护了一个缓存 来存储计算过的运算，那么我们可以减少很多运算。 这其实和动态规划有着异曲同工的地方。</p><h3 id="10-1-爬楼梯"><a href="#10-1-爬楼梯" class="headerlink" title="10.1 爬楼梯"></a>10.1 爬楼梯</h3><h3 id="10-2-聪明的盗贼"><a href="#10-2-聪明的盗贼" class="headerlink" title="10.2 聪明的盗贼"></a>10.2 聪明的盗贼</h3><p>六（七）个版本，带你一步步进化，走向极致</p><h3 id="10-3-不同路径"><a href="#10-3-不同路径" class="headerlink" title="10.3 不同路径"></a>10.3 不同路径</h3><h3 id="10-4-硬币找零"><a href="#10-4-硬币找零" class="headerlink" title="10.4 硬币找零"></a>10.4 硬币找零</h3><h3 id="10-5-最短编辑距离"><a href="#10-5-最短编辑距离" class="headerlink" title="10.5 最短编辑距离"></a>10.5 最短编辑距离</h3><h2 id="11-滑动窗口"><a href="#11-滑动窗口" class="headerlink" title="11. 滑动窗口"></a>11. 滑动窗口</h2><p>你可能听过TCP的滑动窗口，这里要讲的滑动窗口其实思想是一样的，这里要讲的滑动窗口通常被用在处理连续数组或者字符的问题上。</p><h3 id="最长连续不重复子串"><a href="#最长连续不重复子串" class="headerlink" title="最长连续不重复子串"></a>最长连续不重复子串</h3><h3 id="最短子数组之和"><a href="#最短子数组之和" class="headerlink" title="最短子数组之和"></a>最短子数组之和</h3><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><h2 id="12-博弈"><a href="#12-博弈" class="headerlink" title="12. 博弈"></a>12. 博弈</h2><p>博弈，词语解释是局戏、围棋、赌博。 现代数学中有博弈论，亦名“对策论”、“赛局理论”，属应用数学的一个分支， 表示在多决策主体之间行为具有相互作用时，各主体根据所掌握信息及对自身能力的认知，做出有利于自己的决策的一种行为理论。</p><p>这类问题通常没那么直接和好下手，需要你进行一定的推演才能发现问题的本质。</p><h3 id="12-1-alec"><a href="#12-1-alec" class="headerlink" title="12.1 alec"></a>12.1 alec</h3><h3 id="12-2-Nim"><a href="#12-2-Nim" class="headerlink" title="12.2 Nim"></a>12.2 Nim</h3><h3 id="12-3-486-预测赢家"><a href="#12-3-486-预测赢家" class="headerlink" title="12.3 486. 预测赢家"></a>12.3 486. 预测赢家</h3><h2 id="13-股票系列"><a href="#13-股票系列" class="headerlink" title="13. 股票系列"></a>13. 股票系列</h2><p>LeetCode上有很多经典的系列问题，今天我们就来看一下这个股票系列问题。</p><h3 id="13-1-股票买卖的最佳时机-1"><a href="#13-1-股票买卖的最佳时机-1" class="headerlink" title="13.1 股票买卖的最佳时机 1"></a>13.1 股票买卖的最佳时机 1</h3><h3 id="13-2-股票买卖的最佳时机-2"><a href="#13-2-股票买卖的最佳时机-2" class="headerlink" title="13.2 股票买卖的最佳时机 2"></a>13.2 股票买卖的最佳时机 2</h3><h3 id="13-3-股票买卖的最佳时机-3"><a href="#13-3-股票买卖的最佳时机-3" class="headerlink" title="13.3 股票买卖的最佳时机 3"></a>13.3 股票买卖的最佳时机 3</h3><h3 id="13-4-股票买卖的最佳时机-4"><a href="#13-4-股票买卖的最佳时机-4" class="headerlink" title="13.4 股票买卖的最佳时机 4"></a>13.4 股票买卖的最佳时机 4</h3><h2 id="14-分治法"><a href="#14-分治法" class="headerlink" title="14. 分治法"></a>14. 分治法</h2><p>分治是一种非常重要的算法思想，而不是一个算法。和具体算法不同，算法思想在任何数据结构下都可以使用。</p><h3 id="14-1-合并-K-个排序链表"><a href="#14-1-合并-K-个排序链表" class="headerlink" title="14.1 合并 K 个排序链表"></a>14.1 合并 K 个排序链表</h3><h3 id="14-2-数组中的第-K-个最大元素"><a href="#14-2-数组中的第-K-个最大元素" class="headerlink" title="14.2 数组中的第 K 个最大元素"></a>14.2 数组中的第 K 个最大元素</h3><h3 id="14-3-搜索二维矩阵"><a href="#14-3-搜索二维矩阵" class="headerlink" title="14.3 搜索二维矩阵"></a>14.3 搜索二维矩阵</h3><h2 id="15-贪心法"><a href="#15-贪心法" class="headerlink" title="15. 贪心法"></a>15. 贪心法</h2><p>贪心或许是最难的一种算法思想了。</p><h3 id="15-1-跳跃游戏"><a href="#15-1-跳跃游戏" class="headerlink" title="15.1 跳跃游戏"></a>15.1 跳跃游戏</h3><h3 id="15-2-任务调度器"><a href="#15-2-任务调度器" class="headerlink" title="15.2 任务调度器"></a>15.2 任务调度器</h3><h2 id="16-回溯"><a href="#16-回溯" class="headerlink" title="16. 回溯"></a>16. 回溯</h2><p>这是一种非常暴力的搜索算法，优点是书写简单有固定模板，且适用范围很广。</p><h3 id="16-1-求组合数-1"><a href="#16-1-求组合数-1" class="headerlink" title="16.1 求组合数 1"></a>16.1 求组合数 1</h3><h3 id="16-2-求组合数-2"><a href="#16-2-求组合数-2" class="headerlink" title="16.2 求组合数 2"></a>16.2 求组合数 2</h3><h3 id="16-3-求所有子集"><a href="#16-3-求所有子集" class="headerlink" title="16.3 求所有子集"></a>16.3 求所有子集</h3><h3 id="16-4-全排列"><a href="#16-4-全排列" class="headerlink" title="16.4 全排列"></a>16.4 全排列</h3><h3 id="16-5-海岛问题"><a href="#16-5-海岛问题" class="headerlink" title="16.5 海岛问题"></a>16.5 海岛问题</h3><h2 id="17-一些有趣的题目"><a href="#17-一些有趣的题目" class="headerlink" title="17. 一些有趣的题目"></a>17. 一些有趣的题目</h2><p>这里让我们来看一下LeetCode上那些惊人的算法。</p><h3 id="17-1-求众数"><a href="#17-1-求众数" class="headerlink" title="17.1 求众数"></a>17.1 求众数</h3><h3 id="17-2-手撕排序"><a href="#17-2-手撕排序" class="headerlink" title="17.2 手撕排序"></a>17.2 手撕排序</h3><h3 id="17-3-星期几"><a href="#17-3-星期几" class="headerlink" title="17.3 星期几"></a>17.3 星期几</h3><h3 id="17-4-量筒问题"><a href="#17-4-量筒问题" class="headerlink" title="17.4 量筒问题"></a>17.4 量筒问题</h3><h3 id="17-5-实现开方"><a href="#17-5-实现开方" class="headerlink" title="17.5 实现开方"></a>17.5 实现开方</h3><h3 id="17-6-4的次方"><a href="#17-6-4的次方" class="headerlink" title="17.6 4的次方"></a>17.6 4的次方</h3><h2 id="18-一些通用解题模板"><a href="#18-一些通用解题模板" class="headerlink" title="18. 一些通用解题模板"></a>18. 一些通用解题模板</h2><p>不仅是平时做工程项目，刷题的过程也非常讲究风格一致，如果有一些非常优秀的模板可以直接拿来用，一方便减少做题时间和出错的可能，另一方面做题风格一致有利于自己回顾。 如果你是在面试，相信一定也会为你加分不少。</p><h3 id="18-1-二分法"><a href="#18-1-二分法" class="headerlink" title="18.1 二分法"></a>18.1 二分法</h3><h3 id="18-2-回溯法"><a href="#18-2-回溯法" class="headerlink" title="18.2 回溯法"></a>18.2 回溯法</h3><h3 id="18-3-递归"><a href="#18-3-递归" class="headerlink" title="18.3 递归"></a>18.3 递归</h3><h3 id="18-4-并查集"><a href="#18-4-并查集" class="headerlink" title="18.4 并查集"></a>18.4 并查集</h3><ul><li>朋友圈</li><li>计算小岛数2</li></ul><h2 id="19-融会贯通"><a href="#19-融会贯通" class="headerlink" title="19. 融会贯通"></a>19. 融会贯通</h2><p>这里我们要把本书降到的知识进行融会贯通，纵向上我们不满足于一种解法，我们尝试使用多种解法去解决。 横向上我们需要去总结哪些题目和这道题目类似。</p><p>这通常被用在第二遍刷LeetCode的过程中。</p><h3 id="19-1-最大子序列和问题"><a href="#19-1-最大子序列和问题" class="headerlink" title="19.1 最大子序列和问题"></a>19.1 最大子序列和问题</h3><h3 id="19-2-循环移位问题"><a href="#19-2-循环移位问题" class="headerlink" title="19.2 循环移位问题"></a>19.2 循环移位问题</h3><h3 id="19-3-k-问题"><a href="#19-3-k-问题" class="headerlink" title="19.3 k 问题"></a>19.3 k 问题</h3><h2 id="20-解题技巧-amp-面试技巧"><a href="#20-解题技巧-amp-面试技巧" class="headerlink" title="20. 解题技巧&amp;面试技巧"></a>20. 解题技巧&amp;面试技巧</h2><p>在水平知识一样的情况下，如果能够LeetCode上效率更好？如何面试的时候加分，这是本章我们要探讨的主要内容。</p><ul><li>一定要看限制条件，很多时候限制条件起到了提示的作用，并且可以帮助你过滤错误答案</li></ul><h2 id="21-参考"><a href="#21-参考" class="headerlink" title="21. 参考"></a>21. 参考</h2>]]></content>
      
      
      <categories>
          
          <category> 书 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 书 </tag>
            
            <tag> 草稿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《一文看懂浏览器事件循环》</title>
      <link href="/blog/2019/12/11/event-loop/"/>
      <url>/blog/2019/12/11/event-loop/</url>
      
        <content type="html"><![CDATA[<p>实际上浏览器的事件循环标准是由 HTML 标准规定的，具体来说就是由whatwg规定的，具体内容可以参考<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener">event-loops in browser</a>。而NodeJS中事件循环其实也略有不同，具体可以参考<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop" target="_blank" rel="noopener">event-loops in nodejs</a></p><p>我们在讲解<code>事件模型</code>的时候，多次提到了事件循环。 <code>事件</code>指的是其所处理的对象就是事件本身，每一个浏览器都至少有一个事件循环，一个事件循环至少有一个任务队列。<code>循环</code>指的是其永远处于一个“无限循环”中。不断将注册的回调函数推入到执行栈。</p><p>那么事件循环究竟是用来做什么的？浏览器的事件循环和NodeJS的事件循环有什么不同？让我们从零开始，一步一步探究背后的原因。</p><a id="more"></a><h2 id="为什么要有事件循环"><a href="#为什么要有事件循环" class="headerlink" title="为什么要有事件循环"></a>为什么要有事件循环</h2><h3 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h3><p>要回答这个问题，我们先来看一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>以上一段简单的JS代码，究竟是怎么被浏览器执行的？</p><p>首先，浏览器想要执行JS脚本，需要一个“东西”，将JS脚本（本质上是一个纯文本），变成一段机器可以理解并执行的计算机指令。这个“东西”就是JS引擎，它实际上会将JS脚本进行编译和执行，整个过程非常复杂，这里不再过多介绍，感兴趣可以期待下我的V8章节，如无特殊说明，以下都拿V8来举例子。</p><p>有两个非常核心的构成，<code>执行栈</code>和<code>堆</code>。执行栈中存放正在执行的代码，堆中存放变量的值，通常是不规则的。</p><p>当V8执行到<code>a()</code>这一行代码的时候，a会被压入栈顶。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ltfr1pfij307j06gt8h.jpg" alt></p><p>在a的内部，我们碰到了<code>b()</code>，这个时候b被压入栈顶。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lth4pggfj307906rwe9.jpg" alt></p><p>在b的内部，我们又碰到了<code>c()</code>，这个时候c被压入栈顶。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ltert9f5j307i06p0si.jpg" alt></p><p>c执行完毕之后，会从栈顶移除。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lth4pggfj307906rwe9.jpg" alt></p><p>函数返回到b，b也执行完了，b也从栈顶移除。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ltfr1pfij307j06gt8h.jpg" alt></p><p>同样a也会被移除。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ltkvl983j3079068q2p.jpg" alt></p><p>整个过程用动画来表示就是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lx8oasxag30gn09y0wq.gif" alt><br>(<a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gYygpIHt9CmZ1bmN0aW9uIGIoKSB7CgljKCk7Cn0KZnVuY3Rpb24gYSgpIHsKCWIoKTsKfQphKCk7!!!" target="_blank" rel="noopener">在线观看</a>)</p><p>这个时候我们还没有涉及到<code>堆内存</code>和<code>执行上下文栈</code>，一切还比较简单，这些内容我们放到后面来讲。</p><h3 id="DOM-和-WEB-API"><a href="#DOM-和-WEB-API" class="headerlink" title="DOM 和 WEB API"></a>DOM 和 WEB API</h3><p>现在我们有了可以执行JS的引擎，但是我们的目标是<code>构建用户界面</code>，而传统的前端用户界面是基于DOM构建的，因此我们需要引入DOM。DOM是<code>文档对象模型</code>，其提供了一系列JS可以直接调用的接口，理论上其可以提供其他语言的接口，而不仅仅是JS。 而且除了DOM接口可以给JS调用，浏览器还提供了一些WEB API。 DOM也好，WEB API也好，本质上和JS没有什么关系，完全不一回事。JS对应的ECMA规范，V8用来实现ECMA规范，其他的它不管。 这也是JS引擎和JS执行环境的区别，V8是JS引擎，用来执行JS代码，浏览器和Node是JS执行环境，其提供一些JS可以调用的API即<code>JS bindings</code>。</p><p>由于浏览器的存在，现在JS可以操作DOM和WEB API了，看起来是可以构建用户界面啦。 有一点需要提前讲清楚，V8只有栈和堆，其他诸如事件循环，DOM，WEB API它一概不知。原因前面其实已经讲过了，因为V8只负责JS代码的编译执行，你给V8一段JS代码，它就从头到尾一口气执行下去，中间不会停止。</p><p>另外这里我还要继续提一下，JS执行栈和渲染线程是相互阻塞的。为什么呢？ 本质上因为JS太灵活了，它可以去获取DOM中的诸如坐标等信息。 如果两者同时执行，就有可能发生冲突，比如我先获取了某一个DOM节点的x坐标，下一时刻坐标变了。 JS又用这个“旧的”坐标进行计算然后赋值给DOM，冲突便发生了。 解决冲突的方式有两种：</p><ol><li>限制JS的能力，你只能在某些时候使用某些API。 这种做法极其复杂，还会带来很多使用不便。</li><li>JS和渲染线程不同时执行就好了，一种方法就是现在广泛采用的<code>相互阻塞</code>。 实际上这也是目前浏览器广泛采用的方式。</li></ol><h3 id="单线程-or-多线程-or-异步"><a href="#单线程-or-多线程-or-异步" class="headerlink" title="单线程 or 多线程 or 异步"></a>单线程 or 多线程 or 异步</h3><p>前面提到了<code>你给V8一段JS代码，它就从头到尾一口气执行下去，中间不会停止</code>。 为什么不停止，可以设计成可停止么，就好像C语言一样？</p><p>假设我们需要获取用户信息，获取用户的文章，获取用的朋友。</p><h4 id="单线程无异步"><a href="#单线程无异步" class="headerlink" title="单线程无异步"></a>单线程无异步</h4><p>由于是单线程无异步，因此我们三个接口需要采用同步方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetchUserInfoSync().then(doSomethingA); <span class="comment">// 1s</span></span><br><span class="line">fetchMyArcticlesSync().then(doSomethingB);<span class="comment">// 3s</span></span><br><span class="line">fetchMyFriendsSync().then(doSomethingC);<span class="comment">// 2s</span></span><br></pre></td></tr></table></figure><p>由于上面三个请求都是同步执行的，因此上面的代码会先执行<code>fetchUserInfoSync</code>，一秒之后执行<code>fetchMyArcticlesSync</code>，再过三秒执行<code>fetchMyFriendsSync</code>。 最可怕的是我们刚才说了<code>JS执行栈和渲染线程是相互阻塞的</code>。 因此用户就在这期间根本无法操作，界面无法响应，这显然是无法接受的。</p><h4 id="多线程无异步"><a href="#多线程无异步" class="headerlink" title="多线程无异步"></a>多线程无异步</h4><p>由于是多线程无异步，虽然我们三个接口仍然需要采用同步方式，但是我们可以将代码分别在多个线程执行，比如我们将这段代码放在三个线程中执行。</p><p>线程一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetchUserInfoSync().then(doSomethingA); <span class="comment">// 1s</span></span><br></pre></td></tr></table></figure><p>线程二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetchMyArcticlesSync().then(doSomethingB); <span class="comment">// 3s</span></span><br></pre></td></tr></table></figure><p>线程三：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetchMyFriendsSync().then(doSomethingC); <span class="comment">// 2s</span></span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1g9lzjslxcaj20lr08nmy3.jpg" alt="1575538849801.jpg"></p><p>由于三块代码同时执行，因此总的时间最理想的情况下取决与最慢的时间，也就是3s，这一点和使用异步的方式是一样的（当然前提是请求之间无依赖）。为什么要说最理想呢？由于三个线程都可以对DOM和堆内存进行访问，因此很有可能会冲突，冲突的原因和我上面提到的JS线程和渲染线程的冲突的原因没有什么本质不同。因此最理想情况没有任何冲突的话是3s，但是如果有冲突，我们就需要借助于诸如<code>锁</code>来解决，这样时间就有可能高于3s了。 相应地编程模型也会更复杂，处理过锁的程序员应该会感同身受。</p><h4 id="单线程-异步"><a href="#单线程-异步" class="headerlink" title="单线程 + 异步"></a>单线程 + 异步</h4><p>如果还是使用单线程，改成异步是不是会好点？问题的是关键是如何实现异步呢？这就是我们要讲的主题 - <code>事件循环</code>。</p><h2 id="事件循环究竟是怎么实现异步的？"><a href="#事件循环究竟是怎么实现异步的？" class="headerlink" title="事件循环究竟是怎么实现异步的？"></a>事件循环究竟是怎么实现异步的？</h2><p>我们知道浏览器中JS线程只有一个，如果没有事件循环，就会造成一个问题。 即如果JS发起了一个异步IO请求，在等待结果返回的这个时间段，后面的代码都会被阻塞。 我们知道JS主线程和渲染进程是相互阻塞的，因此这就会造成浏览器假死。 如何解决这个问题？ 一个有效的办法就是我们这节要讲的<code>事件循环</code>。</p><p>其实<code>事件循环就是用来做调度的，浏览器和NodeJS中的事件循坏就好像操作系统的调度器一样。</code>操作系统的调度器决定何时将什么资源分配给谁。对于有线程模型的计算机，那么操作系统执行代码的最小单位就是线程，资源分配的最小单位就是进程，代码执行的过程由操作系统进行调度，整个调度过程非常复杂。  我们知道现在很多电脑都是多核的，为了让多个core同时发挥作用，即没有一个core是特别闲置的，也没有一个core是特别累的。操作系统的调度器会进行某一种神秘算法，从而保证每一个core都可以分配到任务。 这也就是我们使用NodeJS做集群的时候，Worker节点数量通常设置为core的数量的原因，调度器会尽量将每一个Worker平均分配到每一个core，当然这个过程并不是确定的，即不一定调度器是这么分配的，但是很多时候都会这样。</p><p>了解了操作系统调度器的原理，我们不妨继续回头看一下事件循环。 事件循环本质上也是做调度的，只不过调度的对象变成了JS的执行。事件循环决定了V8什么时候执行什么代码。<code>V8只是负责JS代码的解析和执行，其他它一概不知。</code>浏览器或者NodeJS中触发事件之后，到事件的监听函数被V8执行这个时间段的所有工作都是事件循环在起作用。</p><p>我们来小结一下：</p><ol><li>对于V8来说，它有：</li></ol><ul><li>调用栈（call stack）<blockquote><p>这里的单线程指的是只有一个call stack。只有一个call stack 意味着同一时间只能执行一段代码。</p></blockquote></li><li>堆（heap）</li></ul><ol start="2"><li>对于浏览器运行环境来说：</li></ol><ul><li>WEB API</li><li>DOM API</li><li>任务队列</li></ul><blockquote><p>事件来触发事件循环进行流动</p></blockquote><p>以如下代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">setTimeout(b, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>执行过程是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lxcn39hhg30go080dj1.gif" alt><br>(<a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gYygpIHt9CmZ1bmN0aW9uIGIoKSB7CgljKCk7Cn0KZnVuY3Rpb24gYSgpIHsKCXNldFRpbWVvdXQoYiwgMjAwMCkKfQphKCk7!!!" target="_blank" rel="noopener">在线观看</a>)</p><p>因此事件循环之所以可以实现异步，是因为碰到异步执行的代码“比如fetch，setTimeout”，浏览器会将用户注册的回调函数存起来，然后继续执行后面的代码。等到未来某一个时刻，“异步任务”完成了，会触发一个事件，浏览器会将“任务的详细信息”作为参数传递给之前用户绑定的回调函数。具体来说，就是将用户绑定的回调函数推入浏览器的执行栈。</p><p>但并不是说随便推入的，只有浏览器将当然要执行的JS脚本“一口气”执行完，要”换气“的时候才会去检查有没有要被处理的“消息”。<br>如果于则将对应消息绑定的回调函数推入栈。当然如果没有绑定事件，这个事件消息实际上会被丢弃，不被处理。比如用户触发了一个click事件，但是用户没有绑定click事件的监听函数，那么实际上这个事件会被丢弃掉。</p><p>我们来看一下加入用户交互之后是什么样的，拿点击事件来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.on(<span class="string">'button'</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'You clicked the button!'</span>);    </span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Click the button!"</span>);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Welcome to loupe."</span>);</span><br></pre></td></tr></table></figure><p>上述代码每次点击按钮，都会发送一个事件，由于我们绑定了一个监听函数。因此每次点击，都会有一个点击事件的消息产生，浏览器会在“空闲的时候”对应将用户绑定的事件处理函数推入栈中执行。</p><p>伪代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">queue.processNextMessage()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动画演示：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lxzvlth0g30go07yhc7.gif" alt><br>(<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank" rel="noopener">在线观看</a>)</p><h3 id="加入宏任务-amp-微任务"><a href="#加入宏任务-amp-微任务" class="headerlink" title="加入宏任务&amp;微任务"></a>加入宏任务&amp;微任务</h3><p>我们来看一个更复制的例子感受一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>上面的代码会输出：1、5、3、4、2。 如果你想要非常严谨的解释可以参考 whatwg 对其进行的描述 -<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">event-loop-processing-model</a>。</p><p>下面我会对其进行一个简单的解释。</p><ul><li>浏览器首先执行宏任务，也就是我们script（仅仅执行一次）</li><li>完成之后检查是否存在微任务，然后不停执行，直到清空队列</li><li>执行宏任务</li></ul><p>其中：</p><p>宏任务主要包含：setTimeout、setInterval、setImmediate、I/O、UI交互事件</p><p>微任务主要包含：Promise、process.nextTick、MutaionObserver 等</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9hfldyzj2j30g909xt8z.jpg" alt></p><p>有了这个知识，我们不难得出上面代码的输出结果。</p><p>由此我们可以看出，<code>宏任务&amp;微任务</code>只是实现异步过程中，我们对于信号的处理顺序不同而已。如果我们不加区分，全部放到一个队列，就不会有<code>宏任务&amp;微任务</code>。这种人为划分优先级的过程，在某些时候非常有用。</p><h3 id="加入执行上下文栈"><a href="#加入执行上下文栈" class="headerlink" title="加入执行上下文栈"></a>加入执行上下文栈</h3><p>说到执行上下文，就不得不提到<code>浏览器执行JS函数其实是分两个过程的</code>。一个是创建阶段<code>Creation Phase</code>,一个是执行阶段<code>Execution Phase</code>。</p><p>同执行栈一样，浏览器每遇到一个函数，也会将当前函数的执行上下文栈推入栈顶。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> n = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(num + n)</span><br><span class="line">&#125;</span><br><span class="line">c(num);</span><br><span class="line">&#125;</span><br><span class="line">b(num);</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>遇到上面的代码。 首先会将a的压入执行栈，我们开始进行创建阶段<code>Creation Phase</code>， 将a的执行上下文压入栈。然后初始化a的执行上下文，分别是VO，ScopeChain（VO chain）和 This。 从这里我们也可以看出，this其实是动态决定的。VO指的是<code>variables, functions 和 arguments</code>。 并且执行上下文栈也会同步随着执行栈的销毁而销毁。</p><p>伪代码表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EC  = &#123;</span><br><span class="line">    <span class="string">'scopeChain'</span>: &#123; &#125;,</span><br><span class="line">    <span class="string">'variableObject'</span>: &#123; &#125;,</span><br><span class="line">    <span class="string">'this'</span>: &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lyjjb6ecj30mh0c0aa2.jpg" alt></p><p>我们来重点看一下ScopeChain(VO chain)。如上图的执行上下文大概长这个样子，伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">global.VO = &#123;</span><br><span class="line">    a: pointer to a(),</span><br><span class="line">    scopeChain: [global.VO]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.VO = &#123;</span><br><span class="line">    b: pointer to b(),</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">    scopeChain: [a.VO, global.VO]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.VO = &#123;</span><br><span class="line">c: pointer to c(),</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">scopeChain: [b.VO, a.VO, global.VO]</span><br><span class="line">&#125;</span><br><span class="line">c.VO = &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">n: <span class="number">3</span></span><br><span class="line">scopeChain: [c.VO, b.VO, a.VO, global.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引擎查找变量的时候，会先从VOC开始找，找不到会继续去VOB…，直到GlobalVO，如果GlobalVO也找不到会返回<code>Referrence Error</code>，整个过程类似原型链的查找。</p><p>值得一提的是，JS是词法作用域，也就是静态作用域。换句话说就是作用域取决于代码定义的位置，而不是执行的位置，<code>这也就是闭包产生的本质原因</code>。 如果上面的代码改造成下面的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">a()</span><br><span class="line">b()</span><br><span class="line">c()</span><br></pre></td></tr></table></figure><p>或者这种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>其执行上下文栈虽然都是一样的，但是其对应的scopeChain则完全不同，因为函数定义的位置发生了变化。拿上面的代码片段来说,c.VO会变成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.VO = &#123;</span><br><span class="line">scopeChain: [c.VO, global.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说其再也无法获取到a和b中的VO了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这篇文章，希望你对单线程，多线程，异步，事件循环，事件驱动等知识点有了更深的理解和感悟。除了这些大的层面，我们还从执行栈，执行上下文栈角度讲解了我们代码是如何被浏览器运行的，我们顺便还解释了作用域和闭包产生的本质原因。</p><p>最后我总结了一个浏览器运行代码的整体原理图，希望对你有帮助：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lzm6dww0j30kw0pjt8s.jpg" alt></p><p>下一节<code>浏览器的事件循环和NodeJS的事件循环有什么不同</code>, 敬请期待～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.logrocket.com/a-complete-guide-to-the-node-js-event-loop/" target="_blank" rel="noopener">Node.js event loop - logrocket</a></li><li><a href="https://nodejs.org/de/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">event-loop - nodejs.org</a></li><li><a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">what-is-the-execution-context-in-javascript</a></li><li><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener">Event Loop in JS - youtube </a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 事件循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一荐 2019-10 汇总</title>
      <link href="/blog/2019/12/11/daily-featured-2019-10/"/>
      <url>/blog/2019/12/11/daily-featured-2019-10/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8d0sktqrwj30hs07maae.jpg" alt></p><p>每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。</p><p>项目主页维护当前月份的内容，想看往期内容，可以去<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">每日一荐主仓库</a>翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。</p><a id="more"></a><h2 id="2019-10"><a href="#2019-10" class="headerlink" title="2019-10"></a>2019-10</h2><h3 id="2019-10-31-技能"><a href="#2019-10-31-技能" class="headerlink" title="2019-10-31[技能]"></a>2019-10-31[技能]</h3><p>虽然我们不是专门的网络工程师，但是不免在实际工作以及面试中会需要这方面的知识，当然这是浅层的即可。如果完全不知道，那么对于一些网络性能优化问题肯定是没有概念，从而无从下手的。</p><p>网上关于HTTP协议的文章很多，面试的时候关于HTTP三大版本的差异也是热门考点。这篇文章就通俗易懂地解释了<code>HTTP/2与HTTP/3 的新特性</code>, 相比于之前，为什么要推出新的协议，核心解决了什么问题？有什么不足？ 这些东西网上资料要么就是太专业，要么就是太笼统和人云亦云，这篇文章是相对比较适合新手读的一个文章。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gfh4xbabj30kp09y3yq.jpg" alt></p><p>文章地址： <a href="https://segmentfault.com/a/1190000020714686#articleHeader16" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020714686#articleHeader16</a></p><h3 id="2019-10-30-类库"><a href="#2019-10-30-类库" class="headerlink" title="2019-10-30[类库]"></a>2019-10-30[类库]</h3><p>很多年前我自己写过一个简陋的<code>pub/sub库</code>, 这个仓库甚至被一些人在用。很多时候我们需要用到这种灵活的<code>pub/sub</code>功能，这个时候我们就会自己实现，或者用一些开源的。 今天给大家介绍的就是鼎鼎大名的Jason Miller写的一个<code>tiny event pub sub implement</code>，代码就几十行，不仅注释详实，而且给出了丰富的类型定义，代码简单易懂，非常适合学习。</p><p>代码地址： <a href="https://github.com/developit/mitt/blob/master/src/index.js" target="_blank" rel="noopener">https://github.com/developit/mitt/blob/master/src/index.js</a></p><h3 id="2019-10-29-网站"><a href="#2019-10-29-网站" class="headerlink" title="2019-10-29[网站]"></a>2019-10-29[网站]</h3><p>上一次给大家分享了一个常用正则的VSCode插件（2019-10-11期），另外的<a href="https://lucifer.ren/fe-interview/#/?id=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f">《大前端面试宝典》</a>也讲到了正则的学习，并给出了我认为非常不错的学习资料。</p><p>今天我继续给大家介绍几个正则学习&amp;练习的网站。</p><ul><li><p><a href="https://alf.nu/RegexGolf" target="_blank" rel="noopener">Regex Golf</a> 是一个有名的正则练习网站，会根据你的正则打分，难度偏高。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8e747lxbtj30xp08w3yn.jpg" alt></p></li><li><p><a href="https://regexone.com/lesson/introduction_abcs" target="_blank" rel="noopener">regexone</a> 是一个交互友好，面向新手的一个正则练习网站，可以交互式地学习正则，右边还贴心地给出了Notes，另外语言不同其实正则规范也不太一样，这个网站给出了不同语言的正则讲解，很用心。值得一题的是，里面的资料非常新，最新的<code>/u- interpret the regular expression as unicode codepoints</code> 都有。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8e77k79czj30wm0kwmyy.jpg" alt></p></li><li><p><a href="https://regexr.com/" target="_blank" rel="noopener">regexr</a>这个不是练习的， 是用来可视化的， 和之前的<a href="https://regexper.com/" target="_blank" rel="noopener">regexper</a>有点像，就连域名都差不多，不过这个用户体验是真的棒。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8e7a58pt9j31gw0oogn4.jpg" alt></p></li><li><p><a href="http://play.inginf.units.it/#/" target="_blank" rel="noopener">The regular expression game</a> 是一个过关类型的正则练习网站，有意思的是它可以根据你写的正则匹配程度进行打分，即使你没有全部匹配也是可以得分的。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8e7doryfpj30wv0exdgu.jpg" alt></p></li></ul><h3 id="2019-10-28-工具"><a href="#2019-10-28-工具" class="headerlink" title="2019-10-28[工具]"></a>2019-10-28[工具]</h3><p>这个是人称贺老的百姓网贺师俊<code>Hax</code>整理的一份<code>中文技术活动日程</code>， 这些活动有几个特点：</p><ul><li>技术活动的主要语言是中文</li><li>技术活动的主要参与者是程序员</li><li>技术活动的主要日程接受公开报名</li><li>技术活动具有一定规模</li></ul><p>目前这个仓库仅有个简陋的 <code>yaml 数据文件</code>，记录<code>技术活动的时间和一些信息</code>。后续希望能加入一个更好的查询界面。活动组织者可直接修改数据文件并提交PR，或提交issue描述一下活动情况。活动组织者也可以 watch 本仓库，这样当有变动时（通常是会议信息更新），可以收到通知。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ankjskagj30rb0fs74l.jpg" alt></p><p>仓库地址：<a href="https://github.com/hax/chinese-tech-conf-schedule" target="_blank" rel="noopener">https://github.com/hax/chinese-tech-conf-schedule</a></p><h3 id="2019-10-25-工具"><a href="#2019-10-25-工具" class="headerlink" title="2019-10-25[工具]"></a>2019-10-25[工具]</h3><p>今天给大家推荐的是一个我个人非常喜欢的一个<code>好用且免费图床工具</code> - <a href="https://apps.apple.com/cn/app/ipic-markdown-%E5%9B%BE%E5%BA%8A-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%B7%A5%E5%85%B7/id1101244278?mt=12" target="_blank" rel="noopener">IPic</a>。 这个工具不仅内置免费的微博图床,还可以自己定义，我本人还添加了腾讯云的COS</p><p>使用起来也非常简单，直接复制图片，然后点击对应的图片即可，另外值得一提的是它本身还支持直接生成MardDown链接，这对经常用MarkDown写作的我来说绝对是一个非常实用的功能。</p><p>另外它还搭配了一个软件<a href="https://apps.apple.com/cn/app/ipic-mover/id1183822957?mt=12" target="_blank" rel="noopener">IPic Mover</a>用来迁移图床，比如你的文章里面都是新浪图床，只需要一键就可以瞬间迁移到别的平台，比如腾讯云COS。 不过这个搭配的工具是收费的，但是有免费体验时间。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89bcu7rihj30ha0zkwgi.jpg" alt></p><h3 id="2019-10-24-技能"><a href="#2019-10-24-技能" class="headerlink" title="2019-10-24[技能]"></a>2019-10-24[技能]</h3><p>今天是1024程序员节，祝广大的程序员们节日快乐。🎩🎩🎩🎩🎩🎩</p><p>之前给大家介绍了一款跨平台的Web平台技术栈检测工具Wappalyzer。这几天我看了下他的源码，觉得很不错，于是就想着推荐给大家。</p><p>Wappalyzer的整体架构非常有意思，这里讲一下我发现的主要特点，更多细节等待着你的探索。</p><ul><li>平台相关的代码放在drivers文件夹下，公共的代码在src/wappalyzer.js</li><li>特地写了validate脚本来检测代码。</li><li>将检测逻辑抽离到了src/app.json中， 以配置文件的形式存放（这个json文件结构设计地很精巧，应该是花了心思的）</li><li>主要采用正则来检测应用</li><li>考虑到间接引用，比如框架A引用了B，那么检测到了A也会把B带上</li></ul><p>如果想快速上手可以看下ta提供的<a href="https://github.com/AliasIO/Wappalyzer/blob/master/src/wappalyzer.spec.js" target="_blank" rel="noopener">测试用例</a>，非常简洁。</p><p>Github地址： <a href="https://github.com/AliasIO/Wappalyzer" target="_blank" rel="noopener">https://github.com/AliasIO/Wappalyzer</a></p><h3 id="2019-10-23-网站"><a href="#2019-10-23-网站" class="headerlink" title="2019-10-23[网站]"></a>2019-10-23[网站]</h3><p>今天给广大的前端朋友们介绍一个在线做题的网站，可以瞬间在线知道答案，而且不需要登陆，一共58道题目，不知道后续会不会更新。 这个网站的题目我看了其实没有什么新意，但是不需要登陆而是直接使用LocalStorage来存储你的答题情况对用户来说很轻量，给我的感觉很好，感兴趣的可以试一下。 </p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87wixe9u2j30gk0f93yu.jpg" alt></p><p>(题目列表)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87wji13epj30ht0ket8v.jpg" alt></p><p>(题目详情)</p><p>网址： <a href="https://quiz.typeofnan.dev/" target="_blank" rel="noopener">https://quiz.typeofnan.dev/</a></p><h3 id="2019-10-22-观点"><a href="#2019-10-22-观点" class="headerlink" title="2019-10-22[观点]"></a>2019-10-22[观点]</h3><p>前一段时间王思聪的股权遭到了冻结，据中新经纬记者计算，王思聪名下冻结股权价值合计已经超过8445万元。</p><p>“这种情况一般是王思聪欠别人钱，别人追讨，作为诉讼保全措施冻结的。”金杜律师事务所律师李量接受虎嗅采访时说，“王思聪欠钱可以是直接欠，或和贾跃亭一样，给别人提供担保，承担了连带责任。”</p><p>但是实际上这种冻结对于王思聪来说根本起不到作用，他会有很多方法来免除所谓的强制执行，他只要将自己的股权先一步将股权质押给万达集团，这样<code>质押权人就对被保全的股份有优先权</code>, 换句话说这<code>对王思聪来说这种冻结根本无效</code>。</p><p>现实中有很多这样的事情，这些规则似乎是在<code>限制那些“能力不足”的人，而对社会上这些“制造规则的人”无能为力</code>。更可悲的是，很多人对这些不知道，不关注。其实越是贫穷的家庭，越是生活在社会底层的人，他们的后代，大概率还会是穷人。其实，我们奋斗的目标无非就是：让子女一出生就站在了别人的肩膀上！</p><h3 id="2019-10-21-效率"><a href="#2019-10-21-效率" class="headerlink" title="2019-10-21[效率]"></a>2019-10-21[效率]</h3><p>我是一个有着轻微强迫症的人，社交软件的小红点有时候会打乱我的节奏，将我从专注模式(Focus Mode)强制转化为发散模式（Diffuse Mode）。 这两种模式适合我们做不同类型的工作，因此掌控小红点，避免这种不希望的模式切换是提高效率的一个有效途径。</p><p>我的做法是：</p><ul><li>手机静音</li><li>电脑关闭红点提醒</li></ul><p>mac电脑可以在系统偏好设置 - 通知 - 对应APP - 将标记应用程序的勾去掉</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g82fq7pugoj30hj09vmzb.jpg" alt></p><p>一般而言，你也不用担心会错过什么东西，因为右侧通知还是会有的，比如钉钉的会议提醒等。</p><p>经过这样的设置，你就可以自由切换两种模式，而不会被频繁打断，当然还是会有人来打断你，这个问题我们以后再讲。</p><h3 id="2019-10-18-类库"><a href="#2019-10-18-类库" class="headerlink" title="2019-10-18[类库]"></a>2019-10-18[类库]</h3><p>UMI的官方定位是<code>可插拔的企业级 react 应用框架</code>。其作者云谦也是Ant-Design，dvajs的核心贡献者，同时也是我早期关注的人之一。这个项目的价值绝对不亚于更受大家欢迎的dvajs，是一个值得学习的项目。</p><p>说白了，Umi 和 create-react-app（cra）类似，就是现有技术栈的组合，封装细节，让开发者用起来更简单，只写业务代码就可以了，它有几个特点：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g81gv20dydj30rd0g7gq3.jpg" alt></p><ul><li>零配置就是默认选型都给你做好了。</li><li>开箱即用就是技术栈都固化了。</li><li>约定大于配置，开发模式也固化好了。</li></ul><p>下图是云谦介绍umi的定位的时候贴的一张架构图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hiqa9s0wj30u00l0ac7.jpg" alt></p><p>项目地址：<a href="https://github.com/umijs/umi" target="_blank" rel="noopener">https://github.com/umijs/umi</a></p><h3 id="2019-10-17-工具"><a href="#2019-10-17-工具" class="headerlink" title="2019-10-17[工具]"></a>2019-10-17[工具]</h3><p>之前分享过《2019-09-23 - 为什么一行80个字符是一个值得遵守的规范，即使你拥有4k显示器？》，里面提到了并排窗口的问题。 多个显示器确实可以提高效率，如果你能高效地利用每一个显示器，效果会更棒。</p><blockquote><p>配合4k大屏显示器效果更棒</p></blockquote><p>今天介绍的这款工具就是一款窗口布局工具，能够快速修改当前窗口大小并放置在指定位置，Moom 默认操作点设立在了窗口左上角的绿色按钮上，将鼠标hover在绿钮上就会弹出一个选择菜单，里面有五种尺寸可选，单击选项即可变化窗口大小，并能将窗口移动到指定位置。</p><blockquote><p>搭配使用快捷键效果更棒</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g80yebwmr2j30u10fwdhw.jpg" alt></p><h3 id="2019-10-16-工具"><a href="#2019-10-16-工具" class="headerlink" title="2019-10-16[工具]"></a>2019-10-16[工具]</h3><p>今天给大家推荐的是一款非常好用的Chrome插件，可以用来查看网站是由什么技术栈构建的。其实类似的软件也有别的，但是这个是我使用过的最好的一个。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z2wky65hj30d5093gln.jpg" alt></p><p>（这个是其官网的检测结果）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z2wyx0jzj30db09374b.jpg" alt></p><p>（这个是GitHub的检测结果）</p><p>项目主页： <a href="https://www.wappalyzer.com" target="_blank" rel="noopener">https://www.wappalyzer.com</a></p><h3 id="2019-10-15-技能"><a href="#2019-10-15-技能" class="headerlink" title="2019-10-15[技能]"></a>2019-10-15[技能]</h3><p>今天给大家分享一个微信小技巧，据说有的人还不知道，所以今天就把它分享出来，大家如果有什么微信使用小技巧也欢迎在下方进行评论。</p><p>今天的小技巧是<code>判断对方是否把你拉黑或者删除</code>:</p><ol><li>给对方转账，是好友会让你输入密码，不是好友都不用你输入密码，直接弹出下图，整个过程好友不知情的！</li></ol><ul><li>如果拉黑会提示： <code>请确认你和他（她）的好友关系是否正常</code></li><li>如果删除，则会提示： <code>你不是收款方的好友</code></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ynsya4cmj306m05wt8l.jpg" alt></p><ol start="2"><li>点开好友名片，如果显示左图，说明她真的没有发过一条朋友圈。若显示右图，点开个人相册却什么也看不到，那么你有可能被删除、拉黑、朋友圈屏蔽，或者发过朋友圈但设为私密了。</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7yns7ad9uj30k00f0aal.jpg" alt></p><p>为了搞清楚对方是删除还是屏蔽，你就可以用到开头转账的那一招啦！</p><h3 id="2019-10-14-好文"><a href="#2019-10-14-好文" class="headerlink" title="2019-10-14[好文]"></a>2019-10-14[好文]</h3><p>如果想做一些高级的东西，编译是一个绕不过的坎，Babel是一个前端的转义工具，Babel有着自己的插件系统，这是个系列文章，通过这个系列你可以学到AST，以及Babel插件相关的东西，并且你可以自己动手写一个Babel插件。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7xhj17ovfj30kv0hhmxq.jpg" alt></p><p>文章地址： </p><ul><li><a href="https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/" target="_blank" rel="noopener">Step-by-step guide for writing a custom babel transformation</a></li><li><a href="https://lihautan.com/creating-custom-javascript-syntax-with-babel/" target="_blank" rel="noopener">Creating custom JavaScript syntax with Babel</a></li></ul><h3 id="2019-10-12-工具"><a href="#2019-10-12-工具" class="headerlink" title="2019-10-12[工具]"></a>2019-10-12[工具]</h3><p>前端在调试兼容性样式的时候是一个很头疼的问题，各个浏览器以及同一个浏览器不同版本支持的css都是不同的，比如有些不支持Grid，有些不支持cal函数。如果你自己根据这些去修改代码肯定是非常低效的，这个Chrome插件就是解决这样的问题，你可以在高级的浏览器上调试，自行禁用一些css特性来debug。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ucx8rqutj30dv05sq2v.jpg" alt></p><p>仓库地址： <a href="https://github.com/keithclark/css-feature-toggle-devtools-extension" target="_blank" rel="noopener">https://github.com/keithclark/css-feature-toggle-devtools-extension</a></p><p>chrome插件地址： <a href="https://chrome.google.com/webstore/detail/css-feature-toggles/aeinmfddnniiloadoappmdnffcbffnjg" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/css-feature-toggles/aeinmfddnniiloadoappmdnffcbffnjg</a></p><h3 id="2019-10-11-工具"><a href="#2019-10-11-工具" class="headerlink" title="2019-10-11[工具]"></a>2019-10-11[工具]</h3><p>常用正则大全, 支持vscode扩展插件</p><p>值得一提的是它支持VSCode插件形式使用：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7u0yqfy5nj30jn0eg0t4.jpg" alt></p><p>目前有57个正则：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7u0zximv9j30b80g3dgg.jpg" alt></p><p>插件地址： <a href="https://github.com/any86/any-rule" target="_blank" rel="noopener">https://github.com/any86/any-rule</a></p><h3 id="2019-10-10-技能"><a href="#2019-10-10-技能" class="headerlink" title="2019-10-10[技能]"></a>2019-10-10[技能]</h3><p>傅里叶变换是一种在各个领域都经常使用的数学工具。这个网站将为你介绍傅里叶变换能干什么，为什么傅里叶变换非常有用，以及你如何利用傅里叶变换干漂亮的事。傅立叶变换有很多实际的应用，比如MP3的原理，MP3是如何将声波转化为二进制，并如何进行压缩的？ 比如JPEG的原理等。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7s4pz83xyj30x50kpt9s.jpg" alt></p><p>这个文章（网站）是我见过傅立叶变换最直观的一个解释之一，并且支持交互式操作。 </p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7s4pm4mooj307404j0sl.jpg" alt></p><p>网站地址： <a href="http://www.jezzamon.com/fourier/zh-cn.html" target="_blank" rel="noopener">http://www.jezzamon.com/fourier/zh-cn.html</a></p><h3 id="2019-10-09-工具"><a href="#2019-10-09-工具" class="headerlink" title="2019-10-09[工具]"></a>2019-10-09[工具]</h3><p>VSCode是我经常使用的一个软件，结合自己的开发习惯我也会增加很多配置和插件等，如何将这些插件进行备份以便将来换电脑可以及时同步过来，这里关于VScode的配置我用的是VSCode <a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" target="_blank" rel="noopener">setting sync 插件</a>。</p><p>这个需要结合Gist使用，具体使用方式请查看官方文档：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7r455m0zmj30i909dq36.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7r4cvxwb5j30rw0gc74r.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7r4db2zxbj30tf0kcgm9.jpg" alt></p><p>其实我有一个专门的<a href="https://github.com/azl397985856/dev-config" target="_blank" rel="noopener">开发常用配置文件备份仓库</a>用来存放这些东西，这是我的仓库存放的配置，这样我即使换了电脑也能很快地用到我最舒服的配置。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7r4nhzmjgj30a808ajrb.jpg" alt></p><p>如果大家没有更好的方式，不妨采用这种方式，如果你有更好的方式欢迎给我留言。</p><h3 id="2019-10-08-工具"><a href="#2019-10-08-工具" class="headerlink" title="2019-10-08[工具]"></a>2019-10-08[工具]</h3><p>今天是国庆结束的第一天，大家假期玩的怎么样？ 希望大家可以尽快从假期的状态中转变回来。今天给大家推荐一个我个人使用比较多的一个功能，就是<code>剪贴板历史</code>。</p><p>我在使用手机的时候（笔者使用的是安卓机），会经常复制一些文字或者图片，然后进行粘贴，有时候会需要粘贴之前复制的一个东西，因此剪贴板历史就显得很重要，手机上我用的就是<code>搜索输入法自带的剪贴板历史功能</code>。</p><p>而在电脑上我使用的是Alfred自带的<code>剪贴板历史</code>功能，只不过默认不开启，你需要去配置一下才行。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pqb232pxj30w50fvdgy.jpg" alt></p><p>然后你就可以查看你的剪贴板历史了：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pqbppfxrj30hg0cn0tt.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pqc0f7tbj30g40bv75d.jpg" alt></p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>我重新整理了下自己的公众号，并且我还给它换了一个名字<code>脑洞前端</code>，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。</p><p>之后我的文章会同步到微信公众号 <code>脑洞前端</code> ，你可以关注获取最新的文章，并和我进行交流。</p><p>另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。</p><img width="300" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7he9xdtmyj30by0byaac.jpg">]]></content>
      
      
      <categories>
          
          <category> 每日一荐 </category>
          
          <category> 2019-10 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/blog/2019/12/11/bloom-filter/"/>
      <url>/blog/2019/12/11/bloom-filter/</url>
      
        <content type="html"><![CDATA[<p>假设你现在要处理这样一个问题，你有一个网站并且拥有<code>很多</code>访客，每当有用户访问时，你想知道这个ip是不是第一次访问你的网站。你会怎么做呢？</p><a id="more"></a><h3 id="hashtable-可以么"><a href="#hashtable-可以么" class="headerlink" title="hashtable 可以么"></a>hashtable 可以么</h3><p>一个显而易见的答案是将所有的ip用hashtable存起来，每次访问都去hashtable中取，然后判断即可。但是题目说了网站有<code>很多</code>访客，<br>假如有10亿个用户访问过，每个ip的长度是4 byte，那么你一共需要4 * 1000000000 = 4000000000Bytes = 4G , 如果是判断URL黑名单，<br>由于每个URL会更长，那么需要的空间可能会远远大于你的期望。</p><h3 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h3><p>另一个稍微难想到的解法是bit， 我们知道bit有0和1两种状态，那么用来表示存在，不存在再合适不过了。</p><p>加入有10亿个ip，我们就可以用10亿个bit来存储，那么你一共需要 1 * 1000000000 = (4000000000 / 8) Bytes = 128M, 变为原来的1/32,<br>如果是存储URL这种更长的字符串，效率会更高。 </p><p>基于这种想法，我们只需要两个操作，set(ip) 和 has(ip)</p><p>这样做有两个非常致命的缺点：</p><ol><li>当样本分布极度不均匀的时候，会造成很大空间上的浪费</li></ol><blockquote><p>我们可以通过散列函数来解决</p></blockquote><ol start="2"><li>当元素不是整型（比如URL）的时候，BitSet就不适用了</li></ol><blockquote><p>我们还是可以使用散列函数来解决， 甚至可以多hash几次</p></blockquote><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器其实就是<code>bit + 多个散列函数</code>,  如果经过多次散列的值再bit上都为1，那么可能存在(可能有冲突)。 如果<br>有一个不为1，那么一定不存在（一个值经过散列函数得到的值一定是唯一的），这也是布隆过滤器的一个重要特点。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-22-041300.jpg" alt="bloom-filter-url"></p><h3 id="布隆过滤器的应用"><a href="#布隆过滤器的应用" class="headerlink" title="布隆过滤器的应用"></a>布隆过滤器的应用</h3><ol><li><p>网络爬虫<br>判断某个URL是否已经被爬取过</p></li><li><p>K-V数据库 判断某个key是否存在</p></li></ol><p>比如Hbase的每个Region中都包含一个BloomFilter，用于在查询时快速判断某个key在该region中是否存在。</p><ol start="3"><li>钓鱼网站识别</li></ol><p>浏览器有时候会警告用户，访问的网站很可能是钓鱼网站，用的就是这种技术</p><blockquote><p>从这个算法大家可以对 tradeoff(取舍) 有更入的理解。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 布隆过滤器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一荐 2019-09 汇总</title>
      <link href="/blog/2019/12/11/daily-featured-2019-09/"/>
      <url>/blog/2019/12/11/daily-featured-2019-09/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8d0sktqrwj30hs07maae.jpg" alt></p><p>每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。</p><p>项目主页维护当前月份的内容，想看往期内容，可以去<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">每日一荐主仓库</a>翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。</p><a id="more"></a><h2 id="2019-09"><a href="#2019-09" class="headerlink" title="2019-09"></a>2019-09</h2><h3 id="2019-09-30-工具"><a href="#2019-09-30-工具" class="headerlink" title="2019-09-30[工具]"></a>2019-09-30[工具]</h3><p>今天是9月的最后一天，明天就是十一了，提前祝大家国庆节快乐 ～～～ 🎉🎉🎉🎉🎉🎉🎉 ！</p><p>今天再来给大家安利6个chrome扩展程序，排名不分先后。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7hccis83hj30g30gl3z1.jpg" alt></p><ol><li>Proxy SwitchyOmega</li></ol><p>此扩展为 SwitchySharp 的升级版，可替代 SwitchyPlus 或 Proxy Switchy. 可轻松快捷地管理和切换多个代理设置，是一个我使用多年的一个插件，配合PAC食用味道更好。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hcjh2gmjj30hs0b43ym.jpg" alt></p><p><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">下载地址</a></p><ol start="2"><li>OneTab</li></ol><p>节省高达95％的内存，并减轻标签页混乱现象。 有些标签关了舍不得，不关太多看的很乱并且更关键的是占用内存。有了这个工具就不存在这些问题了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7hchdk0tyj30hs0b4js1.jpg" alt></p><p><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">下载地址</a></p><ol start="3"><li>AdBlock Plus</li></ol><p>Adblock Plus 是世界上最流行的浏览器扩展，世界各地有数百万用户在使用它。这是一个社区驱动的开源项目，有数百名志愿者为 Adblock Plus 的成功作出了贡献，以实现所有烦人的广告被自动阻挡。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hcm4giztj30u70anjs2.jpg" alt></p><p><a href="https://chrome.google.com/webstore/search/AdBlock" target="_blank" rel="noopener">下载地址</a></p><ol start="4"><li>Multi-highlight</li></ol><p>普通的网页搜索只能一个一个搜索，不能同时搜索多个关键字，这个扩展提供了这种功能上的扩展。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7hcoq78bhj30hs0b4q3i.jpg" alt></p><p><a href="https://chrome.google.com/webstore/detail/multi-highlight/pfgfgjlejbbpfmcfjhdmikihihddeeji" target="_blank" rel="noopener">下载地址</a></p><ol start="5"><li>HTML5 Outliner</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7hcpx8en4j30hs09vmxp.jpg" alt></p><p>我平时再看文章或者文档的时候习惯先看一遍目录或者大纲，然后再决定我到底要不要看，看哪里。我相信很多人和我一样有着同样的习惯。但是很多网站，包括infoq，知乎等大网站这方面都做的比较差。下图是我的个人博客的大纲功能：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7hcwcm5wgj30uo0prq5e.jpg" alt></p><p>因此这款工具对于我这种人来说就非常重要了，他能根据当前网页的结果快速生成大纲，并且支持锚点功能，当然它也有很多覆盖不到的情况，因为标题的种类实现太多了，大家完全可以写一个<code>div class = &#39;header&#39;</code>从而让这个工具无用武之地。 这也从侧面说明了语义化的重要性，不仅对于障碍人士重要，对于无障碍人士也有很大的意义。</p><p><a href="https://chrome.google.com/webstore/detail/html5-outliner/afoibpobokebhgfnknfndkgemglggomo" target="_blank" rel="noopener">下载地址</a></p><ol start="6"><li>眼睛护航</li></ol><p>把网页背景变成眼睛保护色或适合夜晚阅读的夜间模式，一些无法变色的小区块可以通过单击进行变色。到了晚上将自动从绿色护眼模式变为夜间阅读模式。当然，也可以手动强制使用绿色模式或夜间模式。</p><p>这在一些体验差的网站上极为重要，还有一些大量使用亮瞎眼的颜色网站也有很好的作用，类似提升阅读体验的扩展还有<a href="https://chrome.google.com/webstore/detail/simpread-reader-view/ijllcpnolfcooahcekpamkbidhejabll?hl=zh-CN" target="_blank" rel="noopener">简悦</a>。</p><p><a href="https://chrome.google.com/webstore/detail/care-your-eyes/fidmpnedniahpnkeomejhnepmbdamlhl" target="_blank" rel="noopener">下载地址</a></p><h3 id="2019-09-29-工具"><a href="#2019-09-29-工具" class="headerlink" title="2019-09-29[工具]"></a>2019-09-29[工具]</h3><p>如果你是一个站长，那么你一定需要一个网站速度测试工具。</p><p>你的用户如果都是中国用户，那么用<a href="http://tool.chinaz.com/speedtest/lucifer.ren" target="_blank" rel="noopener">站长工具-国内测试</a>应该就够用了。 如果你的用户有海外的话，可以试试<a href="https://tool.chinaz.com/speedworld/" target="_blank" rel="noopener">站长工具-国际测试</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7eb8e0j03j30lc0ftq3q.jpg" alt><br>(国内测速)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7eb8xtac5j30kn097dfz.jpg" alt><br>(国际测试)</p><blockquote><p>不得不吐槽下，网站体验做的不太好，而且广告有点多。</p></blockquote><p>另外还有一个网站，不过这个只能够测试国内的网速，<a href="https://www.17ce.com/" target="_blank" rel="noopener">17ce</a>的体验做的稍微好一点，广告也没有那么显眼，如果你的客户只是国内，不妨考虑这个。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ebbwxvykj31340l53z8.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ebcj8p59j30xq0hcq3l.jpg" alt></p><p>最后介绍一个国外的网站<a href="https://tools.pingdom.com" target="_blank" rel="noopener">pingdom</a>，如果客户是全球的，可以考虑用这个，这个是这几个中用户体验做的最好的。给出的技术指标比较多一点，但是他没有区域分布热力图, 并且支持的区域也不多。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ebja8fm6j30vy0aft93.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ebgcr1elj30uf0llaay.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ebhmc7iij30v20nh74w.jpg" alt></p><h3 id="2019-09-27-类库"><a href="#2019-09-27-类库" class="headerlink" title="2019-09-27[类库]"></a>2019-09-27[类库]</h3><p>之前我写了一篇 <a href="https://github.com/azl397985856/frontend-test" target="_blank" rel="noopener">【前端测试】</a> 的草稿，一直搁置到现在，之前我做后端的时候，写测试尤其是单元测试是很普遍的。但是做前端这么久发现大家对这方面不是很重视， 其实前端也是非常需要做测试的。</p><p>今天给大家推荐的是一个非常流行的前端测试框架jest的GUI工具<a href="https://github.com/Raathigesh/majestic" target="_blank" rel="noopener">majestic</a> (⚡ Zero config GUI for Jest)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7d2hpkzxuj30ym0u0wg9.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7d2icroztj30cx0a33yn.jpg" alt></p><h3 id="2019-09-26-工具"><a href="#2019-09-26-工具" class="headerlink" title="2019-09-26[工具]"></a>2019-09-26[工具]</h3><p>你一定有想用某一个功能的快捷键，却想不出来的情况。也一定面临过多个软件快捷键不统一带来的烦恼，比如A软件<code>CMD + S</code>是保存， 另外一个软件B是<code>Shift + S</code>。</p><p>对于第一种问题，我们可以用一个叫cheatsheet的mac软件，有了它你就可以通过长按command键，从而查看当前应用的快捷键。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bja8uiysj31c20ohdkr.jpg" alt></p><p>cheatsheet下载地址： <a href="https://cheatsheet-mac.en.softonic.com/mac" target="_blank" rel="noopener">https://cheatsheet-mac.en.softonic.com/mac</a>   </p><blockquote><p>顺便吐槽一下，cheatsheet官网用户体验这块做的不怎么样</p></blockquote><p>对于按键不统一的问题，我们可以直接修改对应软件的快捷键即可，毕竟大多数软件都是支持快捷键定制的，还有一些<code>服务</code>快捷键我们可以去<code>系统偏好设置 - 键盘 - 服务</code>中修改。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7bjf9q87uj30ik0g1jry.jpg" alt></p><p>另外给大家安利一个软件<code>Karabiner-Elements</code>, 它是一个mac上好用的键盘定制工作，可以用来改键，定制超级键等，更多功能等你挖掘。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bjhb8tfzj30rq0fvjrh.jpg" alt></p><blockquote><p> 配合HHKB效果更佳</p></blockquote><p>Karabiner-Elements 下载地址： <a href="https://github.com/tekezo/Karabiner-Elements" target="_blank" rel="noopener">https://github.com/tekezo/Karabiner-Elements</a></p><h3 id="2019-09-25-技能"><a href="#2019-09-25-技能" class="headerlink" title="2019-09-25[技能]"></a>2019-09-25[技能]</h3><p>熟练使用命令行是一种常常被忽视，或者被认为难以掌握的技能，一旦掌握，会极大提高你工作的效率。当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。</p><p>今天介绍的这个仓库，首发于 Quora， 后面迁移到了 Github，并由众多高手做出了许多改进，现在已经有6W+ Star了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aupdnzicj30dc08040e.jpg" alt></p><p>仓库目录（目录是我用工具自己抓的，非官方提供）：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7aupokxczj30ed0bp74e.jpg" alt></p><p>仓库地址： <a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" rel="noopener">https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md</a></p><h3 id="2019-09-24-工具"><a href="#2019-09-24-工具" class="headerlink" title="2019-09-24[工具]"></a>2019-09-24[工具]</h3><p>今天给大家分享的是VSCode 前一段时间推出的SSH扩展，实际使用效果非常棒，除了延迟，让你感觉不到你是在操作远程的文件。虽然有延迟，但是也仅仅限于你和服务器有IO交互的情况下才会有感知，结合我的使用体验来说，是“几乎”感觉不到差异（当然也有可能我的网比较快）。</p><p>VSCode SSH 扩展允许你连接到远程的主机，虚拟机或者是容器。而你所需要做的仅仅是点击SSH面板，然后配置一下就好了，配置也极其简单，对于经常使用SSH的你来说千万不要错过了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g79mut0ml3j30d40ebjra.jpg" alt></p><p>下面是官方提供的原理架构图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g79mw5gg3mj30qw08q0tc.jpg" alt></p><p>地址： <a href="https://code.visualstudio.com/docs/remote/ssh" target="_blank" rel="noopener">https://code.visualstudio.com/docs/remote/ssh</a></p><h3 id="2019-09-23-好文"><a href="#2019-09-23-好文" class="headerlink" title="2019-09-23[好文]"></a>2019-09-23[好文]</h3><p>为什么一行80个字符是一个值得遵守的规范，即使你拥有4k显示器？</p><p>我个人一直是80字符的践行者，不仅仅是因为是这大家都普遍采用的标准，更重要的是我个人更习惯多窗口平铺的方式来展示我的窗口，这样效率更高一点，因此太大肯定会影响窗口平铺，太小又不方便阅读，80对我来说其实刚刚好，其他比较常见的还有100字符等， 现在就让我们来看下为什么一行80个字符是一个值得遵守的规范吧。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn405nqj31hc0u0asd.jpg" alt></p><p>文章地址： <a href="https://nickjanetakis.com/blog/80-characters-per-line-is-a-standard-worth-sticking-to-even-today" target="_blank" rel="noopener">https://nickjanetakis.com/blog/80-characters-per-line-is-a-standard-worth-sticking-to-even-today</a></p><h3 id="2019-09-20-工具"><a href="#2019-09-20-工具" class="headerlink" title="2019-09-20[工具]"></a>2019-09-20[工具]</h3><p>我开启了<a href="https://lucifer.ren/blog/">个人博客</a>，增加了评论，分类，统计，RSS，歌单等功能， 之后的文章会在博客首发。 感兴趣的可以RSS订阅我的博客。订阅方法我画了个图。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn4kb9ej30pk0g03zx.jpg" alt="rss-feed"></p><p>RSS是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS文件包含全文或是节录的文字，再加上发布者所订阅之网摘数据和授权的元数据。</p><p>简单来说只要提供了符合RSS格式的数据源，你就可以订阅，然后在RSS阅读器上进行查看更新内容。</p><p>关于RSS订阅，今天我推荐的就是一个RSS的聚合器feedly。<a href="https://feedly.com" target="_blank" rel="noopener">https://feedly.com</a></p><p>Feedly是一个RSS聚合器应用程序，支持各种网页浏览器和运行iOS或Android的移动设备，也是一个基于云端的服务。其从各种在线资源聚合用户自定的新闻订阅源，并可与他人分享。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn51dupj313j0hjjtr.jpg" alt="feedly"></p><p>后续有机会我会向大家推荐我的RSS订阅源。</p><h3 id="2019-09-19-工具"><a href="#2019-09-19-工具" class="headerlink" title="2019-09-19[工具]"></a>2019-09-19[工具]</h3><p>今天给大家推荐一款MarkDown编辑器。 MarkDown在程序员中的使用频率是非常高的，Github是最早一批对MarkDown语法支持度比较好的平台之一。我日常写文档，记笔记等都采用MarkDown格式来书写。 它不仅书写方便，而且由于其格式比较规范，因此理论上可以通过一些“转换规则”将其转化为各种表现形式，市面上也有很多基于Markdown的渲染器，比如<a href="https://github.com/markdown-it/markdown-it" target="_blank" rel="noopener">markdown-it</a>，也有很多基于这些渲染器制作的产品，比如<a href="https://github.com/docsifyjs/docsify" target="_blank" rel="noopener">docsify</a>。</p><p>早些时候，我使用的比较多的是<a href="https://macdown.uranusjr.com" target="_blank" rel="noopener">MacDown</a>和VSCode自带的Markdown功能。这两个功能非常简单，但是却能满足我当时的需求，之后我开始经常用Markdown更新文章之类的，因此这些就显得不太够用了，现在我用的是Yu Writer， 算是一个值得推荐的国人开发的MarkDown编辑器，功能非常强大而且免费。 你可能听过MWeb，但是它是收费的，功能和这个比起来也并不占优势。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn5yydqj31hc0u0tep.jpg" alt="yu-writer"></p><p>下载地址：<a href="https://ivarptr.github.io/yu-writer.site/" target="_blank" rel="noopener">https://ivarptr.github.io/yu-writer.site/</a></p><h3 id="2019-09-18-工具"><a href="#2019-09-18-工具" class="headerlink" title="2019-09-18[工具]"></a>2019-09-18[工具]</h3><p>前天分享了我的 chrome 插件管理器，今天我们就来分享我的《娱乐插件》。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn6fnetj30fe04adg6.jpg" alt="extension-joy"></p><ol><li>listen1</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn70jguj301z021we9.jpg" alt="listen1-icon"></p><p>娱乐插件第一个要分享的是一个听歌的插件，各个平台都有一些独家的音乐，就像视频网站一样，这就可怜了我们这些消费者。<br>如果想要听所有的音乐就要办理各个 APP 的会员，或者在多个音乐 APP 中切换。</p><p>这个插件能让我们听到所有国内几个主流大平台的所有音乐，足不出户畅享所有的音乐，并且值得称赞的是它支持会员系统，你可以保存<br>你的歌单，甚至可以直接登陆你的 Github 账户同步多端的数据。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn7ialcj30pa0j3dyl.jpg" alt="listen1"></p><p>仓库地址：<a href="https://github.com/listen1/listen1" target="_blank" rel="noopener">https://github.com/listen1/listen1</a></p><ol start="2"><li>Video Downloader Professional</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn8f9wkj3022020jr5.jpg" alt="video-downloader-icon"></p><p>我主要用它来下载 Youtube 的视频，据说可以下载任何视频网站的视频，但是我亲测了几个网站不可以。</p><p>扩展下载地址：<a href="https://chrome.google.com/webstore/detail/jpaglkhbmbmhlnpnehlffkgaaapoicnk" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/jpaglkhbmbmhlnpnehlffkgaaapoicnk</a></p><ol start="3"><li>Bilibili 全家桶</li></ol><p>经常看番的朋友怎么能少的了几个好用的插件护体呢？</p><p>这几个插件的功能基本满足了我看番的所有需求，包括弹幕合并，查找弹幕，自动签到，一键直达，猜你喜欢等等，大家可以安装下自己体验。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn8wijhj301x01q0sj.jpg" alt="helper-icon"></p><p><a href="https://chrome.google.com/webstore/detail/kpbnombpnpcffllnianjibmpadjolanh" target="_blank" rel="noopener">bilibili 助手</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn9c9r3j30250210sk.jpg" alt="pakku-icon"></p><p><a href="http://s.xmcp.ml/pakkujs/?src=wext_homepage" target="_blank" rel="noopener">pakku 哔哩哔哩弹幕过滤器</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdnades9j3022020742.jpg" alt="danmu-icon"></p><p><a href="https://chrome.google.com/webstore/detail/ngjddnobeppdekpmimhiamkoonoaccdf" target="_blank" rel="noopener">bilibili 猜你喜欢</a></p><h3 id="2019-09-17-学习方法"><a href="#2019-09-17-学习方法" class="headerlink" title="2019-09-17[学习方法]"></a>2019-09-17[学习方法]</h3><p>很多人想要问我“你的成长史是怎么样的？能不能分享一下你的菜鸡成长史”。 开始我是抵触的，这种东西写的不好大家会骂你，写的“太好”也会骂你。</p><p>今天我就来做个“lucifer”系列的开篇吧，用图来描述“lucifer 的一天”。</p><p>lucifer 的早晨：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdnas1atj30bl0de40e.jpg" alt="morning-lucifer"></p><p>lucifer 搬砖的一天开始了：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdnbsm32j30bl08c74r.jpg" alt="morning-lucifer"></p><p>lucifer 的晚上：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdnclwccj30bl05aq39.jpg" alt="morning-lucifer"></p><h3 id="2019-09-16-工具"><a href="#2019-09-16-工具" class="headerlink" title="2019-09-16[工具]"></a>2019-09-16[工具]</h3><p>经常有同学问我“你的这个扩展看着不错，叫什么”， “有什么好用的扩展程序推荐么？”。</p><p>因此我打算出一个《工具推荐》专题， 然后细分一个类别《工具推荐 - chrome 插件》。 这个算是这个系列的开篇之作，我默默翻开自己的 chrome 插件列表来看，<br>有什么好用的推荐给大家。突然灵机一动，干脆把这个“扩展插件管理器”安利给大家好了。之后我会向大家推荐更多好用好玩的插件，有“工具”，“效率”， “娱乐”，“前端”等等。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdnd1mbdj30fn0g1ab3.jpg" alt="chrome-extension-manager"></p><p>我的 chrome 插件差不多有 60 多个，插件多起来的时候，良好的分类，开启关闭，禁用，卸载等管理就变得非常重要了。<br>毕竟谁也不想在众多插件中寻寻觅觅的感觉，也不想因为开启太多插件吃我们宝贵的内存吧？<br>这个插件的名字是<a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco" target="_blank" rel="noopener">扩展管理器（Extension Manager)</a></p><blockquote><p>对于没有梯子的同学，我还贴心地给大家准备了我从官方下载的扩展文件。 <a href="./assets/2019-09/extension-manager.crx">链接</a></p></blockquote><h3 id="2019-09-12-类库"><a href="#2019-09-12-类库" class="headerlink" title="2019-09-12[类库]"></a>2019-09-12[类库]</h3><p>今天给大家推荐的是一个在给 Git 提交记录增加 emojis 的仓库。</p><p>或许你知道<a href="https://gist.github.com/stephenparish/9941e89d80e2bc58a153" target="_blank" rel="noopener">AngularJS Git Commit Message Conventions</a> , 现在很多开源项目和内部项目都在使用<br>，是一道非常流行的 git commit message 规范。 它的好处就是你可以很轻松地通过提交信息，看出<code>这次提交干的什么，影响范围等</code>，比如是新特性，修复 bug，增加文档， 重构代码等。</p><p>这个项目可以说更进一步，通过图的形式，让你更快地感知到这些信息，<code>可视化形式的沟通毫无疑问是最最有效的。因为人的大脑更擅长处理图像。</code> 项目提供了几十种 emoji，几乎覆盖了所有的场景。 仓库地址： <a href="https://gitmoji.carloscuesta.me/" target="_blank" rel="noopener">https://gitmoji.carloscuesta.me/</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdndga7qj30w20nedi8.jpg" alt="git-emoji"></p><h3 id="2019-09-11-技能"><a href="#2019-09-11-技能" class="headerlink" title="2019-09-11[技能]"></a>2019-09-11[技能]</h3><p>Google 内部有很多通用的最佳实践，在这我推荐一个项目，这是挂在 google group 下的一套通用的工程实战指南，被各个项目广泛使用，覆盖全部的编程语言。</p><p>这个仓库分成两部分：</p><ol><li><p>这部分是给 Code Reviewer（代码评审者）的指南</p></li><li><p>这部分是给 Change Author（CL 作者）的指南</p></li></ol><p>代码评审者指南本来是一个完整的文档，一共分为 6 部分，读者可根据需要阅读。</p><p>修改列表（Change List/CL）制定者指南包括一些浏览代码评审的最佳方式，开发者可以快速处理评审结果。</p><p>项目地址： <a href="https://github.com/google/eng-practices" target="_blank" rel="noopener">https://github.com/google/eng-practices</a></p><h3 id="2019-09-10-类库"><a href="#2019-09-10-类库" class="headerlink" title="2019-09-10[类库]"></a>2019-09-10[类库]</h3><p>今天给大家推荐的是一个打包平台，不知道大家有没有听说过“polyfill.io”，用法有点像。</p><p>这个仓库是 fork 自 packed，并进行了魔改，你可以将多个包打包成一个单独的 ESM，支持多种 options， 仓库地址： <a href="https://github.com/webcomponents-dev/packd-es" target="_blank" rel="noopener">https://github.com/webcomponents-dev/packd-es</a></p><h3 id="2019-09-09-类库"><a href="#2019-09-09-类库" class="headerlink" title="2019-09-09[类库]"></a>2019-09-09[类库]</h3><p>一个可以将草稿转化 HTML 的工具，利用了机器学习来生成页面。 你可以手画一些东西，然后将其直接生成静态页面。缺点也很明显，一方面是静态的，因此没有什么交互，对于交互强的应用没什么用。<br>其次就是生成的是 HTML，可维护性会比较差，如果生成类似 JSX 这样的中间产物可能会好一点。当然市面上其实已经有了生成 JSX 产物的开源框架了。 地址：<a href="https://github.com/ashnkumar/sketch-code" target="_blank" rel="noopener">https://github.com/ashnkumar/sketch-code</a></p><h3 id="2019-09-06-学习方法-好文"><a href="#2019-09-06-学习方法-好文" class="headerlink" title="2019-09-06[学习方法, 好文]"></a>2019-09-06[学习方法, 好文]</h3><p>如何培养自己的程序员思维。- Problem-solving is the meta-skill. 文章地址： <a href="https://learnworthy.net/how-to-think-like-a-programmer/?utm_source=quora&amp;utm_medium=referral" target="_blank" rel="noopener">https://learnworthy.net/how-to-think-like-a-programmer/?utm_source=quora&amp;utm_medium=referral</a></p><h3 id="2019-09-05-类库"><a href="#2019-09-05-类库" class="headerlink" title="2019-09-05[类库]"></a>2019-09-05[类库]</h3><p>这是微软开源的内部用来构建大型应用的工具库，包括接口管理，文档管理，代码仓库管理等。 地址： <a href="https://github.com/microsoft/web-build-tools" target="_blank" rel="noopener">https://github.com/microsoft/web-build-tools</a></p><h2 id="历史汇总"><a href="#历史汇总" class="headerlink" title="历史汇总"></a>历史汇总</h2><ul><li>暂无历史汇总</li></ul><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>我重新整理了下自己的公众号，并且我还给它换了一个名字<code>脑洞前端</code>，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。</p><p>之后我的文章会同步到微信公众号 <code>脑洞前端</code> ，你可以关注获取最新的文章，并和我进行交流。</p><p>另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。</p><img width="300" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7he9xdtmyj30by0byaac.jpg"><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul><li>如果有想法和创意，请提<a href="https://github.com/azl397985856/daily-featured/issues" target="_blank" rel="noopener">issue</a>或者进群提</li><li>如果想贡献代码，请提<a href="https://github.com/azl397985856/daily-featured/pulls" target="_blank" rel="noopener">PR</a></li><li>如果需要修改项目中图片，<a href="./assets/">这里</a>存放了项目中绘制图的源代码， 大家可以用<a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a>打开进行编辑。</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="./LICENSE">Apache-2.0</a></p>]]></content>
      
      
      <categories>
          
          <category> 每日一荐 </category>
          
          <category> 2019-09 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器事件模型</title>
      <link href="/blog/2019/12/11/browser-event/"/>
      <url>/blog/2019/12/11/browser-event/</url>
      
        <content type="html"><![CDATA[<p>我想你很可能听说过<code>事件驱动</code>, 但是事件驱动到底是什么？为什么说浏览器是事件驱动的呢？为什么 NodeJS 也是事件驱动的 ？ 两者是一回事么？</p><p>实际上不管是浏览器还是 Nodejs 都是事件驱动的，都有自己的事件模型。在这里，我们只讲解浏览器端的事件模型，如果对 Nodejs 事件模型感兴趣的，请期待我的 Nodejs 部分的讲解。</p><a id="more"></a><h2 id="什么是事件驱动"><a href="#什么是事件驱动" class="headerlink" title="什么是事件驱动"></a>什么是事件驱动</h2><p>事件驱动通俗地来说就是<code>什么都抽象为事件</code>。</p><ul><li>一次点击是一个事件</li><li>键盘按下是一个事件</li><li>一个网络请求成功是一个事件</li><li>页面加载是一个事件</li><li>页面报错是一个事件</li><li>… </li></ul><p>浏览器依靠事件来驱动APP运行下去，如果没有了事件驱动，那么APP会直接从头到尾运行完，然后结束，事件驱动是浏览器的基石。</p><p>本篇文章不讲解事件循环的内容，事件循环部分会在本章的其他章节讲解，敬请期待。</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>其实现实中的红绿灯就是一种事件，它告诉我们现在是红灯状态，绿灯状态，还是黄灯状态。 我们需要根据这个事件自己去完成一些操作，比如红灯和黄灯我们需要等待，绿灯我们可以过马路。</p><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1g8yigxmdlwj204k048t8t.jpg" alt="WeChatf64afbca051509ddcf379077490e9a2e.png"></p><p>下面我们来看一个最简单的浏览器端的事件：</p><p>html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Change color<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'button clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，我们在button上注册了一个事件，这个事件的handler是一个我们定义的匿名函数。当用户点击了这个被注册了事件的button的时候，这个我们定义好的匿名函数就会被执行。</p><h2 id="如何绑定事件"><a href="#如何绑定事件" class="headerlink" title="如何绑定事件"></a>如何绑定事件</h2><p>我们有三种方法可以绑定事件，分别是<code>行内绑定</code>，<code>直接赋值</code>，用<code>addEventListener</code>。</p><ul><li>内联</li></ul><blockquote><p>这个方法非常不推荐</p></blockquote><p>html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"handleClick()"</span>&gt;</span>Press me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在script标签内写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'button clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接赋值</li></ul><p>和我上面举的例子一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'button clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法有两个缺点</p><ol><li>不能添加多个同类型的handler<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = functionA;</span><br><span class="line">btn.onclick = functionB;</span><br></pre></td></tr></table></figure></li></ol><p>这样只有functionB有效，这可以通过<code>addEventListener</code>来解决。</p><ol start="2"><li>不能控制在哪个阶段来执行，这个会在后面将事件捕获/冒泡的时候讲到。这个同样可以通过<code>addEventListener</code>来解决。</li></ol><p>因此addEventListener横空出世，这个也是目前推荐的写法。</p><ul><li>addEventListener</li></ul><p>旧版本的<code>addEventListener</code>第三个参数是bool，新版版的第三个参数是对象，这样方便之后的扩展，承载更多的功能, 我们来重点介绍一下它。</p><p>addEventListener可以给Element，Document，Window，甚至XMLHttpRequest等绑定事件，当指定的事件发生的时候，绑定的回调函数就会被以某种机制进行执行，这种机制我们稍后就会讲到。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, options]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture, wantsUntrusted  ]); <span class="comment">// Gecko/Mozilla only</span></span><br></pre></td></tr></table></figure><p>type是你想要绑定的事件类型，常见的有click, scroll, touch, mouseover等，旧版本的第三个参数是bool，表示是否是捕获阶段，默认是false，即默认为冒泡阶段。新版本是一个对象，其中有capture（和上面功能一样），passive和once。 once用来执行是否只执行一次，passive如果被指定为true表示永远不会执行<code>preventDefault()</code>,这在实现丝滑柔顺的滚动的效果中很重要。更多请参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners" target="_blank" rel="noopener">Improving scrolling performance with passive listeners</a></p><h2 id="框架中的事件"><a href="#框架中的事件" class="headerlink" title="框架中的事件"></a>框架中的事件</h2><p>实际上，我们现在大多数情况都是用框架来写代码，因此上面的情况其实在现实中是非常少见的，我们更多看到的是框架封装好的事件，比如React的合成事件，感兴趣的可以看下这几篇文章。</p><ul><li><a href="https://reactjs.org/docs/events.html" target="_blank" rel="noopener">React SyntheticEvent</a></li><li><a href="https://developer.51cto.com/art/201907/599732.htm" target="_blank" rel="noopener">Vue和React的优点分别是什么？两者的最核心差异对比是什么？</a></li></ul><p>虽然我们很少时候会接触到原生的事件，但是了解一下事件对象，事件机制，事件代理等还是很有必要的，因为框架的事件系统至少在这方面还是一致的，这些内容我们接下来就会讲到。</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>所有的事件处理函数在被浏览器执行的时候都会带上一个事件对象，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handleClick);</span><br></pre></td></tr></table></figure><p>这个e就是事件对象，即<code>event object</code>。 这个对象有一些很有用的属性和方法，下面举几个常用的属性和方法。</p><ul><li><p>属性</p><ol><li><p>target</p></li><li><p>x, y等位置信息</p></li><li><p>timeStamp</p></li><li><p>eventPhase</p><p>…</p></li></ol></li><li><p>方法</p><ol><li><p>preventDefault 用于阻止浏览器的默认行为，比如a标签会默认进行跳转，form会默认校验并发送请求到action指定的地址等</p></li><li><p>stopPropagation 用于阻止事件的继续冒泡行为，后面讲事件传播的时候会提到。</p><p>…</p><h2 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h2></li></ol></li></ul><p>前面讲到了事件默认是绑定到冒泡阶段的，如果你显式令useCapture为true，则会绑定到捕获阶段。</p><p>事件捕获很有意思，以至于我会经常出事件的题目加上一点事件传播的机制，让候选人进行回答，这很能体现一个人的水平。了解事件的传播机制，对于一些特定问题有着非常大的作用。</p><p>一个Element上绑定的事件触发了，那么其实会经过三个阶段。</p><ul><li>第一个阶段 - 捕获阶段</li></ul><p>从最外层即HTML标签开始，检查当前元素有没有绑定对应捕获阶段事件，如果有则执行，没有则继续往里面传播，这个过程递归执行直到触达<code>触发这个事件的元素</code>为止。</p><p>伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capture</span>(<span class="params">e, currentElement</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (currentElement.listners[e.type] !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">currentElement.listners[e.type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(e))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pass down</span></span><br><span class="line"><span class="keyword">if</span> (currentElement !== e.target) &#123;</span><br><span class="line"><span class="comment">// getActiveChild用于获取当前事件传播链路上的子节点</span></span><br><span class="line">capture(e, getActiveChild(currentElement, e))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">bubble(e, currentElement)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个Event对象由引擎创建</span></span><br><span class="line">capture(<span class="keyword">new</span> Event(), <span class="built_in">document</span>.querySelector(<span class="string">'html'</span>))</span><br></pre></td></tr></table></figure><ul><li>第二个阶段 - 目标阶段</li></ul><p>上面已经提到了，这里省略了。</p><ul><li>第三个阶段 - 冒泡阶段</li></ul><p>从<code>触发这个事件的元素</code>开始，检查当前元素有没有绑定对应冒泡阶段事件，如果有则执行，没有则继续往里面传播，这个过程递归执行直到触达HTML为止。</p><p>伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">e, currentElement</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (currentElement.listners[e.type] !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">currentElement.listners[e.type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(e))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// returning</span></span><br><span class="line"><span class="keyword">if</span> (currentElement !== <span class="built_in">document</span>.querySelector(<span class="string">'html'</span>)) &#123;</span><br><span class="line">bubble(e, currentElement.parent)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的过程用图来表示为：</p><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1g8yif1i5hzj20fs0eewfi.jpg" alt></p><p>如果你不希望事件继续冒泡，可以用之前我提到的<code>stopPropagation</code>。</p><p>伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">e, currentElement</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> stopped = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">stopped = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (currentElement.listners[e.type] !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">currentElement.listners[e.type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">fn(&#123;</span><br><span class="line">...e,</span><br><span class="line">stopPropagation: cb</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (stopped) <span class="keyword">return</span>;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// returning</span></span><br><span class="line"><span class="keyword">if</span> (currentElement !== <span class="built_in">document</span>.querySelector(<span class="string">'html'</span>)) &#123;</span><br><span class="line">bubble(e, currentElement.parent)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>利用上面提到的事件冒泡机制，我们可以选择做一些有趣的东西。 举个例子：</p><p>我们有一个如下的列表，我们想在点击对应列表项的时候，输出是点击了哪个元素。</p><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JS代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; <span class="built_in">console</span>.log(e.target.innerHTML))</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/zhipenglu/pen/JjjePQJ?editors=1111" target="_blank" rel="noopener">在线地址</a></p><p>上面说了<code>addEventListener</code>会默认绑定到冒泡阶段，因此事件会从目标阶段开始，向外层冒泡，到我们绑定了事件的ul上，ul中通过事件对象的target属性就能获取到是哪一个元素触发的。</p><blockquote><p>“事件会从目标阶段开始”，并不是说事件没有捕获阶段，而是我们没有绑定捕获阶段，我描述给省略了。</p></blockquote><p>我们只给外层的ul绑定了事件处理函数，但是可以看到li点击的时候，实际上会打印出对应li的内容（1，2，3或者4）。 我们无须给每一个li绑定事件处理函数，不仅从代码量还是性能上都有一定程度的提升。</p><p>这个有趣的东西，我们给了它一个好听的名字“事件代理”。在实际业务中我们会经常使用到这个技巧，这同时也是面试的高频考点。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事件其实不是浏览器特有的，和JS语言也没有什么关系，这也是我为什么没有将其划分到JS部分的原因。很多地方都有事件系统，但是各种事件模型又不太一致。</p><p>我们今天讲的是浏览器的事件模型，浏览器基于事件驱动，将很多东西都抽象为事件，比如用户交互，网络请求，页面加载，报错等，可以说事件是浏览器正常运行的基石。</p><p>我们在使用的框架都对事件进行了不同程度的封装和处理，除了了解原生的事件和原理，有时候了解一下框架本身对事件的处理也是很有必要的。</p><p>当发生一个事件的时候，浏览器会初始化一个事件对象，然后将这个事件对象按照一定的逻辑进行传播，这个逻辑就是事件传播机制。 我们提到了事件传播其实分为三个阶段，按照时间先后顺序分为捕获阶段，目标阶段和冒泡阶段。开发者可以选择监听不同的阶段，从而达到自己想要的效果。</p><p>事件对象有很多属性和方法，允许你在事件处理函数中进行读取和操作，比如读取点击的坐标信息，阻止冒泡等。</p><p>最后我们通过一个例子，说明了如何利用冒泡机制来实现<code>事件代理</code>。</p><p>本文只是一个浏览器事件机制的科普文，并没有也不会涉及到很多细节。希望这篇文章能让你对浏览器时间有更深的理解，如果你对nodejs时间模型感兴趣，请期待我的nodejs事件模型。 事件循环和事件循环也有千丝万缕的联系，如果有时间，我会出一篇关于时间循环的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
          <category> 事件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文看懂《最大子序列和问题》</title>
      <link href="/blog/2019/12/11/LSS/"/>
      <url>/blog/2019/12/11/LSS/</url>
      
        <content type="html"><![CDATA[<p>最大子序列和是一道经典的算法题， leetcode 也有原题《53.maximum-sum-subarray》，今天我们就来彻底攻克它。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求取数组中最大连续子序列和，例如给定数组为 A = [1， 3， -2， 4， -5]， 则最大连续子序列和为 6，即 1 + 3 +（-2）+ 4 = 6。<br>去</p><p>首先我们来明确一下题意。</p><ul><li>题目说的子数组是连续的</li><li>题目只需要求和，不需要返回子数组的具体位置。</li><li>数组中的元素是整数，但是可能是正数，负数和 0。</li><li>子序列的最小长度为 1。</li></ul><p>比如：</p><ul><li>对于数组 [1, -2, 3, 5, -3, 2], 应该返回 3 + 5 = 8</li><li>对于数组 [0, -2, 3, 5, -1, 2], 应该返回 3 + 5 + -1 + 2 = 9</li><li>对于数组 [-9, -2, -3, -5, -3], 应该返回 -2</li></ul><h2 id="解法一-暴力法（超时法）"><a href="#解法一-暴力法（超时法）" class="headerlink" title="解法一 - 暴力法（超时法）"></a>解法一 - 暴力法（超时法）</h2><p>一般情况下，先从暴力解分析，然后再进行一步步的优化。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们来试下最直接的方法，就是计算所有的子序列的和，然后取出最大值。<br>记 Sum[i,….,j]为数组 A 中第 i 个元素到第 j 个元素的和，其中 0 &lt;= i &lt;= j &lt; n，<br>遍历所有可能的 Sum[i,….,j] 即可。</p><p>我们去枚举以 0,1,2…n-1 开头的所有子序列即可，<br>对于每一个开头的子序列，我们都去枚举从当前开始到 n-1 的所有情况。</p><p>这种做法的时间复杂度为 O(N^2), 空间复杂度为 O(1)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>JavaScript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LSS</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = list.length;</span><br><span class="line">  <span class="keyword">let</span> max = -<span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">      sum += list[j];</span><br><span class="line">      <span class="keyword">if</span> (sum &gt; max) &#123;</span><br><span class="line">        max = sum;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarrayPrefixSum</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> len = nums.length;</span><br><span class="line">      <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">          sum += nums[j];</span><br><span class="line">          maxSum = Math.max(maxSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxSum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        maxSum = -sys.maxsize</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">                sum += nums[j]</span><br><span class="line">                maxSum = max(maxSum, sum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure><p>空间复杂度非常理想，但是时间复杂度有点高。怎么优化呢？我们来看下下一个解法。</p><h2 id="解法二-分治法"><a href="#解法二-分治法" class="headerlink" title="解法二 - 分治法"></a>解法二 - 分治法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们来分析一下这个问题， 我们先把数组平均分成左右两部分。</p><p>此时有三种情况：</p><ul><li>最大子序列全部在数组左部分</li><li>最大子序列全部在数组右部分</li><li>最大子序列横跨左右数组</li></ul><p>对于前两种情况，我们相当于将原问题转化为了规模更小的同样问题。</p><p>对于第三种情况，由于已知循环的起点（即中点），我们只需要进行一次循环，分别找出<br>左边和右边的最大子序列即可。</p><p>所以一个思路就是我们每次都对数组分成左右两部分，然后分别计算上面三种情况的最大子序列和，<br>取出最大的即可。</p><p>举例说明，如下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g83bdq90iwj31400u0ad6.jpg" alt><br>(by <a href="https://github.com/snowan" target="_blank" rel="noopener">snowan</a>)</p><p>这种做法的时间复杂度为 O(N*logN), 空间复杂度为 O(1)。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>JavaScript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">list, m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === n) <span class="keyword">return</span> list[m];</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> lmax = -<span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">  <span class="keyword">let</span> rmax = -<span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">  <span class="keyword">const</span> mid = ((n - m) &gt;&gt; <span class="number">1</span>) + m;</span><br><span class="line">  <span class="keyword">const</span> l = helper(list, m, mid);</span><br><span class="line">  <span class="keyword">const</span> r = helper(list, mid + <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = mid; i &gt;= m; i--) &#123;</span><br><span class="line">    sum += list[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; lmax) lmax = sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = mid + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum += list[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; rmax) rmax = sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(l, r, lmax + rmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LSS</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> helper(list, <span class="number">0</span>, list.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarrayDivideConquer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayDividConquer</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">      <span class="keyword">int</span> mid = (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> left = helper(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> right = helper(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">      <span class="keyword">int</span> leftMaxSum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// left surfix maxSum start from index mid - 1 to l</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= l; i--) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        leftMaxSum = Math.max(leftMaxSum, sum);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> rightMaxSum = <span class="number">0</span>;</span><br><span class="line">      sum = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// right prefix maxSum start from index mid + 1 to r</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        rightMaxSum = Math.max(sum, rightMaxSum);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// max(left, right, crossSum)</span></span><br><span class="line">      <span class="keyword">return</span> Math.max(leftMaxSum + rightMaxSum + nums[mid], Math.max(left, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 3 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> -sys.maxsize</span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line">        left = self.helper(nums, l, mid - <span class="number">1</span>)</span><br><span class="line">        right = self.helper(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">        left_suffix_max_sum = right_prefix_max_sum = <span class="number">0</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(l, mid)):</span><br><span class="line">            sum += nums[i]</span><br><span class="line">            left_suffix_max_sum = max(left_suffix_max_sum, sum)</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mid + <span class="number">1</span>, r + <span class="number">1</span>):</span><br><span class="line">            sum += nums[i]</span><br><span class="line">            right_prefix_max_sum = max(right_prefix_max_sum, sum)</span><br><span class="line">        cross_max_sum = left_suffix_max_sum + right_prefix_max_sum + nums[mid]</span><br><span class="line">        <span class="keyword">return</span> max(cross_max_sum, left, right)</span><br></pre></td></tr></table></figure><h2 id="解法三-动态规划"><a href="#解法三-动态规划" class="headerlink" title="解法三 - 动态规划"></a>解法三 - 动态规划</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们来思考一下这个问题， 看能不能将其拆解为规模更小的同样问题，并且能找出<br>递推关系。</p><p>我们不妨假设问题 Q(list, i) 表示 list 中以索引 i 结尾的情况下最大子序列和，<br>那么原问题就转化为 Q(list, i), 其中 i = 0,1,2…n-1 中的最大值。</p><p>我们继续来看下递归关系，即 Q(list, i)和 Q(list, i - 1)的关系，<br>即如何根据 Q(list, i - 1) 推导出 Q(list, i)。</p><p>如果已知 Q(list, i - 1)， 我们可以将问题分为两种情况，即以索引为 i 的元素终止，<br>或者只有一个索引为 i 的元素。</p><ul><li>如果以索引为 i 的元素终止， 那么就是 Q(list, i - 1) + list[i]</li><li>如果只有一个索引为 i 的元素，那么就是 list[i]</li></ul><p>分析到这里，递推关系就很明朗了，即<code>Q(list, i) = Math.max(0, Q(list, i - 1)) + list[i]</code></p><p>举例说明，如下图：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-115023.jpg" alt="53.maximum-sum-subarray-dp.png"><br>(by <a href="https://github.com/snowan" target="_blank" rel="noopener">snowan</a>)</p><p>这种算法的时间复杂度 O(N), 空间复杂度为 O(1)</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>JavaScript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LSS</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = list.length;</span><br><span class="line">  <span class="keyword">let</span> max = list[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    list[i] = <span class="built_in">Math</span>.max(<span class="number">0</span>, list[i - <span class="number">1</span>]) + list[i];</span><br><span class="line">    <span class="keyword">if</span> (list[i] &gt; max) max = list[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarrayDP</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> currMaxSum = nums[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">       currMaxSum = Math.max(currMaxSum + nums[i], nums[i]);</span><br><span class="line">       maxSum = Math.max(maxSum, currMaxSum);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> maxSum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        max_sum_ending_curr_index = max_sum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            max_sum_ending_curr_index = max(max_sum_ending_curr_index + nums[i], nums[i])</span><br><span class="line">            max_sum = max(max_sum_ending_curr_index, max_sum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><h2 id="解法四-数学分析"><a href="#解法四-数学分析" class="headerlink" title="解法四 - 数学分析"></a>解法四 - 数学分析</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们来通过数学分析来看一下这个题目。</p><p>我们定义函数 S(i) ，它的功能是计算以 0（包括 0）开始加到 i（包括 i）的值。</p><p>那么 S(j) - S(i - 1) 就等于 从 i 开始（包括 i）加到 j（包括 j）的值。</p><p>我们进一步分析，实际上我们只需要遍历一次计算出所有的 S(i), 其中 i 等于 0,1,2….,n-1。<br>然后我们再减去之前的 S(k),其中 k 等于 0，1，i - 1，中的最小值即可。 因此我们需要<br>用一个变量来维护这个最小值，还需要一个变量维护最大值。</p><p>这种算法的时间复杂度 O(N), 空间复杂度为 O(1)。</p><p>其实很多题目，都有这样的思想， 比如之前的《每日一题 - 电梯问题》。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>JavaScript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LSS</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = list.length;</span><br><span class="line">  <span class="keyword">let</span> max = list[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    sum += list[i];</span><br><span class="line">    <span class="keyword">if</span> (sum - min &gt; max) max = sum - min;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; min) &#123;</span><br><span class="line">      min = sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxSumSubarray</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// prefix Sum</span></span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="comment">// update maxSum</span></span><br><span class="line">        maxSum = Math.max(maxSum, sum - minSum);</span><br><span class="line">        <span class="comment">// update minSum</span></span><br><span class="line">        minSum = Math.min(minSum, sum);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxSum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        maxSum = nums[<span class="number">0</span>]</span><br><span class="line">        minSum = sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum += nums[i]</span><br><span class="line">            maxSum = max(maxSum, sum - minSum)</span><br><span class="line">            minSum = min(minSum, sum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们使用四种方法解决了<code>《最大子序列和问题》</code>,<br>并详细分析了各个解法的思路以及复杂度，相信下次你碰到相同或者类似的问题<br>的时候也能够发散思维，做到<code>一题多解，多题一解</code>。</p><p>实际上，我们只是求出了最大的和，如果题目进一步要求出最大子序列和的子序列呢？<br>如果要题目允许不连续呢？ 我们又该如何思考和变通？如何将数组改成二维，求解最大矩阵和怎么计算？<br>这些问题留给读者自己来思考。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 子序列 </category>
          
          <category> 数组 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法之美》-为工程师量身打造的数据结构与算法私教课</title>
      <link href="/blog/2019/12/11/ad/"/>
      <url>/blog/2019/12/11/ad/</url>
      
        <content type="html"><![CDATA[<p>很多人问我如何系统地学习数据结构与算法，是看书，刷题还是看视频？</p><p>这个问题没有一个放之四海而皆准的答案，这是一个因人而异的东西，我之前给初学者推荐过邓俊辉老师免费的《数据结构与算法》课程，以及为《算法图解》这本书。 然而这些只是适合初学者，真正想要掌握数据结构与算法还是不够的，学习了基础之后如何进阶呢？像《算法导论》这些经典书籍，虽然很全面，但是过于缺乏重点。很多人学起来都非常困难。而市面很多在线课程或者线下课程，大多是为了“应试”，只讲一些看似通用，实则脱离真实开发场景的内容。因此这里给大家推荐一本书《数据结构与算法之美》。</p><a id="more"></a><h2 id="程序员必会的数据结构与算法"><a href="#程序员必会的数据结构与算法" class="headerlink" title="程序员必会的数据结构与算法"></a>程序员必会的数据结构与算法</h2><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-22-%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BC%9A%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.jpg" alt></p><h2 id="订阅量TOP1"><a href="#订阅量TOP1" class="headerlink" title="订阅量TOP1"></a>订阅量TOP1</h2><p>这本书是订阅量Top1，50000+程序员的算法课堂，整个专栏会涵盖100 多个算法真实项目场景案例，更难得的是它跟市面上晦涩的算法书籍不同的是，还手绘了一些清晰易懂的详解图（总共有 300 多张），市面上的大多数的算法教程都看过，走心的说，这个专栏是市面上唯一一门真正适用于工程师的专栏，作者是前Google工程师王争，相信会开启你的趣味学习算法之旅。</p><h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>本书作者王争，前 Google 工程师，从事 Google 翻译相关的开发工作，深入研究算法数十年。现任某金融公司资深系统架构师，核心业务接口平台负责人，负责公司核心业务的架构设计、开发，以及可用性、高性能等相关技术问题的解决。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-22-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-%E5%B8%B8%E8%A7%84%E8%BD%AE%E6%92%AD%E5%9B%BE.jpg" alt></p><h2 id="你能获得什么？"><a href="#你能获得什么？" class="headerlink" title="你能获得什么？"></a>你能获得什么？</h2><p>1、掌握数据结构与算法的核心知识</p><p>我根据自己研读数十本算法书籍和多年项目开发的经验，精选了 20 个最实用数据结构和算法结合具体的软件开发实例，由浅入深进行讲解背后的设计思想，并适时总结一些实用“宝典”，保证你印象深刻，并且能够迅速对应到实际工作场景中。</p><p>2、提升算法思维，训练解决实际开发工作难题的强能力</p><p>这部分我会讲一些不是那么常用的数据结构和算法。虽然不常用，但是并不是说他们没用。设置这一部分的目的，是为了让你开拓视野，强化训练算法思维、逻辑思维。如果说学完基础部分可以考 80 分，那掌握这一部分就能让你成为尖子生。再回过来说，不管是现在流行的区块链技术还是人工智能，核心代码实现中都会涉及到这些算法。</p><p>3、学习开源框架、底层系统的设计原理，提升工作实战技能</p><p>最后我会通过实战部分串讲一下前面讲到的数据结构和算法，并且结合 Redis、Disruptor 这样的开源项目，剖析它们背后的数据结构和算法，帮你提升读懂源码的能力（JDK 很多源码，不乏大量的数据结构，例如大家喜闻乐见的面试题 HashMap）。</p><p>我掰着指头数了下，整个专栏会涵盖 100 多个算法真实项目场景案例。我还手绘了一些清晰易懂的详解图，帮你理解核心概念和实现过程，展示每个知识点的框架逻辑，让晦涩难懂的算法变得轻松有趣。</p><h2 id="课程目录"><a href="#课程目录" class="headerlink" title="课程目录"></a>课程目录</h2><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-22-%E4%B8%93%E6%A0%8F%E7%9B%AE%E5%BD%95.jpg" alt></p><h2 id="订阅福利"><a href="#订阅福利" class="headerlink" title="订阅福利"></a>订阅福利</h2><p>扫描下方二维码订阅即可，新人立减30元，另外我本人提供返现11元（到手88元），直接加我微信<code>DevelopeEngineer</code>即可。另外再送你199元限时学习礼包，你可以先领券再购买，领券地址：<a href="http://gk.link/a/108qc" target="_blank" rel="noopener">http://gk.link/a/108qc</a></p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-22-121600.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法在前端领域的应用 - 第四篇</title>
      <link href="/blog/2019/09/21/algorthimn-fe-4/"/>
      <url>/blog/2019/09/21/algorthimn-fe-4/</url>
      
        <content type="html"><![CDATA[<p>前一段时间我分享了几篇关于《数据结构与算法在前端领域的应用》的文章。</p><p>文章链接：</p><ul><li><a href="https://juejin.im/post/5d3dc8466fb9a07efc49d0a9" target="_blank" rel="noopener">数据结构和算法在前端领域的应用(前菜)</a></li><li><a href="https://juejin.im/post/5d4289046fb9a06ad229ad21" target="_blank" rel="noopener">数据结构和算法在前端领域的应用(进阶)</a></li></ul><p>这一次我们顺着前面的内容，讲一些经典的数据结构与算法，本期我们来讲一下时下比较火热的<code>React fiber</code>。</p><p>这部分内容相对比较硬核和难以消化，否则 React 团队也不会花费两年的时间来搞这一个东西。建议大家多读几遍。</p><a id="more"></a><h2 id="fiber-一个用于增量更新的数据结构"><a href="#fiber-一个用于增量更新的数据结构" class="headerlink" title="fiber - 一个用于增量更新的数据结构"></a>fiber - 一个用于增量更新的数据结构</h2><p>前面我的文章提到过 fiber 是一种数据结构，并且是一种链式的数据结构。</p><p>fiber 是为了下一代调和引擎而引入的一种新的数据结构，而下一代调和引擎最核心的部分就是<br>“增量渲染”。为了明白这个“增量渲染”，我们需要打一点小小的基础。</p><h3 id="分片执行"><a href="#分片执行" class="headerlink" title="分片执行"></a>分片执行</h3><p>为了做到上面我提到的“增量渲染”，我们首先要能够停下来。<br>之前 React 的更新 UI 的策略是自顶向下进行渲染，如果没有人工的干涉，React 实际上会更新到<br>所有的子组件，这在大多数情况下没有问题。</p><p>然而随着项目越来越复杂，这种弊端就非常明显了。单纯看这一点，Vue 在这方面做的更好，<br>Vue 提供了更加细粒度的更新组件的方式，甚至无需用户参与。 这是两者设计理念上的差异，不关乎<br>好坏，只是适用场景不一样罢了。</p><p>值得一提的是，Vue 的这种细粒度监听和更新的方式，实际上是内存层面和计算层面的权衡。<br>社区中一些新的优秀框架，也借鉴了 Vue 的这种模式，并且完成了进一步的进化，对不同的类型进行划分，<br>并采取不同的监听更新策略，实际上是一种更加“智能“的取舍罢了。</p><p>言归正传，我们如何才能做到”增量更新“呢？</p><ul><li>首先你要能够在进行到中途的时候停下来</li><li>你能够继续刚才的工作，换句话说可以重用之前的计算结果</li></ul><blockquote><p>实现这两点靠的正是我们今天的主角 fiber，稍后我们再讲。</p></blockquote><p>比如之前 React 执行了一个 100ms 的更新过程，对于新的调和算法，<br>会将这个过程划分为多个过程，当然每一份时间很可能是不同的。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112752.jpg" alt></p><p>由于总时间不会减少，我们设置还增加了调度（上面我提到的两条）的代码，<br>因此单纯从总时间上，甚至是一种倒退。但是为什么用户会感觉到更快了呢？<br>这就是下面我们要讲的调度器。</p><h3 id="三大核心组件-Scheduler，-Reconciliation，-Renderer"><a href="#三大核心组件-Scheduler，-Reconciliation，-Renderer" class="headerlink" title="三大核心组件 - Scheduler， Reconciliation， Renderer"></a>三大核心组件 - Scheduler， Reconciliation， Renderer</h3><p>事实上， React 核心的算法包含了三个核心部分，分别是<code>Scheduler，</code>， <code>Reconciliation</code>，<code>Renderer</code>。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112753.jpg" alt></p><ul><li>scheduler 用于决定何时去执行。</li></ul><p>前面提到了，整个更新过程要比之前的做法要长。总时间变长的情况下，用户感觉性能更好的原因在于<br>scheduler。 对于用户而言，界面交互，动画，界面更新的优先级实际上是不一样的。</p><p>通过保证高优先级的事件的执行，比如用户输入，动画。 可以让用户有性能很好的感觉。</p><p>做到这一点实际上原理很简单，即使前面提到的 chunks，再加上我们给每一个任务分配一个优先级，<br>从而保证 chunks 的执行顺序中高优先级的在前面。</p><blockquote><p>浏览器实际上自己也会对一些事件区分优先级。</p></blockquote><ul><li>Reconciliation 决定哪部分需要更新，以及如何“相对最小化”完成更新过程。<br>这部分算法主要上衣基于<code>VDOM</code>这种数据结构来完成的。</li></ul><p>这部分的算法实际上就是一个“阉割版的最小编辑树算法”。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112754.jpg" alt></p><ul><li>renderer 使用 Reconciliation 的计算结果，然后将这部分差异，最小化更新到视图。可以是 DOM，也可以是<br>native， 理论上可以是任何一种渲染容器。</li></ul><p>在 DOM 中，这部分的工作由 React-DOM 来完成。它会生成一些 DOM 操作的 API，从而去完成一些副作用，<br>这里指的是更新 DOM。</p><h2 id="fiber-一个虚拟调用栈"><a href="#fiber-一个虚拟调用栈" class="headerlink" title="fiber - 一个虚拟调用栈"></a>fiber - 一个虚拟调用栈</h2><p>实际上，fiber 做的事情就是将之前 react 更新策略进行了重构。</p><p>之前的更新策略是从顶向下，通过调用栈的形式保存已经更新的信息。<br>这本身没有问题， 但是这和我们刚才想要实现的效果是不匹配的，我们需要 chunks 的效果。<br>而之前的策略是从顶到下一口气执行完，不断 push stack，然后 pop stack，直到 stack 为空。</p><p>fiber 正是模拟了调用栈，并且通过链表来重新组织，一方面使得我们可以实现 chunks 的功能。<br>另一方面可以和 VDOM 进行很好的对应和映射。</p><h3 id="v-f-d"><a href="#v-f-d" class="headerlink" title="v = f(d)"></a>v = f(d)</h3><p>这是我从 React 官方介绍 fiber 的一个地方抄来的公式。</p><p>它想表达的是 react 是一个视图管理框架，并且是数据驱动的，唯一的数据会驱动产生唯一的视图。</p><p>我们可以把每一个组件都看成一个 view，然而我们的工作就是计算所有的组件的最新的 view。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112755.jpg" alt></p><p>那么 fiber 是如何完成“增量更新”呢？ 秘诀就是它相当于“重新实现了浏览器调用栈”。</p><p>我们来看一下，fiber 是如何实现传统调用栈的功能的。</p><h3 id="fiber-和-传统调用栈的区别"><a href="#fiber-和-传统调用栈的区别" class="headerlink" title="fiber 和 传统调用栈的区别"></a>fiber 和 传统调用栈的区别</h3><p>传统的调用栈，我们实际上将生成 view 的工作放到栈里面执行，浏览器的栈有一个特点就是<br>“你给它一个任务，它必须一口气执行完”。</p><p>而 fiber 由于是自己设计的，因此可以没有这个限制。 具体来说，两者的对应关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传统调用栈            fiber</span><br><span class="line"></span><br><span class="line">  子函数          component type</span><br><span class="line"> 函数嵌套              child</span><br><span class="line">  参数                props</span><br><span class="line"> 返回地址             parent</span><br><span class="line">  返回值          DOM elements</span><br></pre></td></tr></table></figure><p>用图来表示的话，大概是这样：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112757.jpg" alt></p><p>其中具体的算法，我预计会在我的<a href="https://github.com/azl397985856/mono-react" target="_blank" rel="noopener">从零开始开发一个 React</a> 中更新。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章介绍了fiber，fiber其实是一种用于增量更新的数据结构。<br>是为了下一代调和引擎而引入的一种新的数据结构，而下一代调和引擎最核心的部分就是<br>“增量渲染”。</p><p>我们介绍了几个基本概念和组件，包括分片执行， react三大核心组件 - Scheduler， Reconciliation， Renderer。</p><p>最后我们说了“fiber实际上就是一个虚拟调用栈”，并结合传统调用栈的特点和弊端，讲解了fiber是如何组织，<br>从而改进了传统调用栈带来的问题的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法在前端领域的应用 - 第三篇</title>
      <link href="/blog/2019/09/20/algorthimn-fe-3/"/>
      <url>/blog/2019/09/20/algorthimn-fe-3/</url>
      
        <content type="html"><![CDATA[<p>这是本系列文章的第三篇，这里我将带你从新的视角来看当前的前端应用，<br>虽然这其中涉及到的道理很简单，但是这部分知识很少被人看到，更不要说推广和应用了。</p><p>这里新的视角指的是我们从进程和线程的角度来思考我们前端应用的运行，从而从更高的层次去审视和优化我们的应用，甚至整个前端生态。</p><p>希望你看完之后从思维上也好，工作应用中也好能够有所收获。</p><p>前一段时间我分享了几篇关于《数据结构与算法在前端领域的应用》的文章。</p><p>文章链接：</p><ul><li><a href="https://juejin.im/post/5d3dc8466fb9a07efc49d0a9" target="_blank" rel="noopener">数据结构和算法在前端领域的应用(前菜)</a></li><li><a href="https://juejin.im/post/5d4289046fb9a06ad229ad21" target="_blank" rel="noopener">数据结构和算法在前端领域的应用(进阶)</a></li></ul><a id="more"></a><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是一个对技术充满兴趣的程序员, 擅长前端工程化，前端性能优化，前端标准化等。</p><p>做过.net， 搞过 Java，现在是一名前端工程师。</p><p>除了我的本职工作外，我会在开源社区进行一些输出和分享，GitHub 共计获得 1.5W star。比较受欢迎的项目有<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">leetcode 题解</a> , <a href="https://github.com/azl397985856/fe-interview" target="_blank" rel="noopener">宇宙最强的前端面试指南</a> 和<br><a href="https://github.com/azl397985856/automate-everything" target="_blank" rel="noopener">我的第一本小书</a></p><h2 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a>浏览器的进程模型</h2><p>我们首先来看下浏览器的进程模型，我们以 chrome 为例。</p><p>Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075803.jpg" alt><br>(图来自 <a href="https://zhuanlan.zhihu.com/p/47407398" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47407398</a>)</p><p>这也是为什么 chrome 明明只打开了一个 tab，却出现了 4 个进程的原因。</p><p>这部分不是我们本节的主要内容，大家了解这么多就够了，接下来我们看下今天的主角 - 渲染进程。</p><h2 id="浏览器的渲染进程"><a href="#浏览器的渲染进程" class="headerlink" title="浏览器的渲染进程"></a>浏览器的渲染进程</h2><p>渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。</p><p>渲染进程由以下四个线程组成：主线程 Main thread ， 工作线程 Worker thread，光栅线程 Raster thread<br>和排版线程 Compositor thread。</p><p>我们的今天的主角是主线程 Main thread 和 工作线程 Worker thread。</p><h3 id="主线程-Main-thread"><a href="#主线程-Main-thread" class="headerlink" title="主线程 Main thread"></a>主线程 Main thread</h3><p>主线程负责：</p><ul><li>构建 DOM</li><li>和网络进程（上文提到的）通信获取资源</li><li>对资源进行解析</li><li>JS 代码的执行</li><li>样式和布局的计算</li></ul><p>可以看出主线程非常繁忙，需要做很多事情。 主线程很容易成为应用的性能瓶颈。</p><p>当然除了主线程， 我们的其他进程和线程也可能成为我们的性能瓶颈，比如网络进程，解决网络进程瓶颈的方法有很多，可以使用浏览器本身缓存，也可以使用 ServiceWorker，还可以通过资源本身的优化等。这个不是我们本篇文章的讨论重点，这里只是让你有一个新的视角而已，因此不赘述。</p><h3 id="工作线程-Worker-thread"><a href="#工作线程-Worker-thread" class="headerlink" title="工作线程 Worker thread"></a>工作线程 Worker thread</h3><p>工作线程能够分担主线程的计算压力，进而主线程可以获得更多的空闲时间，从而更快地响应用户行为。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075804.jpg" alt></p><p>工作线程主要有 Web Woker 和 Service Worker 两种。</p><h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4><p>以下摘自<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">MDN</a></p><blockquote><p>Web Worker 为 Web 内容在后台线程中运行脚本提供了一种简单的方法。<br>线程可以执行任务而不干扰用户界面。此外，他们可以使用 XMLHttpRequest 执行 I/O<br>(尽管 responseXML 和 channel 属性总是为空)。<br>一旦创建， 一个 worker 可以将消息发送到创建它的 JavaScript 代码,</p></blockquote><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>以下摘自<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">MDN</a></p><blockquote><p>Service workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，<br>也可以在网络可用时作为浏览器和网络间的代理。<br>它们旨在（除其他之外）使得能够创建有效的离线体验，<br>拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。<br>他们还允许访问推送通知和后台同步 API。</p></blockquote><h2 id="重新思考我们的前端应用"><a href="#重新思考我们的前端应用" class="headerlink" title="重新思考我们的前端应用"></a>重新思考我们的前端应用</h2><p>工作线程尤其是Web Worker的出现一部分原因就是为了分担主线程的压力。</p><p>整个过程就像主线程发布命令，然后工作线程执行，执行完毕将执行结果通过消息的形式传递给主线程。</p><p>我们以包工头包工程，然后将工作交给各个单位去做的角度来看的话，大概是这样的：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075805.png" alt></p><p>实际上工作工作进程，尤其是WebWorker已经出现很长时间了。但是很多时候我们并没有充分使用，甚至连使用都没使用。</p><p>下面以Web Worker为例， 我们来深度挖掘一下工作线程的潜力。</p><p>前面的文章，我们谈了很多前端领域的算法，有框架层面的也有应用层面的。</p><p>前面提到了React的调和算法，这部分代码耗时其实还是蛮大的，React16重构了<br>整个调和算法，但是总体的计算成本还是没有减少，甚至是增加的。</p><blockquote><p>关于调和算法可以参考我的另外一篇文章<a href="https://juejin.im/post/5d479ae551882505de0f1525" target="_blank" rel="noopener">前端领域的数据结构与算法解读 - fiber</a></p></blockquote><p>我们有没有可能将这部分内容抽离出主线程，交给工作进程，就像上面的图展示的那样呢？<br>我觉得可以， 另外我前面系列文章提到的所有东西，都可以放到工作线程中执行。<br>比如状态机，时光机，自动完成，差异比对算法等等。</p><p>如果将这些抽离出我们主线程的话，我们的应用大概会是这样的：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075806.png" alt></p><p>这样做主线程只负责UI展示，以及事件分发处理等工作，这样就大大减轻了主线程的负担，我们就可以更快速地响应用户了。<br>然后在计算结果完成之后，我们只需要通知主线程，主线程做出响应即可。<br>可以看出，在项目复杂到一定程度，这种优化带来的效果是非常大的。</p><p>我们来开一下脑洞， 假如流行的前端框架比如React内置了这种线程分离的功能，<br>即将调和算法交给WebWorker来处理，会给前端带来怎么样的变化？</p><p>假如我们可以涉及一个算法，智能地根据当前系统的硬件条件和网络状态，<br>自动判断应该将哪部分交给工作线程，哪部分代码交给主线程，会是怎么样的场景？</p><blockquote><p>这其实就是传说中的启发式算法， 大家有兴趣可以研究一下</p></blockquote><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>上述描述的场景非常美好，但是同样地也会有一些挑战。</p><p>第一个挑战就是操作繁琐，比如webworker只支持单独文件引入，再比如不支持函数序列化,以及反复序列化带来的性能问题， 还有和webworker通信是异步的等等。</p><p>但是这些问题都有很成熟的解决方案，比如对于操作比较繁琐这个问题我们就可以通过使用一些封装好web worker操作的库。<a href="https://github.com/GoogleChromeLabs/comlink" target="_blank" rel="noopener">comlink</a> 就是一个非常不错的web worker的封装工具库。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-075807.png" alt></p><p>对于不支持单文件引入，我们其实可以用<code>Blob</code>, <code>createObjectURL</code>的方式模拟，<br>当然社区中其实也有了成熟的解决方案，如果你使用webpack构建的话，有一个<code>worker-loader</code>可以直接用。</p><p>对于函数序列化这个问题，我们无法传递函数给工作线程，其实上面提到的<br>Comlink， 就很好地解决了这个问题，即使用Comlink提供的<code>proxy</code>,<br>你可以将一个代理传递到工作线程。</p><p>对于反复序列化带来的性能问题，我们其实可以使用一种叫<code>对象转移（Transferable Objects）</code>的技术，幸运的是这个特性的浏览器兼容性也不错。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-75808.png" alt></p><p>对于异步的问题，我们可以采取一定的取舍。 即我们<br>本地每次保存一份最近一份的结果拷贝，我们只需要每次返回这个拷贝，<br>然后在webworker计算结果返回的时候更新拷贝即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章的主要目的是让大家以新的视角来思考当前的前端应用，我们站在进程和线程的角度来看现在的前端应用，或许会有更多的不一样的理解和思考。</p><p>本文先是讲了浏览器的进程模型，然后讲了浏览器的渲染进程中的<br>线程模型。 我们知道了渲染进程主要有四个线程组成，<br>分别是主线程 Main thread ， 工作线程 Worker thread，光栅线程 Raster thread<br>和排版线程 Compositor thread。</p><p>然后详细介绍了主线程和工作线程，并以webworker为例，讲述了如何利用工作线程为我们的主线程分担负担。为了消化这部分知识，建议你自己动手实践一下。</p><p>虽然我们的愿望很好，但是这其中在应用的过程之中还是有一些坑的，我这里列觉了一些常见的坑，并给出了解决方案。</p><p>我相信工作线程的潜力还没有被充分发挥出来，希望可以看到前端应用真正的挖掘各个进程和线程潜力的时候吧，这不但需要前端工程师的努力，也需要浏览器的配合支持，甚至需要标准化组织去推送一些东西。</p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>最近我重新整理了下自己的公众号，并且我还给他换了一个名字《脑洞前端》，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解前端是我的目标。</p><p>之后我的文章同步到微信公众号 脑洞前端 ，您可以关注获取最新的文章，或者和我进行交流。</p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-19-085421.jpg" width="50%" height="50%" alt="gongzhonghao" align="center">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法在前端领域的应用 - 第二篇</title>
      <link href="/blog/2019/09/19/algorthimn-fe-2/"/>
      <url>/blog/2019/09/19/algorthimn-fe-2/</url>
      
        <content type="html"><![CDATA[<p>这是一个我即将做的一个《数据结构与算法在前端领域的应用》主题演讲的一个主菜。<br>如果你对这部分内容比较生疏，可以看我的<a href="https://juejin.im/post/5d3dc8466fb9a07efc49d0a9" target="_blank" rel="noopener">数据结构和算法在前端领域的应用(前菜)</a></p><p>这里我会深入帮助大家如何根据业务抽离出纯粹的模型，从而转化为算法问题，</p><a id="more"></a><h2 id="以上帝角度来看前端"><a href="#以上帝角度来看前端" class="headerlink" title="以上帝角度来看前端"></a>以上帝角度来看前端</h2><p>让我们以更高的层次来看一下，从大的范围上前端领域都在做什么？</p><p>从业务上来说，我们会去做各个端的开发、网关、接口、工程化。<br>从技术上说，则是基于 WEB、Node 的通用技术，以及各平台（最常见的就是安卓和 IOS）的专有技术。</p><p>在这里我以自己的标准总结了以下三点：</p><ol><li>架构和平台</li></ol><p>其实平台建设也是架构中的一环，之所以列出来单独讲是因为这块内容相对比较大。<br>每个公司，部门，项目都有自己的架构设计和规范。它们环环相套组成了整个公司的架构体系。</p><p>很多公司在做工具链，在做跨端方案，在做底层融合等，这些都属于这个范畴。<br>比如最近比较火的 Serverless 也是属于这个范畴。</p><ol start="2"><li>规范和标准化</li></ol><p>前端行业规范目前来看的话就两个，一个是 ECMA 的规范，一个是 W3C 的规范。<br>前端行业规范是非常重要的，不然前端会非常混乱，想一下前端刚刚诞生出来的时候就知道了。</p><p>公司内部也会有一些规范，但是很难上升到标准层次。 目前国内没有一个行业认可的标准化组织，<br>这算是一个遗憾吧。 好消息是国人在标准化组织的参与感越来越强，做了更多的事情。</p><p>其实这部分我们的感知是比较弱的，一个原因就是我们一直在努力对接行业的标准，很少去自己创造一些标准。<br>原因有几点，一方面自己做标准，维护更新标准很难，另一方面自己做标准需要学习成本和转换成本。</p><p>但是这并不意味这做公司标准或者行业领域规范就没有用，相反非常有用。我之前做过一个《标准化能给我们带来什么》的<br>分享，详细介绍了标准化对于我们的重要性。</p><ol start="3"><li>生态体系</li></ol><p>其实前端的工作就是人机交互，这其中涉及的东西很多，相关领域非常广泛。</p><p>比如智能手表、智能 TV、智能眼镜、头戴 AR，VR 等新的交互模式我们如何去融入现有开发体系中 ？<br>人工智能在前端开发可以发挥怎么样的作用 ？ 这些其实很多公司已经在尝试，并且取得了非常不错的效果。</p><p>比如 IDE 是开发过程非常重要的工具，我们是否可以去做标准化的 IDE，甚至放到云端。</p><h2 id="无处不在的算法"><a href="#无处不在的算法" class="headerlink" title="无处不在的算法"></a>无处不在的算法</h2><p>上面我们从多个方面重新审视了一下前端，除了人工智能部分，其他部分根本没有提到算法。<br>是不是算法在前端领域应用很少呢？ 不是的。</p><p>一方面就像上一节介绍的，我们日常开发中使用的很多东西都是经过数据结构和算法的精心封装，<br>比如 DOM 和 VDOM，以及 JSON。 JSON的序列化和反序列化是我们无时无刻使用的方法，<br>比如我们需要和后端进行数据交互，需要和其他线程（比如webworker）进行数据交互都要经过<br>序列化和反序列化，如何减少数据传输，如何提高序列化和反序列化的效率，如何在两者<br>之间寻求一种平衡都是我们需要研究的。</p><blockquote><p>JSON 也是一种树结构</p></blockquote><p>甚至还有很多框架以数据结构直接命名，比如 GraphQL，就是<br>用图这种数据结构来命名，从而体现其强大的关联查询能力。 比如 tensorflow 以张量（tensor）来加深大家对上面两点的印象命名，</p><p>TensorFlow™ 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。</p><p>上面提到的各个环节都或多或少会用到算法。首先网络部分就涉及到很多算法，<br>比如有限状态机，滑动窗口，各种压缩算法，保障我们信息不泄漏的各种加密算法等等，简直不要太多。<br>虽然这些网络部分很多都是现成的，但是也不排除有一些需要我们自己根据当前实际场景自己去搭建一套的可能。<br>这在大公司之中是非常常见的。</p><p>我们再来看下执行我们代码的引擎，以 V8 为例，其本身涉及的算法不算在内。<br>但是当我们基于 V8 去做一些事情，我们就需要了解一些编译相关的原理。<br>这里我举个例子，下图是支付宝的小程序架构。 如果我们不懂一些算法的话，<br>是很难像支付宝一样结合自己的业务去做一些突破的。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112743.png" alt="支付宝小程序架构"><br>(图片来自 <a href="https://www.infoq.cn/article/ullETz7q_Ue4dUptKgKC" target="_blank" rel="noopener">https://www.infoq.cn/article/ullETz7q_Ue4dUptKgKC</a>)</p><p>另外一些高层的架构中也会有很多算法方面的东西，比如我需要在前端做增量更新的功能。<br>增量更新在APP中早已不是新鲜的东西了，但是真正做JS等静态资源的实时增量更新还比较少，<br>这里面会涉及非常复杂的交互和算法。</p><p>上面提到的更多的是高层面上，事实上即使是业务层面也有很多值得挖掘的算法模型。<br>我们需要从复杂的业务中提炼出算法模型，才能得到实际应用。可惜的是很多时候我们缺乏这种抽象能力和意志。</p><p>除了上一节我讲述的常见场景之外，我还会在下一节介绍几个实际业务场景，从而加深大家的理解。<br>希望大家看了之后，能够在自己的实际业务中有所帮助。</p><h2 id="性能和优雅，我全都要"><a href="#性能和优雅，我全都要" class="headerlink" title="性能和优雅，我全都要"></a>性能和优雅，我全都要</h2><p>从表象上看，使用合适的数据结构和算法有两方面的好处。</p><p>第一个是性能，这个比较好理解一点，我们追求更好的时间复杂度和空间复杂度，<br>并且我们需要不断地在两者之间做合理的取舍。</p><p>第二点是优雅，使用合适的数据结构和算法。能让我们处理问题更加简洁优雅。</p><p>下面我会举几个我在实际业务场景中的例子，来加深大家对上面两点的印象。</p><h3 id="权限系统"><a href="#权限系统" class="headerlink" title="权限系统"></a>权限系统</h3><p>假如你现在开发一款类似石墨文档的多人在线协作编辑文档系统。</p><p>这里面有一个小功能是权限系统。 用户可以在我们的系统中创建文件夹和文件，<br>并且管理角色，不同的角色可以分配不同的文件权限。 比如查看，下载，编辑，审批等。</p><p>我们既可以给文件夹分配权限，又可以给文件分配权限，如果对应文件该角色没有权限，<br>我们需要递归往上搜索，看有没有相应权限，如果有，则这个角色有文件的该操作权限。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112744.jpg" alt></p><p>如图，fileA 的权限就需要从 fileA 开始看有没有对应权限，如果有，则返回有权限。<br>如果没有，则查找 app 文件夹的权限，重复这个过程，直到根节点。</p><p>如果你是这个系统的前端负责人，你会如何设计这个系统呢？</p><p>其实做这个功能的方案有很多，我这里参考了 linux 的设计。<br>我们使用一个二进制来标示一个权限有还是没有。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112745.jpg" alt></p><p>这样的话，一方面我们只需要 4 个 bit 就可以存储权限信息，存储已经是极限了。<br>另一方面我们通过位运算即可算出有没有权限，二进制运算在计算性能上也是极限了。</p><p>另外代码写起来，也会非常简洁，感兴趣的可以自己试试。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112746.jpg" alt></p><blockquote><p>扩展： 假如文件权限不是只有两种可能，比如有三个取值怎么办？</p></blockquote><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><h4 id="什么是状态机"><a href="#什么是状态机" class="headerlink" title="什么是状态机"></a>什么是状态机</h4><p>状态机表示若干个状态以及在这些状态之间的转移和动作等行为的数学模型。<br>通俗的描述状态机就是定义了一套状态変更的流程：状态机包含一个状态集合，<br>定义当状态机处于某一个状态的时候它所能接收的事件以及可执行的行为，执行完成后，状态机所处的状态。</p><p>我们以现实中广泛使用的有限状态机（以下简称 FSM）为例进行讲解</p><p>FSM 应用非常广泛， 比如正则表达式的引擎，编译器的词法和语法分析，网络协议，企业应用等很多领域都会用到。</p><p>其中正则中使用的是一种特殊的 FSM， 叫 DFA（Deterministic Finite Automaton）， 通过分裂树形式来运行。</p><h4 id="为什么要使用状态机"><a href="#为什么要使用状态机" class="headerlink" title="为什么要使用状态机"></a>为什么要使用状态机</h4><p>第一个原因，也是大家感触最深的一个原因就是通过状态机去控制系统内部的状态以及状态流转，逻辑会<br>比较清晰，尤其在逻辑比较复杂的时候，这种作用越发明显。</p><p>第二个原因是通过状态机，我们可以实现数据以及系统的可视化。刚才我提到了正则表达式用到了状态机，<br>那么正则是否可以可视化呢？ 答案是肯定的，这里我介绍一个可视化正则表达式的一个网站。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112747.jpg" alt></p><p>实际业务中如果使用状态机来设计系统也可以进行可视化。类似这样子：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112748.jpg" alt></p><p>(图来自 <a href="https://statecharts.github.io/xstate-viz/" target="_blank" rel="noopener">https://statecharts.github.io/xstate-viz/</a>)</p><p>可以看出，逻辑流转非常清晰，我们甚至可以基于此进行调试。<br>当然，将它作为文档的一部分也是极好的，关于状态机的实际意义还有很多，我们接下来举几个例子说明。</p><h4 id="状态机的实际应用场景"><a href="#状态机的实际应用场景" class="headerlink" title="状态机的实际应用场景"></a>状态机的实际应用场景</h4><h5 id="匹配三的倍数"><a href="#匹配三的倍数" class="headerlink" title="匹配三的倍数"></a>匹配三的倍数</h5><p>实现一个功能，判断一个数字是否是三的倍数。 数字可以非常大，以至于超过 Number 的表示范围，<br>因此我们需要用 string 来存储。</p><p>一个简单直观的做法是直接将每一位都加起来，然后看加起来的数字是否是三的倍数。<br>但是如果数字大到一定程度，导致加起来的数字也超过了 Number 的表示范围呢？</p><p>一个方法是使用状态机来解决。</p><p>我们发现一个数字除以 3 的余数一共有三种状态，即 0，1，2。 基于此我们可以构建一个 FSM。<br>0，1，2 之间的状态流转也不难得出。</p><p>举个例子，假设当前我们是余数为 0 的状态，这时候再来一个字符。</p><ul><li>如果这个字符是 0,3 或者 9，那么我们的余数还是 0</li><li>如果这个字符是 1,4 或者 7，那么我们的余数是 1</li><li>如果这个字符是 2,5 或者 8，那么我们的余数还是 2</li></ul><p>用图大概是这个样子：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112749.jpg" alt></p><p>如果用代码大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFSM</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    initial: <span class="number">0</span>,</span><br><span class="line">    states: &#123;</span><br><span class="line">      <span class="number">0</span>: &#123;</span><br><span class="line">        on: &#123;</span><br><span class="line">          read(ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">3</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">9</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">4</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">7</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">2</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">5</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">8</span>: <span class="number">2</span></span><br><span class="line">            &#125;[ch];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="number">1</span>: &#123;</span><br><span class="line">        on: &#123;</span><br><span class="line">          read(ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">3</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">9</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">4</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">7</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">2</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">5</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">            &#125;[ch];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="number">2</span>: &#123;</span><br><span class="line">        on: &#123;</span><br><span class="line">          read(ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              <span class="number">0</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">3</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">9</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">1</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">4</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">7</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">2</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">5</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">8</span>: <span class="number">1</span></span><br><span class="line">            &#125;[ch];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fsm = createFSM();</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"281902812894839483047309573843389230298329038293829329"</span>;</span><br><span class="line"><span class="keyword">let</span> cur = fsm.initial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (![<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>].includes(str[i])) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"非法数字"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cur = fsm.states[cur].on.read(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"可以被3整除"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"不可以被3整除"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实代码还可以简化，读者可以下去尝试一下。</p><p>可以看出，我们这种方式逻辑清晰，且内存占用很少，不会出现溢出的情况。</p><blockquote><p>正则是基于自动机实现的，那么使用正则匹配会是怎么样的呢？大家可以自己试一下。</p></blockquote><h5 id="答题活动"><a href="#答题活动" class="headerlink" title="答题活动"></a>答题活动</h5><p>经过上面的热身，我们来一个真实的项目来练练手。</p><p>有这样一个业务场景，我们需要设计一款答题活动，让用户过来进行答题，<br>我们预先设置 N 道题目。 规则如下：</p><ul><li>初始状态用户会进入欢迎页面</li><li>答对之后可以直接进入下一个题目</li><li>答错了可以使用复活卡重新答，也可以使用过关卡，直接进入下一题</li><li>用户可以通过其他途径获取复活卡和过关卡</li><li>答对全部 N 道题之后用户过关，否则失败</li><li>不管是过关还是失败都展示结果页面，只不过展示不同的文字和图片</li></ul><p>这其实是一个简化版本的真实项目。 如果要你设计这样的一个系统，你会如何设计？</p><p>相信你肯定能想出很多种方法来完成这样的需求，接下来我会用 FSM 来实现。</p><p>我们很容易画出整理的流程图：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112750.jpg" alt></p><p>对于答题部分则稍微有一点麻烦，但是如果你用状态机的思维去思考就很容易,<br>我们不难画出这样的图：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112751.jpg" alt></p><p>JS 中有很多 FSM 的框架， 大家都可以直接拿过来使用。 笔者之前所在的项目<br>也用到了这样的技术，但是笔者是自己手写的简化版本 FSM，基本思想是一致的。</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>事实上，还有很多例子可以举。</p><p>假设我们后端服务器是一主一备，我们将所有的数据都同时存储在两个服务器上。<br>假如某一天，有一份数据丢失了，我们如何快速找到有问题的服务器。</p><p>这其实可以抽象成【Signle Number问题】。 因此很多时候，不是缺乏应用算法的场景，<br>而是缺乏这种将现实业务进行抽象为纯算法问题的能力。<br>我们会被各种细枝末节的问题遮蔽双眼，无法洞察隐藏在背后的深层次的规律。</p><p>编程最难是抽象能力，前几年我写了一篇文章《为什么我们的代码难以维护》，<br>其中一个非常重要的原因就是缺乏抽象。</p><p>从现在开始，让我们来锻炼抽象能力吧。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法在前端领域的应用 - 第一篇</title>
      <link href="/blog/2019/09/18/algorthimn-fe-1/"/>
      <url>/blog/2019/09/18/algorthimn-fe-1/</url>
      
        <content type="html"><![CDATA[<p>这是一个我在公司内部做的一个《数据结构与算法在前端领域的应用》主题演讲的一个前菜。<br>希望通过这个分享让大家认识到其实前端领域也有很多算法的，从而加深前端同学对算法的认识。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g93fslj2pbj30kv113ach.jpg" alt></p><a id="more"></a><h2 id="为什么大家觉得算法没用"><a href="#为什么大家觉得算法没用" class="headerlink" title="为什么大家觉得算法没用"></a>为什么大家觉得算法没用</h2><p>在我的职业生涯中，碰到很多非算法岗的研发同学吐槽“算法在实际业务中没什么用”，<br>甚至在面试官也问过我这个问题。我们姑且不来判断这句话正确与否，我们先来看下为什么大家会有这样的想法。</p><p>我发现很多人喜欢用冰山这个图来表示这种只看到总体的一小部分的情况。<br>我也来借用一下这个创意。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112727.jpg" alt></p><p>根据我的经验，我们写的业务代码通常不到总包体的 5%， 下面是我以前做过的一个实际项目的代码分布。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ du -sh node_modules <span class="comment"># 429M</span></span><br><span class="line">$ du -sh src <span class="comment"># 7.7M</span></span><br></pre></td></tr></table></figure><p>大家可以拿自己的实际项目看一下，看是不是这样的。</p><p>其实不难看出业务代码在整个应用的比例是很小的，软件工程有一个至理名言，“软件开发的 90%的工作是由 10%的人完成的”，<br>这句话很对，那么剩下的 10 的工作却由剩下的 90%来完成。</p><p>因此我们感觉算法没用，是因为我们没用深入剩下的“90%”<br>很多场景我们接触不到，并且没有思考过，就很容易“井底之蛙”，到头来就变成“只会用别人造好的轮子组装代码”的“前端打字员”。</p><p>那剩下的 90% 究竟有哪些涉及到算法呢？是否可以举例说明呢？<br>那接下来让我们来继续看一下。</p><h2 id="前端中算法的应用场景都有哪些"><a href="#前端中算法的应用场景都有哪些" class="headerlink" title="前端中算法的应用场景都有哪些"></a>前端中算法的应用场景都有哪些</h2><p>说实话，这部分内容实在太多啦，为了让大家有一个直观的感受，我画了一个图。</p><blockquote><p>图中黄色的代表我自己实现过。</p></blockquote><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112728.jpg" alt></p><p>这些都是前端开发过程的一些东西， 他们多多少少涉及到了数据结构和算法的知识</p><p>下面我们来简单分析一下。</p><h3 id="VDOM"><a href="#VDOM" class="headerlink" title="VDOM"></a>VDOM</h3><p>事实上 VDOM 就是一种数据结构，但是它并不是我们在《数据结构与算法》课程中学习到的一些现成的数据结构。</p><p>逻辑上 VDOM 就是用来抽象 DOM 的，底层上 VDOM 普遍实现是基于 hash table 这种数据结构的。</p><p>一个典型的 VDOM 可以是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: <span class="string">'lucifer'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    type: <span class="string">'span'</span>,</span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    children: []</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，VDOM 是一种递归的数据结构，因此使用递归的方式来处理是非常直观和容易的。</p><p>我上面提到了 VDOM 是 DOM 的抽象（ye, a new level of abstraction）。<br>根据 VDOM 我们可以创建一个对应的真实 DOM。</p><p>如果我们只是做了这一层抽象的话，我们相当于引入了一种编程模式，即从<br>面向 DOM 编程，切换到面向 VDOM 编程，而现在 VDOM 又是由数据驱动的，因此<br>我们的编程模式切换到了“数据驱动”。</p><p>事实上，VDOM 部分还有一个 VDOM diff 算法，相信大家都听说过。关于<br>DOM diff 的算法，以及它是如何取舍和创新的，我之前在一个地方回答过，这里给一个链接地址:<br><a href="https://juejin.im/post/5d3d8cf15188256ac355a9f0" target="_blank" rel="noopener">https://juejin.im/post/5d3d8cf15188256ac355a9f0</a></p><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p>Hooks 是 React16 添加的一个新功能， 它要解决的问题是状态逻辑复用。</p><p>Hooks 逻辑上解决了纯函数无法持久化状态的“问题”，从而拓宽了纯函数组件的<br>适用范围。</p><p>底层上 Hooks 使用数据来实现状态的对应关系，关于这部分可以参考我的<br><a href="https://github.com/azl397985856/over-fancy-30s/blob/master/problems/create-useState-from-scratch.md" target="_blank" rel="noopener">[第一期]实现一个简化版的 React Hook - useState</a></p><h3 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h3><p>Fiber 也是 React16 添加的一个新功能。</p><p>事实上 Fiber 类似 VDOM，也是一个数据结构，而且同样也是一个递归的数据结构。</p><p>为了解决 React 之前一次全量更新的”问题”, React 引入了 fiber 这种数据结构，<br>并重写了整个调和算法，并且划分了多个阶段。 关于这部分内容，我只推荐一篇文章,<br><a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e" target="_blank" rel="noopener">Inside Fiber: in-depth overview of the new reconciliation algorithm in React</a></p><blockquote><p>其实之前我的<a href="https://github.com/azl397985856/mono-react" target="_blank" rel="noopener">从零开始实现 React 系列教程</a> 也欠了 fiber 😄, 等我开心的时候补充上去哈。</p></blockquote><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>我之前写过一个 Git 终端（代码被我 rm -rf 啦）。 这过程还是用到了很多数据结构和算法的，<br>我也学到了很多东西， 甚至 React16 新的调和算法也有 Git 思想。</p><p>很直观的，Git 在推送本地仓库到远程的时候会进行压缩，其实这里就用到了最小编辑距离算法。<br>Leetcode 有一个题目<a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener">72. Edit Distance</a>,<br>官方难度<code>hard</code>, Git 的算法要是这个算法的复杂版本。</p><p>另外 Git 其实很多存储文件，数据的时候也用到了特殊的数据结构，我在<a href="https://github.com/azl397985856/git" target="_blank" rel="noopener">这里</a><br>进行了详细的描述，感兴趣的可以去看看。</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>Webpack 是众所周知的一个前端构建工具，我们可以用它做很多事情。<br>至今在前端构建领域还是龙头老大 🐲 的位置。</p><p>Webpack 中最核心的 tapable 是什么，是如何配合插件系统的？ webpack 是如何对资源进行抽象的，<br>webpack 是如何对依赖进行处理的？更复杂一点 Tree Shaking 如何做，分包怎么做，<br>加速打包怎么做。</p><p>其实 webpack 的执行过程是基于事件驱动的，tapable 提供了一系列钩子，<br>让 plugin 深入到这些过程之中去。听起来有点像事件总线，其实其中的设计思想和算法<br>细节要复杂和精妙很多。</p><p>关于这部分细节，我在我的<a href="https://github.com/azl397985856/mono-webpack" target="_blank" rel="noopener">从零实现一个 Webpack</a></p><blockquote><p>之后会加入更多特性，比如 tapable</p></blockquote><h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>AST（抽象语法树）是前端 编译（严格意义上是转义）的理论基础，<br>你如果想深入前端编译，就一定不能不会这个知识点。</p><blockquote><p>和 AST 相似的，其实还有 CST，prettier 等格式化工具会用到， 有兴趣可以搜一下。</p></blockquote><p><a href="https://astexplorer.net/" target="_blank" rel="noopener">这个网站</a> 可以让你对 AST 有一个直观的认识。</p><p>AST 厉害就厉害在它本身不涉及到任何语法，因此你只要编写相应的转义规则，就可以将任何语法转义到任何语法。<br>这就是<code>babel</code>， <code>PostCSS</code>, <code>prettier</code>， <code>typescript</code> 等的原理，<br>除此之外，还有很多应用场景，比如编辑器。</p><blockquote><p>之前自己写过一个小型的生成 AST 的程序，源代码忘记放哪了。😅</p></blockquote><h3 id="Browser-History"><a href="#Browser-History" class="headerlink" title="Browser History"></a>Browser History</h3><p>像浏览器中的历史页面，移动端 webview 的 <code>view stack</code>, 都用到了<code>栈</code>这种数据结构。</p><p>剩下的我就不一一说了。其实都是有很多数据结构和算法的影子的。</p><p>OK，说了那么多。 这些都是“大牛”们做的事情，好像和我日常开发没关系啊。<br>我只要用他们做好的东西，调用一下，一样可以完成我的日常工作啊。<br>让我们带着这个问题继续往下看。</p><h2 id="算法在日常开发中的应用都有哪些"><a href="#算法在日常开发中的应用都有哪些" class="headerlink" title="算法在日常开发中的应用都有哪些"></a>算法在日常开发中的应用都有哪些</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大神： “你可以先这样，再这样，然后就会抽象为纯算法问题了。”</span><br><span class="line"></span><br><span class="line">我： “哇，好厉害。”</span><br></pre></td></tr></table></figure><p>其实就是你没有掌握，或者“再思考”，以至于不能融汇贯通。</p><p>比如你可以用 vue 组件写一个递归，实现一些递归的功能，也是可以的，<br>但是大多数人都想不到。</p><p>接下来，我会举几个例子来说明“算法在日常开发中的应用”。<br>注意，以下所有的例子均来自我的实际业务需求。</p><h3 id="第一个例子-撤销与重做"><a href="#第一个例子-撤销与重做" class="headerlink" title="第一个例子 - 撤销与重做"></a>第一个例子 - 撤销与重做</h3><h4 id="业务描述"><a href="#业务描述" class="headerlink" title="业务描述"></a>业务描述</h4><p>某一天，可(gai)爱(si)的产品提了一个需求，”我们的系统需要支持用户撤销和重做最近十次的操作。“</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112729.jpg" alt></p><p>让我们来回忆一下纯函数。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112730.jpg" alt></p><p>纯函数有一个特性是给定输入，输出总是一样的。</p><blockquote><p>关于函数式编程可以参考我之前的<a href="https://github.com/azl397985856/functional-programming" target="_blank" rel="noopener">几篇文章</a><br>和<a href="https://slides.com/azl397985856/functional-programming-4" target="_blank" rel="noopener">一个分享</a></p></blockquote><p>我们对问题进行一些简化，假设我们的应用是纯粹的数据驱动，也就是说满足<code>纯</code>的特性。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112731.jpg" alt></p><p>我们继续引入第二个知识点 - <code>reducer</code>.</p><p>reducer 是一个纯函数，函数签名为<code>(store1, action1) =&gt; store2</code>。<br>即给定 state 和 action，一定会返回确定的新的 state。</p><blockquote><p>本质上 reducer 是 reduce 的空间版本。</p></blockquote><p>假设我们的应用初始 state 为 state1， 我们按照时间先后顺序分别发送了三个 action，<br>action1, action2, action3。</p><p>我们用一个图来表示就是这样的：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112732.jpg" alt></p><p>运用简单的数据知识，我们不难推导出如下关系：</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112733.jpg" alt></p><blockquote><p>如果对这部分知识点还比较迷茫，可以看下我之前的一篇文章，<a href="https://juejin.im/post/5a9e6a61f265da239866c7a3" target="_blank" rel="noopener">从零实现一个 Redux</a></p></blockquote><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>基础知识铺垫完了，我们来看一下怎么解决这个问题。</p><p>第一种方案，我们可以将每次的store，即store1, store2, store3都存起来。<br>比如我想回退到第二步，我们只需要将store2取出来，覆盖当前store，然后重新渲染即可。<br>这种方案很直观，可以满足我们的业务需求。<br>但是缺点也很明显，store在这里被存储了很多。 每次发送一个action都会有一个新的store被存起来。<br>当我们应用比较大的时候，或者用户触发了很多action的时候，会占据大量内存。<br>实际场景中性能上我们很难接受。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112734.jpg" alt></p><p>第二种方案，有了上面的铺垫，我们发现， 事实上我们没必要存储所有的store。<br>因为store可以被计算出来。因此我们只要存储action即可。<br>比如我们要回退到第二步，我们拿出来store1，然后和action运算一次，得到store2，<br>然后将store2覆盖到当前的store即可。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112735.jpg" alt></p><p>这种做法，只需要存储一个store1， 以及若干个action。 action相对于store来说要小很多。<br>这是这种做法相比与上一种的优势。同时由于每次都需要从头（store1）开始计算，<br>因此是一种典型的“时间换空间”的优化手段。</p><p>实际上这种做法，我们可以进行小小的优化。比如我们设置多个snapshot，<br>然后我们就不必每次从头开始计算，而是算出最近的一个snapshot，<br>然后计算即可。 无疑这种做法可以减少很多计算量，但是会增加空间占用。<br>这是典型的“空间换时间”， 如果根据实际业务进行取舍是关键。</p><p>第三种方案，我们可以用树来表示我们的store。每次修改store，我们不是将整个store<br>销毁然后创建一个新的，而是重用可以重用的部分。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112736.jpg" alt></p><p>如图我要修改 <code>store.user.age</code>。我们只需要将root和user的引用进行修改，同时替换age节点即可。</p><p>如果大家对immutable研究比较深的话应该能发现，这其实就是immutable的原理</p><h3 id="第二个例子-巨型Mapper的优化"><a href="#第二个例子-巨型Mapper的优化" class="headerlink" title="第二个例子 - 巨型Mapper的优化"></a>第二个例子 - 巨型Mapper的优化</h3><h4 id="业务描述-1"><a href="#业务描述-1" class="headerlink" title="业务描述"></a>业务描述</h4><p>由于业务需要，我们需要在前端缓存一些HTTP请求。<br>我们设计了如下的数据结构，其中key表示资源的URL，<br>value会上次服务端的返回值。</p><p>现在我们的项目中已经有上千个接口，当接口多起来之后，缓存占用会比较大，我们如何对此进行优化？</p><p>注： 我们的key中的前缀是有规律的，即有很多重复的数据在。 返回值也有可能是有很多重复的。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112737.jpg" alt></p><p>这是一个典型的数据压缩算法。数据压缩算法有很多，我这里就不介绍了，大家可以自行了解一下。</p><p>对数据压缩算法感兴趣的，可以看下我之前写的<a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/run-length-encode-and-huffman-encode.md" target="_blank" rel="noopener">游程编码和哈夫曼编码</a></p><h3 id="第三个例子-实现自动联想功能"><a href="#第三个例子-实现自动联想功能" class="headerlink" title="第三个例子 - 实现自动联想功能"></a>第三个例子 - 实现自动联想功能</h3><h4 id="业务描述-2"><a href="#业务描述-2" class="headerlink" title="业务描述"></a>业务描述</h4><p>现在很多输入框都带了自动联想的功能， 很多组件库也实现了自动填充组件。</p><p>现在需要你完成这个功能，你会怎么做？</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112739.jpg" alt></p><p>我们可以用前缀树，很高效的完成这个工作。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112741.png" alt="prefix-tree"></p><p>对这部分原理感兴趣的可以看下我的<a href="https://github.com/azl397985856/leetcode/blob/master/problems/208.implement-trie-prefix-tree.md" target="_blank" rel="noopener">这个题解</a></p><h3 id="第四个例子-相似度检测"><a href="#第四个例子-相似度检测" class="headerlink" title="第四个例子 - 相似度检测"></a>第四个例子 - 相似度检测</h3><h4 id="业务描述-3"><a href="#业务描述-3" class="headerlink" title="业务描述"></a>业务描述</h4><p>由于业务需要，我们需要对字符串进行相似度检测。<br>对于相似度超过一定阀值的数据，我们认为它是同一个数据。</p><p><img src="https://lucifer-1259702774.cos.ap-shanghai.myqcloud.com/2019-09-20-112742.jpg" alt></p><p>关于相似度检测，我们其实可以借助“最小编辑距离”算法。<br>对于两个字符串a和b，如果a和b的编辑距离越小，我们认为越相似，<br>反之越不相似。 特殊情况，如果编辑距离为0表示是相同的字符串，<br>相似度为100%。  我们可以加入自己的计算因子，将相似度<br>离散在0 - 100%之间。</p><p>这部分的内容，我在介绍Git的时候介绍过了，这里不再重复。</p><p>其实我们可以进一步扩展一下，比如<code>对于一些无意义的词不计入统计范围</code>，我们可以怎么做？</p><h2 id="算法不好会怎么样"><a href="#算法不好会怎么样" class="headerlink" title="算法不好会怎么样"></a>算法不好会怎么样</h2><p>这恐怕是很多人最关心的问题。</p><p>我虽然知道了算法有用，但是我不会怎么办？会有什么样的影响呢？</p><p>这就回到了我们开头的问题，“为什么很多人觉得算法没用”。<br>事实上，我们日常开发中真正用到算法的场景很少，大部分都被别人封装好了。<br>即使真正需要用到一些算法，我们也可以通过一些“低劣”的手段完成，在很多对性能和质量要求<br>不高的业务场景都是没有问题的。 这就是为什么“前端同学更加觉得算法没用”的原因之一。</p><p>那既然这么说，是不是真的算法就没用呢？ 或者说算法不好也不会怎么样了么？<br>当然不是， 如果算法不好，会<code>很难创新和突破</code>。 想想如今前端框架，工具的演进，哪一个不是建立在<br>无数的算法之上。  将视角聚焦到我们当下的业务上，如果算法不好，我们也同样很难让业务不断精进，<br>不断赋能业务。</p><p>React框架就是一个非常典型的例子，它的出现改变了传统的编程模式。<br>Redux的作者，React团队现任领导者 dan 最近发表了一篇个人博客 <a href="https://overreacted.io/algebraic-effects-for-the-rest-of-us/" target="_blank" rel="noopener">Algebraic Effects for the Rest of Us</a><br>这里面也有很多算法相关的东西，大家有兴趣的可以读读看。</p><p>另外我最近在做的一个 stack-visualizer，一个用于跟踪浏览器堆栈信息，以便更好地调试地工具， 这个也是和算法有关系的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
