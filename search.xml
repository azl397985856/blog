<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>typeScript 配置文件该怎么写？</title>
      <link href="/blog/2020/08/24/ts-config/"/>
      <url>/blog/2020/08/24/ts-config/</url>
      
        <content type="html"><![CDATA[<p>TypeScript 的学习资料非常多，其中也不乏很多优秀的文章和教程。但是目前为止没有一个我特别满意的。原因有：</p><ul><li>它们大多数没有一个清晰的主线，而是按照 API 组织章节的，内容在<strong>逻辑上</strong>比较零散。</li><li>大多是“讲是什么，怎么用“，而不是”讲为什么，讲原理“。</li><li>大多数内容比较枯燥，趣味性比较低。都是干巴巴的文字，没有图片，缺乏能够引起强烈共鸣的例子。</li></ul><p>因此我的想法是做一套不同市面上大多数的 TypeScript 学习教程。以人类认知的角度思考问题，学习 TypeScript，通过通俗易懂的例子和图片来帮助大家建立 TypeScript 世界观。</p><p>系列安排：</p><ul><li><a href="https://lucifer.ren/blog/2020/08/04/ts-internal/">上帝视角看 TypeScript（已发布）</a></li><li><a href="https://lucifer.ren/blog/2020/08/15/ts-type-system/">TypeScript 类型系统（已发布）</a></li><li><a href="https://lucifer.ren/blog/2020/08/21/ts-type/">types 和 @types 是什么？（已发布）</a></li><li><a href="https://lucifer.ren/blog/2020/06/16/ts-generics/">你不知道的 TypeScript 泛型（万字长文，建议收藏）（已发布）</a></li><li>TypeScript 配置文件该怎么写？（就是本文）</li><li>TypeScript 是如何与 React，Vue，Webpack 集成的？</li><li>TypeScript 练习题</li></ul><blockquote><p>目录将来可能会有所调整。</p></blockquote><p>注意，我的系列文章基本不会讲 API，因此需要你有一定的 TypeScript 使用基础，推荐两个学习资料。</p><ul><li><a href="https://jkchao.github.io/typescript-book-chinese/" target="_blank" rel="noopener">深入理解 TypeScript</a></li><li><a href="https://www.typescriptlang.org/docs/home" target="_blank" rel="noopener">官方文档</a></li></ul><p>结合这两个资料和我的系列教程，掌握 TypeScript 指日可待。</p><p>接下来，我们通过几个方面来从宏观的角度来看一下 TypeScript。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是我的 TypeScript 系列的<strong>第 5 篇</strong>。今天我们就来看下， TypeScript 的配置文件 tsconfig.json 该如何写。</p><p>和 package.json 一样， 它也是一个 JSON 文件。package.json 是包描述文件，对应的 Commonjs 规范，而 <strong>tsconfig.json 是最终被 TypeScript Compiler 解析和使用的一个 JSON 文件</strong>。 TypeScript Compiler 用这个配置文件来决定如何对项目进行编译。</p><p>说到编译，不得不提一个知名选手 - <a href="https://www.babeljs.cn/docs/babel-cli" target="_blank" rel="noopener">babel</a>。 和 TypeScript 类似， 他们都可以将一种语法静态编译成另外一种语法。如果说我想编译一个文件，我只需要告诉 babel 我的文件路径即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx babel script.js</span><br></pre></td></tr></table></figure><p>有时候我想编译整个文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx babel src --out-dir lib</span><br></pre></td></tr></table></figure><p>babel 也可以指定输出目录，指定需要忽略的文件或目录等等， TypeScript 也是一样！你当然可以像 babel 一样在命令行中全部指定好，也可以将这些配置放到 tsconfig.json 中，以配置文件的形式传递给 TypeScript Compiler 。 这就是 tsconfig.json 文件的初衷，即接受用户输入作为配置项。</p><h2 id="初探-tsconfig"><a href="#初探-tsconfig" class="headerlink" title="初探 tsconfig"></a>初探 tsconfig</h2><p>我们先来看一个简单的 tsconfig 文件。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./built"</span>,</span><br><span class="line">    <span class="attr">"allowJs"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"es5"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"./src/**/*"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上配置做了：</p><ul><li>读取所有可识别的 src 目录下的文件（通过 include）。</li><li>接受 JavaScript 做为输入（通过 allowJs）。</li><li>生成的所有文件放在 built 目录下（通过 outDir）。</li><li>将 JavaScript 代码降级到低版本比如 ECMAScript 5（通过 target）。</li></ul><p>实际项目有比这个更复杂。 接下来， 我们来进一步解读。 不过在讲配置项之前，我们先来看下 tsconfig.json 是如何被解析的。</p><h2 id="tsconfig-是如何被解析的？"><a href="#tsconfig-是如何被解析的？" class="headerlink" title="tsconfig 是如何被解析的？"></a>tsconfig 是如何被解析的？</h2><p><strong>如果一个目录下存在一个 tsconfig.json 文件，那么意味着这个目录是 TypeScript 项目的根目录。</strong> 如果你使用 tsc 编译你的项目，并且没有显式地指定配置文件的路径，那么 tsc 则会逐级向上搜索父目录寻找 tsconfig.json ，这个过程类似 node 的模块查找机制。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gi0ppn43slj31760fe0vo.jpg" alt></p><p>如图：</p><ul><li>在 _<a href="mailto:uglify-js@3.7.2" target="_blank" rel="noopener">uglify-js@3.7.2</a>@uglify-js 下执行 tsc 则会找到 配置文件 1，在 _<a href="mailto:uglify-js@3.7.2" target="_blank" rel="noopener">uglify-js@3.7.2</a>@uglify-js/bin 下执行 tsc 也会找到 配置文件 1</li><li>同理在 lib，node_modules 也会找到 配置文件 1</li><li>在 _<a href="mailto:uglify-js@3.7.2" target="_blank" rel="noopener">uglify-js@3.7.2</a>@uglify-js/bin/lucifer 下执行 tsc 则会找到 配置文件 2</li><li>在 _<a href="mailto:uglify-js@3.7.2" target="_blank" rel="noopener">uglify-js@3.7.2</a>@uglify-js/lib/lucifer 下执行 tsc 则会找到 配置文件 3</li></ul><p>我在 <a href="https://lucifer.ren/blog/2020/08/04/ts-internal/">上帝视角看 TypeScript</a> 一种讲述了 TypeScript 究竟做了什么，带你从宏观的角度看了一下 TypeScript。 其中提到了 TypeScript 编译器会接受文件或者文件集合作为输入，最终转换为 JavaScript（noEmit 为 false） 和 .d.ts(declarations 为 true)。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5ld0kfitj30ow0csdjs.jpg" alt></p><p>这里其实还少了一个点，那就是除了接受文件或者文件集合作为输入，还会接受 tsconfig.json。tsconfig.json 的内容决定了编译的范围和行为，不同的 配置可能会得到不同的输出，或者得到不同的检查结果。</p><p>当 tsc 找到了一个 tsconfig.json 文件，那么其规定的编译目录则全部会被 typescript 处理，当然也包括其依赖的文件。 如果 tsc 没有找到一个 tsconfig.json 或 tsconfig 没有有效信息，那么 tsc 会使用默认配置。 比如 tsconfig 是一个空的就没有有效信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>tsconfig 的全部属性，以及属性的默认值可以在这里找到： <a href="http://json.schemastore.org/tsconfig" target="_blank" rel="noopener">http://json.schemastore.org/tsconfig</a></p></blockquote><p>总结一下 tsc 解析 tsconfig.json 的逻辑。</p><ul><li>如果命令行指定了配置选项或者指定了配置文件的路径，那么直接会读取。<ul><li>根据 <a href="http://json.schemastore.org/tsconfig" target="_blank" rel="noopener">tsconfig json schema</a> 校验是否格式正确。<ul><li>如果正确，则将其和默认配置合并（如果有 extends 字段，也会一起合并），将合并后的配置传递给 TypeScript 编译器并开始编译。</li><li>否则抛出错误</li></ul></li></ul></li><li>否则，会从当前目录查找 tsconfig.json 文件， 如果找不到则逐层向上搜索父目录。<ul><li>如果找到了则会去根据 <a href="http://json.schemastore.org/tsconfig" target="_blank" rel="noopener">tsconfig json schema</a> 校验是否格式正确。<ul><li>如果正确，则将其和默认配置合并（如果有 extends 字段，也会一起合并），将合并后的配置传递给 TypeScript 编译器并开始编译。</li><li>否则抛出错误</li></ul></li><li>否则，始终找不到则直接使用默认配置</li></ul></li></ul><h2 id="tsconfig-的顶层属性"><a href="#tsconfig-的顶层属性" class="headerlink" title="tsconfig 的顶层属性"></a>tsconfig 的顶层属性</h2><p>tsconfig 的顶层属性（Top Level）不多，主要有：<strong>compilerOptions, files, include, exclude,extends,compileOnSave</strong>等。</p><ul><li>compilerOptions 是重头戏，其属性也是最多的，我们的项目也是对这个定制比较多，这个我后面会重点讲。</li><li>files 则是你需要编译的文件</li><li>exclude 则是你不需要编译的文件目录（支持 glob）</li><li>include 是你需要编译的文件目录（支持 glob）</li><li>extends 就是继承另外一个配置文件，TypeScript 会对其进行合并，多项目公共配置有用。你也可以直接继承社区的“最佳实践”，比如:</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: <span class="string">"@tsconfig/node12/tsconfig.json"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"src/**/*"</span>],</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>compileOnSave 则是和编辑器（确切地说是文件系统）联动的配置，即是否在文件保存后进行编译，实际项目不建议使用。</li></ul><p>除了 compilerOptions，其他也相对比较好理解。 因此接下来我只针对 compilerOptions 详细讲解一番。</p><h2 id="tsconfig-的编译项"><a href="#tsconfig-的编译项" class="headerlink" title="tsconfig 的编译项"></a>tsconfig 的编译项</h2><p>详细全面的内容，大家只需要参考<a href="https://www.typescriptlang.org/tsconfig" title="官网-tsconfig" target="_blank" rel="noopener">官网</a>的就好了。官网写的不仅全面，而且做了分类，非常清晰。</p><p>接下来，我会根据功能分开讲几个<strong>常用</strong> 的配置。</p><h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><p>常用的是以下四个，由于前面已经做了介绍，因此就不赘述了。</p><ul><li>exclude</li><li>extends</li><li>files</li><li>include</li></ul><h3 id="严格检查"><a href="#严格检查" class="headerlink" title="严格检查"></a>严格检查</h3><ul><li>alwaysStrict</li></ul><p>默认：false</p><p>首次发布版本：2.1</p><p>这个是和 ECMAScript 规范相关的，工作机制和 ES 5 的严格模式一样， 并且输出的 JS 顶部也会也会带上 ‘use strict’。</p><ul><li>noImplicitAny（推荐打开）</li></ul><p>默认：true</p><p>首次发布版本：-</p><p>我在 - <a href="https://lucifer.ren/blog/2020/08/15/ts-type-system/">TypeScript 类型系统</a> 中提到了如果不对变量显式声明类型，那么 TypeScript 会对变量进行类型推导，这当然也有推导不出的情况，这个时候该变量的类型就是 any，这个叫做隐式 any。区别于显式 any：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">any</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>隐式 any 是 TypeScript 编译器推断的。</p><ul><li>noImplicitThis（推荐打开）</li></ul><p>默认：true</p><p>首次发布版本：2.0</p><p>和隐式 any 类型， 只不过这次是针对的特殊的一个关键字 this，也就是你需要显式地指定 this 的类型。</p><ul><li>strict（推荐打开）</li></ul><p>默认：true</p><p>首次发布版本：2.3</p><p>实际上 strict 只是一个简写，是多个规则的合集。 类似于 babel 中插件（plugins）和 预设（presets）的差别。换句话说如果你指定了 strict 为 true ，那么所有严格相关的规则的都会开启，我所讲的<strong>严格检查</strong>都是，还有一部分我没有提到的。另外将来如果增加更多严格规则，你只要开启了 strict 则会自动加进来。</p><h3 id="模块解析"><a href="#模块解析" class="headerlink" title="模块解析"></a>模块解析</h3><h4 id="模块相关"><a href="#模块相关" class="headerlink" title="模块相关"></a>模块相关</h4><p>目的：<strong>allowSyntheticDefaultImports，allowUmdGlobalAccess，esModuleInterop，moduleResolution 都是为了和其他模块化规范兼容做的。</strong></p><ul><li>allowSyntheticDefaultImports</li><li>allowUmdGlobalAccess</li><li>esModuleInterop</li><li>moduleResolution</li></ul><p>还有一个配置 <strong>module</strong>，规定了项目的模块化方式，选项有 AMD，UMD，commonjs 等。</p><h4 id="路径相关"><a href="#路径相关" class="headerlink" title="路径相关"></a>路径相关</h4><p>目的： <strong>baseUrl，paths，rootDirs， typeRoots，types 都是为了简化路径的拼写做的。</strong></p><ul><li>baseUrl</li></ul><p>这个配置是告诉 TypeScript 如何解析模块路径的。比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; helloWorld &#125; <span class="keyword">from</span> <span class="string">"hello/world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(helloWorld);</span><br></pre></td></tr></table></figure><p>这个就会从 baseUrl 下找 hello 目录下的 world 文件。</p><ul><li>paths</li></ul><p>定义类似别名的存在，从而简化路径的书写。</p><ul><li>rootDirs</li></ul><p>注意是 rootDirs ，而不是 rootDir，也就是说根目录可以有多个。 当你指定了多个根目录的时候， 不同根目录的文件可以像在一个目录下一样互相访问。</p><blockquote><p>实际上也有一个叫 rootDir 的， 和 rootDirs 的区别就是其只能指定一个。</p></blockquote><ul><li>typeRoots</li><li>types</li></ul><p>types 和 typeRoots 我在 - <a href="https://lucifer.ren/blog/2020/08/21/ts-type/">types 和 @types 是什么？</a> 已经讲得很清楚了，这里就不多说了。</p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><h4 id="JavaScript-相关"><a href="#JavaScript-相关" class="headerlink" title="JavaScript 相关"></a>JavaScript 相关</h4><ul><li>allowJs</li></ul><p>默认：false</p><p>首次发布版本：1.8</p><p>顾名思义，允许在 TypeScript 项目中使用 JavaScript，这在从 JavaScript 迁移到 TypeScript 中是非常重要的。</p><ul><li>checkJs</li></ul><p>默认：false</p><p>首次发布版本：-</p><p>和 allowJs 类似， 只不过 checkJs 会额外对 JS 文件进行校验。</p><h4 id="声明文件相关"><a href="#声明文件相关" class="headerlink" title="声明文件相关"></a>声明文件相关</h4><p>如果 TypeScript 是将 TS 文件编译为 JS，那么声明文件 + JS 文件就可以反推出 TS 文件。</p><p>这两个用来生成 .d.ts 和 .d.ts 的 sourcemap 文件。</p><ul><li>declaration</li></ul><p>默认：false</p><p>首次发布版本：1.0</p><ul><li>declarationMap</li></ul><p>默认：false</p><p>首次发布版本：2.9</p><h4 id="外部库相关"><a href="#外部库相关" class="headerlink" title="外部库相关"></a>外部库相关</h4><ul><li>jsx</li></ul><p>默认：react</p><p>首次发布版本：2.2</p><p>这个是告诉 TypeScript 如何编译 jsx 语法的。</p><ul><li>lib</li></ul><p>默认：-</p><p>首次发布版本：2.0</p><p>lib 我在 <a href="https://lucifer.ren/blog/2020/08/15/ts-type-system/">TypeScript 类型系统</a> 中讲过。 Typescript 提供了诸如 lib.d.ts 等类型库文件。随着 ES 的不断更新， JavaScript 类型和全局变量会逐渐变多。Typescript 也是采用这种 lib 的方式来解决的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghmyjgyd7qj307o0lxgmq.jpg" alt></p><p>（TypeScript 提供的部分 lib）</p><h4 id="输出相关"><a href="#输出相关" class="headerlink" title="输出相关"></a>输出相关</h4><p>outDir 和 outFile 这两个配置则是告诉 TypeScript 将文件生成到哪里。</p><ul><li>outDir</li></ul><p>默认：和 ts 文件同目录（且同名，只是后缀不同）</p><p>首次发布版本：-</p><ul><li>outFile</li></ul><p>默认：-</p><p>首次发布版本：1.0</p><p>module 是 CommonJS 和 ES6 module 不能知道 outFile，只有是 None, System 或 AMD 才行，其会将这些模块的文件内容打包到全局文件内容之后。</p><p>而 noEmit 则是控制是否输出 JS 文件的。</p><ul><li>noEmit</li></ul><p>默认：false</p><p>首次发布版本：-</p><p>如果你只希望用 TypeScript 进行类型检查，不希望要它生成文件，则可以将 noEmit 设置成 true。</p><ul><li>target</li></ul><p>即输出的 JavaScript 对标的 ECMA 规范。 比如 “target”: “es6” 就是将 es6 + 的语法转换为 ES6 的 代码。其选项有 ES3，ES5，ES6 等。</p><blockquote><p>为什么没有 ES4 ？ ^_^</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>tsconfig 就是一个 JSON 文件，TypeScript 会使用该文件来决定如何编译和检查 TypeScript 项目。和 babel 类似，甚至很多配置项都是相通的。</p></li><li><p>如果一个目录下存在一个 tsconfig.json 文件，那么意味着这个目录是 TypeScript 项目的根目录。 如果你使用 tsc 编译你的项目，并且没有显式地指定配置文件的路径，那么 tsc 则会逐级向上搜索父目录寻找 tsconfig.json ，这个过程类似 node 的模块查找机制。</p></li><li><p>tsconfig 中最重要的恐怕就是编译器选项（compilerOptions）了。如果你按照功能去记忆则会比较简单， 比如文件相关的有哪些， 严格检查的有哪些，声明文件的有哪些等等。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.typescriptlang.org/tsconfig#jsx" target="_blank" rel="noopener">typescriptlang’s tsconfig</a></li></ul><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的前端硬核文章，带你认识你不知道的前端。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxro1x125j30oz0dw43s.jpg" alt></p><p>公众号【 <a href="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" target="_blank" rel="noopener">力扣加加</a>】<br>知乎专栏【 <a href="https://www.zhihu.com/people/lu-xiao-13-70" target="_blank" rel="noopener">Lucifer - 知乎</a>】</p><p>点关注，不迷路！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>types 和 @types 是什么？</title>
      <link href="/blog/2020/08/21/ts-type/"/>
      <url>/blog/2020/08/21/ts-type/</url>
      
        <content type="html"><![CDATA[<p>TypeScript 的学习资料非常多，其中也不乏很多优秀的文章和教程。但是目前为止没有一个我特别满意的。原因有：</p><ul><li>它们大多数没有一个清晰的主线，而是按照 API 组织章节的，内容在<strong><em>逻辑上</em></strong>比较零散。</li><li>大多是“讲是什么，怎么用“，而不是”讲为什么，讲原理“。</li><li>大多数内容比较枯燥，趣味性比较低。都是干巴巴的文字，没有图片，缺乏能够引起强烈共鸣的例子。</li></ul><p>因此我的想法是做一套不同市面上大多数的 TypeScript 学习教程。以人类认知的角度思考问题，学习 TypeScript，通过通俗易懂的例子和图片来帮助大家建立 TypeScript 世界观。</p><p>系列安排：</p><ul><li><a href="https://lucifer.ren/blog/2020/08/04/ts-internal/">上帝视角看 TypeScript（已发布）</a></li><li><a href="https://lucifer.ren/blog/2020/08/15/ts-type-system/">TypeScript 类型系统（已发布）</a></li><li>types 和 @types 是什么？（就是本文）</li><li><a href="https://lucifer.ren/blog/2020/06/16/ts-generics/">你不知道的 TypeScript 泛型（万字长文，建议收藏）</a>（已发布）</li><li>TypeScript 配置文件该怎么写？</li><li>TypeScript 是如何与 React，Vue，Webpack 集成的？</li><li>TypeScript 练习题</li></ul><blockquote><p>目录将来可能会有所调整。</p></blockquote><p>注意，我的系列文章基本不会讲 API，因此需要你有一定的 TypeScript 使用基础，推荐两个学习资料。</p><ul><li><a href="https://jkchao.github.io/typescript-book-chinese/" target="_blank" rel="noopener">深入理解 TypeScript</a></li><li><a href="https://www.typescriptlang.org/docs/home" target="_blank" rel="noopener">官方文档</a></li></ul><p>结合这两个资料和我的系列教程，掌握 TypeScript 指日可待。</p><p>接下来，我们通过几个方面来从宏观的角度来看一下 TypeScript。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>作者：feiker &amp; Lucifer</li></ul><p>TypeScript 中有几个概念和名字很像，会让初学者傻傻分不清楚。比如配置文件中的 <strong><em>types 和 typeRoots</em></strong>，并且还有一个 @types。接触过 TypeScript 的人一定接触过它们， 这几个有什么区别和联系呢？今天就带你来重新认识下它们。</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>这里我通过一个例子来说明一下什么是 @types，这样大家理解起来更深刻一点。</p><p>当我们用 npm 等包管理工具安装第三方包的时候，有些包并不是 TypeScript 编写的，自然也不会导出 TypeScript 声明文件。这种情况下，如果我们在 TypeScript 项目中引入了这种包，则会编译报错(没有设置 allowJS)。举个例子，当我们通过<code>npm install jquery --save</code> 安装 jquery 包并引用的时候，TypeScript 会报错。</p><blockquote><p>allowJS 是 TypeScript 1.8 引进的一个编译项。</p></blockquote><p>报错内容如下：</p><blockquote><p>Could not find a declaration file for module ‘jquery’. Try <code>npm install @types/jquery</code> if it exists or add a new declaration (.d.ts) file containing <code>declare module &#39;jquery&#39;;</code></p></blockquote><p>这里的意思是 TypeScript 没有找到 jquery 这个包的定义，你可以通过<code>npm install @types/jquery</code>安装相关声明，或者自己定义一份.d.ts 文件，并将 jquery 声明为 module。</p><p>全世界不是 TypeScript 编写的包多了去了。即使你的包是 TypeScript 编写的，如果你没有导出声明文件，也是没用的。（TypeScript 默认不会导出声明文件，只会编译输出 JavaScript 文件）。因此 TypeScript 必须对这种情况提供解决方案，而上面的两种方案（安装 @types 和 自己 declare module）就是 TypeScript 官方提出的， 你可以选择适合你的方案。我的推荐是尽量使用 @types 下的声明，实在没有，再使用第二种方法。</p><p>值得一提的是，并不是所有的包都可以通过这种方式解决的， 能解决的是 DefinitelyTyped 组织已经写好定义的包， 好消息是比较流行的包基本都有。 如果你想查一个包是否在 @type 下，可以访问 <a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">https://microsoft.github.io/TypeSearch/</a></p><p>那么 TypeScript 是怎么找定义的，什么情况会找不到定义而报类似上面举的例子的错误，这里简单介绍下原理。</p><h2 id="包类型定义的查找"><a href="#包类型定义的查找" class="headerlink" title="包类型定义的查找"></a>包类型定义的查找</h2><p>就好像 node 的包查找是先在当前文件夹找 node_modules，在它下找递归找，如果找不到则往上层目录继续找，直到顶部一样， TypeScript 类型查找也是类似的方式。</p><p>具体来说就是：</p><ul><li>TypeScript 编译器先在当前编译上下文找 jquery 的定义。</li><li>如果找不到，则会去 node_modules 中的@types （默认情况，目录可以修改，后面会提到）目录下去寻找对应包名的模块声明文件。</li></ul><blockquote><p><code>@types/*</code>模块声明文件由社区维护，通过发布到@types 空间下。 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener">GitHub - DefinitelyTyped/DefinitelyTyped: The repository for high quality TypeScript type definitions.</a></p></blockquote><h2 id="变量类型定义的查找"><a href="#变量类型定义的查找" class="headerlink" title="变量类型定义的查找"></a>变量类型定义的查找</h2><p>和包查找类似，默认情况下变量类型定义的查找也会去 @types 下去寻找。只不过并不是直接去 @types 找，而是有一定的优先级， 这个过程类似原型链或者作用域链。</p><p>比如如下代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user: User = &#123; name: <span class="string">"lucifer"</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li>Typescript 则会先在本模块查找 User 的定义。</li><li>如果找到，则直接返回。 如果找不到， 则会到全局作用域找，而这个全局默认就是指的就是 @types 下的所有类型定义。（注意目录页是可以配的）</li></ul><blockquote><p>也就是说 @types 下的定义都是全局的。当然你可以导入 @types 下导出的定义，使得它们的作用域变成你的模块内部。</p></blockquote><h2 id="typeRoots-与-types"><a href="#typeRoots-与-types" class="headerlink" title="typeRoots 与 types"></a>typeRoots 与 types</h2><p>前面说了 TypeScript 会默认引入<code>node_modules</code>下的所有<code>@types</code>声明，但是开发者也可以通过修改<code>tsconfig.json</code>的配置来修改默认的行为.</p><p>tsconfig.json 中有两个配置和类型引入有关。</p><ol><li><code>typeRoots</code>: 用来指定默认的类型声明文件查找路径，默认为<code>node_modules/@types</code>, 指定<code>typeRoots</code>后，TypeScript 编译器会从指定的路径去引入声明文件，而不是<code>node_modules/@types</code>, 比如以下配置会从<code>typings</code>路径下去搜索声明</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"typeRoots"</span>: [<span class="string">"./typings"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>types</code>: TypeScript 编译器会默认引入<code>typeRoot</code>下所有的声明文件，但是有时候我们并<strong><em>不希望全局引入所有定义</em></strong>，而是仅引入部分模块。这种情景下可以通过<code>types</code>指定模块名只引入我们想要的模块，比如以下只会引入 jquery 的声明文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"types"</span>: [<span class="string">"jquery"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>typeRoots 是 tsconfig 中 compilerOptions 的一个配置项，typeRoots 下面的包会被 ts 编译器自动包含进来，typeRoots 默认指向 node_modules/@types。</li><li>@types 是 npm 的 scope 命名空间，和@babel 类似，@types 下的所有包会默认被引入，你可以通过修改 compilerOptions 来修改默认策略。</li><li>types 和 typeRoots 一样也是 compilerOptions 的配置，指定 types 后，typeRoots 下只有被指定的包才会被引入。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener">GitHub - DefinitelyTyped/DefinitelyTyped: The repository for high quality TypeScript type definitions.</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/typings/types.html" target="_blank" rel="noopener">@types | 深入理解 TypeScript</a></li><li><a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">tsconfig.json · TypeScript 中文网 · TypeScript——JavaScript 的超集</a></li><li><a href="https://segmentfault.com/a/1190000013514680" target="_blank" rel="noopener">理解 Typescript 配置文件 - 个人文章 - SegmentFault 思否</a></li></ul><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的前端硬核文章，带你认识你不知道的前端。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxro1x125j30oz0dw43s.jpg" alt></p><p>公众号【 <a href="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" target="_blank" rel="noopener">力扣加加</a>】<br>知乎专栏【 <a href="https://www.zhihu.com/people/lu-xiao-13-70" target="_blank" rel="noopener">Lucifer - 知乎</a>】</p><p>点关注，不迷路！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣刷题插件</title>
      <link href="/blog/2020/08/16/leetcode-cheat/"/>
      <url>/blog/2020/08/16/leetcode-cheat/</url>
      
        <content type="html"><![CDATA[<p>之前我做了一个视频， 介绍我的刷题浏览器扩展插件，视频地址：<a href="https://www.bilibili.com/video/BV1UK4y1x7zj/。" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1UK4y1x7zj/。</a> 今天我在上次的基础上增加了部分公司的显示以及优化了若干体验功能。</p><a id="more"></a><h2 id="这个刷题插件能做什么？"><a href="#这个刷题插件能做什么？" class="headerlink" title="这个刷题插件能做什么？"></a>这个刷题插件能做什么？</h2><p>当你在任意非题目详情页或者我还没有收录的题目详情页的时候， 我都会列出当前我总结的所有题解。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghsse7cw2oj313s0u0tbz.jpg" alt></p><blockquote><p>其实我给比较经典的题目做了题解，因此这个题目数目不是很多，目前是 173 道题。另外有时候我直接写了专题，没有单独给每道题写题解，因此数量上要比 173 多很多。</p></blockquote><p>当你进到一个我写了题解的题目详情页的时候， 你就可以正式使用我的插件了。 它可以：</p><ul><li>给出这道题目的前置知识。换句话说就是<strong>我需要先掌握什么才能做出这道题</strong>。</li><li>这个题目的关键点。</li><li>哪些公司出了这道题。</li><li>我实在不会了，给我看看题解吧。好，满足你。</li><li>题解我就不看了，直接 show me code 吧。好，满足你。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghssdtat3zj31290u0dii.jpg" alt></p><h2 id="我怎么才能获取呢？"><a href="#我怎么才能获取呢？" class="headerlink" title="我怎么才能获取呢？"></a>我怎么才能获取呢？</h2><p>公众号《力扣加加》后台回复刷题插件即可。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p><h2 id="后台收到的文件该如何安装呢？"><a href="#后台收到的文件该如何安装呢？" class="headerlink" title="后台收到的文件该如何安装呢？"></a>后台收到的文件该如何安装呢？</h2><ul><li>将下载的压缩包解压</li><li>在 Chrome 浏览器的地址栏输入 chrome://extensions/</li><li>点击 load uppack</li></ul><blockquote><p>不知道中文是什么名字，反正就是上面三个按钮最左边的。</p></blockquote><ul><li>选择你解压之后的文件夹</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghsscnetjej30os0cw75e.jpg" alt></p><ul><li>出现下面这个就说明你安装成功了，点一下试试吧。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghss5p4j9oj30l802g0t3.jpg" alt></p><h2 id="后期的规划是怎么样的？"><a href="#后期的规划是怎么样的？" class="headerlink" title="后期的规划是怎么样的？"></a>后期的规划是怎么样的？</h2><blockquote><p>后期的功能计划先对 91 活动的用户开发。关于 91 活动，大家可以关注我的公众号《力扣加加》了解详情。</p></blockquote><ul><li>更多公司信息。 持续完善题目的公司信息，这个过程需要大家的帮助，大家可以把自己面试遇到的问题发给我（附带公司和岗位信息），我可以免费提供咨询服务。</li><li>根据公司，查找题目。面试突击必备。</li><li>岗位信息。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghss7raskrj31c00u046y.jpg" alt></p><p>这个过程同样需要大家的帮助，大家可以把自己面试遇到的问题发给我（附带公司和岗位信息），我可以免费提供咨询服务。</p><ul><li>可视化调试。 可视化展示你的代码允许情况。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghssbhbbnvg30dc02w3z4.gif" alt></p><p>（一个双指针题目的可视化调试过程）</p><ul><li>自动制定复习计划。</li><li>AI 智能提示。即新的提示也可以根据题目信息推测可能的解法。</li><li>等等</li></ul><h2 id="关注更新"><a href="#关注更新" class="headerlink" title="关注更新"></a>关注更新</h2><p>大家可以关注我的公众号， 如果插件有更新，会第一时间在公众号同步的哦~</p><p>想看题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 35K star 啦。</p><p>关注公众号力扣加加，努力用清晰直白的语言还原解题思路，并且有大量图解，手把手教你识别套路，高效刷题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul><li>感谢<strong>张震</strong>的爬虫脚本。</li><li>感谢<strong>羽飞</strong> 和 <strong>肠粉</strong>提供的公司信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 插件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 插件 </tag>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 类型系统</title>
      <link href="/blog/2020/08/15/ts-type-system/"/>
      <url>/blog/2020/08/15/ts-type-system/</url>
      
        <content type="html"><![CDATA[<p>TypeScript 的学习资料非常多，其中也不乏很多优秀的文章和教程。但是目前为止没有一个我特别满意的。原因有：</p><ul><li>它们大多数没有一个清晰的主线，而是按照 API 组织章节的，内容在<strong>逻辑上</strong>比较零散。</li><li>大多是“讲是什么，怎么用“，而不是”讲为什么，讲原理“。</li><li>大多数内容比较枯燥，趣味性比较低。都是干巴巴的文字，没有图片，缺乏能够引起强烈共鸣的例子。</li></ul><p>因此我的想法是做一套不同市面上大多数的 TypeScript 学习教程。以人类认知的角度思考问题，学习 TypeScript，通过通俗易懂的例子和图片来帮助大家建立 TypeScript 世界观。 而本篇文章则是这个系列的开篇。</p><p>系列安排：</p><ul><li><a href="https://lucifer.ren/blog/2020/08/04/ts-internal/" title="上帝视角看 TypeScrip">上帝视角看 TypeScript</a>（已发布）</li><li>TypeScript 类型系统（就是本文）</li><li>types 和 @types 是什么？</li><li><a href="https://lucifer.ren/blog/2020/06/16/ts-generics/" title="你不知道的 TypeScript 泛型（万字长文，建议收藏）">你不知道的 TypeScript 泛型（万字长文，建议收藏）</a>（已发布）</li><li>TypeScript 配置文件该怎么写？</li><li>TypeScript 是如何与 React，Vue，Webpack 集成的？</li><li>TypeScript 练习题</li></ul><blockquote><p>目录将来可能会有所调整。</p></blockquote><p>注意，我的系列文章基本不会讲 API，因此需要你有一定的 TypeScript 使用基础，推荐两个学习资料。</p><ul><li><a href="https://jkchao.github.io/typescript-book-chinese/" target="_blank" rel="noopener">深入理解 TypeScript</a></li><li><a href="https://www.typescriptlang.org/docs/home" target="_blank" rel="noopener">官方文档</a></li></ul><p>结合这两个资料和我的系列教程，掌握 TypeScript 指日可待。</p><p>接下来，我们通过几个方面来从宏观的角度来看一下 TypeScript。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一节的<a href="https://lucifer.ren/blog/2020/08/04/ts-internal/">上帝视角看 TypeScript</a>，我们从宏观的角度来对 Typescript 进行了一个展望。之所以把那个放到开头讲是让大家有一个大体的认识，不想让大家一叶障目。当你对整个宏观层面有了一定的了解，那么对 Typescript 的理解就不会错太多。相反，一开始就是具体的概念和 API，则很可能会让你丧失都整体的基本判断。</p><p>实际上， Typescript 一直在不断更新迭代。一方面是因为当初许下的诺言”Typescript 是 JavaScript 的超集“（JavaScript 的特性你要同步支持，同时也要处理各种新语法带来的不兼容情况）。不单是 ECMA，社区的其他发展可能也会让 Typescript 很难受。 比如 JSX 的广泛使用就给 Typescript 泛型的使用带来了影响。</p><p>TypeScript 一直处于高速的迭代。除了修复日常的 bug 之外，TypeScript 也在不断发布新的功能，比如最新 <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0-rc/#labeled-tuple-elements" title="4.0.0 beta 版本的**标签元祖**" target="_blank" rel="noopener">4.0.0 beta 版本的<strong>标签元祖</strong></a> 的功能就对智能提示这块很有用。Typescript 在社区发展方面也做的格外好，以至于它的竞争对手 Flow 被 Typescript 完美击败，这在很大程度上就是因为 Typescript 没有烂尾。如今微软在开源方向的发力是越来越显著了，我很期待微软接下来的表现，让我们拭目以待。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghsqcjsrx9j30xc0b4js3.jpg" alt></p><h2 id="变量类型和值类型"><a href="#变量类型和值类型" class="headerlink" title="变量类型和值类型"></a>变量类型和值类型</h2><p>有的同学可能有疑问， JavaScript 不是也有类型么？ 它和 Typescript 的类型是一回事么？JavaScript 不是动态语言么，那么经过 Typescript 的限定会不会丧失动态语言的动态性呢？我们继续往下看。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghsqeaxx8jj30pq09qdga.jpg" alt></p><ul><li><p>JavaScript 中的类型其实是值的类型。实际上不仅仅是 JavaScript，任何动态类型语言都是如此，这也是动态类型语言的本质。</p></li><li><p>Typescript 中的类型其实是变量的类型。实际上不仅仅是 Typescript，任何静态类型语言都是如此，这也是静态类型语言的本质。</p></li></ul><p>记住这两句话，我们接下来解释一下这两句话。</p><p>对于 JavaScript 来说，一个变量可以是任意类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">"lucifer"</span>;</span><br><span class="line">a = &#123;&#125;;</span><br><span class="line">a = [];</span><br></pre></td></tr></table></figure><p>上面的值是有类型的。比如 1 是 number 类型，”lucifer” 是字符串类型， {} 是对象类型， [] 是数组类型。而变量 a 是没有固定类型的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghsqh8ere4j30qc0iygmv.jpg" alt></p><p>对于 Typescript 来说， 一个变量只能接受和它类型兼容的类型的值。说起来比较拗口， 看个例子就明白了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">"lucifer"</span>; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="built_in">any</span> = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">"lucifer"</span>; <span class="comment">// ok</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// ok</span></span><br><span class="line">a = []; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>我们不能将 string 类型的值赋值给变量 a， 因为 string 和 number 类型不兼容。而我们可以将 string,Object,Array 类型的值赋值给 b，因此 它们和 any 类型兼容。简单来说就是，一旦一个变量被标注了某种类型，那么其就只能接受这个类型以及它的子类型。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghsqgexx68j30q80j6ta0.jpg" alt></p><h2 id="类型空间和值空间"><a href="#类型空间和值空间" class="headerlink" title="类型空间和值空间"></a>类型空间和值空间</h2><p>类型和值居住在不同的空间，一个在阳间一个在阴间。他们之间互相不能访问，甚至不知道彼此的存在。类型不能当做值来用，反之亦然。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghsqpfc7uej307b05baa0.jpg" alt></p><h3 id="类型空间"><a href="#类型空间" class="headerlink" title="类型空间"></a>类型空间</h3><p>如下代码会报类型找不到的错：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aa: User = &#123; name: <span class="string">"lucifer"</span>, age: <span class="number">17</span> &#125;;</span><br></pre></td></tr></table></figure><p>这个比较好理解，我们只需要使用 interface 声明一下 User 就行。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> aa: User = &#123; name: <span class="string">"lucifer"</span>, age: <span class="number">17</span> &#125;;</span><br></pre></td></tr></table></figure><p>也就是说使用 interface 可以在类型空间声明一个类型，这个是 Typescript 的类型检查的基础之一。</p><p>实际上类型空间内部也会有子空间。我们可以用 namespace（老）和 module（新） 来创建新的子空间。子空间之间不能直接接触，需要依赖导入导出来交互。</p><h3 id="值空间"><a href="#值空间" class="headerlink" title="值空间"></a>值空间</h3><p>比如，我用 Typescript 写出如下的代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">window</span>.lucifer();</span><br></pre></td></tr></table></figure><p>Typescript 会报告一个类似<code>Property &#39;lucifer&#39; does not exist on type &#39;Window &amp; typeof globalThis&#39;.</code> 的错误。</p><p>实际上，这种错误并不是类型错误，而是找不到成员变量的错误。我们可以这样解决：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> lucifer: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>也就是说使用 declare 可以在值空间声明一个变量。这个是 Typescript 的变量检查的基础，不是本文要讲的主要内容，大家知道就行。</p><p>明白了 JavaScript 和 TypeScript 类型的区别和联系之后，我们就可以来进入我们本文的主题了：<strong>类型系统</strong>。</p><h2 id="类型系统是-TypeScript-最主要的功能"><a href="#类型系统是-TypeScript-最主要的功能" class="headerlink" title="类型系统是 TypeScript 最主要的功能"></a>类型系统是 TypeScript 最主要的功能</h2><p>TypeScript 官方描述中有一句：<strong>TypeScript adds optional types to JavaScript that support tools for large-scale JavaScript applications</strong>。实际上这也正是 Typescript 的主要功能，即给 JavaScript 添加静态类型检查。要想实现静态类型检查，首先就要有类型系统。总之，我们使用 Typescript 的主要目的仍然是要它的静态类型检查，帮助我们提供代码的扩展性和可维护性。因此 Typescript 需要维护一套完整的类型系统。</p><p><strong>类型系统包括 1. 类型 和 2.对类型的使用和操作</strong>，我们先来看类型。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>TypeScript 支持 JavaScript 中所有的类型，并且还支持一些 JavaScript 中没有的类型（毕竟是超集嘛）。没有的类型可以直接提供，也可以提供自定义能力让用户来自己创造。 那为什么要增加 JavaScript 中没有的类型呢？我举个例子，比如如下给一个变量声明类型为 Object，Array 的代码。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">Object</span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">Array</span> = [];</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><p>第一行代码 Typescript 允许，但是太宽泛了，我们很难得到有用的信息，推荐的做法是使用 interface 来描述，这个后面会讲到。</p></li><li><p>第二行 Typescript 则会直接报错，原因的本质也是太宽泛，我们需要使用泛型来进一步约束。</p></li></ul><h3 id="对类型的使用和操作"><a href="#对类型的使用和操作" class="headerlink" title="对类型的使用和操作"></a>对类型的使用和操作</h3><p>上面说了<strong>类型和值居住在不同的空间，一个在阳间一个在阴间。他们之间互相不能访问，甚至不知道彼此的存在。</strong></p><p>使用 declare 和 interface or type 就是分别在两个空间编程。比如 Typescript 的泛型就是在类型空间编程，叫做类型编程。除了泛型，还有集合运算，一些操作符比如 keyof 等。值的编程在 Typescript 中更多的体现是在类似 lib.d.ts 这样的库。当然 lib.d.ts 也会在类型空间定义各种内置类型。我们没有必要去死扣这个，只需要了解即可。</p><p>lib.d.ts 的内容主要是一些变量声明（如：window、document、math）和一些类似的接口声明（如：Window、Document、Math）。寻找代码类型（如：Math.floor）的最简单方式是使用 IDE 的 F12（跳转到定义）。</p><h2 id="类型是如何做到静态类型检查的？"><a href="#类型是如何做到静态类型检查的？" class="headerlink" title="类型是如何做到静态类型检查的？"></a>类型是如何做到静态类型检查的？</h2><p>TypeScript 要想解决 JavaScript 动态语言类型太宽松的问题，就需要：</p><ol><li>提供给<strong>变量</strong>设定类型的能力</li></ol><blockquote><p>注意是变量，不是值。</p></blockquote><ol start="2"><li><p>提供常用类型（不必须，但是没有用户体验会极差）并可以扩展出自定义类型（必须）。</p></li><li><p>根据第一步给变量设定的类型进行类型检查，即不允许类型不兼容的赋值， 不允许使用值空间和类型空间不存在的变量和类型等。</p></li></ol><p>第一个点是通过类型注解的语法来完成。即类似这样：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><blockquote><p>Typescript 的类型注解是这样， Java 的类型注解是另一个样子，Java 类似 int a = 1。 这个只是语法差异而已，作用是一样的。</p></blockquote><p>第二个问题， Typescript 提供了诸如 lib.d.ts 等类型库文件。随着 ES 的不断更新， JavaScript 类型和全局变量会逐渐变多。Typescript 也是采用这种 lib 的方式来解决的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghmyjgyd7qj307o0lxgmq.jpg" alt></p><p>（TypeScript 提供的部分 lib）</p><p>第三个问题，Typescript 主要是通过 interface，type，函数类型等打通<strong>类型空间</strong>，通过 declare 等打通<strong>值空间</strong>，并结合 binder 来进行类型诊断。关于 checker ，binder 是如何运作的，可以参考我第一篇的介绍。</p><p>接下来，我们介绍类型系统的功能，即它能为我们带来什么。如果上面的内容你已经懂了，那么接下来的内容会让你感到”你也不过如此嘛“。</p><h2 id="类型系统的主要功能"><a href="#类型系统的主要功能" class="headerlink" title="类型系统的主要功能"></a>类型系统的主要功能</h2><ol><li>定义类型以及其上的属性和方法。</li></ol><p>比如定义 String 类型， 以及其原型上的方法和属性。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghsqk1u3x8j31d60u0q9u.jpg" alt></p><p>length， includes 以及 toString 是 String 的<strong>成员变量</strong>， 生活在值空间， 值空间虽然不能直接和类型空间接触，但是类型空间可以作用在值空间，从而给其添加类型（如上图黄色部分）。</p><ol start="2"><li>提供自定义类型的能力</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  say(name: <span class="built_in">string</span>): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是我自定义的类型 User，这是 Typescript 必须提供的能力。</p><ol start="3"><li>类型兼容体系。</li></ol><p>这个主要是用来判断类型是否正确的，上面我已经提过了，这里就不赘述了。</p><ol start="4"><li>类型推导</li></ol><p>有时候你不需要显式说明类型（类型注解），Typescript 也能知道他的类型，这就是类型推导结果。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如上代码，编译器会自动推导出 a 的类型 为 number。还可以有连锁推导，泛型的入参（泛型的入参是类型）推导等。类型推导还有一个特别有用的地方，就是用到类型收敛。</p><p>接下来我们详细了解下类型推导和类型收敛。</p><h2 id="类型推导和类型收敛"><a href="#类型推导和类型收敛" class="headerlink" title="类型推导和类型收敛"></a>类型推导和类型收敛</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如上代码。 Typescript 会推导出 a 的类型为 number。</p><p>如果只会你这么写就会报错：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"1"</span>;</span><br></pre></td></tr></table></figure><p>因此 string 类型的值不能赋值给 number 类型的变量。我们可以使用 Typescript 内置的 typeof 关键字来证明一下。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">type</span> A = <span class="keyword">typeof</span> a;</span><br></pre></td></tr></table></figure><p>此时 A 的类型就是 number，证明了变量 a 的类型确实被隐式推导成了 number 类型。</p><p>有意思的是如果 a 使用 const 声明，那么 a 不会被推导为 number，而是推导为类型 1。即<strong>值只能为 1 的类型</strong>，这就是类型收敛。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">type</span> A = <span class="keyword">typeof</span> a;</span><br></pre></td></tr></table></figure><blockquote><p>通过 const ，我们将 number 类型收缩到了 <strong>值只能为 1 的类型</strong>。</p></blockquote><p>实际情况的类型推导和类型收敛要远比这个复杂， 但是做的事情都是一致的。</p><p>比如这个：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> A = ReturnType&lt;<span class="keyword">typeof</span> test&gt;;</span><br></pre></td></tr></table></figure><p>A 就是 number 类型。 也就是 Typescript 知道两个 number 相加结果也是一个 number。因此即使你不显示地注明返回值是 number， Typescript 也能猜到。<strong>这也是为什么 JavaScript 项目不接入 Typescript 也可以获得类型提示的原因之一</strong>。</p><p>除了 const 可以收缩类型， typeof， instanceof 都也可以。 原因很简单，就是<strong>Typescript 在这个时候可以 100% 确定你的类型了</strong>。 我来解释一下：</p><p>比如上面的 const ，由于你是用 const 声明的，因此 100% 不会变，一定永远是 1，因此类型可以收缩为 1。 再比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span> | <span class="built_in">string</span> = <span class="number">1</span>;</span><br><span class="line">a = <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">"string"</span>) &#123;</span><br><span class="line">  a.includes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if 语句内 a 100% 是 string ，不能是 number。因此 if 语句内类型会被收缩为 string。instanceof 也是类似，原理一模一样。大家只要记住<strong>Typescript 如果可以 100% 确定你的类型，并且这个类型要比你定义的或者 Typescript 自动推导的范围更小，那么就会发生类型收缩</strong>就行了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要讲了 Typescript 的类型系统。 Typescript 和 JavaScript 的类型是很不一样的。从表面上来看， TypeScript 的类型是 JavaScript 类型的超集。但是从更深层次上来说，两者的本质是不一样的，一个是值的类型，一个是变量的类型。</p><p>Typescript 空间分为值空间和类型空间。两个空间不互通，因此值不能当成类型，类型不能当成值，并且值和类型不能做运算等。不过 TypeScript 可以将两者结合起来用，这个能力只有 TypeScript 有， 作为 TypeScript 的开发者的你没有这个能力，这个我在第一节也简单介绍了。</p><p>TypeScript 既会对变量存在与否进行检查，也会对变量类型进行兼容检查。因此 TypeScript 就需要定义一系列的类型，以及类型之间的兼容关系。默认情况，TypeScript 是没有任何类型和变量的，因此你使用 String 等都会报错。TypeScript 使用库文件来解决这个问题，最经典的就是 lib.d.ts。</p><p>TypeScript 已经做到了足够智能了，以至于你不需要写类型，它也能猜出来，这就是类型推导和类型收缩。当然 TypeScript 也有一些功能，我们觉得应该有，并且也是可以做到的功能空缺。但是我相信随着 TypeScript 的逐步迭代（截止本文发布，TypeScript 刚刚发布了 4.0.0 的 beta 版本），一定会越来越完善，用着越来越舒服的。</p><p>我们每个项目的需要是不一样的， 简单的基本类型肯定无法满足多样的项目需求，因此我们必须支持自定义类型，比如 interface， type 以及复杂一点的泛型。当然泛型很大程度上是为了减少样板代码而生的，和 interface ， type 这种刚需不太一样。</p><p>有了各种各样的类型以及类型上的成员变量，以及成员变量的类型，再就加上类型的兼容关系，我们就可以做类型检查了，这就是 TypeScript 类型检查的基础。TypeScript 内部需要维护这样的一个关系，并对变量进行类型绑定，从而给开发者提供<strong>类型分析</strong>服务。</p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的前端硬核文章，带你认识你不知道的前端。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxro1x125j30oz0dw43s.jpg" alt></p><p>公众号【 <a href="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" target="_blank" rel="noopener">力扣加加</a>】<br>知乎专栏【 <a href="https://www.zhihu.com/people/lu-xiao-13-70" target="_blank" rel="noopener">Lucifer - 知乎</a>】</p><p>点关注，不迷路！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提前批算法工程师面试之路</title>
      <link href="/blog/2020/08/13/interview-log-tqp/"/>
      <url>/blog/2020/08/13/interview-log-tqp/</url>
      
        <content type="html"><![CDATA[<ul><li>作者：宝石</li><li>校对&amp;整理：lucifer</li></ul><a id="more"></a><h2 id="vivo（已拿-offer）"><a href="#vivo（已拿-offer）" class="headerlink" title="vivo（已拿 offer）"></a>vivo（已拿 offer）</h2><h3 id="技术面（30min）"><a href="#技术面（30min）" class="headerlink" title="技术面（30min）"></a>技术面（30min）</h3><ul><li>自我介绍</li><li>讲实习</li><li>讲比赛</li><li>问了些大数据的问题</li><li>spark transform 和 action 的区别</li><li>手撕了个归并排序</li></ul><h3 id="hr-面（30min，技术只有一面）"><a href="#hr-面（30min，技术只有一面）" class="headerlink" title="hr 面（30min，技术只有一面）"></a>hr 面（30min，技术只有一面）</h3><ul><li>自我介绍</li><li>家庭情况</li><li>讲一下实习亮点</li><li>有女朋友么</li><li>父母同意你去深圳么</li><li>讲一下优缺点</li><li>常规问题等等</li></ul><h2 id="昆仑万维（已拿-offer）"><a href="#昆仑万维（已拿-offer）" class="headerlink" title="昆仑万维（已拿 offer）"></a>昆仑万维（已拿 offer）</h2><h3 id="一面（1h-："><a href="#一面（1h-：" class="headerlink" title="一面（1h)："></a>一面（1h)：</h3><ul><li>上来自我介绍</li><li>讲一下判断回文链表的思路,多方法</li><li>用纸写一下反转链表</li><li>说说 python shuffle 怎么实现的，O(N)时间,O(1)空间</li><li>看你计算机专业，知道哈夫曼树吧，w2v 有用，你能说说么（我就记得分层 softmax 了，实在是不会）</li><li>说说传统机器学习你都了解哪些？推一下 LR，说一下原理</li><li>知道 kmeans 吧，说下迭代过程，簇心随机不好，怎么才能更稳定（类 kmeans++）</li><li>说说深度学习你都知道哪些模型？我说了 LSTM RNN，还没等说推荐的模型。。。</li><li>讲一下 LSTM 吧，门都是怎么迭代的</li><li>各个激活函数的优缺点，sigmoid relu leaklyrelu tanh，又说了下梯度消失</li><li>Sigmoid 求导是什么？</li><li>了解推荐么，说说都知道啥，嘴贱说了个 CF</li><li>讲一下 Item-CF，怎么计算相似度（用交并，也就是 Jaccard 距离，速度比 cos 快），用什么优化呢（倒排索引）</li><li>讲讲数据倾斜怎么处理吧？（用 key+随机前后缀）</li><li>聊一下你这个项目里 LDA 吧？我直接说这个我用过没细研究（他也认同，说数学原理很复杂）</li><li>聊一下你这个项目 query title 统计特征都提了啥，跟他聊了一下，他和我说了一下他的业务理解</li><li>反问</li><li>做什么的（啥都做，业务很广。。。）</li><li>用哪些技术（啥都用，技术栈很广。。。）</li></ul><h3 id="昆仑万维二面（就是确认时间-不算面试）"><a href="#昆仑万维二面（就是确认时间-不算面试）" class="headerlink" title="昆仑万维二面（就是确认时间 不算面试）"></a>昆仑万维二面（就是确认时间 不算面试）</h3><ul><li>和一面面试官聊的如何</li><li>知道他们部门做什么的么</li><li>接下来约一下 boss 面，确认时间</li><li>结束</li></ul><h3 id="昆仑万维三面（不到二十分钟，压力面）："><a href="#昆仑万维三面（不到二十分钟，压力面）：" class="headerlink" title="昆仑万维三面（不到二十分钟，压力面）："></a>昆仑万维三面（不到二十分钟，压力面）：</h3><ul><li>上来就问比赛，两个比赛都问了，和第一差距在哪</li><li>下面问题都是快问快答，都没深问，问题可能记不全了：</li><li>说下你实习吧，没说几句。。</li><li>你怎么解决样本不均衡的</li><li>kmeans 适用于什么情况</li><li>python dict 怎么用</li><li>为什么会产生哈希冲突</li><li>python set dict list 啥场景用</li><li>过拟合有哪些解决方法</li><li>牛顿法和拟牛顿法</li><li>200w 不重复单词一口气放内存中，怎么放最省内存（不会）</li><li>你除了学习之外还做什么项目</li><li>平常刷算法题么，刷多少了</li><li>另一个面试官的问题不是压力测试</li><li>你希望做什么种类的工作（大概就是这个意思）</li><li>没得反问</li></ul><h2 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h2><h3 id="一面（40min"><a href="#一面（40min" class="headerlink" title="一面（40min)"></a>一面（40min)</h3><blockquote><p>很好的年轻女面试官</p></blockquote><ul><li>自我介绍</li><li>跟我聊了一下，然后说看你挺直率，我就直接说了，你想找推荐，我们是机器学习+组合优化，偏向运筹学，考虑么，（我说只要不是 cvnlp，我全要）</li><li>考虑那就开始问些问题吧：</li><li>你讲讲你的实习，最亮点，给他分析了一波我采样策略。</li><li>你知道 gbdt 和 xgboost 吧，给我讲讲（疯狂吹逼 xgboost）</li><li>你知道最大似然估计和最大后验概率估计么，或者挑一个你熟悉的说下（闭着眼睛推 LR，啥伯努利分布，似然函数，疯狂扯）</li><li>来做个题吧，1000w 个数，数范围[-1000, 1000]，写个排序（闭着眼睛桶排）</li><li>你能提前来实习么</li><li>反问（京东零售部的，技术栈 balabala）</li><li>复试待安排</li></ul><h3 id="二面（30min）"><a href="#二面（30min）" class="headerlink" title="二面（30min）"></a>二面（30min）</h3><ul><li>自我介绍</li><li>找个比赛说说创新点，你主要做了哪些创新，最后模型为什么用 CNN 系不用 RNN 系</li><li>由于上面我说我工作有训练词向量了，让我讲 word2vec 的架构，和一些细节问题</li><li>为什么 w2v 向量在语义空间内有很好的数学性质，比如相加减</li><li>数学问题：M 个样本有放回采样 N 次，问某条样本一次没被采中概率</li><li>给你均值方差，让你利用正态分布随机生成 1000 个点（不能用库，说的不是很好）</li><li>反问：哪个部门哪个组（零售-技术中台下）</li><li>为什么选择京东，京东有什么核心竞争力（疯狂扯，我说我不太看好那些不能落地的，因为 jd 是电商，整个算法流程系统化工程化一定很健全，也有实际落地，带来实际效益，面试官非常赞同）</li><li>最后手里有啥 offer 啊</li><li>没了</li></ul><h3 id="hr-面（20min）"><a href="#hr-面（20min）" class="headerlink" title="hr 面（20min）"></a>hr 面（20min）</h3><ul><li>小姐姐人很好，迟到了四分钟，上来道歉一波</li><li>自我介绍</li><li>遇到压力大的时候，比如在实习问题解决不了了，你会怎么办</li><li>与 mentor 产生意见分歧要怎么做</li><li>未来如果入职京东，对领导有什么要求呢</li><li>你平常有什么学习习惯么</li><li>你平常会定期做总结么</li><li>反问<ul><li>当时问应届生入职需要做出啥改变，给小姐姐问懵了，我又补充说比如思想啥的需要有啥改变么，她给我讲了五六分钟，说的很直白，没啥官腔，说在学校如何如何，你来公司了又会如何如何</li><li>啥时候有结果：她也不知道，她拿到的是乱序的面试名单，可能后面会统一安排通知</li></ul></li></ul><h2 id="一点资讯"><a href="#一点资讯" class="headerlink" title="一点资讯"></a>一点资讯</h2><h3 id="一面（不到-40min）"><a href="#一面（不到-40min）" class="headerlink" title="一面（不到 40min）"></a>一面（不到 40min）</h3><ul><li>自我介绍</li><li>讲你的论文，这块一直问，问得特别细节，也问了好久，估计面试官比较清楚这块东西。</li><li>讲实习，都怎么做的，遇到啥问题，怎么解决。</li><li>讲一下 FM，DeepFM 这一系列（我从 LR，POLY2，FM，FFM，Wide&amp;Deep，DeepFm 说了个遍）</li><li>做了个算法题，A 了</li><li>反问：</li><li>部门：算法部信息流，和我微博实习的比较类似</li><li>技术：做推荐 Java 和 Scala 用的多一些</li><li>个人感觉像不招人。。。</li></ul><h2 id="大华"><a href="#大华" class="headerlink" title="大华"></a>大华</h2><h3 id="一面-大数据工程师（数据挖掘）（不到-40min）"><a href="#一面-大数据工程师（数据挖掘）（不到-40min）" class="headerlink" title="一面 - 大数据工程师（数据挖掘）（不到 40min）"></a>一面 - 大数据工程师（数据挖掘）（不到 40min）</h3><ul><li>面试官很有礼貌</li><li>自我介绍</li><li>着重问了好久实习</li><li>着重问了好久比赛</li><li>linux 查指定文件前缀有哪些命令</li><li>讲一下 hive 和 hadoop 关系</li><li>hadoop mapreduce 执行流程</li><li>java 类和对象关系</li></ul><h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><h3 id="一面（1h）"><a href="#一面（1h）" class="headerlink" title="一面（1h）"></a>一面（1h）</h3><ul><li>自我介绍</li><li>介绍实习，然后疯狂挖实习，问的很深</li><li>问如果模型区分不开一些样本，要怎么采样？业界有哪些常用采样策略。我真是懵了。。</li><li>问了一堆 fm，比如表达式，复杂度，改进复杂度的推导</li><li>了解深度学习么，从 wide&amp;deep 出发疯狂问，有的是真不会，要再复习一下</li><li>面试官说了个 DCN（深度交叉网络）,我还以为深度卷积神经网络。。。，结果深度交叉网络的细节也给忘了</li><li>我主动给介绍了下阿里的 DIN 和 DIEN，他问这模型可以用在新闻推荐场景么（答不可以，因为新闻类实时性比较强 balabala。。。不知道对不对）</li><li>如果想让你加入一个用户短期兴趣，比如刚发布的新闻打分低，要怎么改，（我记得在 YouTube 有个说了关于这个，我说加了个时间维度特征，或者时间衰减）</li><li>让我讲 BN，为什么提出 BN（好久没看 nn 的东西了，直说了个表象，容易收敛，面试官说为了解决输入分布不一致，bn 可以拉回来分布，我把这个忘了）</li><li>从 LR 出发问了我 sgd，如何改进，说了个 momentum，再怎么改进，我说我了解个 FTRL</li><li>说一下 boosting bagging ，lgb 为什么并行化效率高（答单边梯度抽样+直方图计算+互斥特征捆绑）</li><li>怎么分析并解过拟合问题的</li><li>算法题：三数之和</li><li>反问<ul><li>部门是推荐策略部</li><li>主要场景是百度直播和贴吧推荐</li><li>用 Python 和 C++，不用 Java</li></ul></li></ul><h2 id="触宝"><a href="#触宝" class="headerlink" title="触宝"></a>触宝</h2><h3 id="一面（1h）-1"><a href="#一面（1h）-1" class="headerlink" title="一面（1h）"></a>一面（1h）</h3><ul><li><p>自我介绍</p></li><li><p>数据结构基础</p><ul><li>数组和链表区别，应用场景</li><li>疯狂问排序算法，最优最坏平均复杂度，稳定排序有哪些（好长时间没复习这个了，答得比较差）</li><li>一个剪枝题，口述算法过程，分析时空复杂度</li><li>说说面向过程、对象、切片编程的区别（我。。。。。。）</li></ul></li><li><p>机器学习基础</p><ul><li>讲一下你了解哪些分类模型</li><li>说说 SVM</li><li>讲讲 id3 和 c4.5</li><li>讲讲 xgboost 和 gbdt</li><li>讲讲怎么判断 kmeans 的 k，聚类效果的好坏<ul><li>k 可以用肘部法则 SSE（误差平方和）和轮廓系数</li></ul></li><li>讲讲分类，回归，推荐，搜索的评价指标</li><li>讲讲 lr 和 fm，fm 的后续（ffm）</li><li>讲讲你知道的各种损失函数</li><li>讲讲 l1 l2 正则，各自的特点</li></ul></li><li><p>深度学习基础</p><ul><li>说说 deepfm，说说 fm 在 nn 中还有哪些（FNN，NFM，AFM）</li><li>说说类似 l1,l2 正则化降低模型过拟合，还有什么别的方法</li><li>说一下 sgd→adam 的过程（下面是面试后简单复盘，本身答的一般）<ul><li>sgd</li><li>momentum 利用了历史信息，意味着参数更新方向不仅由当前的梯度决定，也与此前累积的下降方向有关。这使得参数中那些梯度方向变化不大的维度可以加速更新，并减少梯度方向变化较大的维度上的更新幅度。由此产生了加速收敛和减小震荡的效果。</li><li>rmsprop 在 Adagrad 中， 问题是学习率逐渐递减至 0，可能导致训练过程提前结束。为了改进这一缺点，可以考虑在计算二阶动量时不累积全部历史梯度，而只关注最近某一时间窗口内的下降梯度。根据此思想有了 RMSprop，采用的指数移动平均公式计算</li><li>adam 可以认为是 RMSprop 和 Momentum 结合并加了偏差校正，因为初始化是 0，有一个向初值的偏移（过多的偏向了 0）。因此，可以对一阶和二阶动量做偏置校正 (bias correction)，</li></ul></li><li>介绍下梯度消失和梯度爆炸</li><li>都有哪些方法解决这两个问题</li><li>你了解多目标优化，迁移学习么（不知道）</li></ul></li><li><p>场景问题</p><ul><li>让你加一个兴趣类型特征 你要怎么做</li><li>如何处理年龄类特征</li><li>你了解相似向量快速计算的方法吗（就记得个啥哈希分桶，没做过）<ul><li>局部哈希计算，高维相近的点低维也相近，但是高维较远的点低维可能也相近，将 embedding 应设成 1 维，若担心把远的也算进来可以多设置几个 hash 函数等等。</li></ul></li><li>如何判断你模型上线的好坏</li><li>给你个 nn 模型，如何调参，如何修改架构</li><li>如何解决冷启动问题 用户侧，物品侧</li><li>推荐系统的整体架构</li><li>线上推断这部分再具体点怎么实现的</li></ul></li><li><p>反问</p><ul><li>触宝内容推荐（小说）</li><li>主要用 python</li><li>等后续 hr 通知吧</li></ul></li></ul><h3 id="二面（45min）"><a href="#二面（45min）" class="headerlink" title="二面（45min）"></a>二面（45min）</h3><blockquote><p>面试官人很好，和善可亲</p></blockquote><ul><li>自我介绍</li><li>讲下实习做了哪些优化，问了些问题（我都没介绍实习，面试官已经直接点破我每一点实际都在做什么）</li><li>讨论了一下抽样，作为一个算法工程师如何将抽样导致的得分分布变化给拉回来？</li><li>因为实习模型是 FM，详细讲了下 FM，讨论了下 FM 的泛化性</li><li>用的什么优化算法，顺便介绍下 sgd 后续的优化，sgd→momentun→rmsprop→adam，一面问过的，复盘过</li><li>实习有没有除错过导致线上有点问题（还真有。。。）</li><li>hadoop shuffle 干啥的，为啥 key 相同的要放在一起</li><li>python 深拷贝和浅拷贝的区别</li><li>linux 替换文件中所有的 a，我说的 awk 或者 tr</li><li>算法题：给两个字符串 S 和 T，计算 S 的子序列中 T 出现的次数（dfs A 了）</li><li>反问：竟然和一面面试官不是一个部门。。。二面面试官给我介绍了算法在他们公司都有哪些应用。。。</li><li>总之要有工程师顶层思维，不能局限于模型优化啥的。</li></ul><p>大家可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 35K star 啦。</p><p>关注公众号力扣加加，努力用清晰直白的语言还原解题思路，并且有大量图解，手把手教你识别套路，高效刷题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面经 </category>
          
          <category> 校招 </category>
          
          <category> 百度 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面经 </tag>
            
            <tag> 校招 </tag>
            
            <tag> 百度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webkit 内核初探</title>
      <link href="/blog/2020/08/11/webkit-intro/"/>
      <url>/blog/2020/08/11/webkit-intro/</url>
      
        <content type="html"><![CDATA[<p>作者: 阿吉<br>校对&amp;整理: lucifer</p><p>当下浏览器内核主要有 Webkit、Blink 等。本文分析注意是自 2001 年 Webkit 从 KHTML 分离出去并开源后，各大浏览器厂商魔改 Webkit 的时期，这些魔改的内核最终以 Chromium 受众最多而脱颖而出。本文就以 Chromium 浏览器架构为基础，逐层探入进行剖析。</p><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>这里以一个面试中最常见的题目<code>从 URL 输入到浏览器渲染页面发生了什么？</code>开始。</p><p>这个很常见的题目，涉及的知识非常广泛。大家可先从浏览器监听用户输入开始，浏览器解析 url 的部分，分析出应用层协议 是 HTTPS 还是 HTTP 来决定是否经过会话层 TLS 套接字，然后到 DNS 解析获取 IP，建立 TCP 套接字池 以及 TCP 三次握手，数据封装切片的过程，浏览器发送请求获取对应数据，如何解析 HTML，四次挥手等等等等。 这个回答理论上可以非常详细，远比我提到的多得多。</p><p>本文试图从浏览器获取资源开始探究 Webkit。如浏览器如何获取资源，获取资源时 Webkit 调用了哪些资源加载器（不同的资源使用不同的加载器），Webkit 如何解析 HTML 等入手。想要从前端工程师的角度弄明白这些问题，可以先暂时抛开 C++源码，从浏览器架构出发，做到大致了解。之后学有余力的同学再去深入研究各个底层细节。</p><p>本文的路线循序渐进，从 Chromium 浏览器架构出发，到 Webkit 资源下载时对应的浏览器获取对应资源如 HTML、CSS 等，再到 HTML 的解析，再到 JS 阻塞 DOM 解析而产生的 Webkit 优化 引出浏览器多线程架构，继而出于安全性和稳定性的考虑引出浏览器多进程架构。</p><h2 id="一-Chromium-浏览器架构"><a href="#一-Chromium-浏览器架构" class="headerlink" title="一. Chromium 浏览器架构"></a>一. Chromium 浏览器架构</h2><p><img src="http://m.qpic.cn/psc?/V50vddMl0YvJ9c0IGUY913J7mG1rVs8G/bqQfVz5yrrGYSXMvKr.cqTMrUK10g4vRaHHV49*HvW0FoJTS4c2bz3tSzUqnlZb.vVmuaQiNqi3bk24Ey1ONmRFcv3mSLTbCQZ07nedhD9M!/b&bo=qAMaBAAAAAADB5c!&rf=viewer_4" alt="Chromium浏览器架构"></p><p>（Chromium 浏览器架构）</p><p>我们通常说的浏览器内核，指的是渲染引擎。</p><p>WebCore 基本是共享的，只是在不同浏览器中使用 Webkit 的实现方式不同。它包含解析 HTML 生成 DOM、解析 CSS、渲染布局、资源加载器等等，用于加载和渲染网页。</p><p>JS 解析可以使用 JSCore 或 V8 等 JS 引擎。我们熟悉的谷歌浏览器就是使用 V8。比如比较常见的有内置属性 <code>[[scope]]</code> 就仅在 V8 内部使用，用于对象根据其向上索引自身不存在的属性。而对外暴露的 API，如 <code>__proto__</code> 也可用于更改原型链。实际上 <code>__proto__</code> 并不是 ES 标准提供的，它是浏览器提供的（浏览器可以不提供，因此如果有浏览器不提供的话这也并不是 b ug）。</p><p>Webkit Ports 是不共享的部分。它包含视频、音频、图片解码、硬件加速、网络栈等等，常用于移植。</p><p>同时，浏览器是多进程多线程架构，稍后也会细入。</p><p>在解析 HTML 文档之前，需要先获取资源，那么资源的获取在 Webkit 中应该如何进行呢？</p><h2 id="二-Webkit-资源加载"><a href="#二-Webkit-资源加载" class="headerlink" title="二.Webkit 资源加载"></a>二.Webkit 资源加载</h2><p>HTTP 是超文本传输协议，超文本的含义即包含了文本、图片、视频、音频等等。其对应的不同文件格式，在 Webkit 中 需要调用不同的资源加载器，即 特定资源加载器。</p><p>而浏览器有四级缓存，Disk Cache 是我们最常说的通过 HTTP Header 去控制的，比如强缓存、协商缓存。同时也有浏览器自带的启发式缓存。而 Webkit 对应使用的加载器是资源缓存机制的资源加载器 <code>CachedResoureLoader</code> 类。</p><p>如果每个资源加载器都实现自己的加载方法，则浪费内存空间，同时违背了单一职责的原则，因此可以抽象出一个共享类，即通用资源加载器 <code>ResoureLoader</code> 类。 Webkit 资源加载是使用了三类加载器：<strong>特定资源加载器，资源缓存机制的资源加载器 CachedResoureLoader 和 通用资源加载器 ResoureLoader</strong>。</p><p>既然说到了缓存，那不妨多谈一点。</p><p>资源既然缓存了，那是如何命中的呢？答案是根据资源唯一性的特征 URL。资源存储是有一定有效期的，而这个有效期在 Webkit 中采用的就是 LRU 算法。那什么时候更新缓存呢？答案是不同的缓存类型对应不同的缓存策略。我们知道缓存多数是利用 HTTP 协议减少网络负载的，即强缓存、协商缓存。但是如果关闭缓存了呢？ 比如 HTTP/1.0 Pragma:no-cache 和 HTTP/1.1 Cache-Control: no-cache。此时，对于 Webkit 来说，它会清空全局唯一的对象 MemoryCache 中的所有资源。</p><p>资源加载器内容先到这里。浏览器架构是多进程多线程的，其实多线程可以直接体现在资源加载的过程中，在 JS 阻塞 DOM 解析中发挥作用，下面我们详细讲解一下。</p><h2 id="三-浏览器架构"><a href="#三-浏览器架构" class="headerlink" title="三.浏览器架构"></a>三.浏览器架构</h2><p>浏览器是多进程多线程架构。</p><p>对于浏览器来讲，从网络获取资源是非常耗时的。从资源是否阻塞渲染的角度，对浏览器而言资源仅分为两类：<strong>阻塞渲染</strong>如 JS 和 <strong>不阻塞渲染</strong>如图片。</p><p>我们都知道 JS 阻塞 DOM 解析，反之亦然。然而对于阻塞，Webkit 不会傻傻等着浪费时间，它在内部做了优化：启动另一个线程，去遍历后续的 HTML 文档，收集需要的资源 URL，并发下载资源。最常见的比如<code>&lt;script async&gt;</code>和<code>&lt;script defer&gt;</code>，其 JS 资源下载和 DOM 解析是并行的，JS 下载并不会阻塞 DOM 解析。这就是浏览器的多线程架构。</p><p><img src="http://a1.qpic.cn/psc?/V50vddMl0YvJ9c0IGUY913J7mG1rVs8G/bqQfVz5yrrGYSXMvKr.cqQYq655fTdqtV.7hiPLQGNK3lEmq2f9GXjc.RrNkpc2KrnPa34sYOqInvolRFQDCNcqbuGHTk4D5eqi6VWgzlNs!/c&ek=1&kp=1&pt=0&bo=EwMgAwAAAAADFwE!&tl=1&vuin=741183972&tm=1597122000&sce=60-2-2&rf=0-0" alt="JS async defer"></p><p>总结一下，多线程的好处就是，高响应度，UI 线程不会被耗时操作阻塞而完全阻塞浏览器进程。</p><p>关于多线程，有 GUI 渲染线程，负责解析 HTML、CSS、渲染和布局等等，调用 WebCore 的功能。JS 引擎线程，负责解析 JS 脚本，调用 JSCore 或 V8。我们都知道 JS 阻塞 DOM 解析，这是因为 Webkit 设计上 GUI 渲染线程和 JS 引擎线程的执行是互斥的。如果二者不互斥，假设 JS 引擎线程清空了 DOM 树，在 JS 引擎线程清空的过程中 GUI 渲染线程仍继续渲染页面，这就造成了资源的浪费。更严重的，还可能发生各种多线程问题，比如脏数据等。</p><p>另外我们常说的 JS 操作 DOM 消耗性能，其实有一部分指的就是 JS 引擎线程和 GUI 渲染线程之间的通信，线程之间比较消耗性能。</p><p>除此之外还有别的线程，比如事件触发线程，负责当一个事件被触发时将其添加到待处理队列的队尾。</p><p>值得注意的是，多启动的线程，仅仅是收集后续资源的 URL，线程并不会去下载资源。该线程会把下载的资源 URL 送给 Browser 进程，Browser 进程调用网络栈去下载对应的资源，返回资源交由 Renderer 进程进行渲染，Renderer 进程将最终的渲染结果返回 Browser 进程，由 Browser 进程进行最终呈现。这就是浏览器的多进程架构。</p><p>多进程加载资源的过程是如何的呢？我们上面说到的 HTML 文档在浏览器的渲染，是交由 Renderer 进程的。Renderer 进程在解析 HTML 的过程中，已搜集到所有的资源 URL，如 link CSS、Img src 等等。但出于安全性和效率的角度考虑，Renderer 进程并不能直接下载资源，它需要通过进程间通信将 URL 交由 Browser 进程，Browser 进程有权限调用 URLRequest 类从网络或本地获取资源。</p><blockquote><p>近年来，对于有的浏览器，网络栈由 Browser 进程中的一个模块，变成一个单独的进程。</p></blockquote><p>同时，多进程的好处远远不止安全这一项，即沙箱模型。还有单个网页或者第三方插件的崩溃，并不会影响到浏览器的稳定性。资源加载完成，对于 Webkit 而言，它需要调用 WebCore 对资源进行解析。那么我们先看下 HTML 的解析。之后我们再谈一下，对于浏览器来说，它拥有哪些进程呢？</p><h2 id="四-HTML-解析"><a href="#四-HTML-解析" class="headerlink" title="四.HTML 解析"></a>四.HTML 解析</h2><p>对于 Webkit 而言，将解析半结构化的 HTML 生成 DOM，但是对于 CSS 样式表的解析，严格意义 CSSOM 并不是树，而是一个映射表集合。我们可以通过 document.styleSheets 来获取样式表的有序集合来操作 CSSOM。对于 CSS，Webkit 也有对应的优化策略—ComputedStyle。ComputedStyle 就是如果多个元素的样式可以不经过计算就确认相等，那么就仅会进行一次样式计算，其余元素仅共享该 ComputedStyle。</p><p>共享 ComputedStyle 原则：</p><p>(1) TagName 和 Class 属性必须一样。</p><p>(2)不能有 Style。</p><p>(3)不能有 sibling selector。</p><p>(4)mappedAttribute 必须相等。</p><p>对于 DOM 和 CSSOM，大家说的合成的 render 树在 Webkit 而言是不存在的，在 Webkit 内部生成的是 RenderObject，在它的节点在创建的同时，会根据层次结构创建 RenderLayer 树，同时构建一个虚拟的绘图上下文，生成可视化图像。这四个内部表示结构会一直存在，直到网页被销毁。</p><p>RenderLayer 在浏览器控制台中 Layers 功能卡中可以看到当前网页的图层分层。图层涉及到显式和隐式，如 scale()、z-index 等。层的优点之一是只重绘当前层而不影响其他层，这也是 Webkit 做的优化之一。同时 V8 引擎也做了一些优化，比如说隐藏类、优化回退、内联缓存等等。</p><h2 id="五-浏览器进程"><a href="#五-浏览器进程" class="headerlink" title="五.浏览器进程"></a>五.浏览器进程</h2><p>浏览器进程包括 <strong>Browser 进程、Renderer 进程、GPU 进程、NPAPI 插件进程、Pepper 进程</strong>等等。下面让我们详细看看各大进程。</p><ul><li><p>Browser 进程：浏览器的主进程，有且仅有一个，它是进程祖先。负责页面的显示和管理、其他进程的管理。</p></li><li><p>Renderer 进程：网页的渲染进程，可有多个，和网页数量不一定是一一对应关系。它负责网页的渲染，Webkit 的渲染工作就是在这里完成的。</p></li><li><p>GPU 进程：最多一个。仅当 GPU 硬件加速被打开时创建。它负责 3D 绘制。</p></li><li><p>NPAPI 进程：为 NPAPI 类型的插件而创建。其创建的基本原则是每种类型的插件都只会被创建一次，仅当使用时被创建，可被共享。</p></li><li><p>Pepper 进程：同 NPAPI 进程，不同的是 它为 Pepper 插件而创建的进程。</p></li></ul><blockquote><p>注意：如果页面有 iframe，它会形成影子节点，会运行在单独的进程中。</p></blockquote><p>我们仅仅在围绕 Chromium 浏览器来说上述进程，因为在移动端，毕竟手机厂商很多，各大厂商对浏览器进程的支持也不一样。这其实也是我们最常见的 H5 兼容性问题，比如 IOS <code>margin-bottom</code> 失效等等。再比如 H5 使用 video 标签做直播，也在不同手机之间会存在问题。有的手机直播页面跳出主进程再回来，就会黑屏。</p><p>以 Chromium 的 Android 版为例子，不存在 GPU 进程，GPU 进程变成了 Browser 进程的线程。同时，Renderer 进程演变为服务进程，同时被限制了最大数量。</p><p>为了方便起见，我们以 PC 端谷歌浏览器为例子，打开任务管理器，查看当前浏览器中打开的网页及其进程。</p><p><img src="http://a1.qpic.cn/psc?/V50vddMl0YvJ9c0IGUY913J7mG1rVs8G/bqQfVz5yrrGYSXMvKr.cqbiyEougc0AL0QEl3PZdg8VoMc3IvtAbJcZAPdlr61RytWnxdKgGug9CJ1x5zgjBdRtUb1h3Ve5FOlicgiswBqg!/c&ek=1&kp=1&pt=0&bo=rQU4BAAAAAADN4Y!&tl=1&vuin=741183972&tm=1597118400&sce=60-2-2&rf=0-0" alt="打开浏览器任务管理器"></p><p>当前我打开了 14 个网页，不太好容易观察，但可以从下图中看到，只有一个 Browser 进程，即第 1 行。但是打开的网页对应的 Renderer 进程，并不一定是一个网页对应一个 Renderer 进程，这跟 Renderer 进程配置有关系。比如你看第 6、7 行是每个标签页创建独立 Renderer 进程，但是蓝色光标所在的第 8、9、10 行是共用一个 Renderer 进程，这属于为每个页面创建一个 Renderer 进程。因为第 9、10 行打开的页面是从第 8 行点击链接打开的。第 2 行的 GPU 进程也清晰可见，以及第 3、4、5 行的插件进程。</p><p><img src="http://a1.qpic.cn/psc?/V50vddMl0YvJ9c0IGUY913J7mG1rVs8G/bqQfVz5yrrGYSXMvKr.cqUONLiXR1HrQh.acB9iAV0PCQsnilSowX4VUd2fTJ1890e2KO4dg5OnmEryV3jxZP7N3ZkaTys7CU0rlYm3mHq8!/c&ek=1&kp=1&pt=0&bo=zAMYAwAAAAADJ9Y!&tl=1&vuin=741183972&tm=1597118400&sce=60-2-2&rf=0-0" alt="浏览器进程"></p><p>关于，Renderer 进程和打开的网页并不一定是一一对应的关系，下面我们详细说一下 Renderer 进程。当前只有四种多进程策略：</p><ol><li><p>Process-per-site-instance: 为每个页面单独创建一个进程，从某个网站打开的一系列网站都属于同一个进程。这是浏览器的默认项。上图中的蓝色光标就是这种情况。</p></li><li><p>Process-per-site：同一个域的页面共享一个进程。</p></li><li><p>Process-per-tab：为每个标签页创建一个独立的进程。比如上图第 6、7 行。</p></li><li><p>Single process：所有的渲染工作作为多个线程都在 Browser 进程中进行。这个基本不会用到的。</p></li></ol><p>Single process 突然让我联想到零几年的时候，那会 IE 应该还是单进程浏览器。单进程就是指所有的功能模块全部运行在一个进程，就类似于 Single process。那会玩 4399 如果一个网页卡死了，没响应，点关闭等一会，整个浏览器就崩溃了，得重新打开。所以多进程架构是有利于浏览器的稳定性的。虽然当下浏览器架构为多进程架构，但如果 Renderer 进程配置为 Process-per-site-instance，也可能会出现由于单个页面卡死而导致所有页面崩溃的情况。</p><p>故浏览器多进程架构综上所述，好处有三：</p><p>(1)单个网页的崩溃不会影响这个浏览器的稳定性。</p><p>(2)第三方插件的崩溃不会影响浏览器的稳定性。</p><p>(3)沙箱模型提供了安全保障。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Webkit 使用三类资源加载器去下载对应的资源，并存入缓存池中，对于 HTML 文档的解析，在阻塞时调用另一个线程去收集后续资源的 URL，将其发送给 Browser 进程，Browser 进程调用网络栈去下载对应的本地或网络资源，返回给 Renderer 进程进行渲染，Renderer 进程将最终渲染结果(一系列的合成帧)发送给 Browser 进程，Browser 进程将这些合成帧发送给 GPU 从而显示在屏幕上。<br>(文中有部分不严谨的地方，已由 lucifer 指出修改)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
          <category> 浏览器 </category>
          
          <category> webkit </category>
          
          <category> webkit </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> webkit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好未来-北京-视频面试</title>
      <link href="/blog/2020/08/09/interview-log-haoweilai/"/>
      <url>/blog/2020/08/09/interview-log-haoweilai/</url>
      
        <content type="html"><![CDATA[<ul><li>作者：阿吉</li><li>整理&amp;点评：lucifer</li></ul><a id="more"></a><h2 id="为什么要写这个面经？"><a href="#为什么要写这个面经？" class="headerlink" title="为什么要写这个面经？"></a>为什么要写这个面经？</h2><p>lucifer 说让我写一下秋招面经，但我很菜，一开始不想写的。最主要的是不想暴露自己的菜，虽然群佬都知道我比较菜。</p><p>lucifer 的群大概是我唯一一个每时每刻都能得到响应的群吧。很开心当时只是随便加了一下，但认识了好多大佬，经常在群里问一些很没头脑的问题，但总有人会艾特我回答，尽可能去触摸自己的知识边界帮我解答，大家都在交流（技术+扯皮）。</p><p>比较遗憾没偷学到 lucifer 的算法能力，也没能白嫖到小漾的美图。在 lucifer 群里开群语音，还有幸白嫖过川川(若川大佬)的声音 hhhhhh。大概我挺希望小漾看到这个文章能主动点晒照一下 hhhh（感觉第二天我就没了）。</p><h2 id="面试体验"><a href="#面试体验" class="headerlink" title="面试体验"></a>面试体验</h2><p>好未来的四位面试官给予的面试体验很舒服。四面面试官说话一直用“您”。四面面试快结束的时候：</p><ul><li><p>我：“我们的时间价值并不对等，所以很感谢您愿意抽时间面试我”</p></li><li><p>面试官：“不，我们的时间是对等的，我们今天只是在平等的交流”。</p></li></ul><p>好未来的面试体验可能是目前秋招面试最舒服的，因为平时喜欢看很多闲书（面试很少会问的那种），把那些知识都有机会和面试官进行了分享。</p><blockquote><p>面试官的问题用 Q 表示， 我的回答用 A 表示，序号表示第几个。 比如 Q5 表示面试官的第五个问题， A8 表示我对第八个问题的回答。</p></blockquote><h2 id="一面（男）"><a href="#一面（男）" class="headerlink" title="一面（男）"></a>一面（男）</h2><h3 id="面试内容"><a href="#面试内容" class="headerlink" title="面试内容"></a>面试内容</h3><ul><li>Q1: 聊项目，聊实习公司，问什么时候开始学前端</li><li>A1: 大二</li><li>Q2: 说一下排序算法。手撕冒泡，快排及其优化</li><li>A2: blabla</li></ul><blockquote><p>lucifer 小提示: 要可以手撕才行哦。</p></blockquote><ul><li><p>Q3: TCP 和 UDP 区别。TCP 为什么是可靠的？</p></li><li><p>A3: 《计网 自顶向下》，同时说了应用场景。</p></li><li><p>Q4: 三次握手，四次挥手</p></li><li><p>A4: 过程，字段，为何两次不行，各自作用。SYN 半连接攻击。</p></li><li><p>Q5: 谈一下 HTTP</p></li><li><p>A5:<br>详细说 HTTP 1.0 1.1 2 3<br>细说文本格式和二进制格式（这个很感谢 feiker 大表哥在群里说了下），以及 HPACK，应用层和传输层的队头阻塞，多路复用和多路分解<br>瞎扯了一下 302 303 307 在 RFC 规范中的发展历史，其实是跟浏览器大战年代相关的。</p></li><li><p>Q6: 浏览器缓存</p></li><li><p>A6:<br>四级：Service Work, Memory Cache, Disk Cache, Push Cache<br>HTTP 控制的缓存位于 Disk Cache，即强缓存和协商缓存。二者中间的启发式缓存。</p></li><li><p>Q7: CDN</p></li><li><p>A7: content dispatch newwork。 《计网 自顶向下》</p></li><li><p>Q8: 从 URL 到浏览器渲染，仅围绕 HTTP 相关展开</p></li><li><p>A8: 因为仅涉及 HTTP，除了常规回答，谈了下 webkit 里的三类资源加载器，以及网络栈。</p></li><li><p>Q9: 编译性语言 和 解释性语言的区别</p></li><li><p>A9: java，js。引申 JVM 和 V8。以及 V8 在早些年间拒绝采用中间码（《了不起的 nodejs》那本书比较老，里面就是无中间码），后来又采用了。其实最开始的原因就是考虑到移动端存储量。</p></li><li><p>Q10: 单线程的原因，好处</p></li><li><p>A10: JS 多线程对 DOM 的坏处。引申 webkit 多线程，看面试官比较感兴趣，又分析了浏览器的多进程架构，以及 Renderer 进程的四个配置项。</p></li></ul><h2 id="二面-男"><a href="#二面-男" class="headerlink" title="二面-男"></a>二面-男</h2><h3 id="面试内容-1"><a href="#面试内容-1" class="headerlink" title="面试内容"></a>面试内容</h3><ul><li>Q1: 聊项目，前端倒计时，IOS 兼容等</li><li>A1: …</li><li>Q2: 各种排序的时间复杂度</li><li>A2: …</li></ul><blockquote><p>lucifer 小提示: 不要死记硬背。</p></blockquote><ul><li>Q3: 手撕代码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tpl</span>(<span class="params">template, data</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line">tpl(<span class="string">'&lt;div class=&#123;%className%&#125;&gt;&#123;%name%&#125;&lt;/div&gt;'</span>, &#123;<span class="attr">className</span>:<span class="string">'hd'</span>, <span class="attr">name</span>:<span class="number">123</span>&#125;)</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hd"</span>&gt;<span class="number">123</span>&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 面试时编码思路：根据浏览器的词法分析去做，用stack。但存在问题。</span></span><br></pre></td></tr></table></figure><ul><li><p>A3:…</p></li><li><p>Q4: 看代码说输出，作用域</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a + a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  fn1();</span><br><span class="line">&#125;</span><br><span class="line">fn2();</span><br><span class="line"><span class="comment">// 扯了一下this指向，以及C++中作用域的_variable表默认添加。</span></span><br></pre></td></tr></table></figure><ul><li><p>A4: …</p></li><li><p>Q5: 你对闭包的理解</p></li><li><p>A5: 函数执行的保护机制。围绕函数执行机制（后来 lucifer 男神讲可以从词法作用域说，但毕竟是面试，感觉从函数执行来讲比较 ok），结合 V8 生成 AST 角度去谈何为闭包。具像为作用域链，及其 2 个表象。优缺点。理论应用：在 Vue 中的应用 Dep()，React 中的应用 Redux dispatch，设计模式中单例模式。项目应用：H5 前端自拟倒计时 destroyed 销毁引用。</p></li></ul><h2 id="三面-女"><a href="#三面-女" class="headerlink" title="三面-女"></a>三面-女</h2><h3 id="面试内容-2"><a href="#面试内容-2" class="headerlink" title="面试内容"></a>面试内容</h3><ul><li>Q1: 自我介绍</li><li>A1: 叫 AJ，来自 X，能干活。</li><li>Q2: 聊点你的学校经历吧</li><li>A2: 在校职务…</li><li>Q3: 为什么选择前端</li><li>A3: 经过大一尝试过 java,py,cnn 后决定，前端作为当下的生存技能。兴趣不局限于此。</li></ul><blockquote><p>lucifer 小提示: 不要把自己局限到前端。</p></blockquote><ul><li>Q4: 为什么不现在就去学后端</li><li>A4: 我明白自己每个阶段想要的是什么，当下秋招的我应该找一份匹配自己的工作。</li><li>Q5: 未来三年的职业规划</li><li>A5: 业务崽。</li><li>Q6: 实习公司，对比百度、腾讯、小米，最不喜欢哪一个？</li><li>A6: 从不同的层面去说最喜欢哪家。</li><li>Q7: 你觉得你的缺点有什么</li><li>A7: 不喜欢跟人争执，浪费时间且无趣。</li><li>Q8: 为什么会投我们公司，了解我们吗</li><li>A8: 很好的朋友在开课吧(然哥)，给我说好未来还挺不错的。秒投了。</li><li>Q9: 我们的业务有…你喜欢哪个业务啊</li><li>A10: 直播吧</li></ul><h2 id="四面-男"><a href="#四面-男" class="headerlink" title="四面-男"></a>四面-男</h2><h3 id="面试内容-3"><a href="#面试内容-3" class="headerlink" title="面试内容"></a>面试内容</h3><ul><li>Q1: Vue 那种左右界面，中间的竖线可以滑动，左右布局跟着变化，怎么去做优化，可以从哪些角度触发</li><li>A1: 不会。尝试从 Vue Object.freeze() 和 提升图层角度去说。</li><li>Q2: GPU 硬件加速渲染说下原理</li><li>A2: 不会。从 CSS3 触发的角度说了下。</li><li>Q3: HTTPS 性能损耗在哪里？</li><li>A3: TLS 握手。从《计算机网络 自顶向下》那本书里提的角度简单说了下。同时认为非对称加密算法对服务端资源消耗比较大。</li><li>Q4: 你如何去解决前端人员被需求压满，然后做业务觉得没有技术成长</li><li>A4: 不局限在功能点的开发，真正理解业务，理解业务流程中的数据流向以及坑点。当在当前环境遇到技术瓶颈要跳槽时，带着已有经验去下一个环境。</li><li>Q5. 谈谈 WebSocket，然后怎么去改造。</li><li>A5: 简单说了一点理论，直言没实践过。</li></ul><blockquote><p>lucifer 小提示: 可以自己实现一个 WebSocket 玩玩就啥都知道了。</p></blockquote><ul><li>Q6: 直播业务中，常用的协议是什么</li><li>A6: 仅知道 webRTC。</li><li>Q7: 海量数据找出最大的 K 个，怎么找？时间复杂度是多少？</li><li>A7: lucifer 之前的文章应该有过，没记牢固。简单说了下。</li></ul><blockquote><p>lucifer 小提示：我们只需要建立一个大小为 K 的小顶堆，N 个数分别入堆，最后堆顶的元素就是第 K 大的。 时间复杂度 $O(NlogK)$</p></blockquote><ul><li>Q8: 了解好未来吗？为什么要来？</li><li>A8: 做教育的。我哥推荐的。</li></ul><p>PS: 面试白菜起步。SP 面是四面。</p><h2 id="lucifer-点评"><a href="#lucifer-点评" class="headerlink" title="lucifer 点评"></a>lucifer 点评</h2><p>由于是校招的原因，整个面试过程比较注重的是基础知识以及思考和学习方式。并且可以看出侧重点依然是：</p><ul><li>网络（TCP，DNS，HTTP，HTTPS，浏览器缓存等）</li><li>浏览器渲染（GPU 硬件加速， webkit 原理等）</li><li>数据结构与算法（排序算法，复杂度分析，堆的应用等）</li></ul><p>对于每一个部分，我们首先要做的是建立大局观，这样即使错，也不会错到哪去。大局观建立好了，相当于基本的知识框架有了，接下来就是填充知识框架了。这个阶段最主要的就是巩固复习和查缺补漏。经过这样的一个学习，相信你也能够在面试中崭露头角，获得心仪的 offer。</p><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的前端硬核文章，带你认识你不知道的前端。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxro1x125j30oz0dw43s.jpg" alt></p><p>公众号【 <a href="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" target="_blank" rel="noopener">力扣加加</a>】<br>知乎专栏【 <a href="https://www.zhihu.com/people/lu-xiao-13-70" target="_blank" rel="noopener">Lucifer - 知乎</a>】</p><p>点关注，不迷路！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面经 </category>
          
          <category> 校招 </category>
          
          <category> 好未来 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面经 </tag>
            
            <tag> 校招 </tag>
            
            <tag> 好未来 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>上帝视角看 TypeScript</title>
      <link href="/blog/2020/08/04/ts-internal/"/>
      <url>/blog/2020/08/04/ts-internal/</url>
      
        <content type="html"><![CDATA[<p>TypeScript 的学习资料非常多，其中也不乏很多优秀的文章和教程。但是目前为止没有一个我特别满意的。原因有：</p><ul><li>它们大多数没有一个清晰的主线，而是按照 API 组织章节的，内容在<strong>逻辑上</strong>比较零散。</li><li>大多是“讲是什么，怎么用“，而不是”讲为什么，讲原理“。</li><li>大多数内容比较枯燥，趣味性比较低。都是干巴巴的文字，没有图片，缺乏能够引起强烈共鸣的例子。</li></ul><p>因此我的想法是做一套不同市面上大多数的 TypeScript 学习教程。以人类认知的角度思考问题，学习 TypeScript，通过通俗易懂的例子和图片来帮助大家建立 TypeScript 世界观。 而本篇文章则是这个系列的开篇。</p><p>系列安排：</p><ul><li>上帝视角看 TypeScript（就是本文）</li><li>TypeScript 类型系统</li><li>什么是 types？什么是 @types？</li><li>类型推导， 类型断言与类型保护</li><li><a href="https://lucifer.ren/blog/2020/06/16/ts-generics/">你不知道的 TypeScript 泛型（万字长文，建议收藏）</a>（已发布）</li><li>TypeScript 练习题</li><li>TypeScript 配置文件该怎么写？</li><li>TypeScript 是如何与 React，Vue，Webpack 集成的？</li></ul><blockquote><p>目录将来可能会有所调整。</p></blockquote><p>注意，我的系列文章基本不会讲 API，因此需要你有一定的 TypeScript 使用基础，推荐两个学习资料。</p><ul><li><a href="https://jkchao.github.io/typescript-book-chinese/" target="_blank" rel="noopener">深入理解 TypeScript</a></li><li><a href="https://www.typescriptlang.org/docs/home" target="_blank" rel="noopener">官方文档</a></li></ul><p>结合这两个资料和我的系列教程，掌握 TypeScript 指日可待。</p><p>接下来，我们通过几个方面来从宏观的角度来看一下 TypeScript。</p><a id="more"></a><h2 id="从输入输出上来看"><a href="#从输入输出上来看" class="headerlink" title="从输入输出上来看"></a>从输入输出上来看</h2><p>如果我们把 Typescript 编译器看成一个黑盒的话。其<strong>输入则是使用 TypeScript 语法书写的文本或者文本集合</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5l5pqyw1j304s04wwea.jpg" alt></p><p>（文本）</p><p>如果几个文本有引用关系，比如 a.ts 依赖 foo.ts 和 bar.ts，其就是一个文本集合。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5l7apwnnj30ho09f74h.jpg" alt></p><p>（文本集合）</p><p><strong>输出是编译之后的 JS 文件 和 .d.ts 的声明文件</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5ld0kfitj30ow0csdjs.jpg" alt></p><p>其中 JS 是将来需要运行的文件，而 .d.ts 声明文件则是 ts 文件中的类型声明，<strong>这个类型声明就是你在 ts 文件中声明的类型和 TypeScript 类型推导系统推导的类型</strong>。当然你也可以自己写 .d.ts 声明文件。</p><h2 id="从功能上来看"><a href="#从功能上来看" class="headerlink" title="从功能上来看"></a>从功能上来看</h2><p>从宏观的视角来看，TypeScript 的功能就是：</p><ul><li>提供了丰富的类型系统。</li></ul><p>最简单的就是 变量名:类型 = 值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">Number</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>除了这些基本类型，还提供了函数类型，复合类型等。</p><ul><li>提供了类型操作 API。TypeScript 不但提供内置类型，用户也可以利用集合操作和泛型对类型操作从而生成新的类型。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5lzqpqirj30d104ogml.jpg" alt></p><ul><li>对每一种类型的属性和方法都进行了定义。</li></ul><p>比如 String 类型有 toString 方法，但是没有 toFixed 方法，这就是 lib.d.ts 定义的。这样我在 String 类型的变量上使用 toFixed 方法就会报错，达到了“类型检查”的作用。</p><blockquote><p>小提示：lib.d.ts 的内容主要是一些变量声明（如：window、document、math）和一些类似的接口声明（如：Window、Document、Math）。 你可以通过 –noLib 来关闭这一功能</p></blockquote><ul><li>提供了模块系统（module，namespace）。</li><li>提供了更加方面的 API，比如 class（这在 ES6 class 出来之前尤其好用），装饰器等。</li><li>。。。</li></ul><h2 id="TypeScript-编译器是如何工作的？"><a href="#TypeScript-编译器是如何工作的？" class="headerlink" title="TypeScript 编译器是如何工作的？"></a>TypeScript 编译器是如何工作的？</h2><p>上面已经讨论了 TypeScript 编译器的输入和输出。那黑盒内部是怎么工作呢？这里我简单介绍一下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5nm8tmokj30dl02zq2s.jpg" alt></p><ul><li>TypeScript 文本首先会被解析为 <strong>token 流</strong>。这个过程比较简单，就是单纯地按照分隔符去分割文本即可。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5npflqbbj30eh0490sw.jpg" alt></p><ul><li>接着 token 流会被转换为 AST，也就是<strong>抽象语法树</strong>。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5nqa41bpj309106lt8z.jpg" alt></p><ul><li>binder 则根据 AST 信息生成 <strong>Symbol</strong>（TypeScript 中的一个数据结构）。拿上面的图来说，就是 number 节点。</li><li>当我们需要类型检查的时候， checker 会根据<strong>前面生成的 AST 和 symbols 生成类型检查结果</strong>。</li><li>当我们需要生成 JS 文件的时候，emitter 同样会根据<strong>前面生成的 AST 和 symbols 生成 JS 文件</strong>。</li></ul><p>完整图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh5nfcui6sj30xz0gendl.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，TypeScript 就是一门语言，和 Java，Python，C++ 等类似。只不过这门语言主要目标就是为了弥补 JavaScript 弱类型带来的问题的。因此设计语言的出发点就是：</p><ul><li>静态类型系统</li><li>可以编译成 JavaScript</li></ul><p>因此 TypeScript 是一门最终编译为 JavaScript 的语言（当然还有类型文件）。既然是一门语言，就涉及词法分析，语法分析等流程。由于相对 JavaScript 增加了很多功能， 其中最主要的就是类型系统。因此 TypeScript 的分析工作要比 JavaScript 更加复杂， 集中体现在 binder 和 checker 部分。</p><p>由于提供了静态类型， 因此就需要提供一些内置类型给我们用，比如 number，string，Array 等。但是这并不能满足我们的所有需求，我们需要自定义类型，因此有了 type，有了 interface 等。后来我们又发现自定义的类型重复代码太多， 要是类型也可以通过编程生成新的类型就好了，于是有了集合运算和泛型。</p><p>代码都放到一起不方便维护，要是可以放到不同文件，需要用的时候组装起来就好了，于是有了模块化。我用了别人的用 TypeScript 开发的库，如果也能有类型校验就好了，于是有了 types。</p><p>。。。</p><p>其实这些都是有因果关系的，如果你可以牢牢地掌握这些因果关系，那么学起来还不是易如反掌？</p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul><li><a href="https://jkchao.github.io/typescript-book-chinese/compiler/overview.html" target="_blank" rel="noopener">TypeScript 编译原理</a></li><li><a href="https://github.com/basarat/byots" target="_blank" rel="noopener">Bring your own TypeScript with more internal definitions</a></li><li><a href="https://github.com/microsoft/TypeScript/wiki/Compiler-Internals" target="_blank" rel="noopener">Compiler Internals</a></li><li><a href="https://github.com/azl397985856/fe-interview/issues/135" target="_blank" rel="noopener">TypeScript 编译器是用 TypeScript 写的，那是先有编译器还是 TS？</a></li></ul><h2 id="点关注，不迷路"><a href="#点关注，不迷路" class="headerlink" title="点关注，不迷路"></a>点关注，不迷路</h2><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的前端硬核文章，带你认识你不知道的前端。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxro1x125j30oz0dw43s.jpg" alt></p><p>公众号【 <a href="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" target="_blank" rel="noopener">力扣加加</a>】<br>知乎专栏【 <a href="https://www.zhihu.com/people/lu-xiao-13-70" target="_blank" rel="noopener">Lucifer - 知乎</a>】</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
          <category> 泛型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《我是你的妈妈呀》 - 第一期</title>
      <link href="/blog/2020/08/03/mother-01/"/>
      <url>/blog/2020/08/03/mother-01/</url>
      
        <content type="html"><![CDATA[<p>记得我初中的时候，学校发的一个小册子的名字就是母题啥的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghbhlyhaadj308c08c3yv.jpg" alt></p><p>大概意思是市面上的题（尤其是中考题）都是这些母题生的，都是它们的儿子。</p><p>熟悉我的朋友应该知道，我有一个风格：”喜欢用通俗易懂的语言以及图片，还原解题过程“。包括我是如何抽象的，如何与其他题目建立联系的等。比如：</p><ul><li><a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-6/" target="_blank" rel="noopener">一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～</a></li><li><a href="https://leetcode-cn.com/problems/wildcard-matching/solution/chao-ji-xiang-xi-ji-yi-hua-di-gui-tu-jie-dai-ni-yi/" target="_blank" rel="noopener">超级详细记忆化递归，图解，带你一次攻克三道 Hard 套路题（44. 通配符匹配）</a></li><li><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/chuan-shang-yi-fu-wo-jiu-bu-ren-shi-ni-liao-lai-3/" target="_blank" rel="noopener">穿上衣服我就不认识你了？来聊聊最长上升子序列</a></li><li><a href="https://leetcode-cn.com/problems/integer-break/solution/ba-yi-ba-zhe-chong-ti-de-wai-tao-343-zheng-shu-cha/" target="_blank" rel="noopener">扒一扒这种题的外套（343. 整数拆分）</a></li></ul><p>如果把这个思考过程称之为自顶向下的话，那么实际上能写出来取决于你：</p><ul><li>是否有良好的抽象能力</li><li>是否有足够的基础知识</li><li>是否能与学过的基础知识建立联系</li></ul><p>如果反着呢? 我先把所有抽象之后的纯粹的东西掌握，也就是母题。那么遇到新的题，我就往上套呗？这就是我在《LeetCode 题解仓库》中所说的<strong>只有熟练掌握基础的数据结构与算法，才能对复杂问题迎刃有余。</strong> 这种思路就是<strong>自底向上</strong>。（有点像动态规划?） 市面上的题那么多，但是题目类型就是那几种。甚至出题人出题的时候都是根据以前的题目变个条件，变个说法从而搞出一个“新”的题。</p><p>这个专题的目标就是从反的方向来，我们先学习和记忆底层的被抽象过的经典的题目。遇到新的题目，就往这些母题上套即可。</p><p>那让我们来自底向上看下第一期的这八道母题吧~</p><h2 id="母题-1"><a href="#母题-1" class="headerlink" title="母题 1"></a>母题 1</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个有序的非空数组 nums1 和 nums2，让你从每个数组中分别挑一个，使得二者差的绝对值最小。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>初始化 ans 为无限大</li><li>使用两个指针，一个指针指向数组 1，一个指针指向数组 2</li><li>比较两个指针指向的数字的大小，并更新较小的那个的指针，使其向后移动一位。更新的过程顺便计算 ans</li><li>最后返回 ans</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(nums1, nums2)</span>:</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    ans = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nums1) <span class="keyword">and</span> j &lt; len(nums2):</span><br><span class="line">        ans = min(ans, abs(nums1[i] - nums2[j]))</span><br><span class="line">        <span class="keyword">if</span>  nums1[i] &lt; nums2[j]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="母题-2"><a href="#母题-2" class="headerlink" title="母题 2"></a>母题 2</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个非空数组 nums1 和 nums2，让你从每个数组中分别挑一个，使得二者差的绝对值最小。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>数组没有说明是有序的，可以选择暴力。两两计算绝对值，返回最小的即可。</p><p>代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(nums1, nums2)</span>:</span></span><br><span class="line">    ans = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> num1 <span class="keyword">in</span> nums1:</span><br><span class="line">        <span class="keyword">for</span> num2 <span class="keyword">in</span> nums2:</span><br><span class="line">            ans = min(ans, abs(num1 - num2))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N ^ 2)$</li><li>空间复杂度：$O(1)$</li></ul><p>由于暴力的时间复杂度是 $O(N^2)$，因此其实也可以先排序将问题转换为母题 1，然后用母题 1 的解法求解。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(NlogN)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="母题-3"><a href="#母题-3" class="headerlink" title="母题 3"></a>母题 3</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你 k 个有序的非空数组，让你从每个数组中分别挑一个，使得二者差的绝对值最小。</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>继续使用母题 1 的思路，使用 k 个 指针即可。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(klogM)$，其中 M 为 k 个非空数组的长度的最小值。</li><li>空间复杂度：$O(1)$</li></ul><p>我们也可以使用堆来处理，代码更简单，逻辑更清晰。这里我们使用小顶堆，作用就是选出最小值。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    ans = float(<span class="string">'inf'</span>)</span><br><span class="line">    max_value = max(nums[<span class="number">0</span>] <span class="keyword">for</span> nums <span class="keyword">in</span> matrix)</span><br><span class="line">    heap = [(nums[<span class="number">0</span>], i, <span class="number">0</span>) <span class="keyword">for</span> i, nums <span class="keyword">in</span> enumerate(nums)]</span><br><span class="line">    heapq.heapify(heap)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        min_value, row, idx = heapq.heappop(heap)</span><br><span class="line">        <span class="keyword">if</span> max_value - min_value &lt; ans:</span><br><span class="line">            ans = max_value - min_value</span><br><span class="line">        <span class="keyword">if</span> idx == len(matrix[row]) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        max_value = max(max_value, matrix[row][idx + <span class="number">1</span>])</span><br><span class="line">        heapq.heappush(heap, (matrix[row][idx + <span class="number">1</span>], row, idx + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>建堆的时间和空间复杂度为 $O(k)$。</p><p>while 循环会执行 M 次 ，其中 M 为 k 个非空数组的长度的最小值。heappop 和 heappush 的时间复杂度都是 logk。因此 while 循环总的时间复杂度为 $O(Mlogk)$。</p><ul><li>时间复杂度：$O(max(Mlogk, k))$，其中 M 为 k 个非空数组的长度的最小值。</li><li>空间复杂度：$O(k)$</li></ul><h2 id="母题-4"><a href="#母题-4" class="headerlink" title="母题 4"></a>母题 4</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你 k 个非空数组，让你从每个数组中分别挑一个，使得二者差的绝对值最小。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>先排序，然后转换为母题 3</p><h2 id="母题-5"><a href="#母题-5" class="headerlink" title="母题 5"></a>母题 5</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个有序的非空数组 nums1 和 nums2，让你将两个数组合并，使得新的数组有序。</p><p>LeetCode 地址： <a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-sorted-array/</a></p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>和母题 1 类似。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(nums1, nums2)</span>:</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nums1) <span class="keyword">and</span> j &lt; len(nums2):</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &lt; nums2[j]:</span><br><span class="line">            ans.append(nums1[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans.append(nums2[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> nums1:</span><br><span class="line">        ans += nums2[j:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans += nums1[i:]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="母题-6"><a href="#母题-6" class="headerlink" title="母题 6"></a>母题 6</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你 k 个有序的非空数组 nums1 和 nums2，让你将 k 个数组合并，使得新的数组有序。</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>和母题 5 类似。 只不过不是两个，而是多个。我们继续套用堆的思路。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    ans = []</span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">        heap += row</span><br><span class="line">    heapq.heapify(heap)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        cur = heapq.heappop(heap)</span><br><span class="line">        ans.append(cur)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>建堆的时间和空间复杂度为 $O(N)$。</p><p>heappop 的时间复杂度为 $O(logN)$。</p><ul><li>时间复杂度：$O(NlogN)$，其中 N 是矩阵中的数字总数。</li><li>空间复杂度：$O(N)$，其中 N 是矩阵中的数字总数。</li></ul><h2 id="母题-7"><a href="#母题-7" class="headerlink" title="母题 7"></a>母题 7</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你两个有序的链表 root1 和 root2，让你将两个链表合并，使得新的链表有序。</p><p>LeetCode 地址：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>和母题 5 类似。 不同的地方在于数据结构从数组变成了链表，我们只需要注意链表的操作即可。</p><p>这里我使用了迭代和递归两种方式。</p><blockquote><p>大家可以把母题 5 使用递归写一下。</p></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$，其中 N 为两个链表中较短的那个的长度。</li><li>空间复杂度：$O(N)$，其中 N 为两个链表中较短的那个的长度。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        ans = cur = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">                cur.next = l1</span><br><span class="line">                cur = cur.next</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = l2</span><br><span class="line">                cur = cur.next</span><br><span class="line">                l2 = l2.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            cur.next = l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.next = l2</span><br><span class="line">        <span class="keyword">return</span> ans.next</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$，其中 N 为两个链表中较短的那个的长度。</li><li>空间复杂度：$O(1)$</li></ul><h2 id="母题-8"><a href="#母题-8" class="headerlink" title="母题 8"></a>母题 8</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>给你 k 个有序的链表，让你将 k 个链表合并，使得新的链表有序。</p><p>LeetCode 地址：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>和母题 7 类似，我们使用递归可以轻松解决。其实本质上就是</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(lists) == <span class="number">1</span>: <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(lists[<span class="number">0</span>], self.mergeKLists(lists[<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>mergeKLists 执行了 k 次，每次都执行一次 mergeTwoLists，mergeTwoLists 的时间复杂度前面已经分析过了，为 $O(N)$，其中 N 为两个链表中较短的那个的长度。</p><ul><li>时间复杂度：$O(k * N)$，其中 N 为两个链表中较短的那个的长度</li><li>空间复杂度：$O(max(k, N))$</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1: <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2: <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            l1.next = self.mergeTwoLists(l1.next, l2)</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l2.next = self.mergeTwoLists(l1, l2.next)</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(lists) == <span class="number">1</span>: <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(self.mergeKLists(lists[:len(lists) // <span class="number">2</span>]), self.mergeKLists(lists[len(lists) // <span class="number">2</span>:]))</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>mergeKLists 执行了 logk 次，每次都执行一次 mergeTwoLists，mergeTwoLists 的时间复杂度前面已经分析过了，为 $O(N)$，其中 N 为两个链表中较短的那个的长度。</p><ul><li>时间复杂度：$O(Nlogk)$，其中 N 为两个链表中较短的那个的长度</li><li>空间复杂度：$O(max(logk, N))$，其中 N 为两个链表中较短的那个的长度</li></ul><h2 id="全家福"><a href="#全家福" class="headerlink" title="全家福"></a>全家福</h2><p>最后送大家一张全家福：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghbq8s05y0j31620u0gs0.jpg" alt></p><h2 id="子题"><a href="#子题" class="headerlink" title="子题"></a>子题</h2><p>实际子题数量有很多，这里提供几个供大家练习。一定要练习，不能眼高手低。多看我的题解，多练习，多总结，你也可以的。</p><ul><li><a href="https://leetcode-cn.com/problems/smallest-k-lcci/" target="_blank" rel="noopener">面试题 17.14. 最小 K 个数</a></li><li><a href="https://leetcode-cn.com/problems/minimum-absolute-difference/" target="_blank" rel="noopener">1200. 最小绝对差</a></li><li><a href="https://leetcode-cn.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">632. 最小区间</a></li><li>两数和，三数和，四数和。。。 k 数和</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>母题就是<strong>抽象之后的纯粹的东西</strong>。如果你掌握了母题，即使没有掌握抽象的能力，依然有可能套出来。但是随着题目做的变多，“抽象能力”也会越来越强。因为你知道这些题背后是怎么产生的。</p><p>本期给大家介绍了八道母题， 大家可以在之后的刷题过程中尝试使用母题来套模板。之后会给大家带来更多的母题。</p><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 35K star 啦。</p><p>关注公众号力扣加加，努力用清晰直白的语言还原解题思路，并且有大量图解，手把手教你识别套路，高效刷题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 母题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 母题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文带你看懂二叉树的序列化</title>
      <link href="/blog/2020/07/24/serialize/"/>
      <url>/blog/2020/07/24/serialize/</url>
      
        <content type="html"><![CDATA[<p>我们先来看下什么是序列化，以下定义来自维基百科：</p><blockquote><p>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。</p></blockquote><p>可见，序列化和反序列化在计算机科学中的应用还是非常广泛的。就拿 LeetCode 平台来说，其允许用户输入形如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,null,null,4,5]</span><br></pre></td></tr></table></figure><p>这样的数据结构来描述一颗树：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh2dqqnyzwj30ba0baglw.jpg" alt></p><p>([1,2,3,null,null,4,5] 对应的二叉树)</p><p>其实序列化和反序列化只是一个概念，不是一种具体的算法，而是很多的算法。并且针对不同的数据结构，算法也会不一样。本文主要讲述的是二叉树的序列化和反序列化。看完本文之后，你就可以放心大胆地去 AC 以下两道题：</p><ul><li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/" target="_blank" rel="noopener">449. 序列化和反序列化二叉搜索树(中等)</a></li><li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">297. 二叉树的序列化与反序列化(困难)</a></li></ul><a id="more"></a><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>阅读本文之前，需要你对树的遍历以及 BFS 和 DFS 比较熟悉。如果你还不熟悉，推荐阅读一下相关文章之后再来看。或者我这边也写了一个总结性的文章<a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/binary-tree-traversal.md" target="_blank" rel="noopener">二叉树的遍历</a>，你也可以看看。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道：二叉树的深度优先遍历，根据访问根节点的顺序不同，可以将其分为<code>前序遍历</code>，<code>中序遍历</code>, <code>后序遍历</code>。即如果先访问根节点就是前序遍历，最后访问根节点就是后续遍历，其它则是中序遍历。而左右节点的相对顺序是不会变的，一定是先左后右。</p><blockquote><p>当然也可以设定为先右后左。</p></blockquote><p>并且知道了三种遍历结果中的任意两种即可还原出原有的树结构。这不就是序列化和反序列化么？如果对这个比较陌生的同学建议看看我之前写的<a href="https://lucifer.ren/blog/2020/02/08/%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/">《构造二叉树系列》</a></p><p>有了这样一个前提之后算法就自然而然了。即先对二叉树进行两次不同的遍历，不妨假设按照前序和中序进行两次遍历。然后将两次遍历结果序列化，比如将两次遍历结果以逗号“,” join 成一个字符串。 之后将字符串反序列即可，比如将其以逗号“,” split 成一个数组。</p><p>序列化：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> [str(root.val)] +self. preorder(root.left) + self.preorder(root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span>  self.inorder(root.left) + [str(root.val)] + self.inorder(root.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        ans = <span class="string">''</span></span><br><span class="line">        ans += <span class="string">','</span>.join(self.preorder(root))</span><br><span class="line">        ans += <span class="string">'$'</span></span><br><span class="line">        ans += <span class="string">','</span>.join(self.inorder(root))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>反序列化：</p><p>这里我直接用了力扣 <code>105. 从前序与中序遍历序列构造二叉树</code> 的解法，一行代码都不改。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data: str)</span>:</span></span><br><span class="line">        preorder, inorder = data.split(<span class="string">'$'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.buildTree(preorder.split(<span class="string">','</span>), inorder.split(<span class="string">','</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 实际上inorder 和 preorder 一定是同时为空的，因此你无论判断哪个都行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        i = inorder.index(root.val)</span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:i + <span class="number">1</span>], inorder[:i])</span><br><span class="line">        root.right = self.buildTree(preorder[i + <span class="number">1</span>:], inorder[i+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p>实际上这个算法是不一定成立的，原因在于树的节点可能存在重复元素。也就是说我前面说的<code>知道了三种遍历结果中的任意两种即可还原出原有的树结构</code>是不对的，严格来说应该是<strong>如果树中不存在重复的元素，那么知道了三种遍历结果中的任意两种即可还原出原有的树结构</strong>。</p><p>聪明的你应该发现了，上面我的代码用了 <code>i = inorder.index(root.val)</code>，如果存在重复元素，那么得到的索引 i 就可能不是准确的。但是，如果题目限定了没有重复元素则可以用这种算法。但是现实中不出现重复元素不太现实，因此需要考虑其他方法。那究竟是什么样的方法呢? 接下来进入正题。</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>我们来模仿一下力扣的记法。 比如：<code>[1,2,3,null,null,4,5]</code>(本质上是 BFS 层次遍历)，对应的树如下：</p><blockquote><p>选择这种记法，而不是 DFS 的记法的原因是看起来比较直观</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh2h5bhjryj30b40am74k.jpg" alt></p><p>序列化的代码非常简单， 我们只需要在普通的遍历基础上，增加对空节点的输出即可（普通的遍历是不处理空节点的）。</p><p>比如我们都树进行一次前序遍历的同时增加空节点的处理。选择前序遍历的原因是容易知道根节点的位置，并且代码好写，不信你可以试试。</p><p>因此序列化就仅仅是普通的 DFS 而已，直接给大家看看代码。</p><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize_dfs</span><span class="params">(self, root, ans)</span>:</span></span><br><span class="line">        <span class="comment"># 空节点也需要序列化，否则无法唯一确定一棵树，后不赘述。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> ans + <span class="string">'#,'</span></span><br><span class="line">        <span class="comment"># 节点之间通过逗号（,）分割</span></span><br><span class="line">        ans += str(root.val) + <span class="string">','</span></span><br><span class="line">        ans = self.serialize_dfs(root.left, ans)</span><br><span class="line">        ans = self.serialize_dfs(root.right, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># 由于最后会添加一个额外的逗号，因此需要去除最后一个字符，后不赘述。</span></span><br><span class="line">        <span class="keyword">return</span> self.serialize_dfs(root, <span class="string">''</span>)[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize_dfs</span><span class="params">(TreeNode root, String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            str += <span class="string">"None,"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            str += str.valueOf(root.val) + <span class="string">","</span>;</span><br><span class="line">            str = serialize_dfs(root.left, str);</span><br><span class="line">            str = serialize_dfs(root.right, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialize_dfs(root, <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>[1,2,3,null,null,4,5]</code> 会被处理为<code>1,2,#,#,3,4,#,#,5,#,#</code></p><p>我们先看一个短视频：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh2z5y87n0g30bo05vx6u.gif" alt></p><p>（动画来自力扣）</p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>反序列化的第一步就是将其展开。以上面的例子来说，则会变成数组：<code>[1,2,#,#,3,4,#,#,5,#,#]</code>，然后我们同样执行一次前序遍历，每次处理一个元素，重建即可。由于我们采用的前序遍历，因此第一个是根元素，下一个是其左子节点，下下一个是其右子节点。</p><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deserialize_dfs</span><span class="params">(self, nodes)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> nodes:</span><br><span class="line">        <span class="keyword">if</span> nodes[<span class="number">0</span>] == <span class="string">'#'</span>:</span><br><span class="line">            nodes.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(nodes.pop(<span class="number">0</span>))</span><br><span class="line">        root.left = self.deserialize_dfs(nodes)</span><br><span class="line">        root.right = self.deserialize_dfs(nodes)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data: str)</span>:</span></span><br><span class="line">    nodes = data.split(<span class="string">','</span>)</span><br><span class="line">    <span class="keyword">return</span> self.deserialize_dfs(nodes)</span><br></pre></td></tr></table></figure><p>Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize_dfs</span><span class="params">(List&lt;String&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l.get(<span class="number">0</span>).equals(<span class="string">"None"</span>)) &#123;</span><br><span class="line">        l.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(l.get(<span class="number">0</span>)));</span><br><span class="line">    l.remove(<span class="number">0</span>);</span><br><span class="line">    root.left = deserialize_dfs(l);</span><br><span class="line">    root.right = deserialize_dfs(l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    String[] data_array = data.split(<span class="string">","</span>);</span><br><span class="line">    List&lt;String&gt; data_list = <span class="keyword">new</span> LinkedList&lt;String&gt;(Arrays.asList(data_array));</span><br><span class="line">    <span class="keyword">return</span> deserialize_dfs(data_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：每个节点都会被处理一次，因此时间复杂度为 $O(N)$，其中 $N$ 为节点的总数。</li><li>空间复杂度：空间复杂度取决于栈深度，因此空间复杂度为 $O(h)$，其中 $h$ 为树的深度。</li></ul><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h3><p>实际上我们也可以使用 BFS 的方式来表示一棵树。在这一点上其实就和力扣的记法是一致的了。</p><p>我们知道层次遍历的时候实际上是有层次的。只不过有的题目需要你记录每一个节点的层次信息，有些则不需要。</p><p>这其实就是一个朴实无华的 BFS，唯一不同则是增加了空节点。</p><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        ans = <span class="string">''</span></span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                ans += str(node.val) + <span class="string">','</span></span><br><span class="line">                queue.append(node.left)</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += <span class="string">'#,'</span></span><br><span class="line">        <span class="keyword">return</span> ans[:<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="反序列化-1"><a href="#反序列化-1" class="headerlink" title="反序列化"></a>反序列化</h3><p>如图有这样一棵树：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh2x3gj9n0j30j00gewfx.jpg" alt></p><p>那么其层次遍历为 [1,2,3,#,#, 4, 5]。我们根据此层次遍历的结果来看下如何还原二叉树，如下是我画的一个示意图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh2x55lh7qj31780t0gq8.jpg" alt></p><p>容易看出：</p><ul><li>level x 的节点一定指向 level x + 1 的节点，如何找到 level + 1 呢？ 这很容易通过层次遍历来做到。</li><li>对于给的的 level x，从左到右依次对应 level x + 1 的节点，即第 1 个节点的左右子节点对应下一层的第 1 个和第 2 个节点，第 2 个节点的左右子节点对应下一层的第 3 个和第 4 个节点。。。</li><li>接上，其实如果你仔细观察的话，实际上 level x 和 level x + 1 的判断是无需特别判断的。我们可以把思路逆转过来：<code>即第 1 个节点的左右子节点对应第 1 个和第 2 个节点，第 2 个节点的左右子节点对应第 3 个和第 4 个节点。。。</code>（注意，没了下一层三个字）</li></ul><p>因此我们的思路也是同样的 BFS，并依次连接左右节点。</p><p>Python 代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data: str)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> data == <span class="string">'#'</span>: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 数据准备</span></span><br><span class="line">    nodes = data.split(<span class="string">','</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nodes: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># BFS</span></span><br><span class="line">    root = TreeNode(nodes[<span class="number">0</span>])</span><br><span class="line">    queue = [root]</span><br><span class="line">    <span class="comment"># 已经有 root 了，因此从 1 开始</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(nodes) - <span class="number">1</span>:</span><br><span class="line">        node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        lv = nodes[i]</span><br><span class="line">        rv = nodes[i + <span class="number">1</span>]</span><br><span class="line">        i += <span class="number">2</span></span><br><span class="line">        <span class="comment"># 对于给的的 level x，从左到右依次对应 level x + 1 的节点</span></span><br><span class="line">        <span class="comment"># node 是 level x 的节点，l 和 r 则是 level x + 1 的节点</span></span><br><span class="line">        <span class="keyword">if</span> lv != <span class="string">'#'</span>:</span><br><span class="line">            l = TreeNode(lv)</span><br><span class="line">            node.left = l</span><br><span class="line">            queue.append(l)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rv != <span class="string">'#'</span>:</span><br><span class="line">            r = TreeNode(rv)</span><br><span class="line">            node.right = r</span><br><span class="line">            queue.append(r)</span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：每个节点都会被处理一次，因此时间复杂度为 $O(N)$，其中 $N$ 为节点的总数。</li><li>空间复杂度：$O(N)$，其中 $N$ 为节点的总数。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了这种方法还有很多方案， 比如括号表示法。 关于这个可以参考力扣<a href="https://leetcode-cn.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">606. 根据二叉树创建字符串</a>，这里就不再赘述了。</p><p>本文从 BFS 和 DFS 角度来思考如何序列化和反序列化一棵树。 如果用 BFS 来序列化，那么相应地也需要 BFS 来反序列化。如果用 DFS 来序列化，那么就需要用 DFS 来反序列化。</p><p>我们从马后炮的角度来说，实际上对于序列化来说，BFS 和 DFS 都比较常规。对于反序列化，大家可以像我这样举个例子，画一个图。可以先在纸上，电脑上，如果你熟悉了之后，也可以画在脑子里。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh30bapydej30rq0tcad5.jpg" alt></p><p>（Like This）</p><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p>关注公众号力扣加加，努力用清晰直白的语言还原解题思路，并且有大量图解，手把手教你识别套路，高效刷题。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法，序列化 </category>
          
          <category> 数据结构，二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树专题</title>
      <link href="/blog/2020/07/21/balanced-tree/"/>
      <url>/blog/2020/07/21/balanced-tree/</url>
      
        <content type="html"><![CDATA[<p>力扣关于平衡二叉树的题目还是有一些的，并且都非常经典，推荐大家练习。今天给大家精选了 4 道题，如果你彻底搞明白了这几道题，碰到其他的平衡二叉树的题目应该不至于没有思路。当你领会了我的思路之后， 建议再找几个题目练手，巩固一下学习成果。</p><a id="more"></a><h2 id="110-平衡二叉树（简单）"><a href="#110-平衡二叉树（简单）" class="headerlink" title="110. 平衡二叉树（简单）"></a>110. 平衡二叉树（简单）</h2><p>最简单的莫过于判断一个树是否为平衡二叉树了，我们来看下。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，判断它是否是高度平衡的二叉树。</span><br><span class="line"></span><br><span class="line">本题中，一棵高度平衡二叉树定义为：</span><br><span class="line"></span><br><span class="line">一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回 true 。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">给定二叉树 [1,2,2,3,3,null,null,4,4]</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">返回 false</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于平衡二叉树定义为就是<strong>一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。</strong>用伪代码描述就是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> abs(高度(root.left) - 高度(root.right)) &lt;= <span class="number">1</span> <span class="keyword">and</span> root.left 也是平衡二叉树 <span class="keyword">and</span> root.right 也是平衡二叉树:</span><br><span class="line">    print(<span class="string">'是平衡二叉树'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'不是平衡二叉树'</span>)</span><br></pre></td></tr></table></figure><p>而 root.left 和 root.right <strong>如何判断是否是二叉平衡树就和 root 是一样的了</strong>，可以看出这个问题有明显的递归性。</p><p>因此我们首先需要知道如何计算一个子树的高度。这个可以通过递归的方式轻松地计算出来。计算子树高度的 Python 代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, depth)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    l = dfs(node.left, depth + <span class="number">1</span>)</span><br><span class="line">    r = dfs(node.right, depth + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max(l, r) + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码支持： Python3</p><p>Python3 Code:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, depth)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            l = dfs(node.left, depth + <span class="number">1</span>)</span><br><span class="line">            r = dfs(node.right, depth + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> max(l, r)  + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> abs(dfs(root.left, <span class="number">0</span>) -  dfs(root.right, <span class="number">0</span>)) &gt; <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：对于 isBalanced 来说，由于每个节点最多被访问一次，这部分的时间复杂度为 $O(N)$，而 dfs 函数 每次被调用的次数不超过 $log N$，因此总的时间复杂度为 $O(NlogN)$，其中 $N$ 为 树的节点总数。</li><li>空间复杂度：由于使用了递归，这里的空间复杂度的瓶颈在栈空间，因此空间复杂度为 $O(h)$，其中 $h$ 为树的高度。</li></ul><h2 id="108-将有序数组转换为二叉搜索树（简单）"><a href="#108-将有序数组转换为二叉搜索树（简单）" class="headerlink" title="108. 将有序数组转换为二叉搜索树（简单）"></a>108. 将有序数组转换为二叉搜索树（简单）</h2><p>108 和 109 基本是一样的，只不过数据结构不一样，109 变成了链表了而已。由于链表操作比数组需要考虑更多的因素，因此 109 是 中等难度。</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</span><br><span class="line"></span><br><span class="line">本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对于这个问题或者 <code>给定一个二叉搜索树，将其改为平衡（后面会讲）</code> 基本思路都是一样的。</p><p>题目的要求是将有序数组转化为：</p><ol><li>高度平衡的二叉树</li><li>二叉搜索树</li></ol><p>由于平衡二叉树是左右两个子树的高度差的绝对值不超过 1。因此一种简单的方法是<strong>选择中点作为根节点，根节点左侧的作为左子树，右侧的作为右子树即可。</strong>原因很简单，这样分配可以保证左右子树的节点数目差不超过 1。因此高度差自然也不会超过 1 了。</p><p>上面的操作同时也满足了二叉搜索树，原因就是题目给的数组是有序的。</p><blockquote><p>你也可以选择别的数作为根节点，而不是中点，这也可以看出答案是不唯一的。</p></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码支持： Python3</p><p>Python3 Code:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        mid = (len(nums) - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class="line">        root.right = self.sortedArrayToBST(nums[mid + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：由于每个节点最多被访问一次，因此总的时间复杂度为 $O(N)$，其中 $N$ 为数组长度。</li><li>空间复杂度：由于使用了递归，这里的空间复杂度的瓶颈在栈空间，因此空间复杂度为 $O(h)$，其中 $h$ 为树的高度。同时由于是平衡二叉树，因此 $h$ 就是 $log N$。</li></ul><h2 id="109-有序链表转换二叉搜索树（中等）"><a href="#109-有序链表转换二叉搜索树（中等）" class="headerlink" title="109. 有序链表转换二叉搜索树（中等）"></a>109. 有序链表转换二叉搜索树（中等）</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">`给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</span><br><span class="line"></span><br><span class="line">本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>和 108 思路一样。 不同的是数据结构的不同，因此我们需要关注的是链表和数组的操作差异。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggypywx9eqj31ii0pgdj0.jpg" alt></p><p>（数组的情况）</p><p>我们再来看下链表：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggyq5115dbj31q30u0afz.jpg" alt><br>（链表的情况）</p><p>找到中点，只需要使用经典的快慢指针即可。同时为了防止环的出现， 我们需要斩断指向 mid 的 next 指针，因此需要记录一下中点前的一个节点，这只需要用一个变量 pre 记录即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>代码支持： Python3</p><p>Python3 Code:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        pre, slow, fast = <span class="literal">None</span>, head, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            pre = slow</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">if</span> pre:</span><br><span class="line">            pre.next = <span class="literal">None</span></span><br><span class="line">        node = TreeNode(slow.val)</span><br><span class="line">        <span class="keyword">if</span> slow == fast:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        node.left = self.sortedListToBST(head)</span><br><span class="line">        node.right = self.sortedListToBST(slow.next)</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：由于每个节点最多被访问一次，因此总的时间复杂度为 $O(N)$，其中 $N$ 为链表长度。</li><li>空间复杂度：由于使用了递归，这里的空间复杂度的瓶颈在栈空间，因此空间复杂度为 $O(h)$，其中 $h$ 为树的高度。同时由于是平衡二叉树，因此 $h$ 就是 $log N$。</li></ul><h2 id="1382-将二叉搜索树变平衡（中等）"><a href="#1382-将二叉搜索树变平衡（中等）" class="headerlink" title="1382. 将二叉搜索树变平衡（中等）"></a>1382. 将二叉搜索树变平衡（中等）</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。</span><br><span class="line"></span><br><span class="line">如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。</span><br><span class="line"></span><br><span class="line">如果有多种构造方法，请你返回任意一种。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例：</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggxvm577m7j306j07rdfw.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入：root = [1,null,2,null,3,null,4,null,null]</span><br><span class="line">输出：[2,1,3,null,null,null,4]</span><br><span class="line">解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">树节点的数目在 1 到 10^4 之间。</span><br><span class="line">树节点的值互不相同，且在 1 到 10^5 之间。</span><br></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>由于<code>二叉搜索树的中序遍历是一个有序数组</code>，因此问题很容易就转化为 <code>108. 将有序数组转换为二叉搜索树（简单）</code>。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>代码支持： Python3</p><p>Python3 Code:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> self.inorder(node.left) + [node.val] + self.inorder(node.right)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balanceBST</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        nums = self.inorder(root)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(start, end)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> start == end: <span class="keyword">return</span> TreeNode(nums[start])</span><br><span class="line">            <span class="keyword">if</span> start &gt; end: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            mid = (start + end) // <span class="number">2</span></span><br><span class="line">            root = TreeNode(nums[mid])</span><br><span class="line">            root.left = dfs(start, mid - <span class="number">1</span>)</span><br><span class="line">            root.right = dfs(mid + <span class="number">1</span>, end)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：由于每个节点最多被访问一次，因此总的时间复杂度为 $O(N)$，其中 $N$ 为链表长度。</li><li>空间复杂度：虽然使用了递归，但是瓶颈不在栈空间，而是开辟的长度为 $N$ 的 nums 数组，因此空间复杂度为 $O(N)$，其中 $N$ 为树的节点总数。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过四道关于二叉平衡树的题帮助大家识别此类型题目背后的思维逻辑，我们来总结一下学到的知识。</p><p>平衡二叉树指的是：<code>一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。</code></p><p>如果需要让你判断一个树是否是平衡二叉树，只需要死扣定义，然后用递归即可轻松解决。</p><p>如果需要你将一个数组或者链表（逻辑上都是线性的数据结构）转化为平衡二叉树，只需要随便选一个节点，并分配一半到左子树，另一半到右子树即可。</p><p>同时，如果要求你转化为平衡二叉搜索树，则可以选择排序数组(或链表)的中点，左边的元素为左子树， 右边的元素为右子树即可。</p><blockquote><p>小提示 1： 如果不需要是二叉搜索树则不需要排序，否则需要排序。</p></blockquote><blockquote><p>小提示 2： 你也可以不选择中点， 算法需要相应调整，感兴趣的同学可以试试。</p></blockquote><blockquote><p>小提示 3： 链表的操作需要特别注意环的存在。</p></blockquote><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p>关注公众号力扣加加，努力用清晰直白的语言还原解题思路，并且有大量图解，手把手教你识别套路，高效刷题。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 平衡二叉树 </category>
          
          <category> 二叉搜索树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 611. 有效三角形的个数</title>
      <link href="/blog/2020/07/20/611.triangle/"/>
      <url>/blog/2020/07/20/611.triangle/</url>
      
        <content type="html"><![CDATA[<p>题目地址： <a href="https://leetcode-cn.com/problems/valid-triangle-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-triangle-number/</a></p><p>​<a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [2,2,3,4]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">有效的组合是:</span><br><span class="line">2,3,4 (使用第一个 2)</span><br><span class="line">2,3,4 (使用第二个 2)</span><br><span class="line">2,2,3</span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">数组长度不超过1000。</span><br><span class="line">数组里整数的范围为 [0, 1000]。</span><br></pre></td></tr></table></figure><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>排序</li><li>双指针</li><li>二分法</li><li>三角形边的关系</li></ul><h2 id="暴力法（超时）"><a href="#暴力法（超时）" class="headerlink" title="暴力法（超时）"></a>暴力法（超时）</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先要有一个数学前提： <code>如果三条线段中任意两条的和都大于第三边，那么这三条线段可以组成一个三角形</code>。即给定三个线段 a，b，c，如果满足 a + b &gt; c and a + c &gt; b and b + c &gt; a，则线段 a，b，c 可以构成三角形，否则不可以。</p><p>力扣中有一些题目是需要一些数学前提的，不过这些数学前提都比较简单，一般不会超过高中数学知识，并且也不会特别复杂。一般都是小学初中知识即可。</p><blockquote><p>如果你在面试中碰到不知道的数学前提，可以寻求面试官提示试试。</p></blockquote><h3 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h3><ul><li>三角形边的关系</li><li>三层循环确定三个线段</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码支持: Python</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_triangle</span><span class="params">(self, a, b, c)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> a == <span class="number">0</span> <span class="keyword">or</span> b == <span class="number">0</span> <span class="keyword">or</span> c == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> a + b &gt; c <span class="keyword">and</span> a + c &gt; b <span class="keyword">and</span> b + c &gt; a: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">triangleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j + <span class="number">1</span>, n):</span><br><span class="line">                    <span class="keyword">if</span> self.is_triangle(nums[i], nums[j], nums[k]): ans += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N ^ 3)$，其中 N 为 数组长度。</li><li>空间复杂度：$O(1)$</li></ul><h2 id="优化的暴力法"><a href="#优化的暴力法" class="headerlink" title="优化的暴力法"></a>优化的暴力法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>暴力法的时间复杂度为 $O(N ^ 3)$， 其中 $N$ 最大为 1000。一般来说， $O(N ^ 3)$ 的算法在数据量 &lt;= 500 是可以 AC 的。1000 的数量级则需要考虑 $O(N ^ 2)$ 或者更好的解法。</p><p>OK，到这里了。我给大家一个干货。 应该是其他博主不太会提的。原因可能是他们不知道， 也可能是他们觉得太小儿科不需要说。</p><ol><li>由于前面我根据数据规模推测到到了解法的复杂度区间是 $N ^ 2$, $N ^ 2 * logN$，不可能是 $N$ （WHY？）。</li><li>降低时间复杂度的方法主要有： <code>空间换时间</code> 和 <code>排序换时间</code>（我们一般都是使用基于比较的排序方法）。而<code>排序换时间</code>仅仅在总体复杂度大于 $O(NlogN)$ 才适用（原因不用多说了吧？）。</li></ol><p>这里由于总体的时间复杂度是 $O(N ^ 3)$，因此我自然想到了<code>排序换时间</code>。当我们对 nums 进行一次排序之后，我发现：</p><ul><li>is_triangle 函数有一些判断是无效的</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_triangle</span><span class="params">(self, a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span> <span class="keyword">or</span> b == <span class="number">0</span> <span class="keyword">or</span> c == <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># a + c &gt; b 和  b + c &gt; a 是无效的判断，因为恒成立</span></span><br><span class="line">    <span class="keyword">if</span> a + b &gt; c <span class="keyword">and</span> a + c &gt; b <span class="keyword">and</span> b + c &gt; a: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>因此我们的目标变为找到<code>a + b &gt; c</code>即可，因此第三层循环是可以提前退出的。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">        k = j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &lt; n <span class="keyword">and</span> num[i] + nums[j] &gt; nums[k]:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        ans += k - j - <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>这也仅仅是减枝而已，复杂度没有变化。通过进一步观察，发现 k 没有必要每次都从 j + 1 开始。而是从上次找到的 k 值开始就行。原因很简单， 当 nums[i] + nums[j] &gt; nums[k] 时，我们想要找到下一个满足 nums[i] + nums[j] &gt; nums[k] 的 新的 k 值，由于进行了排序，因此这个 k 肯定比之前的大（单调递增性），因此上一个 k 值之前的数都是无效的，可以跳过。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">    k = i + <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">while</span> k &lt; n <span class="keyword">and</span> nums[i] + nums[j] &gt; nums[k]:</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        ans += k - j - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>由于 K 不会后退，因此最内层循环总共最多执行 N 次，因此总的时间复杂度为 $O(N ^ 2)$。</p><blockquote><p>这个复杂度分析有点像单调栈，大家可以结合起来理解。</p></blockquote><h3 id="关键点分析"><a href="#关键点分析" class="headerlink" title="关键点分析"></a>关键点分析</h3><ul><li>排序</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">triangleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            k = i + <span class="number">2</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">while</span> k &lt; n <span class="keyword">and</span> nums[i] + nums[j] &gt; nums[k]:</span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                ans += k - j - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N ^ 2)$</li><li>空间复杂度：取决于排序算法</li></ul><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p>关注公众号力扣加加，努力用清晰直白的语言还原解题思路，并且有大量图解，手把手教你识别套路，高效刷题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 数组 </category>
          
          <category> 双指针 </category>
          
          <category> Medium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>immutablejs 是如何优化我们的代码的？</title>
      <link href="/blog/2020/07/05/immutable-js/"/>
      <url>/blog/2020/07/05/immutable-js/</url>
      
        <content type="html"><![CDATA[<p>前一段时间群里有小伙伴问 lucifer 我一个问题：”immutablejs 是什么？有什么用？“。我当时的回答是：<code>immutablejs 就是 tree + sharing，解决了数据可变性带来的问题，并顺便优化了性能</code>。今天给大家来详细解释一下这句话。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们还是通过一个例子来进行说明。如下是几个普通地不能再普通的赋值语句:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br><span class="line">c = <span class="number">3</span>;</span><br><span class="line">d = &#123;</span><br><span class="line">  name: <span class="string">"lucifer"</span>,</span><br><span class="line">  age: <span class="number">17</span>,</span><br><span class="line">  location: <span class="string">"西湖"</span>,</span><br><span class="line">&#125;;</span><br><span class="line">e = [<span class="string">"脑洞前端"</span>, <span class="string">"力扣加加"</span>];</span><br></pre></td></tr></table></figure><p>上面代码的内存结构大概是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggg7shvbghj31ew0r8dl6.jpg" alt></p><blockquote><p>lucifer 小提示：可以看出，变量名（ a，b，c，d，e ）只是内存地址的别名而已</p></blockquote><p>由于 d 和 e <strong>的值</strong>是引用类型，数据长度不确定，因此实际上数据区域会指向堆上的一块区域。而 a，b，c 由于长度是编译时确定的，因此可以方便地在栈上存储。</p><blockquote><p>lucifer 小提示：d 和 e 的数据长度不确定， 但指针的长度是确定的，因此可以在栈上存储指针，指针指向堆上内存即可。</p></blockquote><p>实际开发我们经常会进行各种赋值操作，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ca = a;</span><br><span class="line"><span class="keyword">const</span> cb = b;</span><br><span class="line"><span class="keyword">const</span> cc = c;</span><br><span class="line"><span class="keyword">const</span> cd = d;</span><br><span class="line"><span class="keyword">const</span> ce = e;</span><br></pre></td></tr></table></figure><p>经过上面的操作，此时的内存结构图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggg82ifxozj30wo0u0dqd.jpg" alt></p><p>可以看出，ca，cb，cc，cd，ce 的<strong>内存地址都变了，但是值都没变</strong>。原因在于变量名只是内存的别名而已，而赋值操作传递的是 value。</p><p>由于目前 JS 对象操作都是 mutable 的， 因此就有可能会发生这样的 “bug”：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd.name = <span class="string">"azl397985856"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cd.name); <span class="comment">// azl397985856</span></span><br><span class="line"><span class="built_in">console</span>.log(d.name); <span class="comment">// azl397985856</span></span><br></pre></td></tr></table></figure><p>上面的 <code>cd.name</code> <strong>原地修改</strong>了 cd 的 name 值，这会影响所有指向 ta 的引用。</p><p>比如有一个对象被三个指针引用，如果对象被修改了，那么三个指针都会有影响。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gggfzb948kj31kc0sugpl.jpg" alt></p><p>你可以把指针看成线程，对象看成进程资源，资源会被线程共享。 多指针就是多线程，当多个线程同时对一个对象进行读写操作就可能会有问题。</p><p>于是很多人的做法是 copy（shallow or deep）。这样多个指针的对象都是不同的，可以看成多进程。</p><p>接下来我们进行一次 copy 操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sa = a;</span><br><span class="line"><span class="keyword">const</span> sb = b;</span><br><span class="line"><span class="keyword">const</span> sc = c;</span><br><span class="line"><span class="keyword">const</span> sd = &#123; ...d &#125;;</span><br><span class="line"><span class="keyword">const</span> se = [...e];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有的人还觉得不过瘾</span></span><br><span class="line"><span class="keyword">const</span> sxbk = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(e));</span><br></pre></td></tr></table></figure><blockquote><p>旁观者： 为啥你代码那么多 copy 啊？<br>当事人： 我也不知道为啥要 copy 一下，不过这样做使我安心。</p></blockquote><p>此时引用类型的 value 全部发生了变化，此时内存图是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggkjw9miepj30rb0gwq56.jpg" alt></p><p>上面的 ”bug“ 成功解决。</p><blockquote><p>lucifer 小提示： 如果你使用的是 shallow copy， 其内层的对象 value 是不会变化的。如果此时你对内层对象进行诸如 a.b.c 的操作，也会有”bug“。</p></blockquote><p>完整内存图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggkjxw3xufj31c00mmwjs.jpg" alt></p><p>（看不清可以尝试放大）</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果是 shallow copy 还好， 因为你只 copy 一层，但是随着 key 的增加，性能下降还是比较明显的。</p><p>据测量：</p><ul><li>shallow copy 包含 1w 个 属性的对象大概要 10 ms。</li><li>deep copy 一个三层的 1w 个属性的对象大概要 50 ms。</li></ul><p>而 immutablejs 可以帮助我们减少这种时间（和内存）开销，这个我们稍后会讲。</p><blockquote><p>数据仅供参考，大家也可以用自己的项目测量一下。</p></blockquote><p>由于普通项目很难达到这个量级，因此基本结论是：如果你的项目对象不会很大， 完全没必要考虑诸如 immutablejs 进行优化，直接手动 copy 实现 immutable 即可。</p><p>如果我的项目真的很大呢？那么你可以考虑使用 immutable 库来帮你。 immutablejs 是无数 immutable 库中的一个。我们来看下 immutablejs 是如何解决这个性能难题的。</p><h2 id="immutablejs-是什么"><a href="#immutablejs-是什么" class="headerlink" title="immutablejs 是什么"></a>immutablejs 是什么</h2><p>使用 immutablejs 提供的 API 操作数据，每一次操作都会返回一个新的引用，效果类似 deep copy，但是性能更好。</p><p>开头我说了，<code>immutablejs 就是 tree + sharing，解决了数据可变带来的问题，并顺便提供了性能</code>。 其中这里的 tree 就是类似 trie 的一棵树。如果对 trie 不熟悉的，可以看下我之前写的一篇<a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/trie.md" title="前缀树专题" target="_blank" rel="noopener">前缀树专题</a>。</p><p>immutablejs 就是通过树实现的<strong>结构共享</strong>。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> words = [<span class="string">"lucif"</span>, <span class="string">"luck"</span>];</span><br></pre></td></tr></table></figure><p>我根据 words 构建了一个前缀树，节点不存储数据， 数据存储在路径上。其中头节点表示的是对象的引用地址。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggg9bu2jqzj30u010xaeo.jpg" alt></p><p>这样我们就将两个单词 <code>lucif</code> 和 <code>luck</code>存到了树上：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggkk83ng24j30gk0hydhj.jpg" alt></p><p>现在我想要将 lucif 改成 lucie，普通的做法是完全 copy 一份，之后修改即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newWords = [...words];</span><br><span class="line">newWords[<span class="number">1</span>] = <span class="string">"lucie"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggkkb31zwhj30ge0gxq3z.jpg" alt><br>（注意这里整棵树都是新的，你看根节点的内存地址已经变了）</p><p>而所谓的状态共享是：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggg9apgdrwj30u00u9wld.jpg" alt><br>（注意这里整棵树除了新增的一个节点， 其他都是旧的，你看根节点的内存地址没有变）</p><p>可以看出，我们<strong>只是增加了一个节点，并改变了一个指针而已，其他都没有变化，这就是所谓的结构共享。</strong></p><h2 id="还是有问题"><a href="#还是有问题" class="headerlink" title="还是有问题"></a>还是有问题</h2><p>仔细观察会发现：<code>使用我们的方法，会造成 words 和 newWords 引用相等（都是 1fe2ab）</code>，即 words === newWords。</p><p>因此我们需要沿着路径回溯到根节点，并修改沿路的所有节点（绿色部分）。在这个例子，我们仅仅少修改两个节点。但是随着树的节点增加，公共前缀也会随着增加，那时性能提升会很明显。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggg9eb655jj30u0132jw8.jpg" alt></p><p>整个过程类似下面的动图所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gggg8nnbucg30h10fz7co.gif" alt></p><blockquote><p>这个过程非常类似线段树的更新区间信息的过程</p></blockquote><h2 id="取舍之间"><a href="#取舍之间" class="headerlink" title="取舍之间"></a>取舍之间</h2><p>前面提到了 <code>沿着路径回溯到根节点，并修改沿路的所有节点</code>。由于树的总节点数是固定的，因此当树很高的时候，某一个节点的子节点数目会很少，节点的复用率会很低。想象一个极端的情况，树中所有的节点只有一个子节点，此时退化到链表，每次修改的时间复杂度为 O(P)，其中 P 为其祖先节点的个数。如果此时修改的是叶子节点，那么 P 就等于 N，其中 N 为 树的节点总数。</p><p>树很矮的情况，树的子节点数目会增加，因此每次回溯需要修改的指针增加。如图是有四个子节点的情况，相比于上面的两个子节点，需要多创建两个指针。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggg9y2qspej30zj0u0age.jpg" alt></p><p>想象一种极端的情况，树只有一层。还是将 lucif 改成 lucie。我们此时只能重新建立一个全新的 lucie 节点，无法利用已有节点，此时和 deep copy 相比没有一点优化。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggkkpimukwj30ar07hwen.jpg" alt></p><p>因此合理选择树的叉数是一个难点，绝对不是简单的二叉树就行了。这个选择往往需要做很多实验才能得出一个相对合理的值。</p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React 和 Vue 最大的区别之一就是 React 更加 “immutable”。React 更倾向于数据不可变，而 Vue 则相反。如果你恰好两个框架都使用过，应该明白我的意思。</p><p>使用 immutable 的一个好处是<strong>未来的操作不会影响之前创建的对象</strong>。因此你可以很轻松地将应用的数据进行持久化，以便发送给后端做调试分析或者实现时光旅行（感谢可预测的单向数据流）。</p><p>结合 Redux 等状态管理框架，immutablejs 可以发挥更大的作用。这个时候，你的整个 state tree 应该是 immutablejs 对象，不需要使用普通的 JavaScript 对象，并且操作也需要使用 immutablejs 提供的 API 来进行。 并且由于有了 immutablejs，我们可以很方便的使用全等 === 判断。写 SCU 也方便多了。</p><blockquote><p>SCU 是 shouldComponentUpdate 的缩写。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggggqsqkdxj315j0u0wpr.jpg" alt></p><p>通过我的几年使用经验来看，使用类似 immutablejs 的库，会使得性能有不稳定的提升。并且由于多了一个库，调试成本或多或少有所增加，并且有一定的理解和上手成本。因此我的建议是<code>技术咱先学着，如果项目确实需要使用，团队成员技术也可以 Cover的话，再接入也不迟，不可过早优化</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于数据可变性，当多个指针指向同一个引用，其中一个指针修改了数据可能引发”不可思议“的效果。随着项目规模的增大，这种情况会更加普遍。并且由于未来的操作可能会修改之前创建的对象，因此无法获取中间某一时刻的状态，这样就缺少了中间的链路，很难进行调试 。数据不可变则是<strong>未来的操作不会影响之前创建的对象</strong>，这就减少了”不可思议“的现象，并且由于我们可以知道任何中间状态，因此调试也会变得轻松。</p><p>手动实现”数据不可变“可以应付大多数情况。在极端情况下，才会有性能问题。<code>immutablejs 就是 tree + sharing，解决了数据可变带来的问题，并顺便优化了性能</code>。它不但解决了手动 copy 的性能问题，而且可以在 $O(1)$ 的时间比较一个对象是否发生了变化。因此搭配 React 的 SCU 优化 React 应用会很香。</p><p>最后推荐我个人感觉不错的另外两个 immutable 库 <a href="https://github.com/rtfeldman/seamless-immutable" title="seamless-immutable" target="_blank" rel="noopener">seamless-immutable</a> 和 <a href="https://github.com/immerjs/immer" title="Immer" target="_blank" rel="noopener">Immer</a>。</p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的前端硬核文章，带你认识你不知道的前端。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxro1x125j30oz0dw43s.jpg" alt></p><p>知乎专栏【 <a href="https://www.zhihu.com/people/lu-xiao-13-70" title="Lucifer - 知乎" target="_blank" rel="noopener">Lucifer - 知乎</a>】</p><p>点关注，不迷路！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
            <tag> immutablejs </tag>
            
            <tag> immutable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想去力扣当前端，TypeScript 需要掌握到什么程度？</title>
      <link href="/blog/2020/07/05/leetcode-interview-ts/"/>
      <url>/blog/2020/07/05/leetcode-interview-ts/</url>
      
        <content type="html"><![CDATA[<p>2018 年底的时候，力扣发布了岗位招聘，其中就有前端，仓库地址：<a href="https://github.com/LeetCode-OpenSource/hire" target="_blank" rel="noopener">https://github.com/LeetCode-OpenSource/hire</a> 。与大多数 JD 不同， 其提供了 5 道题， 并注明了<code>完成一个或多个面试题，获取免第一轮面试的面试机会。完成的题目越多，质量越高，在面试中的加分更多。完成后的代码可以任意形式发送给 jobs@lingkou.com。以上几个问题完成一个或多个都有可能获得面试机会，具体情况取决于提交给我们的代码。</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggfv55mufyj30u00wh0z0.jpg" alt></p><p>（力扣中国前端工程师 JD）</p><p>今天我们就来看下第二题：<code>编写复杂的 TypeScript 类型</code>。通过这道题来看下， TypeScript 究竟要到什么水平才能进力扣当前端？</p><blockquote><p>其它四道题也蛮有意思的，值得一看。</p></blockquote><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设有一个叫 <code>EffectModule</code> 的类</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> EffectModule &#123;&#125;</span><br></pre></td></tr></table></figure><p>这个对象上的方法<strong>只可能</strong>有两种类型签名:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Action&lt;T&gt; &#123;</span><br><span class="line">  payload?: T</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncMethod&lt;T, U&gt;(input: <span class="built_in">Promise</span>&lt;T&gt;): <span class="built_in">Promise</span>&lt;Action&lt;U&gt;&gt;</span><br><span class="line"></span><br><span class="line">syncMethod&lt;T, U&gt;(action: Action&lt;T&gt;): Action&lt;U&gt;</span><br></pre></td></tr></table></figure><p>这个对象上还可能有一些任意的<strong>非函数属性</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Action&lt;T&gt; &#123;</span><br><span class="line">  payload?: T;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> EffectModule &#123;</span><br><span class="line">  count = <span class="number">1</span>;</span><br><span class="line">  message = <span class="string">"hello!"</span>;</span><br><span class="line"></span><br><span class="line">  delay(input: <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> input.then(<span class="function">(<span class="params">i</span>) =&gt;</span> (&#123;</span><br><span class="line">      payload: <span class="string">`hello <span class="subst">$&#123;i&#125;</span>!`</span>,</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">"delay"</span>,</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMessage(action: Action&lt;<span class="built_in">Date</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      payload: action.payload!.getMilliseconds(),</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">"set-message"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个叫 <code>connect</code> 的函数，它接受 EffectModule 实例，将它变成另一个对象，这个对象上只有<strong>EffectModule 的同名方法</strong>，但是方法的类型签名被改变了:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">asyncMethod&lt;T, U&gt;(input: <span class="built_in">Promise</span>&lt;T&gt;): <span class="built_in">Promise</span>&lt;Action&lt;U&gt;&gt;  变成了</span><br><span class="line">asyncMethod&lt;T, U&gt;(input: T): Action&lt;U&gt;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syncMethod&lt;T, U&gt;(action: Action&lt;T&gt;): Action&lt;U&gt;  变成了</span><br><span class="line">syncMethod&lt;T, U&gt;(action: T): Action&lt;U&gt;</span><br></pre></td></tr></table></figure><p>例子:</p><p>EffectModule 定义如下:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Action&lt;T&gt; &#123;</span><br><span class="line">  payload?: T;</span><br><span class="line">  <span class="keyword">type</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> EffectModule &#123;</span><br><span class="line">  count = <span class="number">1</span>;</span><br><span class="line">  message = <span class="string">"hello!"</span>;</span><br><span class="line"></span><br><span class="line">  delay(input: <span class="built_in">Promise</span>&lt;<span class="built_in">number</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> input.then(<span class="function">(<span class="params">i</span>) =&gt;</span> (&#123;</span><br><span class="line">      payload: <span class="string">`hello <span class="subst">$&#123;i&#125;</span>!`</span>,</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">"delay"</span>,</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setMessage(action: Action&lt;<span class="built_in">Date</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      payload: action.payload!.getMilliseconds(),</span><br><span class="line">      <span class="keyword">type</span>: <span class="string">"set-message"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>connect 之后:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Connected = &#123;</span><br><span class="line">  delay(input: <span class="built_in">number</span>): Action&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">  setMessage(action: <span class="built_in">Date</span>): Action&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> effectModule = <span class="keyword">new</span> EffectModule();</span><br><span class="line"><span class="keyword">const</span> connected: Connected = connect(effectModule);</span><br></pre></td></tr></table></figure><p>要求：</p><p>在 <a href="https://codesandbox.io/s/4tmtp" title="题目链接" target="_blank" rel="noopener">题目链接</a> 里面的 <code>index.ts</code> 文件中，有一个 <code>type Connect = (module: EffectModule) =&gt; any</code>，将 <code>any</code> 替换成题目的解答，让编译能够顺利通过，并且 <code>index.ts</code> 中 <code>connected</code> 的类型与:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Connected = &#123;</span><br><span class="line">  delay(input: <span class="built_in">number</span>): Action&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">  setMessage(action: <span class="built_in">Date</span>): Action&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>完全匹配</strong>。</p><blockquote><p>以上是官方题目描述，下面我的补充</p></blockquote><p>上文提到的<code>index.ts</code> 比 题目描述多了两个语句，它们分别是：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggfvu17znfj30u80eiad2.jpg" alt></p><p>（题目额外信息）</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先来解读下题目。 题目要求我们补充类型 <code>Connect</code> 的定义， 也就是将 any 替换为不报错的其他代码。</p><p>回顾一下题目信息：</p><ul><li>有一个叫 <code>connect</code> 的函数，它接受 EffectModule 实例，将它变成另一个对象，这个对象上只有<strong>EffectModule 的同名方法</strong>，但是方法的类型签名被改变了</li><li>这个对象上还可能有一些任意的<strong>非函数属性</strong></li><li>这个对象（EffectModule 实例）上的方法<strong>只可能</strong>有两种类型签名</li></ul><p>根据以上信息，我们能够得到：<code>我们只需要将作为参数传递进来的 EffectModule 实例上的函数类型签名修改一下，非函数属性去掉即可</code>。所以，我们有两件问题要解决：</p><ol><li>如何将非函数属性去掉</li><li>如何转换函数类型签名</li></ol><h3 id="如何将非函数属性去掉"><a href="#如何将非函数属性去掉" class="headerlink" title="如何将非函数属性去掉"></a>如何将非函数属性去掉</h3><p>我们需要定义一个泛型，功能是接受一个对象，如果对象的 value 是 函数，则保留，否则去掉即可。不懂泛型的朋友可以先看下我之前写的文章： <a href="https://lucifer.ren/blog/2020/06/16/ts-generics/" title="你不知道的 TypeScript 泛型（万字长文，建议收藏）">你不知道的 TypeScript 泛型（万字长文，建议收藏）</a></p><p>这让我想起了官方提供的 Omit 泛型 <code>Omit&lt;T,K&gt;</code>。举个例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPreview = Omit&lt;Todo, <span class="string">"description"</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// description 属性没了</span></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview = &#123;</span><br><span class="line">  title: <span class="string">"Clean room"</span>,</span><br><span class="line">  completed: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>官方的 Omit 实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T;</span><br><span class="line"><span class="keyword">type</span> Omit&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure><p>实际上我们要做的就是 Omit 的变种，不是 Omit 某些 key，而是 Omit 值为非函数的 key。</p><p>由于 Omit 非函数实际就就是 Pick 函数，并且无需显式指定 key，因此我们的泛型只接受一个参数即可。 于是模仿官方的 <code>Pick</code> 写出了如下代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取值为函数的 key，形如： 'funcKeyA' | 'funcKeyB'</span></span><br><span class="line"><span class="keyword">type</span> PickFuncKeys&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> <span class="built_in">Function</span> ? K : never;</span><br><span class="line">&#125;[keyof T];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取值为函数的 key value 对，形如： &#123; 'funcKeyA': ..., 'funKeyB': ...&#125;</span></span><br><span class="line"><span class="keyword">type</span> PickFunc&lt;T&gt; = Pick&lt;T, PickFuncKeys&lt;T&gt;&gt;;</span><br></pre></td></tr></table></figure><p>使用效果：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">  addTodo(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddTodo = PickFunc&lt;Todo&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: AddTodo = &#123;</span><br><span class="line">  addTodo() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"关注脑洞前端~"</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ADDTodoKey = PickFuncKeys&lt;Todo&gt;; <span class="comment">// 'addTodo'</span></span><br></pre></td></tr></table></figure><p>可以看出，PickFunc 只提取了函数属性，忽略了非函数属性。</p><h3 id="如何转换函数类型签名"><a href="#如何转换函数类型签名" class="headerlink" title="如何转换函数类型签名"></a>如何转换函数类型签名</h3><p>我们再来回顾一下题目要求：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggfy6bz4prj31mo0b8goj.jpg" alt></p><p>也就是我们需要知道<strong>怎么才能提取 Promise 和 Action 泛型中的值</strong>。</p><p>实际上这两个几乎一样，会了一个，另外一个也就会了。我们先来看下 <code>Promise</code>。</p><p>从：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(arg: <span class="built_in">Promise</span>&lt;T&gt;) =&gt; <span class="built_in">Promise</span>&lt;U&gt;</span><br></pre></td></tr></table></figure><p>变为：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(arg: T) =&gt; U;</span><br></pre></td></tr></table></figure><p>如果想要完成这个需求，需要借助<code>infer</code>。只需要在类型前加一个关键字前缀 <code>infer</code>，TS 会将推导出的类型自动填充进去。</p><p>infer 最早出现在此 <a href="https://github.com/Microsoft/TypeScript/pull/21496" target="_blank" rel="noopener">官方 PR</a> 中，表示在 extends 条件语句中待推断的类型变量。</p><p>简单示例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParamType&lt;T&gt; = T <span class="keyword">extends</span> (param: infer P) =&gt; <span class="built_in">any</span> ? P : T;</span><br></pre></td></tr></table></figure><p>在这个条件语句 <code>T extends (param: infer P) =&gt; any ? P : T</code> 中，infer P 表示待推断的函数参数。</p><p>整句表示为：如果 T 能赋值给 (param: infer P) =&gt; any，则结果是 (param: infer P) =&gt; any 类型中的参数 P，否则返回为 T。</p><p>一个更具体的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Func = <span class="function">(<span class="params">user: User</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Param = ParamType&lt;Func&gt;; <span class="comment">// Param = User</span></span><br><span class="line"><span class="keyword">type</span> AA = ParamType&lt;<span class="built_in">string</span>&gt;; <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>这些知识已经够我们用了。 更多用法可以参考 <a href="https://jkchao.github.io/typescript-book-chinese/tips/infer.html#%E4%BB%8B%E7%BB%8D" title="深入理解 TypeScript - infer" target="_blank" rel="noopener">深入理解 TypeScript - infer</a> 。</p><p>根据上面的知识，不难写出如下代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ExtractPromise&lt;P&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> PickFuncKeys&lt;P&gt;]: P[K] <span class="keyword">extends</span> (</span><br><span class="line">    arg: <span class="built_in">Promise</span>&lt;infer T&gt;</span><br><span class="line">  ) =&gt; <span class="built_in">Promise</span>&lt;infer U&gt;</span><br><span class="line">    ? <span class="function">(<span class="params">arg: T</span>) =&gt;</span> U</span><br><span class="line">    : never;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提取 Action 的 代码也是类似：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ExtractAction&lt;P&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof PickFunc&lt;P&gt;]: P[K] <span class="keyword">extends</span> (</span><br><span class="line">    arg: Action&lt;infer T&gt;</span><br><span class="line">  ) =&gt; Action&lt;infer U&gt;</span><br><span class="line">    ? <span class="function">(<span class="params">arg: T</span>) =&gt;</span> Action&lt;U&gt;</span><br><span class="line">    : never;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此我们已经解决了全部两个问题，完整代码见下方代码区。</p><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>泛型</li><li>extends 做类型约束</li><li>infer 做类型提取</li><li>内置基本范型的使用和实现</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们将这几个点串起来，不难写出如下最终代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ExtractContainer&lt;P&gt; =  &#123;</span><br><span class="line">  [K <span class="keyword">in</span> PickFuncKeys&lt;P&gt;]:</span><br><span class="line">    P[K] <span class="keyword">extends</span> (arg: <span class="built_in">Promise</span>&lt;infer T&gt;) =&gt; <span class="built_in">Promise</span>&lt;infer U&gt; ? <span class="function">(<span class="params">arg: T</span>) =&gt;</span> U :</span><br><span class="line">      P[K] <span class="keyword">extends</span> (arg: Action&lt;infer T&gt;) =&gt; Action&lt;infer U&gt; ? <span class="function">(<span class="params">arg: T</span>) =&gt;</span> Action&lt;U&gt; :</span><br><span class="line">        never</span><br><span class="line"><span class="keyword">type</span> Connect = <span class="function">(<span class="params"><span class="built_in">module</span>: EffectModule</span>) =&gt;</span> ExtractContainer&lt;EffectModule&gt;</span><br></pre></td></tr></table></figure><p>完整代码在我的 <a href="https://gist.github.com/azl397985856/5aecb2e221dc1b9b15af34680acb6ccf" title="Gist  地址" target="_blank" rel="noopener">Gist</a> 上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们先对问题进行定义，然后分解问题为：<code>1. 如何将非函数属性去掉</code>, <code>2. 如何转换函数类型签名</code>。最后从分解的问题，以及基础泛型工具入手，联系到可能用到的语法。</p><p>这个题目不算难，最多只是中等。但是你可能也看出来了，其不仅仅是考一个语法和 API 而已，而是考综合实力。这点在其他四道题体现地尤为明显。这种考察方式能真正考察一个人的综合实力，背题是背不来的。我个人在面试别人的时候也非常喜欢问这种问题。</p><p>只有<strong>掌握基础 + 解决问题的思维方法</strong>，面对复杂问题才能从容不迫，手到擒来。</p><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的前端硬核文章，带你认识你不知道的前端。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxro1x125j30oz0dw43s.jpg" alt></p><p>知乎专栏【 <a href="https://www.zhihu.com/people/lu-xiao-13-70" title=" Lucifer - 知乎" target="_blank" rel="noopener">Lucifer - 知乎</a>】</p><p>点关注，不迷路！</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你的衣服我扒了 - 《最长公共子序列》</title>
      <link href="/blog/2020/07/01/LCS/"/>
      <url>/blog/2020/07/01/LCS/</url>
      
        <content type="html"><![CDATA[<p>之前出了一篇<a href="https://lucifer.ren/blog/2020/06/20/LIS/">穿上衣服我就不认识你了？来聊聊最长上升子序列</a>，收到了大家的一致好评。今天给大家带来的依然是换皮题 - 最长公共子序列系列。</p><p>最长公共子序列是一个很经典的算法题。有的会直接让你求最长上升子序列，有的则会换个说法，但最终考察的还是最长公共子序列。那么问题来了，它穿上衣服你还看得出来是么？</p><p>如果你完全看不出来了，说明抽象思维还不到火候。经常看我的题解的同学应该会知道，我经常强调<code>抽象思维</code>。没有抽象思维，所有的题目对你来说都是新题。你无法将之前做题的经验迁移到这道题，那你做的题意义何在？</p><p>虽然抽象思维很难练成，但是幸好算法套路是有限的，经常考察的题型更是有限的。从这些入手，或许可以让你轻松一些。本文就从一个经典到不行的题型《最长公共子序列》，来帮你进一步理解<code>抽象思维</code>。</p><blockquote><p>注意。 本文是帮助你识别套路，从横向上理清解题的思维框架，并没有采用最优解，所有的题目给的解法可能不是最优的，但是都可以通过所有的测试用例。如果你想看最优解，可以直接去讨论区看。或者期待我的<code>深入剖析系列</code>。</p></blockquote><a id="more"></a><h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718. 最长重复子数组"></a>718. 最长重复子数组</h2><h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给两个整数数组  A  和  B ，返回两个数组中公共的、长度最长的子数组的长度。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">A: [1,2,3,2,1]</span><br><span class="line">B: [3,2,1,4,7]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">长度最长的公共子数组是 [3, 2, 1]。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">1 &lt;= len(A), len(B) &lt;= 1000</span><br><span class="line">0 &lt;= A[i], B[i] &lt; 100</span><br></pre></td></tr></table></figure><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>哈希表</li><li>数组</li><li>二分查找</li><li>动态规划</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这就是最经典的最长公共子序列问题。一般这种求解<strong>两个数组或者字符串求最大或者最小</strong>的题目都可以考虑动态规划，并且通常都定义 dp[i][j] 为 <code>以 A[i], B[j] 结尾的 xxx</code>。这道题就是：<code>以 A[i], B[j] 结尾的两个数组中公共的、长度最长的子数组的长度</code>。</p><blockquote><p>关于状态转移方程的选择可以参考： <a href="https://lucifer.ren/blog/2020/06/20/LIS/">穿上衣服我就不认识你了？来聊聊最长上升子序列</a></p></blockquote><p>算法很简单：</p><ul><li>双层循环找出所有的 i, j 组合，时间复杂度 $O(m * n)$，其中 m 和 n 分别为 A 和 B 的 长度。<ul><li>如果 A[i] == B[j]，dp[i][j] = dp[i - 1][j - 1] + 1</li><li>否则，dp[i][j] = 0</li></ul></li><li>循环过程记录最大值即可。</li></ul><p><strong>记住这个状态转移方程，后面我们还会频繁用到。</strong></p><h3 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h3><ul><li>dp 建模套路</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码支持：Python</p><p>Python Code:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLength</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        m, n = len(A), len(B)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, dp[i][j])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(m * n)$，其中 m 和 n 分别为 A 和 B 的 长度。</li><li>空间复杂度：$O(m * n)$，其中 m 和 n 分别为 A 和 B 的 长度。</li></ul><blockquote><p>二分查找也是可以的，不过并不容易想到，大家可以试试。</p></blockquote><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143.最长公共子序列"></a>1143.最长公共子序列</h2><h3 id="题目地址-1"><a href="#题目地址-1" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串  text1 和  text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的   子序列   是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><p>示例 1:</p><p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace”，它的长度为 3。<br>示例 2:</p><p>输入：text1 = “abc”, text2 = “abc”<br>输出：3<br>解释：最长公共子序列是 “abc”，它的长度为 3。<br>示例 3:</p><p>输入：text1 = “abc”, text2 = “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0。</p><p>提示:</p><p>1 &lt;= text1.length &lt;= 1000<br>1 &lt;= text2.length &lt;= 1000<br>输入的字符串只含有小写英文字符。</p><h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>数组</li><li>动态规划</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和上面的题目类似，只不过数组变成了字符串（这个无所谓），子数组（连续）变成了子序列 （非连续）。</p><p>算法只需要一点小的微调： <code>如果 A[i] != B[j]，那么 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</code></p><h3 id="关键点解析-1"><a href="#关键点解析-1" class="headerlink" title="关键点解析"></a>关键点解析</h3><ul><li>dp 建模套路</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><blockquote><p>你看代码多像</p></blockquote><p>代码支持：Python</p><p>Python Code:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, A: str, B: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(A), len(B)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, dp[i][j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(m * n)$，其中 m 和 n 分别为 A 和 B 的 长度。</li><li>空间复杂度：$O(m * n)$，其中 m 和 n 分别为 A 和 B 的 长度。</li></ul><h2 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a>1035. 不相交的线</h2><h3 id="题目地址-2"><a href="#题目地址-2" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/uncrossed-lines/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/uncrossed-lines/description/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们在两条独立的水平线上按给定的顺序写下  A  和  B  中的整数。</p><p>现在，我们可以绘制一些连接两个数字  A[i]  和  B[j]  的直线，只要  A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p><p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p><p>示例 1：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ggbkku13xuj315x0u0abp.jpg" alt></p><p>输入：A = [1,4,2], B = [1,2,4]<br>输出：2<br>解释：<br>我们可以画出两条不交叉的线，如上图所示。<br>我们无法画出第三条不相交的直线，因为从 A[1]=4 到 B[2]=4 的直线将与从 A[2]=2 到 B[1]=2 的直线相交。<br>示例 2：</p><p>输入：A = [2,5,1,2,5], B = [10,5,2,1,5,2]<br>输出：3<br>示例 3：</p><p>输入：A = [1,3,7,1,7,5], B = [1,9,2,5,1]<br>输出：2</p><p>提示：</p><p>1 &lt;= A.length &lt;= 500<br>1 &lt;= B.length &lt;= 500<br>1 &lt;= A[i], B[i] &lt;= 2000</p><h3 id="前置知识-2"><a href="#前置知识-2" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>数组</li><li>动态规划</li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>从图中可以看出，如果想要不相交，则必然相对位置要一致，换句话说就是：<strong>公共子序列</strong>。因此和上面的 <code>1143.最长公共子序列</code> 一样，属于换皮题，代码也是一模一样。</p><h3 id="关键点解析-2"><a href="#关键点解析-2" class="headerlink" title="关键点解析"></a>关键点解析</h3><ul><li>dp 建模套路</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><blockquote><p>你看代码多像</p></blockquote><p>代码支持：Python</p><p>Python Code:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, A: str, B: str)</span> -&gt; int:</span></span><br><span class="line">        m, n = len(A), len(B)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, dp[i][j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(m * n)$，其中 m 和 n 分别为 A 和 B 的 长度。</li><li>空间复杂度：$O(m * n)$，其中 m 和 n 分别为 A 和 B 的 长度。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一道是“子串”题型，第二和第三则是“子序列”。不管是“子串”还是“子序列”，状态定义都是一样的，不同的只是一点小细节。</p><p><strong>只有熟练掌握基础的数据结构与算法，才能对复杂问题迎刃有余。</strong> 基础算法，把它彻底搞懂，再去面对出题人的各种换皮就不怕了。相反，如果你不去思考题目背后的逻辑，就会刷地很痛苦。题目稍微一变化你就不会了，这也是为什么很多人说<strong>刷了很多题，但是碰到新的题目还是不会做</strong>的原因之一。关注公众号力扣加加，努力用清晰直白的语言还原解题思路，并且有大量图解，手把手教你识别套路，高效刷题。</p><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 最长公共子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>穿上衣服我就不认识你了？来聊聊最长上升子序列</title>
      <link href="/blog/2020/06/20/LIS/"/>
      <url>/blog/2020/06/20/LIS/</url>
      
        <content type="html"><![CDATA[<p>最长上升子序列是一个很经典的算法题。有的会直接让你求最长上升子序列，有的则会换个说法，但最终考察的还是最长上升子序列。那么问题来了，它穿上衣服你还看得出来是么？</p><p>如果你完全看不出来了，说明抽象思维还不到火候。经常看我的题解的同学应该会知道，我经常强调<code>抽象思维</code>。没有抽象思维，所有的题目对你来说都是新题。你无法将之前做题的经验迁移到这道题，那你做的题意义何在？</p><p>虽然抽象思维很难练成，但是幸好算法套路是有限的，经常考察的题型更是有限的。从这些入手，或许可以让你轻松一些。本文就从一个经典到不行的题型《最长上升子序列》，来帮你进一步理解<code>抽象思维</code>。</p><blockquote><p>注意。 本文是帮助你识别套路，从横向上理清解题的思维框架，并没有采用最优解，所有的题目给的解法都不是最优的，但是都可以通过所有的测试用例。如果你想看最优解，可以直接去讨论区看。或者期待我的<code>深入剖析系列</code>。</p></blockquote><a id="more"></a><h2 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a>300. 最长上升子序列</h2><h3 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定一个无序的整数数组，找到其中最长上升子序列的长度。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</span><br><span class="line">你算法的时间复杂度应该为 O(n2) 。</span><br><span class="line">进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>美团和华为都考了这个题。</p></blockquote><p>题目的意思是让我们从给定数组中挑选若干数字，这些数字满足： <code>如果 i &lt; j 则 nums[i] &lt; nums[j]</code>。问：一次可以挑选最多满足条件的数字是多少个。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyyu7187bj31ku0igq6f.jpg" alt></p><p>这种子序列求极值的题目，应该要考虑到贪心或者动态规划。这道题贪心是不可以的，我们考虑动态规划。</p><p>按照动态规划定义状态的套路，我们有<strong>两种常见</strong>的定义状态的方式：</p><ul><li>dp[i] : 以 i 结尾（一定包括 i）所能形成的最长上升子序列长度, 答案是 max(dp[i])，其中 i = 0,1,2, …, n - 1</li><li>dp[i] : 以 i 结尾（可能包括 i）所能形成的最长上升子序列长度，答案是 dp[-1] （-1 表示最后一个元素）</li></ul><p>容易看出第二种定义方式由于无需比较不同的 dp[i] 就可以获得答案，因此更加方便。但是想了下，状态转移方程会很不好写，因为 dp[i] 的末尾数字（最大的）可能是 任意 j &lt; i 的位置。</p><p>第一种定义方式虽然需要比较不同的 dp[i] 从而获得结果，但是我们可以在循环的时候顺便得出，对复杂度不会有影响，只是代码多了一点而已。因此我们<strong>选择第一种建模方式</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyyz18gu6j31t40dy77l.jpg" alt></p><p>由于 dp[j] 中一定会包括 j，且以 j 结尾， 那么 nums[j] 一定是其所形成的序列中最大的元素，那么如果位于其后（意味着 i &gt; j）的 nums[i] &gt; nums[j]，那么 nums[i] 一定能够融入 dp[j] 从而形成更大的序列，这个序列的长度是 dp[j] + 1。因此状态转移方程就有了：<code>dp[i] = dp[j] + 1 (其中 i &gt; j, nums[i] &gt; nums[j])</code></p><p>以 <code>[10, 9, 2, 5, 3, 7, 101, 18]</code> 为例，当我们计算到 dp[5]的时候，我们需要往回和 0，1，2，3，4 进行比较。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzzp18iyej311i0o8dk8.jpg" alt></p><p>具体的比较内容是：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzzqeaen1j30um0fwwhd.jpg" alt></p><p>最后从三个中选一个最大的 + 1 赋给 dp[5]即可。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzzt54n5wj30ys05g74x.jpg" alt></p><p><strong>记住这个状态转移方程，后面我们还会频繁用到。</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLIS</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">                    ans = max(ans, dp[i])</span><br><span class="line">        <span class="keyword">return</span>  ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N ^ 2)$</li><li>空间复杂度：$O(N)$</li></ul><h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435. 无重叠区间"></a>435. 无重叠区间</h2><h3 id="题目地址-1"><a href="#题目地址-1" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/non-overlapping-intervals/</a></p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">可以认为区间的终点总是大于它的起点。</span><br><span class="line">区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们先来看下最终<strong>剩下</strong>的区间。由于剩下的区间都是不重叠的，因此剩下的<strong>相邻区间的后一个区间的开始时间一定是不小于前一个区间的结束时间的</strong>。 比如我们剩下的区间是<code>[ [1,2], [2,3], [3,4] ]</code>。就是第一个区间的 2 小于等于 第二个区间的 2，第二个区间的 3 小于等于第三个区间的 3。</p><p>不难发现如果我们将<code>前面区间的结束</code>和<code>后面区间的开始</code>结合起来看，其就是一个<strong>非严格递增序列</strong>。而我们的目标就是删除若干区间，从而<strong>剩下最长的非严格递增子序列</strong>。这不就是上面的题么？只不过上面是严格递增，这不重要，就是改个符号的事情。 上面的题你可以看成是删除了若干数字，然后剩下<strong>剩下最长的严格递增子序列</strong>。 <strong>这就是抽象的力量，这就是套路。</strong></p><p>如果对区间按照起点或者终点进行排序，那么就转化为上面的最长递增子序列问题了。和上面问题不同的是，由于是一个区间。因此实际上，我们是需要拿<strong>后面的开始时间</strong>和<strong>前面的结束时间</strong>进行比较。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfyzp8n59cj31000a2jse.jpg" alt></p><p>而由于：</p><ul><li>题目求的是需要移除的区间，因此最后 return 的时候需要做一个转化。</li><li>题目不是要求严格递增，而是可以相等，因此我们的判断条件要加上等号。</li></ul><blockquote><p>这道题还有一种贪心的解法，其效率要比动态规划更好，但由于和本文的主题不一致，就不在这里讲了。</p></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p><strong>你看代码多像</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(intervals)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        intervals.sort(key=<span class="keyword">lambda</span> a: a[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(intervals)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= intervals[j][<span class="number">1</span>]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">                    <span class="comment"># 由于我事先进行了排序，因此倒着找的时候，找到的第一个一定是最大的数，因此不用往前继续找了。</span></span><br><span class="line">                    <span class="comment"># 这也是为什么我按照结束时间排序的原因。</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            dp[i] = max(dp[i], dp[i - <span class="number">1</span>])</span><br><span class="line">            ans = max(ans, dp[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n - ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N ^ 2)$</li><li>空间复杂度：$O(N)$</li></ul><h2 id="646-最长数对链"><a href="#646-最长数对链" class="headerlink" title="646. 最长数对链"></a>646. 最长数对链</h2><h3 id="题目地址-2"><a href="#题目地址-2" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-length-of-pair-chain/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-length-of-pair-chain/</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</span><br><span class="line"></span><br><span class="line">现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</span><br><span class="line"></span><br><span class="line">给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</span><br><span class="line"></span><br><span class="line">示例 :</span><br><span class="line"></span><br><span class="line">输入: [[1,2], [2,3], [3,4]]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长的数对链是 [1,2] -&gt; [3,4]</span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">给出数对的个数在 [1, 1000] 范围内。</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>和上面的<code>435. 无重叠区间</code>是换皮题，唯一的区别这里又变成了严格增加。没关系，我们把等号去掉就行了。并且由于这道题求解的是最长的长度，因此转化也不需要了。</p><blockquote><p>当然，这道题也有一种贪心的解法，其效率要比动态规划更好，但由于和本文的主题不一致，就不在这里讲了。</p></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p><strong>这代码更像了！</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLongestChain</span><span class="params">(self, pairs: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(pairs)</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        pairs.sort(key=<span class="keyword">lambda</span> a: a[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> pairs[i][<span class="number">0</span>] &gt; pairs[j][<span class="number">1</span>]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">                    ans = max(ans, dp[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N ^ 2)$</li><li>空间复杂度：$O(N)$</li></ul><h2 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h2><h3 id="题目地址-3"><a href="#题目地址-3" class="headerlink" title="题目地址"></a>题目地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。</span><br><span class="line"></span><br><span class="line">一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[[10,16], [2,8], [1,6], [7,12]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。</span><br></pre></td></tr></table></figure><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>把气球看成区间，几个箭可以全部射爆，意思就是有多少不重叠的区间。注意这里重叠的情况也可以射爆。这么一抽象，就和上面的<code>646. 最长数对链</code>一模一样了，不用我多说了吧？</p><blockquote><p>当然，这道题也有一种贪心的解法，其效率要比动态规划更好，但由于和本文的主题不一致，就不在这里讲了。</p></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p><strong>代码像不像？</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinArrowShots</span><span class="params">(self, points: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(points)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        points.sort(key=<span class="keyword">lambda</span> a:a[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> points[i][<span class="number">0</span>] &gt; points[j][<span class="number">1</span>]:</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">                    cnt = max(cnt, dp[i])</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N ^ 2)$</li><li>空间复杂度：$O(N)$</li></ul><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p>其他的我就不一一说了。比如 <a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/" target="_blank" rel="noopener">673. 最长递增子序列的个数</a> （滴滴面试题）。 不就是求出最长序列，之后再循环比对一次就可以得出答案了么？</p><p><a href="https://leetcode-cn.com/problems/increasing-subsequences/" target="_blank" rel="noopener">491. 递增子序列</a> 由于需要找到所有的递增子序列，因此动态规划就不行了，妥妥回溯就行了，套一个模板就出来了。回溯的模板可以看我之前写的<a href="https://github.com/azl397985856/leetcode/blob/master/problems/90.subsets-ii.md" title="回溯专题" target="_blank" rel="noopener">回溯专题</a>。</p><p>大家把我讲的思路搞懂，这几个题一写，还怕碰到类似的题不会么？<strong>只有熟练掌握基础的数据结构与算法，才能对复杂问题迎刃有余。</strong> 最长上升子序列就是一个非常经典的基础算法，把它彻底搞懂，再去面对出题人的各种换皮就不怕了。相反，如果你不去思考题目背后的逻辑，就会刷地很痛苦。题目稍微一变化你就不会了，这也是为什么很多人说<strong>刷了很多题，但是碰到新的题目还是不会做</strong>的原因之一。关注公众号力扣加加，努力用清晰直白的语言还原解题思路，并且有大量图解，手把手教你识别套路，高效刷题。</p><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 最长上升子序列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的 TypeScript 泛型（万字长文，建议收藏）</title>
      <link href="/blog/2020/06/16/ts-generics/"/>
      <url>/blog/2020/06/16/ts-generics/</url>
      
        <content type="html"><![CDATA[<p>泛型是 TypeScript（以下简称 TS） 比较高级的功能之一，理解起来也比较困难。泛型应用场景非常广泛，很多地方都能看到它的影子。平时我们阅读开源 TS 项目源码，或者在自己的 TS 项目中使用一些第三方库（比如 React）的时候，经常会看到各种泛型定义。如果你不是特别了解泛型，那么你很可能不仅不会用，不会实现，甚至看不懂这是在干什么。</p><p>相信大家都经历过，看到过，或者正在写<strong>一些应用，这些应用充斥着各种重复类型定义， any 类型层出不穷，鼠标移到变量上面的提示只有 any，不要说类型操作了，类型能写对都是个问题</strong>。我也经历过这样的阶段，那个时候我对 TS 还比较陌生。</p><p>随着在 TS 方面学习的深入，越来越认识到 <strong>真正的 TS 高手都是在玩类型</strong>，对类型进行各种运算生成新的类型。这也好理解，毕竟 <strong>TS 提供的其实就是类型系统</strong>。你去看那些 TS 高手的代码，会各种<strong>花式使用泛型</strong>。 可以说泛型是一道坎，只有真正掌握它，你才知道<strong>原来 TS 还可以这么玩</strong>。怪不得面试的时候大家都愿意问泛型，尽管面试官很可能也不怎么懂。</p><p><strong>只有理解事物的内在逻辑，才算真正掌握了，不然永远只是皮毛，不得其法</strong>。 本文就带你走进泛型，带你从另一个角度看看究竟什么是泛型，为什么要有它，它给 TS 带来了什么样的不同。</p><blockquote><p>注意：不同语言泛型略有不同，知识迁移虽然可以，但是不能生搬硬套，本文所讲的泛型都指的是 TS 下的泛型。</p></blockquote><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我总结了一下，学习 TS 有两个难点。第一个是<code>TS 和 JS 中容易混淆的写法</code>，第二个是<code>TS中特有的一些东西</code>。</p><ul><li>TS 中容易引起大家的混淆的写法</li></ul><p>比如：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfwlko8ermj310x0fx77r.jpg" alt="容易混淆的箭头函数"></p><p>（容易混淆的箭头函数）</p><p>再比如：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfwlnifyi5j311j0ao0vw.jpg" alt></p><p>（容易混淆的 interface 内的小括号）</p><ul><li>TS 中特有的一些东西</li></ul><p>比如 typeof，keyof， infer 以及本文要讲的泛型。</p><p><strong>把这些和 JS 中容易混淆的东西分清楚，然后搞懂 TS 特有的东西，尤其是泛型</strong>（其他基本上相对简单），TS 就入门了。</p><h3 id="泛型初体验"><a href="#泛型初体验" class="headerlink" title="泛型初体验"></a>泛型初体验</h3><p>在强类型语言中，一般而言需要给变量指定类型才能使用该变量。如下代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name: <span class="built_in">string</span> = <span class="string">"lucifer"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure><p>我们需要给 name 声明 string 类型，然后才能在后面使用 name 变量，当我们执行以下操作的时候会报错。</p><ul><li>给 name 赋其他类型的值</li><li>使用其他类型值特有的方法（比如 Number 类型特有的 toFixed）</li><li>将 name 以参数传给不支持 string 的函数。 比如 <code>divide(1, name)</code>,其中 divide 就是功能就是<code>将第一个数（number 类型）除以第二个数（number 类型），并将结果返回</code>。</li></ul><p>TS 除了提供一些基本类型（比如上面的 string）供我们直接使用。还：</p><ul><li>提供了 <code>inteface</code> 和 <code>type</code> 关键字供我们定义自己的类型，之后就能像使用基本类型一样使用自己定义的类型了。</li><li>提供了各种逻辑运算符，比如 &amp;, | 等 ，供我们对类型进行操作，从而生成新的类型。</li><li>提供泛型，允许我们在定义的时候不具体指定类型，而是泛泛地说一种类型，并在函数调用的时候再指定具体的参数类型。</li><li>。。。</li></ul><p>也就是说泛型也是一种类型，只不过不同于 string, number 等具体的类型，它是一种抽象的类型，我们不能直接定义一个变量类型为泛型。</p><p>简单来说，区别于平时我们对<strong>值</strong>进行编程，泛型是对<strong>类型</strong>进行编程。这个听起来比较抽象。之后我们会通过若干实例带你理解这句话，你先留一个印象就好。</p><p>为了明白上面这句话，·首先要区分“值”和“类型”。</p><h3 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h3><p>我们平时写代码基本都是<strong>对值编程</strong>。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (person.isVIP) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'VIP'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personNames = persons.map(<span class="function"><span class="params">p</span> =&gt;</span> p.name)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看出这都是对具体的值进行编程，<strong>这符合我们对现实世界的抽象</strong>。从集合论的角度上来说， 值的集合就是类型，在 TS 中最简单的用法是对值限定类型，从根本上来说是限定值的集合。这个集合可以是一个具体的集合，也可以是多个集合通过集合运算（交叉并）生成的新集合。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfvq6o3iwcj32960su42q.jpg" alt></p><p>（值和类型）</p><p>再来看一个更具体的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">t(<span class="string">"lucifer"</span>);</span><br></pre></td></tr></table></figure><p>字符串 “lucifer” 是 string <strong>类型</strong>的一个具体<strong>值</strong>。 在这里 “lucifer” 就是值，而 string 就是类型。</p><p>TS 明白 “lucifer” 是 string 集合中的一个元素，因此上面代码不会有问题，但是如果是这样就会报错：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>因为 123 并不是 string 集合中的一个元素。</p><p>对于 t(“lucifer”)而言，TS 判断逻辑的伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v = getValue(); <span class="comment">// will return 'lucifer' by ast</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> v === <span class="string">"string"</span>) &#123;</span><br><span class="line">  <span class="comment">// ok</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"type error"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于是静态类型分析工具，因此 TS 并不会执行 JS 代码，但并不是说 TS 内部没有执行逻辑。</p></blockquote><p>简单来总结一下就是： 值的集合就是类型，平时写代码基本都是对值编程，TS 提供了很多<strong>类型</strong>（也可以自定义）以及很多<strong>类型操作</strong>帮助我们<strong>限定值以及对值的操作</strong>。</p><h2 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h2><p>上面已经铺垫了一番，大家已经知道了值和类型的区别，以及 TS 究竟帮我们做了什么事情。但是直接理解泛型仍然会比较吃力，接下来我会通过若干实例，慢慢带大家走进泛型。</p><p>首先来思考一个问题：<code>为什么要有泛型呢</code>？这个原因实际上有很多，在这里我选择大家普遍认同的一个切入点来解释。如果你明白了这个点，其他点相对而言理解起来会比较轻松。还是通过一个例子来进行说明。</p><h3 id="不容小觑的-id-函数"><a href="#不容小觑的-id-函数" class="headerlink" title="不容小觑的 id 函数"></a>不容小觑的 id 函数</h3><p>假如让你实现一个函数 <code>id</code>，函数的参数可以是任何值，返回值就是将参数原样返回，并且其只能接受一个参数，你会怎么做？</p><p>你会觉得这很简单，顺手就写出这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> id = <span class="function">(<span class="params">arg</span>) =&gt;</span> arg;</span><br></pre></td></tr></table></figure><blockquote><p>有的人可能觉得 id 函数没有什么实际作用。其实不然， id 函数在函数式编程中应用非常广泛。</p></blockquote><p>由于其可以接受任意值，也就是说你的函数的入参和返回值都应该可以是任意类型。 现在让我们给代码增加类型声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type idBoolean = <span class="function">(<span class="params">arg: boolean</span>) =&gt;</span> boolean;</span><br><span class="line">type idNumber = <span class="function">(<span class="params">arg: number</span>) =&gt;</span> number;</span><br><span class="line">type idString = <span class="function">(<span class="params">arg: string</span>) =&gt;</span> string;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一个笨的方法就像上面那样，也就是说 JS 提供多少种类型，就需要复制多少份代码，然后改下类型签名。这对程序员来说是致命的。这种复制粘贴增加了出错的概率，使得代码难以维护，牵一发而动全身。并且将来 JS 新增新的类型，你仍然需要修改代码，也就是说你的代码<strong>对修改开放</strong>，这样不好。还有一种方式是使用 any 这种“万能语法”。缺点是什么呢？我举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">id(<span class="string">"string"</span>).length; <span class="comment">// ok</span></span><br><span class="line">id(<span class="string">"string"</span>).toFixed(<span class="number">2</span>); <span class="comment">// ok</span></span><br><span class="line">id(<span class="literal">null</span>).toString(); <span class="comment">// ok</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果你使用 any 的话，怎么写都是 ok 的， 这就丧失了类型检查的效果。实际上我知道我传给你的是 string，返回来的也一定是 string，而 string 上没有 toFixed 方法，因此需要报错才是我想要的。也就是说我真正想要的效果是：<code>当我用到id的时候，你根据我传给你的类型进行推导</code>。比如我传入的是 string，但是使用了 number 上的方法，你就应该报错。</p><p>为了解决上面的这些问题，我们<strong>使用泛型对上面的代码进行重构</strong>。和我们的定义不同，这里用了一个 类型 T，这个 <strong>T 是一个抽象类型，只有在调用的时候才确定它的值</strong>，这就不用我们复制粘贴无数份代码了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这样就可以了？ 为什么要用这种写法？这个尖括号什么鬼？万物必有因果，之所以这么设计泛型也是有原因的。那么就让我来给大家解释一下，相信很多人都没有从这个角度思考过这个问题。</p><h3 id="泛型就是对类型编程"><a href="#泛型就是对类型编程" class="headerlink" title="泛型就是对类型编程"></a>泛型就是对类型编程</h3><p>上面提到了一个重要的点 <code>平时我们都是对值进行编程，泛型是对类型进行编程</code>。上面我没有给大家解释这句话。现在铺垫足够了，那就让我们开始吧！</p><p>继续举一个例子：假如我们定义了一个 Person 类，这个 Person 类有三个属性，并且都是必填的。这个 Person 类会被用于用户提交表单的时候限定表单数据。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Sex &#123;</span><br><span class="line">  Man,</span><br><span class="line">  Woman,</span><br><span class="line">  UnKnow,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  sex: Sex;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突然有一天，公司运营想搞一个促销活动，也需要用到 Person 这个 <code>shape</code>，但是这三个属性都可以选填，同时要求用户必须填写手机号以便标记用户和接受短信。一个很笨的方法是重新写一个新的类：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MarketPerson &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  sex?: Sex;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">  phone: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>还记得我开头讲的重复类型定义么？ 这就是！</p></blockquote><p>这明显不够优雅。如果 Person 字段很多呢?这种重复代码会异常多，不利于维护。 TS 的设计者当然不允许这么丑陋的设计存在。那么是否可以根据已有类型，生成新的类型呢？当然可以！答案就是前面我提到了两种对类型的操作：<strong>一种是集合操作，另一种是今天要讲的泛型。</strong></p><p>先来看下集合操作:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MarketPerson = Person &amp; &#123; phone: <span class="built_in">string</span> &#125;;</span><br></pre></td></tr></table></figure><p>这个时候我们虽然添加了一个必填字段 phone，但是没有做到<code>name, sex, age</code> 选填，似乎集合操作做不到这一点呀。我们脑洞一下，假如我们可以<strong>像操作函数那样操作类型</strong>，是不是有可能呢？比如我定义了一个函数 <code>Partial</code>，这个函数的功能入参是一个类型，返回值是新的类型，这个类型里的属性全部变成可选的。</p><p>伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Partial</span>(<span class="params">Type</span>) </span>&#123;</span><br><span class="line">    type ans = 空类型</span><br><span class="line">    <span class="keyword">for</span>(k <span class="keyword">in</span> Type) &#123;</span><br><span class="line">        空类型[k]  = makeOptional(Type, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PartialedPerson = Partial(Person)</span><br></pre></td></tr></table></figure><p>可惜的是上面代码不能运行，也不可能运行。不可能运行的原因有：</p><ul><li>这里使用函数 Partial 操作类型，可以看出上面的函数我是没有添加签名的，我是故意的。如果让你给这个函数添加签名你怎么加？没办法加！</li><li>这里使用 JS 的语法对类型进行操作，这是不恰当的。首先这种操作依赖了 JS 运行时，而 TS 是静态分析工具，不应该依赖 JS 运行时。其次如果要支持这种操作是否意味者 TS 对 JS 妥协，JS 出了新的语法（比如早几年出的 async await），TS 都要支持其对 TS 进行操作。</li></ul><p>因此迫切需要一种不依赖 JS 行为，特别是运行时行为的方式，并且逻辑其实和上面类似的，且不会和现有语法体系冲突的语法。 我们看下 TS 团队是怎么做的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以看成是上面的函数定义，可以接受任意类型。由于是这里的 “Type” 形参，因此理论上你叫什么名字都是无所谓的，就好像函数定义的形参一样。</span></span><br><span class="line">type Partial&lt;Type&gt; = &#123; <span class="keyword">do</span> something &#125;</span><br><span class="line"><span class="comment">// 可以看成是上面的函数调用，调用的时候传入了具体的类型 Person</span></span><br><span class="line">type PartialedPerson = Partial&lt;Person&gt;</span><br></pre></td></tr></table></figure><p>先不管功能，我们来看下这两种写法有多像：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxpuyc9hjj30nf05awhq.jpg" alt></p><p>（定义）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxpvjwoktj30od04tgnz.jpg" alt></p><p>（运行）</p><p>再来看下上面泛型的功能。上面代码的意思是对 T 进行处理，是返回一个 T 的子集，具体来说就是将 T 的所有属性变成可选。这时 <code>PartialedPerson</code> 就等于 :</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name?: <span class="built_in">string</span>;</span><br><span class="line">  sex?: Sex;</span><br><span class="line">  age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>功能和上面新建一个新的 interface 一样，但是更优雅。</p></blockquote><p>最后来看下泛型 Partial<type> 的具体实现，可以看出其没有直接使用 JS 的语法，而是自己定义了一套语法，比如这里的 <code>keyof</code>，至此完全应证了我上面的观点。</type></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;;</span><br></pre></td></tr></table></figure><blockquote><p>刚才说了“由于是形参，因此起什么名字无所谓” 。因此这里就起了 T 而不是 Type，更短了。这也算是一种约定俗称的规范，大家一般习惯叫 T， U 等表示泛型的形参。</p></blockquote><p>我们来看下完整的泛型和函数有多像！</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfwakdx0mcj30z40cywha.jpg" alt></p><p>（定义）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfwam1jg34j30fx0df75m.jpg" alt></p><p>（使用）</p><ul><li><p>从外表看只不过是 <code>function</code> 变成了 <code>type</code>，<code>()</code> 变成了 <code>&lt;&gt;</code>而已。</p></li><li><p>从语法规则上来看， 函数内部对标的是 ES 标准。而泛型对应的是 TS 实现的一套标准。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfwau8hq65j30yb0ad3zx.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfwce290nzj310t0km410.jpg" alt></p><p>简单来说，将类型看成值，然后对类型进行编程，这就是泛型的基本思想。泛型类似我们平时使用的函数，只不过其是作用在类型上，思想上和我们平时使用的函数并没有什么太多不同，泛型产生的具体类型也支持类型的操作。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type ComponentType&lt;P = &#123;&#125;&gt; = ComponentClass&lt;P&gt; | FunctionComponent&lt;P&gt;;</span><br></pre></td></tr></table></figure><p>有了上面的知识，我们通过几个例子来巩固一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">arg1: T, arg2: U</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面定义了泛型 id，其入参分别是 T 和 U，和函数参数一样，使用逗号分隔。定义了形参就可以在函数体内使用形参了。如上我们在函数的参数列表和返回值中使用了形参 T 和 U。</p><p>返回值也可以是复杂类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function ids&lt;T, U&gt;(arg1: T, arg2: U): [T, U] &#123;</span><br><span class="line">  <span class="keyword">return</span> [arg1, arg2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfz110rqdzj31sm0l278m.jpg" alt></p><p>（泛型的形参）</p><p>和上面类似， 只不过返回值变成了数组而已。</p><p>需要注意的是，思想上我们可以这样去理解。但是具体的实现过程会有一些细微差别，比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> P = [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">boolean</span>];</span><br><span class="line"><span class="keyword">type</span> Q = <span class="built_in">Date</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> R = [Q, ...P]; <span class="comment">// A rest element type must be an array type.</span></span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lucifer = LeetCode;</span><br><span class="line"><span class="keyword">type</span> LeetCode&lt;T = &#123;&#125;&gt; = &#123;</span><br><span class="line">  name: T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: LeetCode&lt;<span class="built_in">string</span>&gt;; <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">const</span> a: Lucifer&lt;<span class="built_in">string</span>&gt;; <span class="comment">// Type 'Lucifer' is not generic.</span></span><br></pre></td></tr></table></figure><p>改成这样是 ok 的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lucifer&lt;T&gt; = LeetCode&lt;T&gt;;</span><br></pre></td></tr></table></figure><h2 id="泛型为什么使用尖括号"><a href="#泛型为什么使用尖括号" class="headerlink" title="泛型为什么使用尖括号"></a>泛型为什么使用尖括号</h2><p>为什么泛型要用尖括号（&lt;&gt;），而不是别的？ 我猜是因为它和 () 长得最像，且在现在的 JS 中不会有语法歧义。但是，它和 JSX 不兼容！比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Form() &#123;</span><br><span class="line">  // ...</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;Select&lt;string&gt; options=&#123;targets&#125; value=&#123;target&#125; onChange=&#123;setTarget&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为 TS 发明这个语法的时候，还没想过有 JSX 这种东西。后来 TS 团队在 TypeScript 2.9 版本修复了这个问题。也就是说现在你可以直接在 TS 中使用带有泛型参数的 JSX 啦（比如上面的代码）。</p><h2 id="泛型的种类"><a href="#泛型的种类" class="headerlink" title="泛型的种类"></a>泛型的种类</h2><p>实际上除了上面讲到的函数泛型，还有接口泛型和类泛型。不过语法和含义基本同函数泛型一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface id&lt;T, U&gt; &#123;</span><br><span class="line">  id1: T;</span><br><span class="line">  id2: U;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（接口泛型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span>&lt;<span class="title">Props</span>, <span class="title">State</span>&gt; </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(类泛型)</p><p>总结下就是： 泛型的写法就是在标志符后面添加尖括号（&lt;&gt;），然后在尖括号里写形参，并在 body（函数体， 接口体或类体） 里用这些形参做一些逻辑处理。</p><h2 id="泛型的参数类型-“泛型约束”"><a href="#泛型的参数类型-“泛型约束”" class="headerlink" title="泛型的参数类型 - “泛型约束”"></a>泛型的参数类型 - “泛型约束”</h2><p>正如文章开头那样，我们可以对函数的参数进行限定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">name: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line">t(<span class="string">"lucifer"</span>);</span><br></pre></td></tr></table></figure><p>如上代码对函数的形参进行了类型限定，使得函数仅可以接受 string 类型的值。那么泛型如何达到类似的效果呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type MyType = <span class="function">(<span class="params">T: constrain</span>) =&gt;</span> &#123; <span class="keyword">do</span> something &#125;;</span><br></pre></td></tr></table></figure><p>还是以 id 函数为例，我们给 id 函数增加功能，使其不仅可以返回参数，还会打印出参数。熟悉函数式编程的人可能知道了，这就是 trace 函数，用于调试程序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如我想打印出参数的 size 属性呢？如果完全不进行约束 TS 是会报错的：</p><blockquote><p>注意：不同 TS 版本可能提示信息不完全一致，我的版本是 3.9.5。下文的所有测试结果均是使用该版本，不再赘述。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.size); <span class="comment">// Error: Property 'size doesn't exist on type 'T'</span></span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错的原因在于 T 理论上是可以是任何类型的，不同于 any，你不管使用它的什么属性或者方法都会报错（除非这个属性和方法是所有集合共有的）。那么直观的想法是限定传给 trace 函数的<strong>参数类型</strong>应该有 size 类型，这样就不会报错了。如何去表达这个<strong>类型约束</strong>的点呢？实现这个需求的关键在于使用类型约束。 使用 extends 关键字可以做到这一点。简单来说就是你定义一个类型，然后让 T 实现这个接口即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Sizeable &#123;</span><br><span class="line">  size: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trace</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Sizeable</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg.size);</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfwflqisraj312a0mijv8.jpg" alt></p><p>这个时候 T 就不再是任意类型，而是被实现接口的 shape，当然你也可以继承多个接口。<strong>类型约束是非常常见的操作，大家一定要掌握。</strong></p><blockquote><p>有的人可能说我直接将 Trace 的参数限定为 Sizeable 类型可以么？如果你这么做，会有类型丢失的风险，详情可以参考这篇文章<a href="https://juliangaramendy.dev/when-ts-generics/" title="A use case for TypeScript Generics" target="_blank" rel="noopener">A use case for TypeScript Generics</a>。</p></blockquote><h2 id="常见的泛型"><a href="#常见的泛型" class="headerlink" title="常见的泛型"></a>常见的泛型</h2><h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><p>大家平时写 TS 一定见过类似 <code>Array&lt;String&gt;</code> 这种写法吧？ 这其实是集合类，也是一种泛型。</p><p>本质上数组就是一系列值的集合，这些值可以可以是任意类型，数组只是一个容器而已。然而平时开发的时候通常数组的项目类型都是相同的，如果不加约束的话会有很多问题。 比如我应该是一个字符串数组，然是却不小心用到了 number 的方法，这个时候类型系统应该帮我识别出这种<strong>类型问题</strong>。</p><p>由于数组理论可以存放任意类型，因此需要使用者动态决定你想存储的数据类型，并且这些类型只有在被调用的时候才能去确定。 <code>Array&lt;String&gt;</code> 就是调用，经过这个调用会产生一个具体集合，这个集合只能存放 string 类型的值。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxqhlaya6j317y0dcgnl.jpg" alt></p><p>不调用直接把 Array 是不被允许的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">Array</span> = [<span class="string">"1"</span>];</span><br></pre></td></tr></table></figure><p>如上代码会被错：<code>Generic type &#39;Array&lt;T&gt;&#39; requires 1 type argument(s).ts</code> 。 有没有觉得和函数调用没传递参数报错很像？像就对了。</p><p>这个时候你再去看 Set<number>， Promise<string>，是不是很快就知道啥意思了？它们本质上都是包装类型，并且支持多种参数类型，因此可以用泛型来约束。</string></number></p><h3 id="React-FC"><a href="#React-FC" class="headerlink" title="React.FC"></a>React.FC</h3><p>大家如果开发过 React 的 TS 应用，一定知道 <code>React.FC</code> 这个类型。我们来看下它是如何<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts" title="React.FC Type Definition" target="_blank" rel="noopener">定义</a>的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type FC&lt;P = &#123;&#125;&gt; = FunctionComponent&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">interface FunctionComponent&lt;P = &#123;&#125;&gt; &#123;</span><br><span class="line">  (props: PropsWithChildren&lt;P&gt;, context?: any): ReactElement&lt;any, any&gt; | <span class="literal">null</span>;</span><br><span class="line">  propTypes?: WeakValidationMap&lt;P&gt;;</span><br><span class="line">  contextTypes?: ValidationMap&lt;any&gt;;</span><br><span class="line">  defaultProps?: Partial&lt;P&gt;;</span><br><span class="line">  displayName?: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出其大量使用了泛型。你如果不懂泛型怎么看得懂呢？不管它多复杂，我们从头一点点分析就行，记住我刚才讲的类比方法，将泛型类比到函数进行理解。·</p><ul><li>首先定义了一个泛型类型 FC，这个 FC 就是我们平时用的 React.FC。它是通过另外一个泛型 FunctionComponent 产生的。</li></ul><blockquote><p>因此，实际上第一行代码的作用就是起了一个别名</p></blockquote><ul><li>FunctionComponent 实际上是就是一个接口泛型，它定义了五个属性，其中四个是可选的，并且是静态类属性。</li><li>displayName 比较简单，而 propTypes，contextTypes，defaultProps 又是通过其他泛型生成的类型。我们仍然可以采用我的这个分析方法继续分析。由于篇幅原因，这里就不一一分析，读者可以看完我的分析过程之后，自己尝试分析一波。</li><li><code>(props: PropsWithChildren&lt;P&gt;, context?: any): ReactElement&lt;any, any&gt; | null;</code> 的含义是 FunctionComponent 是一个函数，接受两个参数（props 和 context ）返回 ReactElement 或者 null。ReactElement 大家应该比较熟悉了。<code>PropsWithChildren</code> 实际上就是往 props 中插入 children，源码也很简单，代码如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type PropsWithChildren&lt;P&gt; = P &amp; &#123; children?: ReactNode &#125;;</span><br></pre></td></tr></table></figure><p>这不就是我们上面讲的<strong>集合操作</strong>和 <strong>可选属性</strong>么？至此，React.FC 的全貌我们已经清楚了。读者可以试着分析别的源码检测下自己的学习效果，比如 <code>React.useState</code> 类型的签名。</p><h2 id="类型推导与默认参数"><a href="#类型推导与默认参数" class="headerlink" title="类型推导与默认参数"></a>类型推导与默认参数</h2><p>类型推导和默认参数是 TS 两个重要功能，其依然可以作用到泛型上，我们来看下。</p><h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>我们一般常见的类型推导是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">"lucifer"</span>; <span class="comment">// 我们没有给 a 声明类型， a 被推导为 string</span></span><br><span class="line">a.toFixed(); <span class="comment">// Property 'toFixed' does not exist on type 'string'.</span></span><br><span class="line">a.includes(<span class="string">"1"</span>); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>需要注意的是，类型推导是仅仅在初始化的时候进行推导，如下是无法正确推导的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">"lucifer"</span>; <span class="comment">// 我们没有给 a 声明类型， a 被推导为string</span></span><br><span class="line">a.toFixed(); <span class="comment">// Property 'toFixed' does not exist on type 'string'.</span></span><br><span class="line">a.includes(<span class="string">"1"</span>); <span class="comment">// ok</span></span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">a.toFixed(); <span class="comment">// 依然报错， a 不会被推导 为 number</span></span><br></pre></td></tr></table></figure><p>而泛型也支持类型推导，以上面的 id 函数为例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">id</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">id&lt;<span class="built_in">string</span>&gt;(<span class="string">"lucifer"</span>); <span class="comment">// 这是ok的，也是最完整的写法</span></span><br><span class="line">id(<span class="string">"lucifer"</span>); <span class="comment">// 基于类型推导，我们可以这样简写</span></span><br></pre></td></tr></table></figure><p>这也就是为什么 useState 有如下两种写法的原因。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = useState(<span class="string">"lucifer"</span>);</span><br><span class="line"><span class="keyword">const</span> [name, setName] = useState&lt;<span class="built_in">string</span>&gt;(<span class="string">"lucifer"</span>);</span><br></pre></td></tr></table></figure><p>实际的类型推导要更加复杂和智能。相信随着时间的推进，TS 的类型推导会更加智能。</p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>和<code>类型推导</code>相同的点是，默认参数也可以减少代码量，让你少些代码。前提是你要懂，不然伴随你的永远是大大的问号。其实你完全可以将其类比到函数的默认参数来理解。</p><p>举个例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A&lt;T = <span class="built_in">string</span>&gt; = <span class="built_in">Array</span>&lt;T&gt;;</span><br><span class="line"><span class="keyword">const</span> aa: A = [<span class="number">1</span>]; <span class="comment">// type 'number' is not assignable to type 'string'.</span></span><br><span class="line"><span class="keyword">const</span> bb: A = [<span class="string">"1"</span>]; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">const</span> cc: A&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>]; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>上面的 A 类型默认是 string 类型的数组。你可以不指定，等价于 Array<string>，当然你也可以显式指定数组类型。有一点需要注意：在 JS 中，函数也是值的一种，因此:</string></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">null</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>但是泛型这样是不行的，这是和函数不一样的地方（设计缺陷？Maybe）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type A = <span class="built_in">Array</span>; <span class="comment">// error: Generic type 'Array&lt;T&gt;' requires 1 type argument(s).</span></span><br></pre></td></tr></table></figure><p>其原因在与 Array 的定义是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Array&lt;T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果 Array 的类型也支持默认参数的话，比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Array&lt;T = string&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 <code>type A = Array;</code> 就是成立的，如果不指定的话，会默认为 string 类型。</p><h2 id="什么时候用泛型"><a href="#什么时候用泛型" class="headerlink" title="什么时候用泛型"></a>什么时候用泛型</h2><p>如果你认真看完本文，相信应该知道什么时候使用泛型了，我这里简单总结一下。</p><p>当你的函数，接口或者类：</p><ul><li>需要作用到很多类型的时候，比如我们介绍的 id 函数的泛型声明。</li><li>需要被用到很多地方的时候，比如我们介绍的 Partial 泛型。</li></ul><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>上面说了泛型和普通的函数有着很多相似的地方。普通的函数可以嵌套其他函数，甚至嵌套自己从而形成递归。泛型也是一样！</p><h3 id="泛型支持函数嵌套"><a href="#泛型支持函数嵌套" class="headerlink" title="泛型支持函数嵌套"></a>泛型支持函数嵌套</h3><p>比如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CutTail&lt;Tuple <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = Reverse&lt;CutHead&lt;Reverse&lt;Tuple&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure><p>如上代码中， Reverse 是将参数列表反转，CutHead 是将数组第一项切掉。因此 CutTail 的意思就是将传递进来的参数列表反转，切掉第一个参数，然后反转回来。换句话说就是切掉参数列表的最后一项。 比如，一个函数是 function fn (a: string, b: number, c: boolean):boolean {}，那么经过操作<code>type cutTailFn = CutTail&lt;typeof fn&gt;</code>，可以返回<code>(a: string, b:number) =&gt; boolean</code>。 具体实现可以参考<a href="https://zhuanlan.zhihu.com/p/147248333" title="Typescript 复杂泛型实践：如何切掉函数参数表的最后一个参数？" target="_blank" rel="noopener">Typescript 复杂泛型实践：如何切掉函数参数表的最后一个参数？</a>。 在这里，你知道泛型支持嵌套就够了。</p><h3 id="泛型支持递归"><a href="#泛型支持递归" class="headerlink" title="泛型支持递归"></a>泛型支持递归</h3><p>泛型甚至可以嵌套自己从而形成递归，比如我们最熟悉的单链表的定义就是递归的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ListNode&lt;T&gt; = &#123;</span><br><span class="line">  data: T;</span><br><span class="line">  next: ListNode&lt;T&gt; | <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（单链表）</p><p>再比如 <strong>HTMLElement</strong> 的定义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> HTMLElement: &#123;</span><br><span class="line">    prototype: HTMLElement;</span><br><span class="line">    <span class="keyword">new</span>(): HTMLElement;</span><br><span class="line">&#125;;。</span><br></pre></td></tr></table></figure><p>（<a href="https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts" title="HTMLElement Type Definition" target="_blank" rel="noopener">HTMLElement</a>）</p><p>上面是<strong>递归声明</strong>，我们再来看一个更复杂一点的递归形式 - <strong>递归调用</strong>，这个递归调用的功能是：<strong>递归地将类型中所有的属性都变成可选</strong>。类似于深拷贝那样，只不过这不是拷贝操作，而是变成可选，并且是作用在类型，而不是值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DeepPartial&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">Function</span></span><br><span class="line">  ? T</span><br><span class="line">  : T <span class="keyword">extends</span> object</span><br><span class="line">  ? &#123; [P <span class="keyword">in</span> keyof T]?: DeepPartial&lt;T[P]&gt; &#125;</span><br><span class="line">  : T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PartialedWindow = DeepPartial&lt;Window&gt;; <span class="comment">// 现在window 上所有属性都变成了可选啦</span></span><br></pre></td></tr></table></figure><h2 id="TS-泛型工具及实现"><a href="#TS-泛型工具及实现" class="headerlink" title="TS 泛型工具及实现"></a>TS 泛型工具及实现</h2><p>虽然泛型支持函数的嵌套，甚至递归，但是其语法能力肯定和 JS 没法比， 想要实现一个泛型功能真的不是一件容易的事情。这里提供几个例子，看完这几个例子，相信你至少可以达到比葫芦画瓢的水平。这样多看多练，慢慢水平就上来了。</p><p>截止目前（2020-06-21），TS 提供了 <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt" title="TS 官方的16 种工具类型" target="_blank" rel="noopener">16 种工具类型</a>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzuu9kjtnj30g80nqmze.jpg" alt></p><p>（官方提供的工具类型）</p><p>除了官方的工具类型，还有一些社区的工具类型，比如<a href="https://github.com/sindresorhus/type-fest" title="type-fest" target="_blank" rel="noopener">type-fest</a>，你可以直接用或者去看看源码看看高手是怎么玩类型的。</p><p>我挑选几个工具类，给大家讲一下<strong>实现原理</strong>。</p><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial</h3><p>功能是将类型的属性<strong>变成可选</strong>。注意这是浅 Partial，DeepPartial 上面我讲过了，只要配合递归调用使用即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;;</span><br></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required</h3><p>功能和<code>Partial</code> 相反，是将类型的属性<strong>变成必填</strong>， 这里的 <code>-</code>指的是去除。 <code>-?</code> 意思就是去除可选，也就是必填啦。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]-?: T[P] &#125;;</span><br></pre></td></tr></table></figure><h3 id="Mutable"><a href="#Mutable" class="headerlink" title="Mutable"></a>Mutable</h3><p>功能是将类型的属性<strong>变成可修改</strong>，这里的 <code>-</code>指的是去除。 <code>-readonly</code> 意思就是去除只读，也就是可修改啦。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutable&lt;T&gt; = &#123;</span><br><span class="line">  -readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly</h3><p>功能和<code>Mutable</code> 相反，功能是将类型的属性<strong>变成只读</strong>， 在属性前面增加 <code>readonly</code> 意思会将其变成只读。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123; readonly [P <span class="keyword">in</span> keyof T]: T[P] &#125;;</span><br></pre></td></tr></table></figure><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType</h3><p>功能是用来得到一个函数的返回值类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><p>下面的示例用 ReturnType 获取到 Func 的返回值类型为 string，所以，foo 也就只能被赋值为字符串了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Func = <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo: ReturnType&lt;Func&gt; = <span class="string">"1"</span>;</span><br></pre></td></tr></table></figure><p>更多参考<a href="https://github.com/microsoft/TypeScript/blob/master/src/lib/es5.d.ts#L1431" title="TS - es5.d.ts" target="_blank" rel="noopener">TS - es5.d.ts</a> 这些泛型可以极大减少大家的冗余代码，大家可以在自己的项目中自定义一些工具类泛型。</p><h2 id="Bonus-接口智能提示"><a href="#Bonus-接口智能提示" class="headerlink" title="Bonus - 接口智能提示"></a>Bonus - 接口智能提示</h2><p>最后介绍一个实用的小技巧。如下是一个接口的类型定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Seal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  url: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> API &#123;</span><br><span class="line">  <span class="string">"/user"</span>: &#123; name: <span class="built_in">string</span>; age: <span class="built_in">number</span>; phone: <span class="built_in">string</span> &#125;;</span><br><span class="line">  <span class="string">"/seals"</span>: &#123; seal: Seal[] &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> api = &lt;URL <span class="keyword">extends</span> keyof API&gt;(url: URL): <span class="built_in">Promise</span>&lt;API[URL]&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(url).then(<span class="function">(<span class="params">res</span>) =&gt;</span> res.json());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们通过泛型以及泛型约束，实现了智能提示的功能。使用效果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzwmfvajej30tu04cglu.jpg" alt></p><p>（接口名智能提示）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzwn2fovdj313u03egm2.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfzxwbhc6yj314q05oaaq.jpg" alt></p><p>（接口返回智能提示）</p><p>原理很简单，当你仅输入 api 的时候，其会将 API interface 下的所有 key 提示给你，当你输入某一个 key 的时候，其会根据 key 命中 interface 定义的类型，然后给予类型提示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习 Typescript 并不是一件简单的事情，尤其是没有其他语言背景的情况。而 TS 中最为困难的内容之一恐怕就是泛型了。</p><p>泛型和我们平时使用的函数是很像的，如果将两者进行横向对比，会很容易理解，很多函数的都关系可以迁移到泛型，比如函数嵌套，递归，默认参数等等。泛型是对类型进行编程，参数是类型，返回值是一个新的类型。我们甚至可以对泛型的参数进行约束，就类似于函数的类型约束。</p><p>最后通过几个高级的泛型用法以及若干使用的泛型工具类帮助大家理解和消化上面的知识。要知道真正的 TS 高手都是玩类型的，高手才不会满足于类型的交叉并操作。 泛型用的好确实可以极大减少代码量，提高代码维护性。如果用的太深入，也可能会团队成员面面相觑，一脸茫然。因此抽象层次一定要合理，不仅仅是泛型，整个软件工程都是如此。</p><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的前端硬核文章，带你认识你不知道的前端。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfxro1x125j30oz0dw43s.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> TypeScript </category>
          
          <category> 泛型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> TypeScript </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的前端异常处理（万字长文，建议收藏）</title>
      <link href="/blog/2020/06/14/error-catch/"/>
      <url>/blog/2020/06/14/error-catch/</url>
      
        <content type="html"><![CDATA[<p>除了调试，处理异常或许是程序员编程时间占比最高的了。我们天天和各种异常打交道，就好像我们天天和 Bug 打交道一样。因此正确认识异常，并作出合适的异常处理就显得很重要了。</p><p>我们先尝试抛开前端这个限定条件，来看下更广泛意义上程序的报错以及异常处理。不管是什么语言，都会有异常的发生。而我们程序员要做的就是正确识别程序中的各种异常，并针对其做相应的<strong>异常处理</strong>。</p><p>然而，很多人对异常的处理方式是<strong>事后修补</strong>，即某个异常发生的时候，增加对应的条件判断，这真的是一种非常低效的开发方式，非常不推荐大家这么做。那么究竟如何正确处理异常呢？由于不同语言有不同的特性，因此异常处理方式也不尽相同。但是异常处理的思维框架一定是一致的。本文就<strong>前端</strong>异常进行详细阐述，但是读者也可以稍加修改延伸到其他各个领域。</p><blockquote><p>本文讨论的异常指的是软件异常，而非硬件异常。</p></blockquote><a id="more"></a><h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p>用直白的话来解释异常的话，就是<strong>程序发生了意想不到的情况，这种情况影响到了程序的正确运行</strong>。</p><p>从根本上来说，异常就是一个<strong>数据结构</strong>，其保存了异常发生的相关信息，比如错误码，错误信息等。以 JS 中的标准内置对象 Error 为例，其标准属性有 name 和 message。然而不同的浏览器厂商有自己的自定义属性，这些属性并不通用。比如 Mozilla 浏览器就增加了 filename 和 stack 等属性。</p><p>值得注意的是错误只有被抛出，才会产生异常，不被抛出的错误不会产生异常。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br><span class="line">&#125;</span><br><span class="line">t();</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfsy45k62og30760h20ug.gif" alt></p><p>（动画演示）</p><p>这段代码不会产生任何的异常，控制台也不会有任何错误输出。</p><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><p>按照产生异常时程序是否正在运行，我们可以将错误分为<strong>编译时异常</strong>和<strong>运行时异常</strong>。</p><p>编译时异常指的是源代码在编译成可执行代码之前产生的异常。而运行时异常指的是可执行代码被装载到内存中执行之后产生的异常。</p><h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>我们知道 TS 最终会被编译成 JS，从而在 <code>JS Runtime</code>中执行。既然存在编译，就有可能编译失败，就会有编译时异常。</p><p>比如我使用 TS 写出了如下代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s: <span class="built_in">string</span> = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>这很明显是错误的代码， 我给 s 声明了 string 类型，但是却给它赋值 number。</p><p>当我使用 tsc（typescript 编译工具，全称是 typescript compiler）尝试编译这个文件的时候会有异常抛出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tsc a.ts</span><br><span class="line">a.ts:1:7 - error TS2322: Type <span class="string">'123'</span> is not assignable to <span class="built_in">type</span> <span class="string">'string'</span>.</span><br><span class="line"></span><br><span class="line">1 const s: string = 123;</span><br><span class="line">        ~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found 1 error.</span><br></pre></td></tr></table></figure><p>这个异常就是编译时异常，因为我的代码还没有执行。</p><p>然而并不是你用了 TS 才存在编译时异常，JS 同样有编译时异常。有的人可能会问 JS 不是解释性语言么？是边解释边执行，没有编译环节，怎么会有编译时异常？</p><p>别急，我举个例子你就明白了。如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">  <span class="keyword">await</span> sa</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;</span><br><span class="line">t()</span><br></pre></td></tr></table></figure><p>上面的代码由于存在语法错误，不会编译通过，因此并不会打印<code>start</code>，侧面证明了这是一个编译时异常。尽管 JS 是解释语言，也依然存在编译阶段，这是必然的，因此自然也会有编译异常。</p><p>总的来说，编译异常可以在代码被编译成最终代码前被发现，因此对我们的伤害更小。接下来，看一下令人心生畏惧的<strong>运行时异常</strong>。</p><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>相信大家对运行时异常非常熟悉。这恐怕是广大前端碰到最多的异常类型了。众所周知的 <a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E6%8C%87%E6%A8%99#NullPointerException" title="Null Pointer Exception" target="_blank" rel="noopener">NPE（Null Pointer Exception）</a> 就是运行时异常。</p><p>将上面的例子稍加改造，得到下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br><span class="line">&#125;</span><br><span class="line">t();</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfsy7388tng30760h2gn6.gif" alt></p><p>（动画演示）</p><blockquote><p>注意 end 没有打印，并且 t 没有弹出栈。实际上 t 最终还是会被弹出的，只不过和普通的返回不一样。</p></blockquote><p>如上，则会打印出<code>start</code>。由于异常是在代码运行过程中抛出的，因此这个异常属于运行时异常。相对于编译时异常，这种异常更加难以发现。上面的例子可能比较简单，但是如果我的异常是隐藏在某一个流程控制语句（比如 if else）里面呢？程序就可能在客户的电脑走入那个抛出异常的 if 语句，而在你的电脑走入另一条。这就是著名的 <strong>《在我电脑上好好的》</strong> 事件。</p><h2 id="异常的传播"><a href="#异常的传播" class="headerlink" title="异常的传播"></a>异常的传播</h2><p>异常的传播和我之前写的<a href="https://lucifer.ren/blog/2019/12/11/browser-event/" title="浏览器事件模型">浏览器事件模型</a>有很大的相似性。只不过那个是作用在 <strong>DOM 这样的数据结构</strong>，这个则是作用在<strong>函数调用栈这种数据结构</strong>，并且事件传播存在捕获阶段，异常传播是没有的。不同 C 语言，JS 中异常传播是自动的，不需要程序员手动地一层层传递。如果一个异常没有被 catch，它会沿着函数调用栈一层层传播直到栈空。</p><p>异常处理中有两个关键词，它们是<strong>throw（抛出异常）</strong> 和 <strong>catch（处理异常）</strong>。 当一个异常被抛出的时候，异常的传播就开始了。异常会不断传播直到遇到第一个 catch。 如果程序员没有手动 catch，那么一般而言程序会抛出类似<strong>unCaughtError</strong>，表示发生了一个异常，并且这个异常没有被程序中的任何 catch 语言处理。未被捕获的异常通常会被打印在控制台上，里面有详细的堆栈信息，从而帮助程序员快速排查问题。实际上我们的程序的目标是<strong>避免 unCaughtError</strong>这种异常，而不是一般性的异常。</p><h3 id="一点小前提"><a href="#一点小前提" class="headerlink" title="一点小前提"></a>一点小前提</h3><p>由于 JS 的 Error 对象没有 code 属性，只能根据 message 来呈现，不是很方便。我这里进行了简单的扩展，后面很多地方我用的都是自己扩展的 Error ，而不是原生 JS Error ，不再赘述。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">oldError = <span class="built_in">Error</span>;</span><br><span class="line"><span class="built_in">Error</span> = <span class="function"><span class="keyword">function</span> (<span class="params">&#123; code, message, fileName, lineNumber &#125;</span>) </span>&#123;</span><br><span class="line">  error = <span class="keyword">new</span> oldError(message, fileName, lineNumber);</span><br><span class="line">  error.code = code;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="手动抛出-or-自动抛出"><a href="#手动抛出-or-自动抛出" class="headerlink" title="手动抛出 or 自动抛出"></a>手动抛出 or 自动抛出</h3><p>异常既可以由程序员自己手动抛出，也可以由程序自动抛出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`I'm Exception`</span>);</span><br></pre></td></tr></table></figure><p>（手动抛出的例子）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">null</span>;</span><br><span class="line">a.toString(); <span class="comment">// Thrown: TypeError: Cannot read property 'toString' of null</span></span><br></pre></td></tr></table></figure><p>（程序自动抛出的例子）</p><p>自动抛出异常很好理解，毕竟我们哪个程序员没有看到过程序自动抛出的异常呢？</p><blockquote><p>“这个异常突然就跳出来！吓我一跳！”，某不知名程序员如是说。</p></blockquote><p>那什么时候应该手动抛出异常呢？</p><p>一个指导原则就是<strong>你已经预知到程序不能正确进行下去了</strong>。比如我们要实现除法，首先我们要考虑的是被除数为 0 的情况。当被除数为 0 的时候，我们应该怎么办呢？是抛出异常，还是 return 一个特殊值？答案是都可以，你自己能区分就行，这没有一个严格的参考标准。 我们先来看下抛出异常，告诉调用者<strong>你的输入，我处理不了</strong>这种情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  a = +a;</span><br><span class="line">  b = +b; <span class="comment">// 转化成数字</span></span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    <span class="comment">// 匹配 +0, -0, NaN</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(&#123;</span><br><span class="line">      code: <span class="number">1</span>,</span><br><span class="line">      message: <span class="string">"Invalid dividend "</span> + b,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(a)) &#123;</span><br><span class="line">    <span class="comment">// 匹配 NaN</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(&#123;</span><br><span class="line">      code: <span class="number">2</span>,</span><br><span class="line">      message: <span class="string">"Invalid divisor "</span> + a,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码会在两种情况下抛出异常，告诉调用者你的输入我处理不了。由于这两个异常都是程序员自动手动抛出的，因此是<strong>可预知的异常</strong>。</p><p>刚才说了，我们也可以通过返回值来区分<code>异常输入</code>。我们来看下返回值输入是什么，以及和异常有什么关系。</p><h3 id="异常-or-返回"><a href="#异常-or-返回" class="headerlink" title="异常 or 返回"></a>异常 or 返回</h3><p>如果是基于异常形式（遇到不能处理的输入就抛出异常）。当别的代码调用<code>divide</code>的时候，需要自己 catch。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    divide(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"被除数必须是除0之外的数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"除数必须是数字"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"不可预知的错误"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而就像上面我说的那样，divide 函数设计的时候，也完全可以不用异常，而是使用返回值来区分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  a = +a;</span><br><span class="line">  b = +b; <span class="comment">// 转化成数字</span></span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    <span class="comment">// 匹配 +0, -0, NaN</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(&#123;</span><br><span class="line">      code: <span class="number">1</span>,</span><br><span class="line">      message: <span class="string">"Invalid dividend "</span> + b,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(a)) &#123;</span><br><span class="line">    <span class="comment">// 匹配 NaN</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(&#123;</span><br><span class="line">      code: <span class="number">2</span>,</span><br><span class="line">      message: <span class="string">"Invalid divisor "</span> + a,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们使用方式也要作出相应改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = divide(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (res.code === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"被除数必须是除0之外的数"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (res.code === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"除数必须是数字"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"不可预知的错误"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种函数设计方式和抛出异常的设计方式从功能上说都是一样的，只是告诉调用方的方式不同。如果你选择第二种方式，而不是抛出异常，那么实际上需要调用方书写额外的代码，用来区分正常情况和异常情况，这并不是一种良好的编程习惯。</p><p>然而在 Go 等返回值可以为复数的语言中，我们无需使用上面蹩脚的方式，而是可以：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res, err := divide(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是和 Java 和 JS 等语言使用的 try catch 不一样的的地方，Go 是通过 panic recover defer 机制来进行异常处理的。感兴趣的可以去看看 <a href="https://github.com/golang/go/blob/master/src/os/error_test.go" title="Go 源码关于错误测试部分" target="_blank" rel="noopener">Go 源码关于错误测试部分</a></p><p>可能大家对 Go 不太熟悉。没关系，我们来继续看下 shell。实际上 shell 也是通过返回值来处理异常的，我们可以通过 $? 拿到上一个命令的返回值，这本质上也是一种调用栈的传播行为，而且是通过返回值而不是捕获来处理异常的。</p><blockquote><p>作为函数返回值处理和 try catch 一样，这是语言的设计者和开发者共同决定的一件事情。</p></blockquote><p>上面提到了异常传播是作用在<strong>函数调用栈</strong>上的。当一个异常发生的时候，其会沿着函数调用栈逐层返回，直到第一个 catch 语句。当然 catch 语句内部仍然可以触发异常（自动或者手动）。如果 catch 语句内部发生了异常，也一样会沿着其函数调用栈继续执行上述逻辑，专业术语是 <strong>stack unwinding</strong>。</p><blockquote><p>实际上并不是所有的语言都会进行 stack unwinding，这个我们会在接下来的《运行时异常可以恢复么？》部分讲解。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfsax74xjdj30ya0s040p.jpg" alt></p><p>伪代码来描述一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">error, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fn.hasCatchBlock()) &#123;</span><br><span class="line">    runCatchCode(error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (callstack.isNotEmpty()) &#123;</span><br><span class="line">    bubble(error, callstack.pop());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从我的伪代码可以看出所谓的 stack unwinding 其实就是 callstack.pop()</p></blockquote><p>这就是异常传播的一切！仅此而已。</p><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>我们已经了解来异常的传播方式了。那么接下来的问题是，我们应该如何在这个传播过程中处理异常呢？</p><p>我们来看一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"an error  occured"</span>);</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>我们将上面的代码放到 chrome 中执行， 会在控制台显示如下输出：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfs9viibxvj30gq08qjsf.jpg" alt></p><p>我们可以清楚地看出函数的调用关系。即错误是在 c 中发生的，而 c 是 b 调用的，b 是 a 调用的。这个函数调用栈是为了方便开发者定位问题而存在的。</p><p>上面的代码，我们并没有 catch 错误，因此上面才会有<strong>uncaught Error</strong>。</p><p>那么如果我们 catch ，会发生什么样的变化呢？catch 的位置会对结果产生什么样的影响？在 a ，b，c 中 catch 的效果是一样的么？</p><p>我们来分别看下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"an error  occured"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>(在 c 中 catch)</p><p>我们将上面的代码放到 chrome 中执行， 会在控制台显示如下输出：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfsa1idhyij30fw04at96.jpg" alt></p><p>可以看出，此时已经没有<strong>uncaught Error</strong>啦，仅仅在控制台显示了<strong>标准输出</strong>，而<strong>非错误输出</strong>（因为我用的是 console.log，而不是 console.error）。然而更重要是的是，如果我们没有 catch，那么后面的同步代码将不会执行。</p><p>比如在 c 的 throw 下面增加一行代码，这行代码是无法被执行的，<strong>无论这个错误有没有被捕获</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"an error  occured"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"will never run"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将 catch 移动到 b 中试试看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    c();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"an error  occured"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>(在 b 中 catch)</p><p>在这个例子中，和上面在 c 中捕获没有什么本质不同。其实放到 a 中捕获也是一样，这里不再贴代码了，感兴趣的自己试下。</p><p>既然处于函数调用栈顶部的函数报错， 其函数调用栈下方的任意函数都可以进行捕获，并且效果没有本质不同。那么问题来了，我到底应该在哪里进行错误处理呢？</p><p>答案是责任链模式。我们先来简单介绍一下责任链模式，不过细节不会在这里展开。</p><p>假如 lucifer 要请假。</p><ul><li>如果请假天数小于等于 1 天，则主管同意即可</li><li>如果请假大于 1 天，但是小于等于三天，则需要 CTO 同意。</li><li>如果请假天数大于三天，则需要老板同意。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfsbg56kx0j31tk0bc40k.jpg" alt></p><p>这就是一个典型的责任链模式。谁有责任干什么事情是确定的，不要做自己能力范围之外的事情。比如主管不要去同意大于 1 天的审批。</p><p>举个例子，假设我们的应用有三个异常处理类，它们分别是：<code>用户输入错误</code>，<code>网络错误</code> 和 <code>类型错误</code>。如下代码，当代码执行的时候会报错一个<code>用户输入异常</code>。这个异常没有被 C 捕获，会 unwind stack 到 b，而 b 中 catch 到这个错误之后，通过查看 code 值判断其可以被处理，于是打印<code>I can handle this</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    b();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="string">"NETWORK_ERROR"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"I can handle this"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// can't handle, pass it down</span></span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    c();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="string">"INPUT_ERROR"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"I can handle this"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// can't handle, pass it down</span></span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(&#123;</span><br><span class="line">    code: <span class="string">"INPUT_ERROR"</span>,</span><br><span class="line">    message: <span class="string">"an error  occured"</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>而如果 c 中抛出的是别的异常，比如<code>网络异常</code>，那么 b 是无法处理的，虽然 b catch 住了，但是由于你无法处理，因此一个好的做法是<code>继续抛出异常</code>，而不是<strong>吞没</strong>异常。不要畏惧错误，抛出它。<strong>只有没有被捕获的异常才是可怕的</strong>，如果一个错误可以被捕获并得到正确处理，它就不可怕。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    b();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="string">"NETWORK_ERROR"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"I can handle this"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// can't handle, pass it down</span></span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    c();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="string">"INPUT_ERROR"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"I can handle this"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(&#123;</span><br><span class="line">    code: <span class="string">"NETWORK_ERROR"</span>,</span><br><span class="line">    message: <span class="string">"an error  occured"</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>如上代码不会有任何异常被抛出，它被完全吞没了，这对我们调试问题简直是灾难。因此切记<strong>不要吞没你不能处理的异常</strong>。正确的做法应该是上面讲的那种<strong>只 catch 你可以处理的异常，而将你不能处理的异常 throw 出来</strong>，这就是责任链模式的典型应用。</p><p>这只是一个简单的例子，就足以绕半天。实际业务肯定比这个复杂多得多。因此异常处理绝对不是一件容易的事情。</p><p>如果说谁来处理是一件困难的事情，那么在异步中决定谁来处理异常就是难上加难，我们来看下。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步异步一直是前端难以跨越的坎，对于异常处理也是一样。以 NodeJS 中用的比较多的<strong>读取文件</strong> API 为例。它有两个版本，一个是异步，一个是同步。同步读取仅仅应该被用在没了这个文件无法进行下去的时候。比如读取一个配置文件。而不应该在比如浏览器中读取用户磁盘上的一个图片等，这样会造成主线程阻塞，导致浏览器卡死。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步读取文件</span></span><br><span class="line">fs.readFileSync();</span><br><span class="line"><span class="comment">// 同步读取文件</span></span><br><span class="line">fs.readFile();</span><br></pre></td></tr></table></figure><p>当我们试图<strong>同步</strong>读取一个不存在的文件的时候，会抛出以下异常：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.readFileSync(<span class="string">'something-not-exist.lucifer'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'脑洞前端'</span>);</span><br><span class="line">Thrown:</span><br><span class="line"><span class="built_in">Error</span>: ENOENT: no such file or directory, open <span class="string">'something-not-exist.lucifer'</span></span><br><span class="line">    at <span class="built_in">Object</span>.openSync (fs.js:<span class="number">446</span>:<span class="number">3</span>)</span><br><span class="line">    at <span class="built_in">Object</span>.readFileSync (fs.js:<span class="number">348</span>:<span class="number">35</span>) &#123;</span><br><span class="line">  errno: <span class="number">-2</span>,</span><br><span class="line">  syscall: <span class="string">'open'</span>,</span><br><span class="line">  code: <span class="string">'ENOENT'</span>,</span><br><span class="line">  path: <span class="string">'something-not-exist.lucifer'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且<code>脑洞前端</code>是不会被打印出来的。这个比较好理解，我们上面已经解释过了。</p><p>而如果以异步方式的话：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'something-not-exist.lucifer'</span>, (err, data) =&gt; &#123;<span class="keyword">if</span>(err) &#123;<span class="keyword">throw</span> err&#125;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'lucifer'</span>)</span><br><span class="line">lucifer</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">Thrown:</span><br><span class="line">[<span class="built_in">Error</span>: ENOENT: no such file or directory, open <span class="string">'something-not-exist.lucifer'</span>] &#123;</span><br><span class="line">  errno: <span class="number">-2</span>,</span><br><span class="line">  code: <span class="string">'ENOENT'</span>,</span><br><span class="line">  syscall: <span class="string">'open'</span>,</span><br><span class="line">  path: <span class="string">'something-not-exist.lucifer'</span></span><br><span class="line">&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><code>脑洞前端</code>是会被打印出来的。</p><p>其本质在于 fs.readFile 的函数调用已经成功，并从调用栈返回并执行到下一行的<code>console.log(&#39;lucifer&#39;)</code>。因此错误发生的时候，调用栈是空的，这一点可以从上面的错误堆栈信息中看出来。</p><blockquote><p>不明白为什么调用栈是空的同学可以看下我之前写的<a href="https://lucifer.ren/blog/2019/12/11/event-loop/" title="《一文看懂浏览器事件循环》">《一文看懂浏览器事件循环》</a></p></blockquote><p>而 try catch 的作用仅仅是捕获当前调用栈的错误（上面异常传播部分已经讲过了）。因此异步的错误是无法捕获的，比如；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  fs.readFile(<span class="string">"something-not-exist.lucifer"</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catching an error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 <code>catching an error</code> 不会被打印。因为错误抛出的时候， 调用栈中不包含这个 catch 语句，而仅仅在执行<code>fs.readFile</code>的时候才会。</p><p>如果我们换成同步读取文件的例子看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  fs.readFileSync(<span class="string">"something-not-exist.lucifer"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"catching an error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码会打印 <code>catching an error</code>。因为读取文件被同步发起，文件返回之前线程会被挂起，当线程恢复执行的时候， fs.readFileSync 仍然在函数调用栈中，因此 fs.readFileSync 产生的异常会冒泡到 catch 语句。</p><p>简单来说就是<strong>异步产生的错误不能用 try catch 捕获，而要使用回调捕获。</strong></p><p>可能有人会问了，我见过用 try catch 捕获异步异常啊。 比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rejectIn = <span class="function">(<span class="params">ms</span>) =&gt;</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">_, r</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      r(<span class="number">1</span>);</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> rejectIn(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"catching an error"</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t();</span><br></pre></td></tr></table></figure><p>本质上这只是一个语法糖，是 Promise.prototype.catch 的一个语法糖而已。而这一语法糖能够成立的原因在于其用了 Promise 这种包装类型。如果你不用包装类型，比如上面的 fs.readFile 不用 Promise 等包装类型包装，打死都不能用 try catch 捕获。</p><p>而如果我们使用 babel 转义下，会发现 try catch 不见了，变成了 switch case 语句。这就是 try catch “可以捕获异步异常”的原因，仅此而已，没有更多。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfsyweyu9tj30l90fajtj.jpg" alt><br>（babel 转义结果）</p><p>我使用的 babel 转义环境都记录在<a href="https://babeljs.io/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&build=&builtIns=usage&spec=true&loose=true&code_lz=E4UwViDGAuCSB2ACAvIgFAWwM4EoUD4AoRReEAd0QAVgB7DASyxDTQH0AaRYPZfRAN7ESiZtAAqDDCFoBXaK178hIkcDQBGHAG5hJAL5dsO4fpMBDLAE94kRADNZt6A1pIFeFYmjArgvYjm5OYM0NzgUHDwaAAMJgaIkObQkAAW6CDAPP6qkG5YtAA2IAB0hbQA5mgAREkpqQzwFYFImXTA1Vxt8Yj6hH2EHtpAA&debug=false&forceAllTransforms=true&shippedProposals=true&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=false&presets=env%2Ces2015%2Ces2016%2Ces2017%2Creact%2Cstage-0%2Cstage-1%2Cstage-2%2Cstage-3%2Ces2015-loose%2Ctypescript%2Cflow%2Cenv&prettier=false&targets=Electron-1.8%252CNode-10.13&version=7.10.2&externalPlugins=%40babel%2Fplugin-transform-arrow-functions%407.8.3" title="babel 转义环境" target="_blank" rel="noopener">这里</a>，大家可以直接点开链接查看.</p><blockquote><p>虽然浏览器并不像 babel 转义这般实现，但是至少我们明白了一点。目前的 try catch 的作用机制是无法捕获异步异常的。</p></blockquote><p>异步的错误处理推荐使用容器包装，比如 Promise。然后使用 catch 进行处理。实际上 Promise 的 catch 和 try catch 的 catch 有很多相似的地方，大家可以类比过去。</p><p>和同步处理一样，很多原则都是通用的。比如异步也不要去吞没异常。下面的代码是不好的，因为它吞没了<strong>它不能处理的</strong>异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">Promise</span>.reject(<span class="number">1</span>);</span><br><span class="line">p.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>更合适的做法的应该是类似这种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">Promise</span>.reject(<span class="number">1</span>);</span><br><span class="line">p.catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"I can handle this"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="彻底消除运行时异常可能么？"><a href="#彻底消除运行时异常可能么？" class="headerlink" title="彻底消除运行时异常可能么？"></a>彻底消除运行时异常可能么？</h2><p>我个人对目前前端现状最为头疼的一点是：<strong>大家过分依赖运行时，而严重忽略编译时</strong>。我见过很多程序，你如果不运行，根本不知道程序是怎么走的，每个变量的 shape 是什么。怪不得处处都可以看到 console.log。我相信你一定对此感同身受。也许你就是那个写出这种代码的人，也许你是给别人擦屁股的人。为什么会这样？ 就是因为大家太依赖运行时。TS 的出现很大程度上改善了这一点，前提是你用的是 typescript，而不是 anyscript。其实 eslint 以及 stylint 对此也有贡献，毕竟它们都是静态分析工具。</p><p>我强烈建议将异常保留在编译时，而不是运行时。不妨极端一点来看：假如所有的异常都在编译时发生，而一定不会在运行时发生。那么我们是不是就可以<strong>信心满满</strong>地对应用进行重构啦?</p><p>幸运的是，我们能够做到。只不过如果当前语言做不到的话，则需要对现有的语言体系进行改造。这种改造成本真的很大。不仅仅是 API，编程模型也发生了翻天覆地的变化，不然函数式也不会这么多年没有得到普及了。</p><blockquote><p>不熟悉函数编程的可以看看我之前写的<a href="https://github.com/azl397985856/functional-programming" title="函数式编程入门篇" target="_blank" rel="noopener">函数式编程入门篇</a>。</p></blockquote><p>如果才能彻底消除异常呢？在回答这个问题之前，我们先来看下一门号称<strong>没有运行时异常</strong>的语言 <a href="https://guide.elm-lang.org/error_handling/" target="_blank" rel="noopener">elm</a>。elm 是一门可以编译为 JS 的函数式编程语言，其封装了诸如网络 IO 等副作用，是一种声明式可推导的语言。 有趣的是，elm 也有异常处理。 elm 中关于异常处理（Error Handling）部分有两个小节的内容，分别是：<code>Maybe</code> 和 <code>Result</code>。elm 之所以没有运行时异常的一个原因就是它们。 一句话概括“为什么 elm 没有异常”的话，那就是<strong>elm 把异常看作数据（data）</strong>。</p><p>举个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">maybeResolveOrNot = <span class="function">(<span class="params">ms</span>) =&gt;</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"ok"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码有一半的可能报错。那么在 elm 中就不允许这样的情况发生。所有的可能发生异常的代码都会被强制包装一层容器，这个容器在这里是 Maybe。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gft3bwkkufj30hh082aac.jpg" alt></p><p>在其他函数式编程语言名字可能有所不同，但是意义相同。实际上，不仅仅是异常，正常的数据也会被包装到容器中，你需要通过容器的接口来获取数据。如果难以理解的话，你可以将其简单理解为 Promsie（但并不完全等价）。</p><p>Maybe 可能返回正常的数据 data，也可能会生成一个错误 error。某一个时刻只能是其中一个，并且只有运行的时候，我们才真正知道它是什么。从这一点来看，有点像薛定谔的猫。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gft3dcn99mj30yn0jkgno.jpg" alt></p><p>不过 Maybe 已经完全考虑到异常的存在，一切都在它的掌握之中。所有的异常都能够在编译时推导出来。当然要想推导出这些东西，你需要对整个编程模型做一定的封装会抽象，比如 DOM 就不能直接用了，而是需要一个中间层。</p><p>再来看下一个更普遍的例子 NPE：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>.toString();</span><br></pre></td></tr></table></figure><p>elm 也不会发生。原因也很简单，因为 null 也会被包装起来，当你通过这个包装类型就行访问的时候，容器有能力避免这种情况，因此就可以不会发生异常。当然这里有一个很重要的前提就是<strong>可推导</strong>，而这正是函数式编程语言的特性。这部分内容超出了本文的讨论范围，不再这里说了。</p><h2 id="运行时异常可以恢复么？"><a href="#运行时异常可以恢复么？" class="headerlink" title="运行时异常可以恢复么？"></a>运行时异常可以恢复么？</h2><p>最后要讨论的一个主题是运行时异常是否可以恢复。先来解释一下，什么是运行时异常的恢复。 还是用上面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br><span class="line">&#125;</span><br><span class="line">t();</span><br></pre></td></tr></table></figure><p>这个我们已经知道了， <code>end</code> 是不会打印的。 尽管你这么写也是无济于事：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"start"</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"relax, I can handle this"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">t();</span><br></pre></td></tr></table></figure><p>如果我想让它打印呢？我想让程序面对异常可以自己 recover 怎么办？我已经捕获这个错误， 并且我确信我可以处理，让流程继续走下去吧！如果有能力做到这个，这个就是<strong>运行时异常恢复</strong>。</p><p>遗憾地告诉你，据我所知，目前没有任何一个引擎能够做到这一点。</p><p>这个例子过于简单， 只能帮助我们理解什么是运行时异常恢复，但是不足以让我们看出这有什么用？</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gft490joaij30er0c4q3p.jpg" alt></p><p>我们来看一个更加复杂的例子，我们这里直接使用上面实现过的函数<code>divide</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = divide(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">    alert(<span class="string">`you got <span class="subst">$&#123;res&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"被除数必须是除0之外的数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"除数必须是数字"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"不可预知的错误"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，会进入 catch ，而不会 alert。因此对于用户来说， 应用程序是没有任何响应的。这是不可接受的。</p><blockquote><p>要吐槽一点的是这种事情真的是挺常见的，只不过大家用的不是 alert 罢了。</p></blockquote><p>如果我们的代码在进入 catch 之后还能够继续返回出错位置继续执行就好了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gftakhm2tqj31m20qcwmv.jpg" alt></p><p>如何实现异常中断的恢复呢？我刚刚说了：据我所知，目前没有任何一个引擎能够做到<strong>异常恢复</strong>。那么我就来<strong>发明一个新的语法</strong>解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = divide(<span class="string">"foo"</span>, <span class="string">"bar"</span>);</span><br><span class="line">    alert(<span class="string">`you got <span class="subst">$&#123;res&#125;</span>`</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"releax, I can handle this"</span>);</span><br><span class="line">    resume - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">t();</span><br></pre></td></tr></table></figure><p>上面的 resume 是我定义的一个关键字，功能是如果遇到异常，则返回到异常发生的地方，然后给当前发生异常的函数一个返回值 <strong>-1</strong>，并使得后续代码能够正常运行，不受影响。这其实是一种 fallback。</p><p>这绝对是一个超前的理念。当然挑战也非常大，对现有的体系冲击很大，很多东西都要改。我希望社区可以考虑把这个东西加到标准。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>通过前面的学习，你已经知道了异常是什么，异常是怎么产生的，以及如何正确处理异常（同步和异步）。接下来，我们谈一下异常处理的最佳实践。</p><p>我们平时开发一个应用。 如果站在生产者和消费者的角度来看的话。当我们使用别人封装的框架，库，模块，甚至是函数的时候，我们就是消费者。而当我们写的东西被他人使用的时候，我们就是生产者。</p><p>实际上，就算是生产者内部也会有多个模块构成，多个模块之间也会有生产者和消费者的再次身份转化。不过为了简单起见，本文不考虑这种关系。这里的生产者指的就是给他人使用的功能，是纯粹的生产者。</p><p>从这个角度出发，来看下异常处理的最佳实践。</p><h3 id="作为消费者"><a href="#作为消费者" class="headerlink" title="作为消费者"></a>作为消费者</h3><p>当作为消费者的时候，我们关心的是使用的功能是否会抛出异常，如果是，他们有哪些异常。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">"lucifer"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// 有哪些异常？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，理论上 foo.bar 可能产生任何异常，而不管它的 API 是这么写的。但是我们关心的是<strong>可预期的异常</strong>。因此你一定希望这个时候有一个 API 文档，详细列举了这个 API 可能产生的异常有哪些。</p><p>比如这个 foo.bar 4 种可能的异常 分别是 A，B，C 和 D。其中 A 和 B 是我可以处理的，而 C 和 D 是我不能处理的。那么我应该：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">"lucifer"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  foo.bar();</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.code === <span class="string">"A"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"A happened"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (err.code === <span class="string">"B"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">"B happened"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，不管是 C 和 D，还是 API 中没有列举的各种可能异常，我们的做法都是直接抛出。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gft4ymgbxij30uv0hiwgo.jpg" alt></p><h3 id="作为生产者"><a href="#作为生产者" class="headerlink" title="作为生产者"></a>作为生产者</h3><p>如果你作为生产者，你要做的就是提供上面提到的详细的 API，告诉消费者你的可能错误有哪些。这样消费者就可以在 catch 中进行相应判断，处理异常情况。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gft2iv4af5j30cz08zt9f.jpg" alt></p><p>你可以提供类似上图的错误表，让大家可以很快知道可能存在的<strong>可预知</strong>异常有哪些。不得不吐槽一句，在这一方面很多框架，库做的都很差。希望大家可以重视起来，努力维护良好的前端开发大环境。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文很长，如果你能耐心看完，你真得给可以给自己鼓个掌 👏👏👏。</p><p>我从什么是异常，以及异常的分类，让大家正确认识异常，简单来说异常就是一种数据结构而已。</p><p>接着，我又讲到了异常的传播和处理。这两个部分是紧密联系的。异常的传播和事件传播没有本质不同，主要不同是数据结构不同，思想是类似的。具体来说异常会从发生错误的调用处，沿着调用栈回退，直到第一个 catch 语句或者栈为空。如果栈为空都没有碰到一个 catch，则会抛出<strong>uncaught Error</strong>。 需要特别注意的是异步的异常处理，不过你如果对我讲的原理了解了，这都不是事。</p><p>然后，我提出了两个脑洞问题：</p><ul><li>彻底消除运行时异常可能么？</li><li>运行时异常可以恢复么？</li></ul><p>这两个问题非常值得研究，但由于篇幅原因，我这里只是给你讲个轮廓而已。如果你对这两个话题感兴趣，可以和我交流。</p><p>最后，我提到了前端异常处理的最佳实践。大家通过两种角色（生产者和消费者）的转换，认识一下不同决定关注点以及承担责任的不同。具体来说提到了 <strong>明确声明可能的异常</strong>以及 <strong>处理你应该处理的，不要吞没你不能处理的异常</strong>。当然这个最佳实践仍然是轮廓性的。如果大家想要一份 前端最佳实践 checklist，可以给我留言。留言人数较多的话，我考虑专门写一个前端最佳实践 checklist 类型的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 异常处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一招吃遍力扣四道题，妈妈再也不用担心我被套路啦～</title>
      <link href="/blog/2020/06/13/%E5%88%A0%E9%99%A4%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2020/06/13/%E5%88%A0%E9%99%A4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>我花了几天时间，从力扣中精选了四道相同思想的题目，来帮助大家解套，如果觉得文章对你有用，记得点赞分享，让我看到你的认可，有动力继续做下去。</p><p>这就是接下来要给大家讲的四个题，其中 1081 和 316 题只是换了说法而已。</p><ul><li><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/" target="_blank" rel="noopener">316. 去除重复字母</a>(困难)</li><li><a href="https://leetcode-cn.com/problems/create-maximum-number/" target="_blank" rel="noopener">321. 拼接最大数</a>(困难)</li><li><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">402. 移掉 K 位数字</a>(中等)</li><li><a href="https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/" target="_blank" rel="noopener">1081. 不同字符的最小子序列</a>（中等）</li></ul><a id="more"></a><h2 id="402-移掉-K-位数字（中等）"><a href="#402-移掉-K-位数字（中等）" class="headerlink" title="402. 移掉 K 位数字（中等）"></a>402. 移掉 K 位数字（中等）</h2><p>我们从一个简单的问题入手，识别一下这种题的基本形式和套路，为之后的三道题打基础。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">给定一个以字符串表示的非负整数  num，移除这个数中的 k 位数字，使得剩下的数字最小。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">num 的长度小于 10002 且  ≥ k。</span><br><span class="line">num 不会包含任何前导零。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1 :</span><br><span class="line"></span><br><span class="line">输入: num = &quot;1432219&quot;, k = 3</span><br><span class="line">输出: &quot;1219&quot;</span><br><span class="line">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</span><br><span class="line">示例 2 :</span><br><span class="line"></span><br><span class="line">输入: num = &quot;10200&quot;, k = 1</span><br><span class="line">输出: &quot;200&quot;</span><br><span class="line">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br><span class="line">示例 3 :</span><br><span class="line"></span><br><span class="line">输入: num = &quot;10&quot;, k = 2</span><br><span class="line">输出: &quot;0&quot;</span><br><span class="line">解释: 从原数字移除所有的数字，剩余为空就是 0。</span><br></pre></td></tr></table></figure><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>数学</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题让我们从一个字符串数字中删除 k 个数字，使得剩下的数最小。也就说，我们要保持原来的数字的相对位置不变。</p><p>以题目中的 <code>num = 1432219， k = 3</code> 为例，我们需要返回一个长度为 4 的字符串，问题在于： 我们怎么才能求出这四个位置依次是什么呢？</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfr0o3bz8aj30ya0he75v.jpg" alt></p><p>（图 1）</p><p>暴力法的话，我们需要枚举<code>C_n^(n - k)</code> 种序列（其中 n 为数字长度），并逐个比较最大。这个时间复杂度是指数级别的，必须进行优化。</p><p>一个思路是：</p><ul><li>从左到右遍历</li><li>对于每一个遍历到的元素，我们决定是<strong>丢弃</strong>还是<strong>保留</strong></li></ul><p>问题的关键是：我们怎么知道，一个元素是应该保留还是丢弃呢？</p><p>这里有一个前置知识：<strong>对于两个数 123a456 和 123b456，如果 a &gt; b， 那么数字 123a456 大于 数字 123b456，否则数字 123a456 小于等于数字 123b456</strong>。也就说，两个<strong>相同位数</strong>的数字大小关系取决于第一个不同的数的大小。</p><p>因此我们的思路就是：</p><ul><li>从左到右遍历</li><li>对于遍历到的元素，我们选择保留。</li><li>但是我们可以选择性丢弃前面相邻的元素。</li><li>丢弃与否的依据如上面的前置知识中阐述中的方法。</li></ul><p>以题目中的 <code>num = 1432219， k = 3</code> 为例的图解过程如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfr3me4mltj30u00xjgp5.jpg" alt></p><p>（图 2）</p><p>由于没有左侧相邻元素，因此<strong>没办法丢弃</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfr3p4idahj30sk116dj7.jpg" alt></p><p>（图 3）</p><p>由于 4 比左侧相邻的 1 大。如果选择丢弃左侧的 1，那么会使得剩下的数字更大（开头的数从 1 变成了 4）。因此我们仍然选择<strong>不丢弃</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfr3rtp1b1j30tk12etcr.jpg" alt></p><p>（图 4）</p><p>由于 3 比左侧相邻的 4 小。 如果选择丢弃左侧的 4，那么会使得剩下的数字更小（开头的数从 4 变成了 3）。因此我们选择<strong>丢弃</strong>。</p><p>。。。</p><p>后面的思路类似，我就不继续分析啦。</p><p>然而需要注意的是，如果给定的数字是一个单调递增的数字，那么我们的算法会永远<strong>选择不丢弃</strong>。这个题目中要求的，我们要永远确保<strong>丢弃</strong> k 个矛盾。</p><p>一个简单的思路就是：</p><ul><li>每次丢弃一次，k 减去 1。当 k 减到 0 ，我们可以提前终止遍历。</li><li>而当遍历完成，如果 k 仍然大于 0。不妨假设最终还剩下 x 个需要丢弃，那么我们需要选择删除末尾 x 个元素。</li></ul><p>上面的思路可行，但是稍显复杂。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfk7m9z3elj30zk0i01kx.jpg" alt><br>（图 5）</p><p>我们需要把思路逆转过来。刚才我的关注点一直是<strong>丢弃</strong>，题目要求我们丢弃 k 个。反过来说，不就是让我们保留 $n - k$ 个元素么？其中 n 为数字长度。 那么我们只需要按照上面的方法遍历完成之后，再截取前<strong>n - k</strong>个元素即可。</p><p>按照上面的思路，我们来选择数据结构。由于我们需要<strong>保留</strong>和<strong>丢弃相邻</strong>的元素，因此使用栈这种在一端进行添加和删除的数据结构是再合适不过了，我们来看下代码实现。</p><h3 id="代码（Python）"><a href="#代码（Python）" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span><span class="params">(self, num, k)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        remain = len(num) - k</span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; digit:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(digit)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack[:remain]).lstrip(<span class="string">'0'</span>) <span class="keyword">or</span> <span class="string">'0'</span></span><br></pre></td></tr></table></figure><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：虽然内层还有一个 while 循环，但是由于每个数字最多仅会入栈出栈一次，因此时间复杂度仍然为 $O(N)$，其中 $N$ 为数字长度。</li><li>空间复杂度：我们使用了额外的栈来存储数字，因此空间复杂度为 $O(N)$，其中 $N$ 为数字长度。</li></ul><blockquote><p>提示： 如果题目改成求删除 k 个字符之后的最大数，我们只需要将 stack[-1] &gt; digit 中的大于号改成小于号即可。</p></blockquote><h2 id="316-去除重复字母（困难）"><a href="#316-去除重复字母（困难）" class="headerlink" title="316. 去除重复字母（困难）"></a>316. 去除重复字母（困难）</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给你一个仅包含小写字母的字符串，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;bcabc&quot;</span><br><span class="line">输出: &quot;abc&quot;</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;cbacdcbc&quot;</span><br><span class="line">输出: &quot;acdb&quot;</span><br></pre></td></tr></table></figure><h2 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>字典序</li><li>数学</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>与上面题目不同，这道题没有一个全局的删除次数 k。而是对于每一个在字符串 s 中出现的字母 c 都有一个 k 值。这个 k 是 c 出现次数 - 1。</p><p>沿用上面的知识的话，我们首先要做的就是计算每一个字符的 k，可以用一个字典来描述这种关系，其中 key 为 字符 c，value 为其出现的次数。</p><p>具体算法：</p><ul><li>建立一个字典。其中 key 为 字符 c，value 为其出现的剩余次数。</li><li>从左往右遍历字符串，每次遍历到一个字符，其剩余出现次数 - 1.</li><li>对于每一个字符，如果其对应的剩余出现次数大于 1，我们<strong>可以</strong>选择丢弃（也可以选择不丢弃），否则不可以丢弃。</li><li>是否丢弃的标准和上面题目类似。如果栈中相邻的元素字典序更大，那么我们选择丢弃相邻的栈中的元素。</li></ul><p>还记得上面题目的边界条件么？如果栈中剩下的元素大于 $n - k$，我们选择截取前 $n - k$ 个数字。然而本题中的 k 是分散在各个字符中的，因此这种思路不可行的。</p><p>不过不必担心。由于题目是要求只出现一次。我们可以在遍历的时候简单地判断其是否在栈上即可。</p><p>代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span><span class="params">(self, s)</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        remain_counter = collections.Counter(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> stack:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> c &lt; stack[<span class="number">-1</span>] <span class="keyword">and</span>  remain_counter[stack[<span class="number">-1</span>]] &gt; <span class="number">0</span>:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                stack.append(c)</span><br><span class="line">            remain_counter[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：由于判断当前字符是否在栈上存在需要 $O(N)$ 的时间，因此总的时间复杂度就是 $O(N ^ 2)$，其中 $N$ 为字符串长度。</li><li>空间复杂度：我们使用了额外的栈来存储数字，因此空间复杂度为 $O(N)$，其中 $N$ 为字符串长度。</li></ul><p>查询给定字符是否在一个序列中存在的方法。根本上来说，有两种可能：</p><ul><li>有序序列： 可以二分法，时间复杂度大致是 $O(N)$。</li><li>无序序列： 可以使用遍历的方式，最坏的情况下时间复杂度为 $O(N)$。我们也可以使用空间换时间的方式，使用 $N$的空间 换取 $O(1)$的时间复杂度。</li></ul><p>由于本题中的 stack 并不是有序的，因此我们的优化点考虑空间换时间。而由于每种字符仅可以出现一次，这里使用 hashset 即可。</p><h3 id="代码（Python）-1"><a href="#代码（Python）-1" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span><span class="params">(self, s)</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        seen = set()</span><br><span class="line">        remain_counter = collections.Counter(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> c &lt; stack[<span class="number">-1</span>] <span class="keyword">and</span>  remain_counter[stack[<span class="number">-1</span>]] &gt; <span class="number">0</span>:</span><br><span class="line">                    seen.discard(stack.pop())</span><br><span class="line">                seen.add(c)</span><br><span class="line">                stack.append(c)</span><br><span class="line">            remain_counter[c] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：$O(N)$，其中 $N$ 为字符串长度。</li><li>空间复杂度：我们使用了额外的栈和 hashset，因此空间复杂度为 $O(N)$，其中 $N$ 为字符串长度。</li></ul><blockquote><p>LeetCode 《1081. 不同字符的最小子序列》 和本题一样，不再赘述。</p></blockquote><h2 id="321-拼接最大数（困难）"><a href="#321-拼接最大数（困难）" class="headerlink" title="321. 拼接最大数（困难）"></a>321. 拼接最大数（困难）</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">给定长度分别为  m  和  n  的两个数组，其元素由  0-9  构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k &lt;= m + n)  个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</span><br><span class="line"></span><br><span class="line">求满足该条件的最大数。结果返回一个表示该最大数的长度为  k  的数组。</span><br><span class="line"></span><br><span class="line">说明: 请尽可能地优化你算法的时间和空间复杂度。</span><br><span class="line"></span><br><span class="line">示例  1:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">nums1 = [3, 4, 6, 5]</span><br><span class="line">nums2 = [9, 1, 2, 5, 8, 3]</span><br><span class="line">k = 5</span><br><span class="line">输出:</span><br><span class="line">[9, 8, 6, 5, 3]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">nums1 = [6, 7]</span><br><span class="line">nums2 = [6, 0, 4]</span><br><span class="line">k = 5</span><br><span class="line">输出:</span><br><span class="line">[6, 7, 6, 0, 4]</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">nums1 = [3, 9]</span><br><span class="line">nums2 = [8, 9]</span><br><span class="line">k = 3</span><br><span class="line">输出:</span><br><span class="line">[9, 8, 9]</span><br></pre></td></tr></table></figure><h3 id="前置知识-2"><a href="#前置知识-2" class="headerlink" title="前置知识"></a>前置知识</h3><ul><li>分治</li><li>数学</li></ul><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>和第一道题类似，只不不过这一次是两个<strong>数组</strong>，而不是一个，并且是求最大数。</p><p>最大最小是无关紧要的，关键在于是两个数组，并且要求从两个数组选取的元素个数加起来一共是 k。</p><p>然而在一个数组中取 k 个数字，并保持其最小（或者最大），我们已经会了。但是如果问题扩展到两个，会有什么变化呢？</p><p>实际上，问题本质并没有发生变化。 假设我们从 nums1 中取了 k1 个，从 num2 中取了 k2 个，其中 k1 + k2 = k。而 k1 和 k2 这 两个子问题我们是会解决的。由于这两个子问题是相互独立的，因此我们只需要分别求解，然后将结果合并即可。</p><p>假如 k1 和 k2 个数字，已经取出来了。那么剩下要做的就是将这个长度分别为 k1 和 k2 的数字，合并成一个长度为 k 的数组合并成一个最大的数组。</p><p>以题目的 <code>nums1 = [3, 4, 6, 5] nums2 = [9, 1, 2, 5, 8, 3] k = 5</code> 为例。 假如我们从 num1 中取出 1 个数字，那么就要从 nums2 中取出 4 个数字。</p><p>运用第一题的方法，我们计算出应该取 nums1 的 [6]，并取 nums2 的 [9,5,8,3]。 如何将 [6] 和 [9,5,8,3]，使得数字尽可能大，并且保持相对位置不变呢？</p><p>实际上这个过程有点类似<code>归并排序</code>中的<strong>治</strong>，而上面我们分别计算 num1 和 num2 的最大数的过程类似<code>归并排序</code>中的<strong>分</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfruuvyrn5j31mk0i8414.jpg" alt><br>（图 6）</p><p>代码：</p><blockquote><p>我们将从 num1 中挑选的 k1 个数组成的数组称之为 A，将从 num2 中挑选的 k2 个数组成的数组称之为 B，</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(A, B)</span>:</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="keyword">while</span> A <span class="keyword">or</span> B:</span><br><span class="line">        bigger = A <span class="keyword">if</span> A &gt; B <span class="keyword">else</span> B</span><br><span class="line">        ans.append(bigger[<span class="number">0</span>])</span><br><span class="line">        bigger.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>这里需要说明一下。 在很多编程语言中：<strong>如果 A 和 B 是两个数组，当前仅当 A 的首个元素字典序大于 B 的首个元素，A &gt; B 返回 true，否则返回 false</strong>。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A = [1,2]</span><br><span class="line">B = [2]</span><br><span class="line">A &lt; B # True</span><br><span class="line"></span><br><span class="line">A = [1,2]</span><br><span class="line">B = [1,2,3]</span><br><span class="line">A &lt; B # False</span><br></pre></td></tr></table></figure><p>以合并 [6] 和 [9,5,8,3] 为例，图解过程如下：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfruxjfwlhj31cu0u07c0.jpg" alt><br>（图 7）</p><p>具体算法：</p><ul><li>从 nums1 中 取 $min(i, len(nums1))$ 个数形成新的数组 A（取的逻辑同第一题），其中 i 等于 0,1,2, … k。</li><li>从 nums2 中 对应取 $min(j, len(nums2))$ 个数形成新的数组 B（取的逻辑同第一题），其中 j 等于 k - i。</li><li>将 A 和 B 按照上面的 merge 方法合并</li><li>上面我们暴力了 k 种组合情况，我们只需要将 k 种情况取出最大值即可。</li></ul><h3 id="代码（Python）-2"><a href="#代码（Python）-2" class="headerlink" title="代码（Python）"></a>代码（Python）</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumber</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">pick_max</span><span class="params">(nums, k)</span>:</span></span><br><span class="line">            stack = []</span><br><span class="line">            drop = len(nums) - k</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">while</span> drop <span class="keyword">and</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>] &lt; num:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    drop -= <span class="number">1</span></span><br><span class="line">                stack.append(num)</span><br><span class="line">            <span class="keyword">return</span> stack[:k]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(A, B)</span>:</span></span><br><span class="line">            ans = []</span><br><span class="line">            <span class="keyword">while</span> A <span class="keyword">or</span> B:</span><br><span class="line">                bigger = A <span class="keyword">if</span> A &gt; B <span class="keyword">else</span> B</span><br><span class="line">                ans.append(bigger[<span class="number">0</span>])</span><br><span class="line">                bigger.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(merge(pick_max(nums1, i), pick_max(nums2, k-i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(k+<span class="number">1</span>) <span class="keyword">if</span> i &lt;= len(nums1) <span class="keyword">and</span> k-i &lt;= len(nums2))</span><br></pre></td></tr></table></figure><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：pick_max 的时间复杂度为 $O(M + N)$ ，其中 $M$ 为 nums1 的长度，$N$ 为 nums2 的长度。 merge 的时间复杂度为 $O(k)$，再加上外层遍历所有的 k 中可能性。因此总的时间复杂度为 $O(k^2 * (M + N))$。</li><li>空间复杂度：我们使用了额外的 stack 和 ans 数组，因此空间复杂度为 $O(max(M, N, k))$，其中 $M$ 为 nums1 的长度，$N$ 为 nums2 的长度。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这四道题都是删除或者保留若干个字符，使得剩下的数字最小（或最大）或者字典序最小（或最大）。而解决问题的前提是要有一定<strong>数学前提</strong>。而基于这个数学前提，我们贪心地删除栈中相邻的字符。如果你会了这个套路，那么这四个题目应该都可以轻松解决。</p><p><code>316. 去除重复字母（困难）</code>，我们使用 hashmap 代替了数组的遍历查找，属于典型的空间换时间方式，可以认识到数据结构的灵活使用是多么的重要。背后的思路是怎么样的？为什么想到空间换时间的方式，我在文中也进行了详细的说明，这都是值得大家思考的问题。然而实际上，这些题目中使用的栈也都是空间换时间的思想。大家下次碰到<strong>需要空间换取时间</strong>的场景，是否能够想到本文给大家介绍的<strong>栈</strong>和<strong>哈希表</strong>呢？</p><p><code>321. 拼接最大数（困难）</code>则需要我们能够对问题进行分解，这绝对不是一件简单的事情。但是对难以解决的问题进行分解是一种很重要的技能，希望大家能够通过这道题加深这种<strong>分治</strong>思想的理解。 大家可以结合我之前写过的几个题解练习一下，它们分别是：</p><ul><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/jian-dan-yi-dong-gui-bing-pai-xu-python-by-azl3979/" target="_blank" rel="noopener">【简单易懂】归并排序（Python）</a></li><li><a href="https://lucifer.ren/blog/2019/12/11/LSS/">一文看懂《最大子序列和问题》</a></li></ul><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p>大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 经验分享 </tag>
            
            <tag> 困难 </tag>
            
            <tag> 中等 </tag>
            
            <tag> 删除 k 个字符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法小白如何高效、快速刷 leetcode？</title>
      <link href="/blog/2020/06/12/%E5%88%B7%E9%A2%98%E6%96%B0%E6%89%8B/"/>
      <url>/blog/2020/06/12/%E5%88%B7%E9%A2%98%E6%96%B0%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>我本身刷了大概 600 道左右的题目，总结 200 多篇的题解，另外总结了十多个常见的算法专题，基本已经覆盖了大多数的常见考点和题型，全部放在我的 Github <a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。</p><p>然而作为一个新手，看着茫茫多的题解和资料难免会陷入一种“不知从何开始”的境地。<strong>不必担心，你不是一个人。</strong></p><p>实际上，我最近一直在思考“初学者如何快速提高自己的算法能力，高效刷题”。因此我也一直在不断定位自己，最终我对自己作出了定位“用清晰直白的语言还原解题全过程，做西湖区最好的算法题解”。</p><p>然而我意识到，我进去了一个很大的误区。我的想法一直是“努力帮助算法小白提高算法能力，高效刷题”。然而算法小白除了清晰直白的算法题解外，还需要系统的前置知识。因此我的假设“大家都会基础的数据结构和算法”很可能就是不成立的。</p><a id="more"></a><h2 id="小白阶段划分"><a href="#小白阶段划分" class="headerlink" title="小白阶段划分"></a>小白阶段划分</h2><p>如果让我对算法小白进行一个阶段划分的话，我会将其分为：</p><h3 id="阶段一-系统学习数据结构和算法知识。"><a href="#阶段一-系统学习数据结构和算法知识。" class="headerlink" title="阶段一 系统学习数据结构和算法知识。"></a>阶段一 系统学习数据结构和算法知识。</h3><p>第一，你不能根本不懂得基础，比如根本不知道什么哈希表，或者只知道其简单的 API。</p><p>第二，你不能从网上不断搜索知识，因为这些知识是零散的，不利于新手形成自己的<strong>算法观</strong>。</p><p>当你成功跨越了上面两个坎，那么恭喜你，你可以进入下一个阶段啦。</p><p>对于这个阶段，想要跨过。需要系统性学习一些基础知识，推荐啃《算法 4》或者直接啃各个大学里面的教材。实在有困难的，可以先啃《算法图解》，《我的第一本算法书》这种入个门，然后再去啃。</p><h3 id="阶段二-针对性刷题。"><a href="#阶段二-针对性刷题。" class="headerlink" title="阶段二 针对性刷题。"></a>阶段二 针对性刷题。</h3><p>比如按照力扣的标签去刷。因此上面的学习阶段并不见得你要学习完所有的基础再去刷，而是学习一个专题就可以针对性地刷。比如我学了二分法，就可以找一个二分法的题目刷一下。</p><p>想要跨越这一个坎，除了多做题之外，还有一个就是多看题解，多写题解。当然要看优秀的题解，这个我会在后面提到。</p><p>如果你跨越完上面两个坎，那么恭喜你， 你已经不是算法小白了（至少对于非算法岗来说）。</p><h2 id="我的算法观"><a href="#我的算法观" class="headerlink" title="我的算法观"></a>我的算法观</h2><p>继续回到刚才的问题“我的定位误区”。正因为很多小白没有跨越阶段一，因此我的所谓的“用清晰直白的语言还原解题全过程，做西湖区最好的算法题解”对他们没有实质帮助。他们迫切需要的是一个<strong>系统地整理算法思想，套路</strong> 的东西。因此我准备搞 <a href="https://lucifer.ren/blog/2020/05/23/91-algo/">91</a>，这个就是后话，不再这里赘述。</p><p>注意，上面我提到了一个名次<strong>算法观</strong>。我并不知道这个词是否真的存在，不过这并不重要。如果不存在我就赋予其含义，如果存在我就来重新定义它。</p><p>算法观指的是你对于算法全面的认识。比如我拿到一个题目，如何审题，如何抽象成算法模型，如何根据模型选取合适的数据结构和算法。这就需要你对各种数据结构与算法的特性，使用场景有着身后的理解。</p><p>我举一个例子，这个例子就是今天（2020-06-12）我的 91 群的每日一题。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpg154rgbj30dc0hrace.jpg" alt></p><p>API 示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure><p>按照上面的过程，我们来<strong>套</strong>一个。</p><ol><li>如何审题</li></ol><p>看完题的话，只要抓住一个核心点即可。对于本题，核心点在于 <strong>删除最久未使用</strong>，<strong>O(1)时间</strong>。</p><ol start="2"><li>抽象算法模型</li></ol><p>这个题目是一个设计题。API 帮我们设计好了，只需要填充功能即可，也就是说算法模型不需要我们抽象了。</p><ol start="3"><li>根据模型选取合适的数据结构和算法</li></ol><p>我们的算法有两个操作：<strong>get</strong> 和 <strong>put</strong>。既然要支持这两个操作，肯定要有一个地方存数据。那么我们存到哪里呢？数组？链表？哈希表？其中链表又有很多，单向双向，循环不循环。</p><p>由于第一步审题过程中，我们获取到 <strong>O(1)时间</strong> 这个关键信息。那么：</p><ul><li>数组无法做到更新，删除 $O(1)$</li><li>链表无法做到查找，更新，删除 $O(1)$。</li></ul><blockquote><p>有的人说链表更新，删除是 $O(1)$，那么我要问你如何找到需要删除的节点呢？遍历找到的话最坏情况下就是 $O(N)$</p></blockquote><ul><li>哈希表是无序的，因此不能实现 <strong>删除最久未使用</strong>。</li></ul><p>似乎单独使用三种的任何一种都是不可以的。那么我们考虑组合多种数据结构。</p><p>我刚才说了链表只所以删除和更新都是 $O(N)$，是因为查找的时间损耗。</p><p>具体来说，我要删除图中值为 3 的节点，需要移动一次。因为我只能从头开始遍历去找。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpoa6nxlmj30ft03i0sv.jpg" alt><br>（图 1）</p><p>又或者我要更新图中值为 7 的节点，则需要移动两次。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpobio49mj30eq02q0su.jpg" alt></p><p>（图 2）</p><p>有没有什么办法可以省去这种遍历的时间损耗呢？其实我们的根本目的是<strong>找到目标节点</strong>， 而找到目标节点最暴力的方式是<strong>遍历</strong>。有没有巧妙一点的方法呢？毫无疑问，如果不借助额外的空间，这是不可能的。我们的想法只有<strong>空间换时间</strong>。</p><p>假设有这么一种数据结构，你告诉它你想要查的对象，它能帮你在 $O(1)$ 的时间内找到并返回给你结果。结合这个<strong>神秘数据结构</strong>和链表是不是我们就完成这道题了？这个神秘的数据结构就是哈希表。如果你对哈希表熟悉的话，想到几乎应该是瞬间的事情。如果不熟悉，那么经过排除，也应该可以得出这个结论。相信你随着做题数的增加，这种<strong>算法直觉</strong>会更加敏锐。</p><p>然而上面的空间复杂度是 $O(N)$。如果我的内存有限，不能承受 $O(N)$ 的空间，怎么办呢？相应地，我们可能就需要牺牲时间。那么问题是我们必须要退化到 $O(N)$ 么？显然不是，我们可以搞一些<strong>存档点</strong>。比如：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfpognuvp6j30vb051q3n.jpg" alt></p><p>这样，我们需要操作 1 前面的，我们就从头开始遍历，如果需要操作 1 后面的，就从 1 开始遍历。时间复杂度最坏的情况可以降低到 $O(N / 2)$。通过进一步增加<strong>存档点</strong>，可以进一步减少时间，但是会增加空间。这是一种<strong>取舍</strong>。类似的取舍在实际工程中很多，这里不展开。 如果你了解过跳表， 实际上，上面的算法就是跳表的基本思想。</p><p>如果对每一道题你都能按照上面的流程走一遍，并且基于增加适当扩展，我相信你的刷题效率会高得可怕。</p><h2 id="每道题都想这么多么？"><a href="#每道题都想这么多么？" class="headerlink" title="每道题都想这么多么？"></a>每道题都想这么多么？</h2><p>强烈建议新手都按照上面的逻辑进行思考，做题，并写题解总结。这样随着做题数的增加，量变引起质变，你会发现上面的几个步骤做下来很可能就是<strong>几秒钟的事情</strong>。如果你擅长图解，或者你经常看别人的图解（比如我的），那么这种图解能够帮你更快地检索大脑中的信息，这个时间会更短。</p><blockquote><p>图解就是大脑检索信息的哈希表？哈哈，Maybe。</p></blockquote><h2 id="题解的水很深"><a href="#题解的水很深" class="headerlink" title="题解的水很深"></a>题解的水很深</h2><p>我看了很多人的题解直接就是两句话，然后跟上代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def integerBreak(self, n: int) -&gt; int:</span><br><span class="line">        dp = [1] * (n + 1)</span><br><span class="line">        for i in range(3, n + 1):</span><br><span class="line">            for j in range(1, i):</span><br><span class="line">                dp[i] = max(j * dp[i - j], j * (i - j), dp[i])</span><br><span class="line">        return dp[n]</span><br></pre></td></tr></table></figure><p>这种题解说实话，只针对那些”自己会， 然后去题解区看看有没有新的更好的解法的人“。但是大多数看题解的人是那种自己没思路，不会做的人。那么这种题解就没什么用了。</p><p>我认为好的题解应该是新手友好的，并且能够将解题人思路完整展现的题解。比如看到这个题目，我首先想到了什么（对错没有关系），然后头脑中经过怎么样的筛选将算法筛选到具体某一个或某几个。我的最终算法是如何想到的，有没有一些先行知识。</p><p>当然我也承认自己有很多题解也是直接给的答案，这对很多人来说用处不大，甚至有可能有反作用，给他们一种”我已经会了“的假象。实际上他们根本不懂解题人本身原本的想法， 也许是写题解的人觉得”这很自然“，也可能”只是为了秀技“。</p><h2 id="刷题顺序"><a href="#刷题顺序" class="headerlink" title="刷题顺序"></a>刷题顺序</h2><p>最后给小白一个刷题顺序，帮助大家最大化利用自己的时间。</p><h3 id="基础篇（30-天）"><a href="#基础篇（30-天）" class="headerlink" title="基础篇（30 天）"></a>基础篇（30 天）</h3><p>基础永远是最重要的，先把最最基础的这些搞熟，磨刀不误砍柴工。</p><ul><li>数组，队列，栈</li><li>链表</li><li>树与递归</li><li>哈希表</li><li>双指针</li></ul><h3 id="思想篇（30-天）"><a href="#思想篇（30-天）" class="headerlink" title="思想篇（30 天）"></a>思想篇（30 天）</h3><p>这些思想是投资回报率极高的，强烈推荐每一个小的专题花一定的时间掌握。</p><ul><li>二分</li><li>滑动窗口</li><li>搜索（BFS，DFS，回溯）</li><li>动态规划</li></ul><h3 id="提高篇（31-天）"><a href="#提高篇（31-天）" class="headerlink" title="提高篇（31 天）"></a>提高篇（31 天）</h3><p>这部分收益没那么明显，并且往往需要一定的技术积累。出现的频率相对而言比较低。但是有的题目需要你使用这些技巧。又或者可以使用这些技巧可以实现<strong>降维打击</strong>。</p><ul><li>贪心</li><li>分治</li><li>位运算</li><li>KMP &amp; RK</li><li>并查集</li><li>前缀树</li><li>线段树</li><li>堆</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>目前，我本人也在写一本题解方面的书包括近期组织的 91 算法 ，其目标受众正是“阶段一到阶段二”。为了真正帮助刷题小白成长，我打算画三个月的时间对数据结构和算法进行系统总结，帮助大家跨过阶段一。当然我还会不断更新题解，通过清晰直白的方式来让大家跨越阶段二。</p><p>大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 经验分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode 日记】面试题46. 把数字翻译成字符串</title>
      <link href="/blog/2020/06/09/%E9%9D%A2%E8%AF%95%E9%A2%9846.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/blog/2020/06/09/%E9%9D%A2%E8%AF%95%E9%A2%9846.%20%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>​<a id="more"></a></p><p>原题地址： <a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><p>示例 1:</p><p>输入: 12258<br>输出: 5<br>解释: 12258 有 5 种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”</p><p>提示：</p><p>0 &lt;= num &lt; 231</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们另 f(n)表示给定数字 num 的情况下，从 num 的第 1 位（包含）到第 n 位（包含）有多少种不同的翻译方法。</p><p>我们从几个简单的例子入手，尝试打开思路。</p><p>对于数字 12258 来说:</p><blockquote><p>| （挡板）表示从这里分开翻译， ，（逗号）表示分割多个翻译方式。</p></blockquote><ul><li>f(1) = 1，分别为 1。</li><li>f(2) = 2，分别为 1|2， 12。</li><li>f(3) = 3，分别为 1|2|2，1|22，12|2</li><li>…</li></ul><p>其实对于 f(3) 来说， 我手动的情况下，是这么想的：</p><ul><li>先把 f(2) 结果搬过来，即 1|2，12</li><li>在 f(2)的基础上分割，我要添加第三位，也就是一个 2 到末尾。 1|2|2 这样是行的， 12|2 同样是可以的。</li><li>继续在 f(1) 的基础上分割，我要添加第三位，也就是一个 2 到末尾。 1|22</li></ul><p>那么总的情况就是三种。OK，总结下我的逻辑：</p><ul><li>如果我不可以和前面的数字组成 10 - 25 之间的数，那么在 f(n - 1) 的末尾添加挡板</li><li>如果可以，同时在 f(n - 1)和 f(n -2) 的末尾添加挡板</li></ul><p>用图来表示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfm39qp6h2j30qh0h90u9.jpg" alt></p><p>因此，实际上这道题就是爬楼梯的换皮题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line"><span class="meta">        @lru_cache</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(s: str)</span> -&gt; int:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            pre = helper(s[:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= int(s[<span class="number">-2</span>:]) &lt;= <span class="number">25</span>:</span><br><span class="line">                <span class="keyword">return</span> pre + helper(s[:<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">return</span> pre</span><br><span class="line">        <span class="keyword">return</span> helper(str(num))</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：最坏的情况，每一个数组都可以和前面的组成新的数组， 有大约 $2^N$ 种组合，因此时间复杂度为 $O(2^N)$，而我这里使用了 @lru_cache 因此不会有重复计算，时间复杂度为 $(N)$，其中 N 为 数字长度。</li><li>空间复杂度：由于空间复杂的受递归调用栈的影响，因此空间复杂度为 $O(2^N)$，而我这里使用了 @lru_cache 因此不会有重复计算，空间复杂度为 $(N)$，其中 N 为 数字长度。</li></ul><p>如果你愿意的话，其实优化起来也比较简单，我们只需要 bottom-up 即可。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        s = str(num)</span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="number">1</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= int(s[i - <span class="number">1</span>:i + <span class="number">1</span>]) &lt;= <span class="number">25</span>:</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>进而可以优化到空间 $O(1)$</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">translateNum</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">        s = str(num)</span><br><span class="line">        n = len(s)</span><br><span class="line">        a = b = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= int(s[i - <span class="number">1</span>:i + <span class="number">1</span>]) &lt;= <span class="number">25</span>:</span><br><span class="line">                temp = a</span><br><span class="line">                a = b</span><br><span class="line">                b = temp + b</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = b</span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p>大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法，动态规划 </category>
          
          <category> 中等 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构，算法，LeetCode 日记，中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端测试最佳实践（持续更新，建议收藏）</title>
      <link href="/blog/2020/06/08/fe-test-best-practice/"/>
      <url>/blog/2020/06/08/fe-test-best-practice/</url>
      
        <content type="html"><![CDATA[<p>最近公司在推行单元测试，但是一些同事对于单元测试只是了解，甚至不怎么了解。因此推动单元测试的阻碍是有的，这种阻碍除了人的层面，还有基础设施的层面。希望通过本文，一方面加深大家对前端测试最佳实践的认知，另一方面可以作为手册，在日常开发中做参考。本文也会不断更新，期待你的参与。</p><p>如果大家对前端测试不太清楚，可以先看下文末我写的科普短文。如果你已经对前端测试有所了解，并且希望对前端测试有更深入的了解，以及对如何写出更好的单元测试有兴趣的话，那就让我们开始吧。</p><a id="more"></a><h2 id="写易于测试的代码（Writing-test-friendly-code）"><a href="#写易于测试的代码（Writing-test-friendly-code）" class="headerlink" title="写易于测试的代码（Writing test-friendly code）"></a>写易于测试的代码（Writing test-friendly code）</h2><p>这是一个非常宽泛的话题，本文试图从几个具体的切入点来阐述这个庞大且模糊的话题。</p><h3 id="纯函数（Pure-Function）"><a href="#纯函数（Pure-Function）" class="headerlink" title="纯函数（Pure Function）"></a>纯函数（Pure Function）</h3><p>关于<a href="https://github.com/azl397985856/functional-programming" title="函数式教程" target="_blank" rel="noopener">纯函数</a>可以参考之前我写的一篇函数式教程中的入门篇。</p><p>简单来说，纯函数就是数学中的函数。有两个好处：</p><ul><li>断言容易了。 （可推导性）</li><li>我可以多次，顺序无关地执行测试用例。 （无副作用）</li></ul><p>我举一个例子，这是一个稍微高级一点的技巧。不过你一旦理解了其意图，就会发现其思想是多么的简单。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = &#123;</span><br><span class="line">    name: <span class="string">`lucifer's site`</span></span><br><span class="line">    start(html) &#123;</span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">'#app'</span>).innerHTM = html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.start(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>inner<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>上面代码如果要测试，首先你要在 node 环境模拟 document。</p><p>如果换一种写法呢？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = &#123;</span><br><span class="line">    name: <span class="string">`lucifer's site`</span></span><br><span class="line">    start(querySelector, html) &#123;</span><br><span class="line">        querySelector(<span class="string">'#app'</span>).innerHTM = html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.start(<span class="built_in">document</span>.querySelector, &lt;div&gt;inner&lt;<span class="regexp">/div&gt;);</span></span><br></pre></td></tr></table></figure><p>这样模拟 querySelector 就会变得容易起来。eg:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .test.js</span></span><br><span class="line"><span class="keyword">import</span> app <span class="keyword">from</span> <span class="string">"./app"</span>;</span><br><span class="line">app.start(<span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>lucifer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>, &lt;div&gt;inner&lt;<span class="regexp">/div&gt;);</span></span><br></pre></td></tr></table></figure><p>如果你熟悉这种看成方法的话，可能知道它的名字<code>控制反转</code>，英文名 IoC。</p><h3 id="单一职责（Single-Responsibility-Principle）"><a href="#单一职责（Single-Responsibility-Principle）" class="headerlink" title="单一职责（Single Responsibility Principle）"></a>单一职责（Single Responsibility Principle）</h3><p>如果一个函数承担了一个以上的职责。那么对我们测试有什么影响呢？</p><p>如果对于一个函数 f,其功能有 A 和 B。</p><ul><li>A 的输入我们计作 ia，输出计作 oa。</li><li>B 的输入我们计作 ib，输出计作 ob。</li></ul><p>那么 f 的圈复杂度会增加很多，具体来说。</p><ul><li>如果 A 功能和 B 功能相关的话，其测试用例的长度增长是笛卡尔积。</li><li>如果 A 功能和 B 功能无关的话，其测试用例的长度增长是线性增长。</li></ul><p>eg:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">math</span>(<span class="params">a, b, operator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (operator === <span class="string">"+"</span>) <span class="keyword">return</span> a + b;</span><br><span class="line">  <span class="keyword">if</span> (operator === <span class="string">"-"</span>) <span class="keyword">return</span> a - b;</span><br><span class="line">  <span class="keyword">if</span> (operator === <span class="string">"*"</span>) <span class="keyword">return</span> a * b;</span><br><span class="line">  <span class="keyword">if</span> (operator === <span class="string">"/"</span>) <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码有四个功能，并且四个功能互相独立。测试用例增长是线性的，也就说将其拆分为四个函数之后，测试用例的数量不变，但是单一函数的圈复杂度降低了，虽然总的软件复杂度并没有降低。</p><p>如果四个功能相互耦合的话，后果会更严重。这种情况，拆分多个功能块已经无法解决问题了。这个时候需要对功能进行再次拆解，直到子功能块相互独立。</p><h2 id="写清晰直白的测试描述（Wrting-Deadly-Simply-Description）"><a href="#写清晰直白的测试描述（Wrting-Deadly-Simply-Description）" class="headerlink" title="写清晰直白的测试描述（Wrting Deadly Simply Description）"></a>写清晰直白的测试描述（Wrting Deadly Simply Description）</h2><p>这里我给一个简单的判断标准。</p><p>当这个测试报错的时候， 其他人能够只看报错信息，就知道出了什么问题。</p><p>比如这样写是好的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">`math -&gt; add`</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">"3 + 2 should equal to 5"</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="number">3</span> + <span class="number">2</span>).to.be.equal(<span class="number">5</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而这样是不好的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">`math -&gt; add`</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">"add two numbers"</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="number">3</span> + <span class="number">2</span>).to.be.equal(<span class="number">5</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我举的例子大家可能不屑一顾， 但是当你以我的标准去衡量的时候会发现很多用例都不合格。</p><h2 id="逻辑覆盖率（Logic-Coverage）"><a href="#逻辑覆盖率（Logic-Coverage）" class="headerlink" title="逻辑覆盖率（Logic Coverage）"></a>逻辑覆盖率（Logic Coverage）</h2><p>很多人关注的是单元测试的物理覆盖率，比如行覆盖率，文件覆盖率等，而大家往往会忽略逻辑覆盖率。</p><p>eg:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (a, b) =&gt; a / b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.test.js</span></span><br><span class="line"><span class="keyword">import</span> divide <span class="string">'./a.js'</span></span><br><span class="line">describe(<span class="string">`math -&gt; divide`</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">"2 / 2 should be 1"</span>, () =&gt; &#123;</span><br><span class="line">    expect(divide(<span class="number">2</span>, <span class="number">2</span>)).to.be(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上物理覆盖率可以达到 100%，但是很明显逻辑覆盖率却不可以。因为它连最简单的被除数不能为 0 都没包括。</p><p>一个更格式的例子，应该是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (a, b) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (b === <span class="number">0</span> or b === <span class="number">-0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'dividend should not be zero!'</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Number</span>(a) !== a || <span class="built_in">Number</span>(b)=== b) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`divisor and dividend should be number，but got <span class="subst">$&#123;a, b&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// a.test.js</span></span><br><span class="line"><span class="keyword">import</span> divide <span class="string">'./a.js'</span></span><br><span class="line">describe(<span class="string">`math -&gt; divide`</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">"when dividend it zero, there should throw an corresponding eror"</span>, () =&gt; &#123;</span><br><span class="line">    expect(divide(<span class="number">3</span>, <span class="number">0</span>)).toThrowError(<span class="regexp">/dividend should not be zero/</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">"when dividend it zero, there should throw an corresponding eror"</span>, () =&gt; &#123;</span><br><span class="line">    expect(divide(<span class="number">3</span>, <span class="string">'f'</span>)).toThrowError(<span class="regexp">/divisor and dividend should be number/</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">"2 / 2 should be 1"</span>, () =&gt; &#123;</span><br><span class="line">    expect(divide(<span class="number">2</span>, <span class="number">2</span>)).to.be(<span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>逻辑的严密性是双向的，一方面他让你的测试用例更严密，更无懈可击。另一方面你的测试用例越严密， 就越驱使你写出更严密的代码。如上 divide 方法就是我根据测试用例反馈的结果后添加上去的。</p><p>然后我上面的测试逻辑上还是很不严密，比如：</p><ul><li>没有考虑大数的溢出。</li><li>没有考虑无限循环小数。</li></ul><p>这么一个简单的除法就有这么多 edge cases，如果是我们实际的业务的话，情况会更加复杂。因此<strong>写好</strong>测试从来都不是一件简单的事情。</p><h2 id="给测试增加-lint（Add-Linting）"><a href="#给测试增加-lint（Add-Linting）" class="headerlink" title="给测试增加 lint（Add Linting）"></a>给测试增加 lint（Add Linting）</h2><p>测试代码也是需要 lint 的。除了源码的一些 lint 规则，测试应该要加入一些独特的规则。</p><p>比如，你的测试代码只是把代码跑了一遍，没有进行任何断言。亦或者是直接断言<code>expect(true.to.be(true))</code>，都是不应该被允许的。</p><p>比如，断言的时候使用非全等，这也不好的实践。</p><p>再比如，使用<code>toBeNull()</code>断言，而不是:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(<span class="literal">null</span>).toBe(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">expect(<span class="literal">null</span>).toEqual(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">expect(<span class="literal">null</span>).toStrictEqual(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>…</p><p>类似的例子还有很多，总之测试代码也是需要 lint 的 ，并且相比于被测试代码，其应该有额外的特殊规则，来避免测试代码的<strong>腐烂问题</strong>。</p><h2 id="CI"><a href="#CI" class="headerlink" title="CI"></a>CI</h2><h3 id="本地测试（Local-CI）"><a href="#本地测试（Local-CI）" class="headerlink" title="本地测试（Local CI）"></a>本地测试（Local CI）</h3><p>可以仅对修改的文件进行测试，eg:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jest -o</span><br></pre></td></tr></table></figure><h3 id="分阶段测试（Tags）"><a href="#分阶段测试（Tags）" class="headerlink" title="分阶段测试（Tags）"></a>分阶段测试（Tags）</h3><p>我们可以按照一定分类标准对测试用例进行分类。</p><p>举个例子，我按照测试是否有 IO 将用例分为 IO 类型和 非 IO 类型。那么我就可以在提交的时候只执行非 IO 类型，这样反馈更快。等到我推送到远程的时候执行一次全量操作。</p><p>eg:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">`"face swiping" -&gt; alipay #io`</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">"it should go to http://www.alipay.com/identify when user choose alipay"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// simulate click</span></span><br><span class="line">    <span class="comment">// do heavy io</span></span><br><span class="line">    <span class="comment">// expect</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以这么做</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jest -t = <span class="string">"#io"</span>;</span><br></pre></td></tr></table></figure><p>同样，我可以按照其他纬度对用例进行切分，比如各种业务纬度。这在业务达到一定规模之后，收益非常明显。eg:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jest -t = &quot;[#io|#cold|#biz]&quot;;</span><br></pre></td></tr></table></figure><p>如上会仅测试有<code>io</code>,<code>cold</code>,<code>biz</code> 三个标签中的一个或者多个的用例。</p><blockquote><p>文件夹和文件名本身也是一种 tag，合理利用可以减少很多工作。</p></blockquote><h2 id="框架相关（Framework）"><a href="#框架相关（Framework）" class="headerlink" title="框架相关（Framework）"></a>框架相关（Framework）</h2><p>大家问的比较多的问题是如何测试视图，以及如何测试特定的某一种框架下的代码。</p><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>一个典型的 Vue 项目可能有如下文件类型：</p><ul><li>html</li><li>vue</li><li>js</li><li>ts</li><li>json</li><li>css</li><li>图片，音视频等媒体资源</li></ul><p>如何对他们进行测试呢？JS 和 TS 我们暂时讨论，这个和框架相关性不大。而我们这里关心框架相关的 vue 文件和视图相关的文件。而<strong>json，图片，音视频等媒体资源是没有必要测试的。</strong></p><p>那么如何测试 html，vue 和 css 文件呢？而大多数情况， 大家应用都是 CSR 的，html 只是一个傀儡文件，没有测试的价值。css 的话，如果要测试，只有两种情况，一种是对 CSSOM 进行测试，另外一种是对渲染树的内容进行测试。而一般大家都会对渲染树进行测试。为什么呢？留给大家来思考，欢迎文章后留言讨论。因此本文主要讨论 vue 文件，以及渲染树的测试。</p><p>实际上， vue 文件会导出一个 vue 的构造函数，并且合适的时候完成实例化和挂载的过程。而其真正渲染到中的时候，会把 template 标签，style 标签内容一并带过去，当然这中间有一些复杂逻辑存在，这不是本文重点，故不做延伸。</p><p>那么，对基于 vue 框架的应用测试主要关注一点，渲染树本身。 其实你用别的框架，或者不用框架也是一样的。</p><p>不同的是，vue 是一种基于数据驱动的框架。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(props) =&gt; view;</span><br></pre></td></tr></table></figure><p>因此我们是不是只要测试不同的 props 组合，是否展示我们期望的 view 就可以了？</p><p>是也不是。 我们先假定”是“。那么我们的问题转化为：</p><ul><li>如何组合合适的 props</li><li>如何断言 view 是否正确渲染</li></ul><p>对于第一个问题，这个是组件设计的时候应该考虑的事情。对于第二个问题，答案是 <code>vue-test-utils</code>。</p><p><code>vue-test-utils</code> 本身就是解决这个问题的，如果我将一个 app 看成是组件的有机体（组件以及组件之间的通信协作），并将组件看成函数的话。那么<code>vue-test-utils</code> 的核心功能就是:</p><ul><li>帮你执行这些函数。</li><li>改变函数内部的状态。</li><li>触发函数之间的通信。</li><li>。。。</li></ul><p><code>vue-test-utils</code> 的 wrapper 同时完成了上面两件事<code>setProps</code> 和 <code>assert</code>。<code>vue-test-utils</code> 还帮你做了很多事情， 比如组件嵌套（类似函数调用栈）如何测试，怎么 mock props，router 等。</p><p>一句话来说，就像是一双无形的手，<strong>帮你操作 app 的初始化， 挂载，更新，卸载等，并且直接或者间接提供断言机制</strong>。 更多可以参考 <a href="https://vue-test-utils.vuejs.org/" target="_blank" rel="noopener">https://vue-test-utils.vuejs.org/</a></p><p>以上内容基于一个事实 <code>我们只要测试不同的 props 组合，是否展示我们期望的 view 就可以</code>。然而， vue 虽然将其抽象为函数，但是要注意这个函数和我上文讲到的纯函数相差甚远，就连以<code>函数式友好</code>闻名的 React 也做不到这一点。</p><p>也就是说，你还需要考虑副作用。从这一点上来看，这是和我上文提到的最佳实践背离的。但是真正地将副作用全部抽离开的框架不怎么流行，比如 cyclejs, elm。因此我们必须接受这个事实。我们虽然无法避免这种事情的发生，但是我们可以限制其在我们可控制的范围，典型的技巧就是沙箱机制，这同样超出了本文的论述范围，故不做引申。</p><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>TODO</p><h2 id="其他（Others）"><a href="#其他（Others）" class="headerlink" title="其他（Others）"></a>其他（Others）</h2><h3 id="Make-it-Red，-Make-it-Green"><a href="#Make-it-Red，-Make-it-Green" class="headerlink" title="Make it Red， Make it Green"></a>Make it Red， Make it Green</h3><p>其实这就是测试驱动开发的本质。</p><ul><li><p>先写用例，甭管飘红不飘红，先把测试用例写好，定义好问题边界。</p></li><li><p>然后一个个将红色的变成绿色。</p></li><li><p>再结合上面我提到的技巧，做持续集成。在你打字的时候可以执行的测试用例有哪些，在你提交到本地仓库的时候可以执行的用例有哪些。</p></li></ul><h2 id="参考（Reference）"><a href="#参考（Reference）" class="headerlink" title="参考（Reference）"></a>参考（Reference）</h2><ul><li><a href="https://github.com/azl397985856/frontend-test" title="两年前写的前端测试短文" target="_blank" rel="noopener">两年前写的前端测试短文</a></li><li><a href="https://github.com/jest-community/eslint-plugin-jest" target="_blank" rel="noopener">eslint-plugin-jest</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 测试 </tag>
            
            <tag> 单元测试 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《丢鸡蛋问题》重制版来袭～</title>
      <link href="/blog/2020/06/08/887.super-egg-drop/"/>
      <url>/blog/2020/06/08/887.super-egg-drop/</url>
      
        <content type="html"><![CDATA[<p>这是一道 LeetCode 难度为 Hard 的题目，很多大公司都会考，来看看。</p><p>​<a id="more"></a></p><p>原题地址：<a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/super-egg-drop/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你将获得  K  个鸡蛋，并可以使用一栋从  1  到  N   共有 N  层楼的建筑。</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层  F ，满足  0 &lt;= F &lt;= N 任何从高于 F  的楼层落下的鸡蛋都会碎，从  F  楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层  X  扔下（满足  1 &lt;= X &lt;= N）。</p><p>你的目标是确切地知道 F 的值是多少。</p><p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p><p>示例 1：</p><p>输入：K = 1, N = 2<br>输出：2<br>解释：<br>鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>如果它没碎，那么我们肯定知道 F = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。<br>示例 2：</p><p>输入：K = 2, N = 6<br>输出：3<br>示例 3：</p><p>输入：K = 3, N = 14<br>输出：4</p><p>提示：</p><p>1 &lt;= K &lt;= 100<br>1 &lt;= N &lt;= 10000</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>递归</li><li><a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md" title="动态规划" target="_blank" rel="noopener">动态规划</a></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题也是 vivo 2020 年提前批的一个笔试题。时间一个小时，一共三道题，分别是本题，合并 k 个链表，以及种花问题。</p><p>这道题我在很早的时候做过，也写了<a href="https://github.com/azl397985856/leetcode/blob/master/problems/887.super-egg-drop.md" title="887.super-egg-drop 题解" target="_blank" rel="noopener">题解</a>。现在看来，思路没有讲清楚。没有讲当时的思考过程还原出来，导致大家看的不太明白。今天给大家带来的是 887.super-egg-drop 题解的<strong>重制版</strong>。思路更清晰，讲解更透彻，如果觉得有用，那就转发在看支持一下？OK，我们来看下这道题吧。</p><p>这道题乍一看很复杂，我们不妨从几个简单的例子入手，尝试打开思路。</p><p>假如有 2 个鸡蛋，6 层楼。 我们应该先从哪层楼开始扔呢？想了一会，没有什么好的办法。我们来考虑使用暴力的手段。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfk793ken5j30zi0fidhu.jpg" alt><br>（图 1. 这种思路是不对的）</p><p>既然我不知道先从哪层楼开始扔是最优的，那我就依次模拟从第 1，第 2。。。第 6 层扔。每一层楼丢鸡蛋，都有两种可能，碎或者不碎。由于是最坏的情况，因此我们需要模拟两种情况，并取两种情况中的扔次数的较大值（较大值就是最坏情况）。 然后我们从六种扔法中选择最少次数的即可。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfk7a7q9h5j32bo0jutfj.jpg" alt><br>（图 2. 应该是这样的）</p><p>而每一次选择从第几层楼扔之后，剩下的问题似乎是一个规模变小的同样问题。嗯哼？递归？</p><p>为了方便描述，我将 f(i, j) 表示有 i 个鸡蛋， j 层楼，在最坏情况下，最少的次数。</p><p>伪代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(K, N)</span>:</span></span><br><span class="line">    ans = N</span><br><span class="line">    <span class="comment"># 暴力枚举从第 i 层开始扔</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">        ans = min(ans, max(self.superEggDrop(K - <span class="number">1</span>, i - <span class="number">1</span>) + <span class="number">1</span>, self.superEggDrop(K,  N - i) + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>如上代码：</p><ul><li>self.superEggDrop(K - 1, i - 1) 指的是鸡蛋破碎的情况，我们就只剩下 K - 1 个鸡蛋， 并且 i - 1 个楼层需要 check。</li><li>self.superEggDrop(K, N - i) + 1 指的是鸡蛋没有破碎的情况，我们仍然有 K 个鸡蛋， 并且剩下 N - i 个楼层需要 check。</li></ul><p>接下来，我们增加两行递归的终止条件，这道题就完成了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span> <span class="keyword">or</span> N == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        ans = N</span><br><span class="line">        <span class="comment"># 暴力枚举从第 i 层开始扔</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            ans = min(ans, max(self.superEggDrop(K - <span class="number">1</span>, i - <span class="number">1</span>) + <span class="number">1</span>, self.superEggDrop(K,  N - i) + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>可是如何这就结束的话，这道题也不能是 hard，而且这道题是公认难度较大的 hard 之一。</p><p>上面的代码会 TLE，我们尝试使用记忆化递归来试一下，看能不能 AC。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="meta">    @lru_cache()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> K == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span> <span class="keyword">or</span> N == <span class="number">1</span>: <span class="keyword">return</span> N</span><br><span class="line">        ans = N</span><br><span class="line">        <span class="comment"># 暴力枚举从第 i 层开始扔</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">            ans = min(ans, max(self.superEggDrop(K - <span class="number">1</span>, i - <span class="number">1</span>) + <span class="number">1</span>, self.superEggDrop(K,  N - i) + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>性能比刚才稍微好一点，但是还是很容易挂。</p><p>那只好 bottom-up（动态规划）啦。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfk77gt74aj310d0u0adb.jpg" alt><br>(图 3)</p><p>我将上面的过程简写成如下形式：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfk78qrz6yj316s09k75o.jpg" alt><br>(图 4)</p><p>与其递归地进行这个过程，我们可以使用迭代的方式。 相比于上面的递归式，减少了栈开销。然而两者有着很多的相似之处。</p><p>如果说递归是用函数调用来模拟所有情况， 那么动态规划就是用表来模拟。我们知道所有的情况，无非就是 N 和 K 的所有组合，我们怎么去枚举 K 和 N 的所有组合？ 当然是套两层循环啦！</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfk7d63dfoj31qw0s2dkw.jpg" alt><br>（图 5. 递归 vs 迭代）</p><p>如上，你将 dp[i][j] 看成 superEggDrop(i, j)，是不是和递归是一摸一样？</p><p>来看下迭代的代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(K + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(N + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = j</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">1</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] == j</span><br><span class="line">                dp[i][j] = j</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, j + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = min(dp[i][j], max(dp[i - <span class="number">1</span>][k - <span class="number">1</span>] + <span class="number">1</span>, dp[i][j - k] + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> dp[K][N]</span><br></pre></td></tr></table></figure><p>值得注意的是，在这里内外循环的顺序无关紧要，并且内外循坏的顺序对我们写代码来说复杂程度也是类似的，各位客官可以随意调整内外循环的顺序。比如这样也是可以的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (K + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range( K + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = i</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">or</span> i == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] == i</span><br><span class="line">                dp[i][j] = i</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                    dp[i][j] = min(dp[i][j], max(dp[k - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - k][j] + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> dp[N][K]</span><br><span class="line">        dp = [[<span class="number">0</span>] * (N + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(K + <span class="number">1</span>)]</span><br></pre></td></tr></table></figure><p>总结一下，上面的解题方法思路是：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfk7arzmn3j30pa0nemzo.jpg" alt></p><p>然而这样还是不能 AC。这正是这道题困难的地方。 <strong>一道题目往往有不止一种状态转移方程，而不同的状态转移方程往往性能是不同的。</strong></p><p>那么这道题有没有性能更好的其他的状态转移方程呢？</p><p>把思路逆转！</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfk7m9z3elj30zk0i01kx.jpg" alt></p><blockquote><p>这是《逆转裁判》 中经典的台词， 主角在深处绝境的时候，会突然冒出这句话，从而逆转思维，寻求突破口。</p></blockquote><p>我们这样来思考这个问题。 既然题目要求最少的扔的次数，假设有一个函数 f(k, i)，他的功能是求出 k 个鸡蛋，扔 i 次所能检测的最高楼层。</p><p>我们只需要不断进行发问：</p><ul><li>”f 函数啊 f 函数，我扔一次可以么？“， 也就是判断 f(k, 1) &gt;= N 的返回值</li><li>”f 函数啊 f 函数，我扔两次呢？“， 也就是判断 f(k, 2) &gt;= N 的返回值</li><li>…</li><li>”f 函数啊 f 函数，我扔 m 次呢？“， 也就是判断 f(k, m) &gt;= N 的返回值</li></ul><p>我们只需要返回第一个返回值为 true 的 m 即可。</p><blockquote><p>想到这里，我条件发射地想到了二分法。 聪明的小朋友们，你们觉得二分可以么？为什么？欢迎评论区留言讨论。</p></blockquote><p>那么这个神奇的 f 函数怎么实现呢？其实很简单。</p><ul><li>摔碎的情况，可以检测的最高楼层是<code>f(m - 1, k - 1) + 1</code>。因为碎了嘛，我们多检测了摔碎的这一层。</li><li>没有摔碎的情况，可以检测的最高楼层是<code>f(m - 1, k)</code>。因为没有碎，也就是说我们啥都没检测出来（对能检测的最高楼层无贡献）。</li></ul><p>我们来看下代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(m, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">or</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> f(m - <span class="number">1</span>, k - <span class="number">1</span>) + <span class="number">1</span> +  f(m - <span class="number">1</span>, k)</span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> f(m, K) &lt; N:</span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><p>上面的代码可以 AC。我们来顺手优化成迭代式。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (K + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dp[m][K] &lt; N:</span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">                dp[m][i] = dp[m - <span class="number">1</span>][i - <span class="number">1</span>] + <span class="number">1</span> + dp[m - <span class="number">1</span>][i]</span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码支持：JavaSCript，Python</p><p>Python:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">superEggDrop</span><span class="params">(self, K: int, N: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (K + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(N + <span class="number">1</span>)]</span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dp[m][K] &lt; N:</span><br><span class="line">            m += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, K + <span class="number">1</span>):</span><br><span class="line">                dp[m][i] = dp[m - <span class="number">1</span>][i - <span class="number">1</span>] + <span class="number">1</span> + dp[m - <span class="number">1</span>][i]</span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><p>JavaSCript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> superEggDrop = <span class="function"><span class="keyword">function</span> (<span class="params">K, N</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不选择dp[K][M]的原因是dp[M][K]可以简化操作</span></span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>(N + <span class="number">1</span>)</span><br><span class="line">    .fill(<span class="number">0</span>)</span><br><span class="line">    .map(<span class="function">(<span class="params">_</span>) =&gt;</span> <span class="built_in">Array</span>(K + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (dp[m][K] &lt; N) &#123;</span><br><span class="line">    m++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt;= K; ++k) dp[m][k] = dp[m - <span class="number">1</span>][k - <span class="number">1</span>] + <span class="number">1</span> + dp[m - <span class="number">1</span>][k];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(m * K)$，其中 m 为答案。</li><li>空间复杂度：$O(K * N)$</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对于困难，先举几个简单例子帮助你思考。</li><li>递归和迭代的关系，以及如何从容地在两者间穿梭。</li><li>如果你还不熟悉动态规划，可以先从递归做起。多画图，当你做多了题之后，就会越来越从容。</li><li>对于动态规划问题，往往有不止一种状态转移方程，而不同的状态转移方程往往性能是不同的。</li></ul><blockquote><p>友情提示: 大家不要为了这个题目高空抛物哦。</p></blockquote><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p>大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题效率低？或许你就差这么一个插件</title>
      <link href="/blog/2020/06/06/algo-chrome-extension/"/>
      <url>/blog/2020/06/06/algo-chrome-extension/</url>
      
        <content type="html"><![CDATA[<p>这两天我写了一个浏览器插件，这个插件的定位就是帮助大家提高刷题效率。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfiqhxykhtj32m10u0qdc.jpg" alt></p><a id="more"></a><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>目前主要有四个部分组成：</p><ul><li>前置知识。 如果你想刷这道题，你需要掌握的知识是什么？如果没掌握这个前置知识，你是刷不出来的。提醒你去复习什么东西。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfiqnya27qj30n00iodgg.jpg" alt></p><ul><li>关键点。有了前置知识，并不代表你就能想到，并不代表你就能做出来。有一些关键点你是要想到，不然要么就是做不出来，要么就是解法效率很低。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfiqook3yjj30n00iojs0.jpg" alt></p><ul><li>题解。 这里精选一些好的题解，帮助大家少走弯路。目前只放了我的题解，后续可能会陆续增加其他优秀题解。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfiqovm8ocj30n00ioq3k.jpg" alt></p><ul><li>代码。 大家可以直接复制进行调试。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfiqp35h71j30n00ioq3s.jpg" alt></p><p>计划中的功能：</p><ul><li>国内哪个公司出过这道题， 这对于想进某一家公司的人很有用</li><li>可视化调试</li><li>复杂度分析小工具</li></ul><blockquote><p>具体做什么，等出来之后再和大家同步</p></blockquote><h2 id="如何使用（暂时没开放下载，正式开放时间等公众号通知）"><a href="#如何使用（暂时没开放下载，正式开放时间等公众号通知）" class="headerlink" title="如何使用（暂时没开放下载，正式开放时间等公众号通知）"></a>如何使用（暂时没开放下载，正式开放时间等公众号通知）</h2><ul><li>下载插件</li><li>用 chrome 浏览器，访问 chrome://extensions/</li><li>点击 load unpackd，选择刚刚下载好的插件</li><li>现在去 leetcode 就随便找一个题看看吧。</li></ul><p>PS: 对于收录的题，展示效果类似上面的截图。对于未收录的题，展示效果如下图</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfiqrr2v4gj30n00io3zj.jpg" alt></p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>我这里录制了一个视频，关于这个插件的。<a href="https://www.bilibili.com/video/BV1UK4y1x7zj/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1UK4y1x7zj/</a></p><h2 id="如何贡献"><a href="#如何贡献" class="headerlink" title="如何贡献"></a>如何贡献</h2><ul><li>关注公众号《力扣加加》，点击更多 - 联系我，添加我为好友，备注插件开发。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 扩展程序 </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【异议！】第一期 《这个🦅题的复杂度怎么分析？》</title>
      <link href="/blog/2020/06/03/over-fancy01/"/>
      <url>/blog/2020/06/03/over-fancy01/</url>
      
        <content type="html"><![CDATA[<p>力扣加加，努力做西湖区最好的算法题解。</p><p>去年的一年时间，我在群里每天都会出题给大家做。但是就在 2020-03 开始，力扣也开展了每日一题活动。我突然觉得这个每日一题的必要性变得小了很多，并且逐渐减少了出题频率。但是我还是不愿意放弃大家一起集中进行交流学习的机会。于是我打算新开辟一个专题，这个专题一方面要和力扣官方的每日一题重合度低，另一方面要让大家有参与的热情。</p><p> 于是【异议！】系列应运而生。它是个什么东西呢？ 我相信大家一定在平时刷算法的过程中，一定遇到过“这解法怎么想到的？”，“这解法不对吧？”的情况，并且可悲的是没有人能够回答你。来这里，<strong>力扣加加</strong> 来回答你。 我们会对大家提出的问题进行筛选，将有意义的问题开放出来给大家讨论和学习。</p><p>本次给大家带来的/是【异议！】系列<strong>第一篇</strong>。</p><a id="more"></a><h2 id="事情的起源"><a href="#事情的起源" class="headerlink" title="事情的起源"></a>事情的起源</h2><p>昨天有人在我的力扣题解下留言，说我的时间复杂度解释有问题。思考再三，决定将这个问题抛出来大家一起讨论一下，我会在明天的公众号给大家公布参考答案。对于回答正确且点赞数最高的，我会送出 <strong>8.88</strong> 的现金红包，参与方式以及要求在文末。</p><p>其实这是一道前几天的力扣官方每日一题，我们先来看一下题目描述：</p><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfewdafiexj305805odft.jpg" alt></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为  [2,1,5,6,2,3]。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfewdi9rmlj305805o0sv.jpg" alt></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为  10  个单位。</p><p>示例:</p><p>输入: [2,1,5,6,2,3]</p><p>输出: 10</p><h2 id="那么问题来了"><a href="#那么问题来了" class="headerlink" title="那么问题来了"></a>那么问题来了</h2><p>这个题目我给出了四个解法，其中前两个是超时的，后两个是可以 AC 的。</p><p>而后两个可以 AC 的有一个是单调栈的解法，这个单调栈的解法有两个精妙的地方。第一是哨兵元素的选取，第二是是用了一个栈而不是两个。</p><p>另外一个可以 AC 的解法，也就是今天我们要讨论的解法，这个解法使用了两个数组，相对于单调栈的复杂度，其常系数更大，但是其思路同样巧妙。</p><p>为了大家更好的理解这个解法，我这里贴一下它的未被优化版本。思路为：</p><p>暴力尝试<code>所有可能的矩形</code>。从中心向两边进行扩展。对于每一个 i，我们计算出其左边第一个高度小于它的索引 p，同样地，计算出右边第一个高度小于它的索引 q。那么以 i 为最低点能够构成的面积就是<code>(q - p - 1) * heights[i]</code>。 这种算法毫无疑问也是正确的。 假设 f(i) 表示求以 i 为最低点的情况下，所能形成的最大矩阵面积。那么原问题转化为<code>max(f(0), f(1), f(2), ..., f(n - 1))</code>。</p><p>具体算法如下：</p><ul><li>我们使用 l 和 r 数组。l[i] 表示 左边第一个高度小于它的索引，r[i] 表示 右边第一个高度小于它的索引。</li><li>我们从前往后求出 l，再从后往前计算出 r。</li><li>再次遍历求出所有的可能面积，并取出最大的。</li></ul><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(heights)</span><br><span class="line">        l, r, ans = [<span class="number">-1</span>] * n, [n] * n, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> heights[j] &gt;= heights[i]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            l[i] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> heights[j] &gt;= heights[i]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            r[i] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ans = max(ans, heights[i] * (r[i] - l[i] - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>其实 while 循环内部是没有必要一格一格移动的。 举例来说，对于数组[1,2,3,4,5]，我们要建立 r 数组。我们从 4 开始，4 的右侧第一个小于它索引的是 n（表示不存在）。同样 3 的右侧第一个小于它索引的也是 n（表示不存在），以此类推。如果用上面的解法的话，我们每次都需要从当前位置遍历到尾部，时间复杂度为$O(N^2)$。</p><p>实际上，比如遍历到 2 的时候，我们拿 2 和前面的 3 比较，发现 3 比 2 大，并且我们之前计算出了比 3 大的右侧第一个小于它索引的是 n，也就是说我们可以直接移动到 n 继续搜索，因为<strong>这中间的都比 3 大，自然比 2 大了，没有比较的意义</strong>。 这样看来时间复杂度就被优化到了$O(N)$。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(heights)</span><br><span class="line">        l, r, ans = [<span class="number">-1</span>] * n, [n] * n, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> heights[j] &gt;= heights[i]:</span><br><span class="line">                j = l[j]</span><br><span class="line">            l[i] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> heights[j] &gt;= heights[i]:</span><br><span class="line">                j = r[j]</span><br><span class="line">            r[i] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ans = max(ans, heights[i] * (r[i] - l[i] - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>这位读者看到这里产生了一个疑问，这个疑问就是我开篇所讲的。我们来看下他是怎么说的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfexzj6zm3j31ae0b8q4w.jpg" alt></p><p>这位读者提到<strong>交替的这种情况时间复杂度会退化到$O(N^2)$</strong>，那么实际情况真的是这样么？</p><h2 id="悬赏"><a href="#悬赏" class="headerlink" title="悬赏"></a>悬赏</h2><p>大家对上面的优化后的算法复杂度是怎么看的？请留言告诉我！ 需要注意的是：</p><ol><li>我们所说的复杂度是渐进复杂度，也就是说是忽略常数项的。而这里我要求你<strong>带上常系数</strong>。</li><li>这里要求计算的是<strong>整个完整算法</strong>的复杂度。</li><li>请分别说出该算法在<code>最差情况</code>，<code>最好情况</code>下的复杂度。</li></ol><p>参与方式：<code>复制链接，并在浏览器打开，然后在里面评论即可</code>。链接地址：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-zhu-zhuang-tu-zhong-zui-da-de-ju-xing-duo-chong/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-zhu-zhuang-tu-zhong-zui-da-de-ju-xing-duo-chong/</a></p><p>大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 异议！ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异议！ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>听说这题套个BFS模板就可以 AC？</title>
      <link href="/blog/2020/06/02/1091.shortest-path-in-binary-matrix/"/>
      <url>/blog/2020/06/02/1091.shortest-path-in-binary-matrix/</url>
      
        <content type="html"><![CDATA[<p>​<a id="more"></a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。</span><br><span class="line"></span><br><span class="line">一条从左上角到右下角、长度为 k 的畅通路径，由满足下述条件的单元格 C_1, C_2, ..., C_k 组成：</span><br><span class="line"></span><br><span class="line">相邻单元格 C*i 和 C*&#123;i+1&#125; 在八个方向之一上连通（此时，C*i 和 C*&#123;i+1&#125; 不同且共享边或角）</span><br><span class="line">C_1 位于 (0, 0)（即，值为 grid[0][0]）</span><br><span class="line">C_k 位于 (N-1, N-1)（即，值为 grid[N-1][n-1]）</span><br><span class="line">如果 C_i 位于 (r, c)，则 grid[r][c] 为空（即，grid[r][c] == 0）</span><br><span class="line">返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。</span><br></pre></td></tr></table></figure><p>示例 1：</p><p>输入：[[0,1],[1,0]]</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfdxfinc0vj30k90kfdge.jpg" alt></p><p>输出：2</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfdxfxn4lij30k90kf0td.jpg" alt></p><p>示例 2：</p><p>输入：[[0,0,0],[1,1,0],[1,1,0]]</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfdxg2495gj30k90kfaat.jpg" alt></p><p>输出：4</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfdxg8aihtj30k90kft9k.jpg" alt></p><p>提示：</p><p>1 &lt;= grid.length == grid[0].length &lt;= 100<br>grid[i][j] 为 0 或 1</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题乍一看很像之前写过的一些“机器人”。但是不同的地方在于机器人只能“向下移动和向右移动”，因此机器人那个题目就很适合用动态规划来做。为什么呢？</p><p>因为这道题可以移动的范围是八个方向，题目给的示例不是很好，我这里给大家画了一个示例。我相信你一看就明白了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfe09lk8j2j30d30awwin.jpg" alt><br>（图 1）</p><p>如图，我们发现每一个点的状态其实依赖了周围八个方向。如果我们使用动态规划来求解的时候，我们如何遍历（枚举所有子问题）呢？ 由于每一个 cell 依赖了周围八个 cell，那么我应该先更新谁呢？这个问题就会比较复杂。</p><p>具体来说， 当我需要计算 dp[1][2]的值的时候，实际上我需要先计算<code>dp[0][2]</code>，<code>dp[1][1]</code>，<code>dp[2][2]</code> … 等八个值，这样才能确定 dp[1][2]的值。而计算 dp[0][2] 又是八个值，dp[1][1]等也是同理。 这样就会很复杂。</p><p>而如果你做题比较多的话，分析到这里会发现，应该会想到 BFS。 即使你做题不多，那么根据题目给出的关键字<strong>最短</strong>畅通路径，也应该想到 BFS 才对。</p><p>这道题我直接复制了一个我直接总结的模板，稍微改了一下就 OK 了。大家也可以在平时刷题过程总结自己的解题模板，这在争分夺秒的打比赛环节是很重要的。</p><p>我复制的模板是下面这个，大家可以对比下我提交的代码看看相似度有多少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateMatrix</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        ans = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        seen = set()</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        steps = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                    queue.append((i, j))</span><br><span class="line">                    seen.add((i, j))</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                i, j = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="number">1</span>: ans[i][j] = steps</span><br><span class="line">                <span class="keyword">for</span> x, y <span class="keyword">in</span> [(i + <span class="number">1</span>, j), (i - <span class="number">1</span>, j),(i, j + <span class="number">1</span>),(i, j - <span class="number">1</span>)]:</span><br><span class="line">                    <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> x &lt; m <span class="keyword">and</span> y &gt;=<span class="number">0</span> <span class="keyword">and</span> y &lt; n <span class="keyword">and</span> (x, y) <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        queue.append((x, y))</span><br><span class="line">                        seen.add((x, y))</span><br><span class="line">            steps += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>（Python BFS 模板代码）</p><p>我来用伪代码解释下这段代码的意思：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template BFS(board) &#123;</span><br><span class="line">  边界处理</span><br><span class="line">  seen = set() # 存储已经遍历过的节点，防止环的出现。</span><br><span class="line">  初始化队列</span><br><span class="line">  steps = 0</span><br><span class="line"></span><br><span class="line">  while 队列不为空 &#123;</span><br><span class="line">    逐个取出队列中的元素（不包括在 while 循环内新添加的）</span><br><span class="line">    if 满足条件 return steps</span><br><span class="line">    for dir in dirs &#123;</span><br><span class="line">      将周围的都加到队列，注意边界处理</span><br><span class="line">    &#125;</span><br><span class="line">    steps += 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return 不存在（一般是 -1）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（BFS 模板伪代码）</p><p>大家可以根据我的伪代码，自己定制属于自己的模板。</p><p>值得注意的是，本题我并没有使用 seen 来记录访问过的节点，而是直接原地修改，这是一个很常见的技巧，对这个技巧不熟悉的可以看下我的<a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/island.md" title="小岛专题" target="_blank" rel="noopener">小岛专题</a></p><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>BFS</li><li>BFS 模板</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码支持：Python3</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> <span class="keyword">or</span> grid[n<span class="number">-1</span>][n<span class="number">-1</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        steps = <span class="number">1</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append((<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                i, j  = queue.popleft()</span><br><span class="line">                <span class="keyword">if</span> i == n - <span class="number">1</span> <span class="keyword">and</span> j == n - <span class="number">1</span>: <span class="keyword">return</span> steps</span><br><span class="line">                <span class="keyword">for</span> dx, dy <span class="keyword">in</span> [(<span class="number">-1</span>,<span class="number">-1</span>), (<span class="number">1</span>,<span class="number">0</span>), (<span class="number">0</span>,<span class="number">1</span>), (<span class="number">-1</span>,<span class="number">0</span>), (<span class="number">0</span>,<span class="number">-1</span>), (<span class="number">1</span>,<span class="number">1</span>), (<span class="number">1</span>,<span class="number">-1</span>), (<span class="number">-1</span>,<span class="number">1</span>)]:</span><br><span class="line">                    <span class="comment"># 注意越界处理</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= i + dx &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= j + dy &lt; n <span class="keyword">and</span> grid[i+dx][j+dy] == <span class="number">0</span>:</span><br><span class="line">                        queue.append((i + dx, j + dy))</span><br><span class="line">                        grid[i + dx][j + dy] = <span class="number">1</span></span><br><span class="line">            steps += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：最坏的情况，我们需要遍历整个 board，因此时间复杂度取决于 cell 数，故时间复杂度为 $O(N ^ 2)$，其中 N 为边长。</li><li>空间复杂度：我们没有使用 seen，仅仅是借助了队列， 故空间复杂度为 $O(N)$，如果使用 seen 的话复杂度会上升到$O(N ^ 2)$，其中 N 为边长。</li></ul><p>补充：</p><ul><li>空间复杂度的$O(N)$ 是怎么来的？ 我这里给大家画了一个图， 相信大家一下子就懂来。其中不同的颜色表示不同的层次，从红色开始表示第一层，然后往外扩张。可以看出队列最长的情况下和$N$同阶，因此空间复杂度为$O(N)$。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfdz2wpkvij30fj0au78o.jpg" alt></p><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://github.com/azl397985856/leetcode/blob/master/problems/200.number-of-islands.md" title="200. 岛屿数量" target="_blank" rel="noopener">200. 岛屿数量</a></li><li><a href="https://leetcode-cn.com/problems/max-area-of-island/solution/695-dao-yu-de-zui-da-mian-ji-dfspython3-by-fe-luci/" title="695. 岛屿的最大面积" target="_blank" rel="noopener">695. 岛屿的最大面积</a></li><li><a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/python-tu-jie-chao-jian-dan-de-bfs1162-di-tu-fen-x/" title="1162. 地图分析" target="_blank" rel="noopener">1162. 地图分析</a></li><li><a href="https://github.com/azl397985856/leetcode/blob/master/problems/62.unique-paths.md" title="62. 不同路径" target="_blank" rel="noopener">62. 不同路径</a></li></ul><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p>大家也可以关注我的公众号《力扣加加 sa》获取更多更新鲜的 LeetCode 题解</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> BFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣加加闪亮登场～</title>
      <link href="/blog/2020/06/01/leetcode-pp/"/>
      <url>/blog/2020/06/01/leetcode-pp/</url>
      
        <content type="html"><![CDATA[<p>力扣加加，一个努力做西湖区最好的算法题解的团队。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2atkdikgj30u70u0tct.jpg" width="50%"><p>​<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">脑洞前端：你已经长大了，是时候自己写题解了。</span><br><span class="line">力扣加加：。。。</span><br></pre></td></tr></table></figure><p>独立的原因是让公众号的定位更加清晰，喜欢我的题解的朋友可以关注力扣加加，喜欢我的前端架构剖析，徒手造框架的朋友可以关注脑洞前端。当然如果你同时关注两个，那我会感动到哭。</p><p>虽然是新的公众号，但是我的初心不变，依然是<code>力求用清晰直白的方式还原解题过程，努力做西湖区最好的算法题解</code>。最后感谢大家一路以来的支持，我一定不负众望，越做越好。</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>预计力扣加加会推出<strong>五个</strong>板块。</p><h3 id="91-算法"><a href="#91-算法" class="headerlink" title="91 算法"></a>91 算法</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfctrpi6sfj30xm0b6js7.jpg" alt></p><p>通过在 91 天的集中训练，帮助大家摆脱困境，征服算法。我们会帮助大家规划学习路线，91 天见证不一样的自己。群里会有专门的资深算法竞赛大佬坐阵解答大家的问题和疑问，并且会对前一天的题目进行讲解。<strong>我会在结束之后将讲义和题解放到公众号号</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcubuzax3j30h9086gm6.jpg" alt><br>（仓库部分内容）</p><h3 id="算法题解"><a href="#算法题解" class="headerlink" title="算法题解"></a>算法题解</h3><p>就是对力扣中的题目进行讲解，尤其是经典的题目。并且尽量从多个角度思路，帮助大家纵向打开解题思路。目前差不多有几百的题解了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuje66ltj30wl0migsw.jpg" alt></p><h3 id="专题讲解"><a href="#专题讲解" class="headerlink" title="专题讲解"></a>专题讲解</h3><p>对于共性比较强的，我会抽离成专题形式，帮助大家横向打开解题思路。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcucqfgczj30am0fgabj.jpg" alt><br>（之后会陆续加入更多专题）</p><h3 id="视频题解"><a href="#视频题解" class="headerlink" title="视频题解"></a>视频题解</h3><p>对于一些题目采用视频的方式可能更加直观方便，之后还会考虑直播。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcueie2w0j31bf07nwhl.jpg" alt></p><h3 id="刷题工具"><a href="#刷题工具" class="headerlink" title="刷题工具"></a>刷题工具</h3><p>初步规划了两个小工具，之后出测试版本会第一时间告诉大家，如果你对开发小工具感兴趣，也可以点击公众号的联系我来和我取得联系。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcun5uakzj31j20u0kc3.jpg" alt><br>（力扣加加刷题小助手）</p><h2 id="悬赏令"><a href="#悬赏令" class="headerlink" title="悬赏令"></a>悬赏令</h2><p>大家在日常生活或是在刷题过程中有时一定会产生一些疑问，百度谷歌翻来覆去的找也找不到心中所期待的答案，因此，大家可以通过<strong>力扣加加</strong>来将这些疑问提出来，不定期从大家的问题中挑选出比较经典的几个问题来供大家一起讨论，大致的问题类型如下：</p><ul><li>日常生活中有个问题想用数据结构+算法解决，但苦于思路不清晰</li><li>问题本身比较纠结，网上众说纷纭，找不到明确的答案</li><li>脑洞问题等等</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcwc7ow13j30la0cewgf.jpg" alt><br>（比如这种问题）</p><p>被抽中的问题对应的朋友及问题回答出色的朋友可以获得准备的小礼物哦！</p><p>最后，每周我们会根据公众号后台的阅读量及分享次数最多的小伙伴给予现金奖励奖励哦～。分享最多 <code>1</code> 人 <code>8.88</code> 红包，阅读最多的 <code>1</code> 人 <code>6.66</code> 红包。</p><p>不是第一也没有关系，我们会从分享排名 <code>2-10</code>撒 名的小伙伴中随机抽取<code>2个</code> 8.88 元红包，阅读排名 <code>2-10</code> 名的小伙伴中随机抽取<code>2个</code> 6.88 元红包，</p><blockquote><p>每周日下午，我们会对本周的数据进行统计，并随机抽取幸运的小伙伴，并对中奖结果在力扣加加公众号进行公布，中奖的小伙伴请主动联系我哦。领奖时间截止到每周日的 24:00。</p></blockquote><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><h3 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h3><p>点关注，不迷路。如果再给 ➕ 个星标就更棒啦！</p><blockquote><p>关注加加，星标加加～</p></blockquote><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" width="100%"><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><ul><li><a href="http://leetcode-solution.cn/" target="_blank" rel="noopener">力扣加加官网</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 力扣加加 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 算法提高班 </tag>
            
            <tag> 力扣加加 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 312. 戳气球</title>
      <link href="/blog/2020/06/01/312.burst-balloons/"/>
      <url>/blog/2020/06/01/312.burst-balloons/</url>
      
        <content type="html"><![CDATA[<p>​<a id="more"></a></p><h2 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312. 戳气球"></a>312. 戳气球</h2><blockquote><p>作者：dp 加加</p></blockquote><p>这是一道比较难且巧妙的动态规划题目；这道题目并不适合初学者看，比较适合 dp 进阶选手研究。好了，废话不多说，直接上菜。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">有 n 个气球，编号为0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。</span><br><span class="line"></span><br><span class="line">现在要求你戳破所有的气球。每当你戳破一个气球 i 时，你可以获得 nums[left] * nums[i] * nums[right] 个硬币。 这里的 left 和 right 代表和 i 相邻的两个气球的序号。注意当你戳破了气球 i 后，气球 left 和气球 right 就变成了相邻的气球。</span><br><span class="line"></span><br><span class="line">求所能获得硬币的最大数量。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">你可以假设 nums[-1] = nums[n] = 1，但注意它们不是真实存在的所以并不能被戳破。</span><br><span class="line">0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100</span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [3,1,5,8]</span><br><span class="line">输出: 167</span><br><span class="line">解释: nums = [3,1,5,8] --&gt; [3,5,8] --&gt;   [3,8]   --&gt;  [8]  --&gt; []</span><br><span class="line">     coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><p>分析一下这道题，就是要截破所有的气球，获得硬币的最大数量，然后左右两边的气球相邻了。那就截呗，我的第一反应就是暴力，回溯法；但是肯定会超时，为什么呢？因为题目给的气球数量有点多，最多 500 个；500 的阶乘，会超时爆栈；但是我们依然写一下代码，找下突破口，小伙伴们千万不要看不起暴力，暴力是优化的突破口；如果小伙伴对回溯法不太熟悉，我建议你记住下面的模版，也可以看我之前写的文章，回溯法基本可以使用以下的模版写。回溯法省心省力，0 智商负担，懂的朋友都懂，QAQ。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxCoins = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="built_in">Number</span>.MIN_VALUE;</span><br><span class="line">  backtrack(nums, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">  <span class="comment">// 回溯法，状态树很大</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">nums, score</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">      res = <span class="built_in">Math</span>.max(res, score);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = nums.length; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> point =</span><br><span class="line">        (i - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">1</span> : nums[i - <span class="number">1</span>]) *</span><br><span class="line">        nums[i] *</span><br><span class="line">        (i + <span class="number">1</span> &gt;= n ? <span class="number">1</span> : nums[i + <span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">let</span> tempNums = [].concat(nums);</span><br><span class="line">      <span class="comment">// 做选择 在 nums 中删除元素 nums[i]</span></span><br><span class="line">      nums.splice(i, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 递归回溯</span></span><br><span class="line">      backtrack(nums, score + point);</span><br><span class="line">      <span class="comment">// 撤销选择</span></span><br><span class="line">      nums = [...tempNums];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>回溯法的缺点也很明显，复杂度很高，对应本题截气球；小伙伴们可以脑补一下执行过程的状态树，这里我偷个懒就不画了；通过仔细观察这个状态树，我们会发现这个状态树的【选择】上，会有一些重复的选择分支；很明显存在了重复子问题；自然我就想到了能不能用动态规划来解决；</p><p>判读能不能用动态规划解决，还有一个问题，就是必须存在最优子结构；什么意思呢？其实就是根据局部最优，推导出答案；假设我们截破第 k 个气球是最优策略的最后一步，和上一步有没有联系呢？根据题目意思，截破第 k 个，前一个和后一个就变成相邻的了，看似是会有联系，其实是没有的。因为截破第 k 个和 k-1 个是没有联系的，脑补一下回溯法的状态树就更加明确了；</p><p>既然用动态规划，那就老套路了，把动态规划的三个问题想清楚定义好；然后找出题目的【状态】和【选择】，然后根据【状态】枚举，枚举的过程中根据【选择】计算递推就能得到答案了。</p><p>那本题的【选择】是什么呢？就是截哪一个气球。那【状态】呢？就是题目给的气球数量。</p><ol><li>定义状态</li></ol><ul><li>这里有个细节，就是题目说明有两个虚拟气球，nums[-1] = nums[n] = 1；如果当前截破的气球是最后一个或者第一个，前面/后面没有气球了，不能乘以 0，而是乘以 1。</li><li>定义状态的最关键两个点，往子问题（问题规模变小）想，最后一步最优策略是什么；我们假设最后截破的气球是 k，截破 k 获得最大数量的银币就是 nums[i] _ nums[k] _ nums[j] 再加上前面截破的最大数量和后面的最大数量，即：nums[i] _ nums[k] _ nums[j] + 前面最大数量 + 后面最大数量，就是答案。</li><li>而如果我们不考虑两个虚拟气球而直接定义状态，截到最后两个气球的时候又该怎么定义状态来避免和前面的产生联系呢？这两个虚拟气球就恰到好处了，太细节了；这也是本题的一个难点之一。</li><li>那我们可以这样来定义状态，dp[i][j] = x 表示，戳破气球 i 和气球 j 之间（开区间，不包括 i 和 j）的所有气球，可以获得的最大硬币数为 x。为什么开区间？因为不能和已经计算过的产生联系，我们这样定义之后，利用两个虚拟气球，截到最后两个气球的时候就完美的避开了所有状态的联系，太细节了。</li></ul><ol start="2"><li>状态转移方程</li></ol><ul><li>而对于 dp[i][j]，i 和 j 之间会有很多气球，到底该截哪个先呢？我们直接设为 k，枚举选择最优的 k 就可以了。</li><li>所以，最终的状态转移方程为：dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[k] + nums[i] + nums[j])</li></ul><ol start="3"><li>初始值和边界</li></ol><ul><li>由于我们利用了两个虚拟气球，边界就是气球数 n + 2</li><li>初始值，当 i == j 时，很明显两个之间没有气球，所有为 0；</li></ul><ol start="4"><li>如何枚举状态</li></ol><ul><li>因为我们最终要求的答案是 dp[0][n + 1]，就是截破虚拟气球之间的所有气球获得的最大值；</li><li>当 i == j 时，i 和 j 之间是没有气球的，所以枚举的状态很明显是 dp table 的左上部分，也就是 j 大于 i，如下图所示，只给出一部分方便思考。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfckn1vngxj30lk0aodgf.jpg" alt></p><blockquote><p>从上图可以看出，我们需要从下到上，从左到右进行遍历。</p></blockquote><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxCoins = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.length;</span><br><span class="line">  <span class="comment">// 添加两侧的虚拟气球</span></span><br><span class="line">  <span class="keyword">let</span> points = [<span class="number">1</span>, ...nums, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="built_in">Array</span>.from(<span class="built_in">Array</span>(n + <span class="number">2</span>), () =&gt; <span class="built_in">Array</span>(n + <span class="number">2</span>).fill(<span class="number">0</span>));</span><br><span class="line">  <span class="comment">// 最后一行开始遍历,从下往上</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 从左往右</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">Math</span>.max(</span><br><span class="line">          dp[i][j],</span><br><span class="line">          points[j] * points[k] * points[i] + dp[i][k] + dp[k][j]</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单的 dp 题目会直接告诉你怎么定义状态，告诉你怎么选择计算，你只需要根据套路判断一下能不能用 dp 解题即可，而判断能不能，往往暴力就是突破口。而困难点的 dp，我觉的都是细节问题了，要注意的细节太多了。感觉力扣加加，路西法大佬，把我领进了动态规划的大门，共勉。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 数组 </category>
          
          <category> 动态规划 </category>
          
          <category> 回溯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 101. 对称二叉树</title>
      <link href="/blog/2020/05/31/101.symmetric-tree/"/>
      <url>/blog/2020/05/31/101.symmetric-tree/</url>
      
        <content type="html"><![CDATA[<p>​<a id="more"></a></p><h2 id="题目地址-101-对称二叉树"><a href="#题目地址-101-对称二叉树" class="headerlink" title="题目地址(101. 对称二叉树)"></a>题目地址(101. 对称二叉树)</h2><p><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，检查它是否是镜像对称的。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">进阶：</span><br><span class="line"></span><br><span class="line">你可以运用递归和迭代两种方法解决这个问题吗？</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到这题的时候，我的第一直觉是 DFS。然后我就想:<code>如果左子树是镜像，并且右子树也是镜像，是不是就说明整体是镜像？</code>。经过几秒的思考， 这显然是不对的，不符合题意。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfbmeoo45bj31200iuabh.jpg" alt></p><p>很明显其中左子树中的节点会和右子树中的节点进行比较，我把比较的元素进行了颜色区分，方便大家看。</p><p>这里我的想法是：<code>遍历每一个节点的时候，我都可以通过某种方法知道它对应的对称节点是谁。这样的话我直接比较两者是否一致就行了。</code></p><p>最初我的想法是两次遍历，第一次遍历的同时将遍历结果存储到哈希表中，然后第二次遍历去哈希表取。</p><p>这种方法可行，但是需要 N 的空间（N 为节点总数）。我想到如果两者可以同时进行遍历，是不是就省去了哈希表的开销。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfbso8u6myj31a30u0tf5.jpg" alt></p><p>如果不明白的话，我举个简单例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，检查它是否是镜像对称的。例如，数组 [1,2,2,3,2,2,1] 是对称的。</span><br></pre></td></tr></table></figure><p>如果用哈希表的话大概是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seen = dict()</span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">    seen[i] = num</span><br><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">    <span class="keyword">if</span>  seen[len(nums) - <span class="number">1</span> - i] != num:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>而同时遍历的话大概是这样的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="number">0</span></span><br><span class="line">r = len(nums) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> l &lt; r:</span><br><span class="line">   <span class="keyword">if</span> nums[l] != nums[r]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">   l += <span class="number">1</span></span><br><span class="line">   r -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><p>其实更像本题一点的话应该是从中间分别向两边扩展 😂</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(root1, root2)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root1 == root2: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">or</span> <span class="keyword">not</span> root2: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> root1.val != root2.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> dfs(root1.left, root2.right) <span class="keyword">and</span> dfs(root1.right, root2.left)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, root.right)</span><br></pre></td></tr></table></figure><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：$O(N)$，其中 N 为节点数。</li><li>空间复杂度：递归的深度最高为节点数，因此空间复杂度是 $O(N)$，其中 N 为节点数。</li></ul><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的 LeetCode 题解</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfaq00p8stj30x20iw7b0.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> hashtable </category>
          
          <category> DFS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 1449. 数位成本和为目标值的最大数字</title>
      <link href="/blog/2020/05/30/1449.form-largest-integer-with-digits-that-add-up-to-target/"/>
      <url>/blog/2020/05/30/1449.form-largest-integer-with-digits-that-add-up-to-target/</url>
      
        <content type="html"><![CDATA[<p>这是一道难度 Hard 的经典背包问题，属于完全背包问题，来看看背包问题的套路吧～</p><p>​<a id="more"></a></p><h1 id="题目地址（1449-数位成本和为目标值的最大数字）"><a href="#题目地址（1449-数位成本和为目标值的最大数字）" class="headerlink" title="题目地址（1449. 数位成本和为目标值的最大数字）"></a>题目地址（1449. 数位成本和为目标值的最大数字）</h1><p><a href="https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 最大 整数：</span><br><span class="line"></span><br><span class="line">给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。</span><br><span class="line">总成本必须恰好等于 target 。</span><br><span class="line">添加的数位中没有数字 0 。</span><br><span class="line">由于答案可能会很大，请你以字符串形式返回。</span><br><span class="line"></span><br><span class="line">如果按照上述要求无法得到任何整数，请你返回 &quot;0&quot; 。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：cost = [4,3,2,5,6,7,2,5,5], target = 9</span><br><span class="line">输出：&quot;7772&quot;</span><br><span class="line">解释：添加数位 &apos;7&apos; 的成本为 2 ，添加数位 &apos;2&apos; 的成本为 3 。所以 &quot;7772&quot; 的代价为 2*3+ 3*1 = 9 。 &quot;997&quot; 也是满足要求的数字，但 &quot;7772&quot; 是较大的数字。</span><br><span class="line"> 数字     成本</span><br><span class="line">  1  -&gt;   4</span><br><span class="line">  2  -&gt;   3</span><br><span class="line">  3  -&gt;   2</span><br><span class="line">  4  -&gt;   5</span><br><span class="line">  5  -&gt;   6</span><br><span class="line">  6  -&gt;   7</span><br><span class="line">  7  -&gt;   2</span><br><span class="line">  8  -&gt;   5</span><br><span class="line">  9  -&gt;   5</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：cost = [7,6,5,5,5,6,8,7,8], target = 12</span><br><span class="line">输出：&quot;85&quot;</span><br><span class="line">解释：添加数位 &apos;8&apos; 的成本是 7 ，添加数位 &apos;5&apos; 的成本是 5 。&quot;85&quot; 的成本为 7 + 5 = 12 。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：cost = [2,4,6,2,4,6,4,4,4], target = 5</span><br><span class="line">输出：&quot;0&quot;</span><br><span class="line">解释：总成本是 target 的条件下，无法生成任何整数。</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：cost = [6,10,15,40,40,40,40,40,40], target = 47</span><br><span class="line">输出：&quot;32211&quot;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">cost.length == 9</span><br><span class="line">1 &lt;= cost[i] &lt;= 5000</span><br><span class="line">1 &lt;= target &lt;= 5000</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于数组可以重复选择，因此这是一个完全背包问题。</p><h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><p>对于 01 背包问题，我们的套路是：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> to N:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span> to V + <span class="number">1</span>:</span><br><span class="line">        dp[j] = max(dp[j], dp[j - cost[i])</span><br></pre></td></tr></table></figure><p>而一般我们为了处理边界问题，我们一般会这么写代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> to N + <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 这里是倒序的，原因在于这里是01背包。</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> V to <span class="number">0</span>:</span><br><span class="line">        dp[j] = max(dp[j], dp[j - cost[i - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>其中 dp[j] 表示只能选择前 i 个物品，背包容量为 j 的情况下，能够获得的最大价值。</p><blockquote><p>dp[j] 不是没 i 么？ 其实我这里 i 指的是 dp[j]当前所处的循环中的 i 值</p></blockquote><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>回到问题，我们这是完全背包问题:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> to N + <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 这里不是倒序，原因是我们这里是完全背包问题</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span> to V + <span class="number">1</span>:</span><br><span class="line">        dp[j] = max(dp[j], dp[j - cost[i - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="为什么-01-背包需要倒序，而完全背包则不可以"><a href="#为什么-01-背包需要倒序，而完全背包则不可以" class="headerlink" title="为什么 01 背包需要倒序，而完全背包则不可以"></a>为什么 01 背包需要倒序，而完全背包则不可以</h3><p>实际上，这是一个骚操作，我来详细给你讲一下。</p><p>其实要回答这个问题，我要先将 01 背包和完全背包退化二维的情况。</p><p>对于 01 背包：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> to N + <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> V to <span class="number">0</span>:</span><br><span class="line">        dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - cost[i - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>注意等号左边是 i，右边是 i - 1，这很好理解，因为 i 只能取一次嘛。</p><p>那么如果我们不降序遍历会怎么样呢？</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfaqt9hh8hj30uy0giabo.jpg" alt></p><p>如图橙色部分表示已经遍历的部分，而让我们去用[j - cost[i - 1]] 往前面回溯的时候，实际上回溯的是 dp[i]j - cost[i - 1]]，而不是 dp[i - 1]j - cost[i - 1]]。</p><p>如果是降序就可以了，如图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfaqtkc1cmj30u80fcmyo.jpg" alt></p><p>这个明白的话，我们继续思考为什么完全背包就要不降序了呢？</p><p>我们还是像上面一样写出二维的代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> to N + <span class="number">1</span>:</span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span> to V + <span class="number">1</span>:</span><br><span class="line">       dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - cost[i - <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>由于 i 可以取无数次，那么正序遍历正好可以满足，如上图。</p><h3 id="恰好装满-VS-可以不装满"><a href="#恰好装满-VS-可以不装满" class="headerlink" title="恰好装满 VS 可以不装满"></a>恰好装满 VS 可以不装满</h3><p>题目有两种可能，一种是要求背包恰好装满，一种是可以不装满（只要不超过容量就行）。而本题是要求<code>恰好装满</code>的。而这两种情况仅仅影响我们<code>dp数组初始化</code>。</p><ul><li>恰好装满。只需要初始化 dp[0] 为 0， 其他初始化为负数即可。</li><li>可以不装满。 只需要全部初始化为 0，即可，</li></ul><p>原因很简单，我多次强调过 dp 数组本质上是记录了一个个自问题。 dp[0]是一个子问题，dp[1]是一个子问题。。。</p><p>有了上面的知识就不难理解了。 初始化的时候，我们还没有进行任何选择，那么也就是说 dp[0] = 0，因为我们可以通过什么都不选达到最大值 0。而 dp[1],dp[2]…则在当前什么都不选的情况下无法达成，也就是无解，因为为了区分，我们可以用负数来表示，当然你可以用任何可以区分的东西表示，比如 None。</p><h3 id="回到本题"><a href="#回到本题" class="headerlink" title="回到本题"></a>回到本题</h3><p>而这道题和普通的完全背包不一样，这个是选择一个组成的最大数。由小学数学知识<code>一个数字的全排列中，按照数字降序排列是最大的</code>，我这里用了一个骚操作，那就是 cost 从后往前遍历，因为后面表示的数字大。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestNumber</span><span class="params">(self, cost: List[int], target: int)</span> -&gt; str:</span></span><br><span class="line">        dp = [<span class="number">0</span>] + [float(<span class="string">'-inf'</span>)] * target</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, target+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j &gt;= cost[i - <span class="number">1</span>]:</span><br><span class="line">                    dp[j] = max(dp[j], (dp[j-cost[i - <span class="number">1</span>]] * <span class="number">10</span>) + i)</span><br><span class="line">        <span class="keyword">return</span> str(dp[target]) <span class="keyword">if</span> dp[target] &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">'0'</span></span><br></pre></td></tr></table></figure><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：$O(target))$</li><li>空间复杂度：$O(target)$</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>最后贴几个我写过的背包问题，让大家看看历史是多么的相似。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfaqty4tg3j31iq0sotdg.jpg" alt><br>（<a href="https://github.com/azl397985856/leetcode/blob/master/problems/322.coin-change.md" target="_blank" rel="noopener">322. 硬币找零(完全背包问题)</a>）</p><blockquote><p>这里内外循环和本题正好是反的，我只是为了”秀技”(好玩)，实际上在这里对答案并不影响。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfaqu6xzg5j31go0gwq4o.jpg" alt><br>（<a href="https://github.com/azl397985856/leetcode/blob/master/problems/518.coin-change-2.md" target="_blank" rel="noopener">518. 零钱兑换 II</a>）</p><blockquote><p>这里内外循环和本题正好是反的，但是这里必须这么做，否则结果是不对的，具体可以点进去链接看我那个题解</p></blockquote><p>所以这两层循环的位置起的实际作用是什么？ 代表的含义有什么不同？</p><p>本质上:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> to N + <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> V to <span class="number">0</span>:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>这种情况选择物品 1 和物品 3（随便举的例子），是一种方式。选择物品 3 个物品 1（注意是有顺序的）是同一种方式。 <strong>原因在于你是固定物品，去扫描容量</strong>。</p><p>而：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> V to <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> to N + <span class="number">1</span>:</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>这种情况选择物品 1 和物品 3（随便举的例子），是一种方式。选择物品 3 个物品 1（注意是有顺序的）也是一种方式。<strong>原因在于你是固定容量，去扫描物品</strong>。</p><p><strong>因此总的来说，如果你认为[1,3]和[3,1]是一种，那么就用方法 1 的遍历，否则用方法 2。</strong></p><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的 LeetCode 题解</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfaq00p8stj30x20iw7b0.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 数组 </category>
          
          <category> 动态规划 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>倒计时两天～91算法，儿童节发车！</title>
      <link href="/blog/2020/05/30/91algo-05-30/"/>
      <url>/blog/2020/05/30/91algo-05-30/</url>
      
        <content type="html"><![CDATA[<p>力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2atkdikgj30u70u0tct.jpg" width="50%"><p>​<a id="more"></a></p><p>91 算法第一期，从<strong>2020-06-01 到 2020-08-30</strong>。</p><p>马上就要发车了哦，大家准备好了么？儿童节，我们来啦。如果还有<strong>没参与的小伙伴</strong>，想要参与的可以在下方<code>更多</code>部分寻找参与方式，目前支持 QQ 和微信加入。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>共分为三篇，<code>基础篇</code>，<code>进阶篇</code>和<code>专题篇</code>。</p><p>让你：</p><ul><li>显著提高你的刷题效率，让你少走弯路</li><li>掌握常见面试题的思路和解法</li><li>掌握常见套路，了解常见算法的本质，横向对比各种题目</li><li>纵向剖析一道题，多种方法不同角度解决同一题目</li></ul><p>第一阶段基础篇(30 天)。预计五个子栏目，每个子栏目 6 天。到时候发讲义给大家，题目的话天一道。 <strong>讲义的内容大概是我在下方讲义部分放出的链接那样哦。</strong></p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>大家的问题，打卡题目，讲义都在这里更新哦，冲鸭 🦆 。91 天见证更好的自己！不过要注意一周不打卡会被强制清退。</p><h2 id="需要提前准备些什么？"><a href="#需要提前准备些什么？" class="headerlink" title="需要提前准备些什么？"></a>需要提前准备些什么？</h2><ul><li>数据结构与算法的基础知识。 推荐看一下大学里面的教材讲义，或者看一些入门的图书，视频等，比如《图解算法》，邓俊辉的《数据结构与算法》免费视频课程。总之， 至少<code>你要知道有哪些常见的数据结构与算法以及他们各自的特点。</code></li><li>有 Github 账号，且会使用 Github 常用操作。 比如提 issue，留言等。</li><li>有 LeetCode 账号，且会用其提交代码。</li></ul><blockquote><p>语言不限，大家可以用自己喜欢的任何语言。同时我也希望你不要纠结于语言本身。</p></blockquote><h2 id="具体形式是什么样的？"><a href="#具体形式是什么样的？" class="headerlink" title="具体形式是什么样的？"></a>具体形式是什么样的？</h2><ul><li>总共三个大的阶段</li><li>每个大阶段划分为几个小阶段</li><li>每个小阶段前会将这个小阶段的资料发到群里</li><li>每个小阶段的时间内，每天都会出关于这个阶段的题目，第二天进行解答</li></ul><p>比如：</p><ul><li>第一个大阶段是基础</li><li>基础中第一个小阶段是<code>数组，栈和队列</code>。</li><li><code>数组，栈和队列</code>正式开始前，会将资料发到群里，大家可以提前预习。</li><li>之后的每天都会围绕<code>数组，栈和队列</code>出一道题，第二天进行解答。大家可以在出题当天上 Github 上打卡。</li></ul><blockquote><p>大家遇到问题可以在群里回答，对于比较好的问题，会记录到 github issue 中，让更多的人看到。Github 仓库地址届时会在群里公布。</p></blockquote><h2 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h2><p>对于坚持打卡满一个月的同学，可以参加抽奖，奖品包括算法模拟面试，算法相关的图书等<br>连续打卡七天可以获得补签卡一张哦</p><h2 id="讲义"><a href="#讲义" class="headerlink" title="讲义"></a>讲义</h2><ul><li><a href="https://lucifer.ren/blog/2020/05/26/91algo-basic-05.two-pointer/">【91 算法-基础篇】05.双指针</a></li></ul><h2 id="课程列表"><a href="#课程列表" class="headerlink" title="课程列表"></a>课程列表</h2><ul><li><a href="https://lucifer.ren/blog/2020/05/23/91-algo/">回炉重铸， 91 天见证不一样的自己</a></li></ul><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><ul><li><a href="https://lucifer.ren/blog/2020/05/25/91-algo2/">如何加入微信群？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 力扣加加 </category>
          
          <category> 91天学算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 算法提高班 </tag>
            
            <tag> 91天学算法 </tag>
            
            <tag> 力扣加加 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【91算法-基础篇】05.双指针</title>
      <link href="/blog/2020/05/26/91algo-basic-05.two-pointer/"/>
      <url>/blog/2020/05/26/91algo-basic-05.two-pointer/</url>
      
        <content type="html"><![CDATA[<p>力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2atkdikgj30u70u0tct.jpg" width="50%"><p>​<a id="more"></a></p><h2 id="什么是双指针"><a href="#什么是双指针" class="headerlink" title="什么是双指针"></a>什么是双指针</h2><p>顾名思议，双指针就是<strong>两个指针</strong>，但是不同于 C，C++中的指针， 其是一种<strong>算法思想</strong>。</p><p>如果说，我们迭代一个数组，并输出数组每一项，我们需要一个指针来记录当前遍历的项，这个过程我们叫单指针（index）的话。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size(); i++) &#123;</span><br><span class="line">  输出(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5w79tciyj30aa0hl77b.jpg" alt></p><p>（图 1）</p><p>那么双指针实际上就是有两个这样的指针，最为经典的就是二分法中的左右双指针啦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r = nums.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">if</span>(一定条件) <span class="keyword">return</span> 合适的值，一般是 l 和 r 的中点</span><br><span class="line">    <span class="keyword">if</span>(一定条件) l++</span><br><span class="line">    <span class="keyword">if</span>(一定条件) r--</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为 l == r，因此返回 l 和 r 都是一样的</span></span><br><span class="line"><span class="keyword">return</span> l</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf5yfe9da7j307504ut8r.jpg" alt></p><p>（图 2）</p><p>读到这里，你发现双指针是一个很宽泛的概念，就好像数组，链表一样，其类型会有很多很多， 比如二分法经常用到<code>左右端点双指针</code>。滑动窗口会用到<code>快慢指针和固定间距指针</code>。 因此双指针其实是一种综合性很强的类型，类似于数组，栈等。 但是我们这里所讲述的双指针，往往指的是某几种类型的双指针，而不是“只要有两个指针就是双指针了”。</p><blockquote><p>有了这样一个<strong>算法框架</strong>，或者算法思维，有很大的好处。它能帮助你理清思路，当你碰到新的问题，在脑海里进行搜索的时候，<strong>双指针</strong>这个词就会在你脑海里闪过，闪过的同时你可以根据<strong>双指针</strong>的所有套路和这道题进行<strong>穷举匹配</strong>，这个思考解题过程本来就像是算法，我会在进阶篇《搜索算法》中详细阐述。</p></blockquote><p>那么究竟我们算法中提到的双指针指的是什么呢？我们一起来看下算法中双指针的常见题型吧。</p><h2 id="常见题型有哪些？"><a href="#常见题型有哪些？" class="headerlink" title="常见题型有哪些？"></a>常见题型有哪些？</h2><p>这里我将其分为三种类类型，分别是：</p><ol><li>快慢指针（两个指针步长不同）</li><li>左右端点指针（两个指针分别指向头尾，并往中间移动，步长不确定）</li><li>固定间距指针（两个指针间距相同，步长相同）</li></ol><blockquote><p>上面是我自己的分类，没有参考别人。可以发现我的分类标准已经覆盖了几乎所有常见的情况。 大家在平时做题的时候一定要养成这样的习惯，将题目类型进行总结，当然这个总结可以是别人总结好的，也可以是自己独立总结的。不管是哪一种，都要进行一定的消化吸收，把它们变成真正属于自己的知识。</p></blockquote><p>不管是哪一种双指针，只考虑双指针部分的话 ，由于最多还是会遍历整个数组一次，因此时间复杂度取决于步长，如果步长是 1，2 这种常数的话，那么时间复杂度就是 O(N)，如果步长是和数据规模有关（比如二分法），其时间复杂度就是 O(logN)。并且由于不管规模多大，我们都只需要最多两个指针，因此空间复杂度是 O(1)。下面我们就来看看双指针的常见套路有哪些。</p><h2 id="常见套路"><a href="#常见套路" class="headerlink" title="常见套路"></a>常见套路</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><ol><li>判断链表是否有环</li></ol><p>这里给大家推荐两个非常经典的题目，一个是力扣 287 题，一个是 142 题。其中 142 题我在我的 LeetCode 题解仓库中的每日一题板块出过，并且给了很详细的证明和解答。而 287 题相对不直观，比较难以想到，这道题曾被官方选定为每日一题，也是相当经典的。</p><ul><li><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></p></li><li><p><a href="https://github.com/azl397985856/leetcode/issues/274" target="_blank" rel="noopener">【每日一题】- 2020-01-14 - 142. 环形链表 II · Issue #274 · azl397985856/leetcode</a></p></li></ul><ol start="2"><li>读写指针。典型的是<code>删除重复元素</code></li></ol><p>这里推荐我仓库中的一道题， 我这里写了一个题解，横向对比了几个相似题目，并剖析了这种题目的本质是什么，让你看透题目本质，推荐阅读。</p><ul><li><a href="https://github.com/azl397985856/leetcode/blob/master/problems/80.remove-duplicates-from-sorted-array-ii.md" target="_blank" rel="noopener">80.删除排序数组中的重复项 II</a></li></ul><h2 id="左右端点指针"><a href="#左右端点指针" class="headerlink" title="左右端点指针"></a>左右端点指针</h2><ol><li>二分查找。</li></ol><p>二分查找会在专题篇展开，这里不多说，大家先知道就行了。</p><ol start="2"><li>暴力枚举中“从大到小枚举”（剪枝）</li></ol><p>一个典型的题目是我之前参加官方每日一题的时候给的一个解法，大家可以看下。这种解法是可以 AC 的。同样地，这道题我也给出了三种方法，帮助大家从多个纬度看清这个题目。强烈推荐大家做到一题多解。这对于你做题很多帮助。除了一题多解，还有一个大招是多题同解，这部分我们放在专题篇介绍。</p><p><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/qian-zhui-he-zhuang-tai-ya-suo-pythonjava-by-fe-lu/" target="_blank" rel="noopener">find-the-longest-substring-containing-vowels-in-even</a></p><ol start="3"><li>有序数组。</li></ol><p>区别于上面的二分查找，这种算法指针移动是连续的，而不是跳跃性的，典型的是 LeetCode 的<code>两数和</code>，以及<code>N数和</code>系列问题。</p><h2 id="固定间距指针"><a href="#固定间距指针" class="headerlink" title="固定间距指针"></a>固定间距指针</h2><ol><li><p>一次遍历（One Pass）求链表的中点</p></li><li><p>一次遍历（One Pass）求链表的倒数第 k 个元素</p></li><li><p>固定窗口大小的滑动窗口</p></li></ol><h2 id="模板-伪代码"><a href="#模板-伪代码" class="headerlink" title="模板(伪代码)"></a>模板(伪代码)</h2><p>我们来看下上面三种题目的算法框架是什么样的。这个时候我们没必要纠结具体的语言，这里我直接使用了伪代码，就是防止你掉进细节。</p><p>当你掌握了这种算法的细节，就应该找几个题目试试。一方面是检测自己是否真的掌握了，另一方面是“细节”，”细节“是人类，尤其是软件工程师最大的敌人，毕竟我们都是<code>差不多先生</code>。</p><ol><li>快慢指针</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="number">0</span></span><br><span class="line">r = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> 没有遍历完</span><br><span class="line">  <span class="keyword">if</span> 一定条件</span><br><span class="line">    l += <span class="number">1</span></span><br><span class="line">  r += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> 合适的值</span><br></pre></td></tr></table></figure><ol start="2"><li>左右端点指针</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="number">0</span></span><br><span class="line">r = n - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> l &lt; r</span><br><span class="line">  <span class="keyword">if</span> 找到了</span><br><span class="line">    <span class="keyword">return</span> 找到的值</span><br><span class="line">  <span class="keyword">if</span> 一定条件<span class="number">1</span></span><br><span class="line">    l += <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>  一定条件<span class="number">2</span></span><br><span class="line">    r -= <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> 没找到</span><br></pre></td></tr></table></figure><ol start="3"><li>固定间距指针</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l = <span class="number">0</span></span><br><span class="line">r = k</span><br><span class="line"><span class="keyword">while</span> 没有遍历完</span><br><span class="line">  自定义逻辑</span><br><span class="line">  l += <span class="number">1</span></span><br><span class="line">  r += <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> 合适的值</span><br></pre></td></tr></table></figure><h2 id="题目推荐"><a href="#题目推荐" class="headerlink" title="题目推荐"></a>题目推荐</h2><p>如果你<code>差不多</code>理解了上面的东西，那么可以拿下面的题练练手。Let’s Go!</p><h3 id="左右端点指针-1"><a href="#左右端点指针-1" class="headerlink" title="左右端点指针"></a>左右端点指针</h3><ul><li>16.3Sum Closest (Medium)</li><li>713.Subarray Product Less Than K (Medium)</li><li>977.Squares of a Sorted Array (Easy)</li><li>Dutch National Flag Problem</li></ul><blockquote><p>下面是二分类型</p></blockquote><ul><li>33.Search in Rotated Sorted Array (Medium)</li><li>875.Koko Eating Bananas（Medium）</li><li>881.Boats to Save People（Medium）</li></ul><h3 id="快慢指针-1"><a href="#快慢指针-1" class="headerlink" title="快慢指针"></a>快慢指针</h3><ul><li>26.Remove Duplicates from Sorted Array（Easy）</li><li>141.Linked List Cycle (Easy)</li><li>142.Linked List Cycle II（Medium）</li><li>287.Find the Duplicate Number（Medium）</li><li>202.Happy Number (Easy)</li></ul><h3 id="固定间距指针-1"><a href="#固定间距指针-1" class="headerlink" title="固定间距指针"></a>固定间距指针</h3><ul><li>1456.Maximum Number of Vowels in a Substring of Given Length（Medium）</li></ul><blockquote><p>固定窗口大小的滑动窗口见专题篇的滑动窗口专题（暂未发布）</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>有时候也不能太思维定式，比如 <a href="https://leetcode-cn.com/problems/consecutive-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/consecutive-characters/</a> 这道题根本就没必要双指针什么的。</p><p>再比如：<a href="https://lucifer.ren/blog/2020/05/31/101.symmetric-tree/">https://lucifer.ren/blog/2020/05/31/101.symmetric-tree/</a></p>]]></content>
      
      
      <categories>
          
          <category> 力扣加加 </category>
          
          <category> 91天学算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 算法提高班 </tag>
            
            <tag> 91天学算法 </tag>
            
            <tag> 力扣加加 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回炉重铸， 91 天见证不一样的自己（2）</title>
      <link href="/blog/2020/05/25/91-algo2/"/>
      <url>/blog/2020/05/25/91-algo2/</url>
      
        <content type="html"><![CDATA[<p>力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。<code>前天想加入却没能加入的小伙伴可以进来啦，直接扫描文末二维码即可。</code></p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2atkdikgj30u70u0tct.jpg" width="50%"><p>​<a id="more"></a></p><p>自从前天开始，就接到了非常多的入群申请， 我一个人忙不过来， 就暂停了入群，希望大家理解。今天除了宣布<code>微信群今天开启入群</code> 之外，还给大家带来了几个大家问的多的问题的答案。分别是<code>我需要提前准备什么？</code>，<code>具体形式是怎么样的？</code>，<code>我还可以入群么？</code>。</p><blockquote><p>qq 群开放时间待定，开放后会第一时间在朋友圈和微信交流群进行告知</p></blockquote><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>为了让想学习的人能够真正学习到东西， 我打算新开一个栏目《91 天学算法》，在 91 天内来帮助那些想要学习算法，提升自己算法能力的同学，帮助大家建立完整的算法知识体系。</p><p>群里每天都会有题目，推荐大家讨论当天的题目。我们会帮助大家规划学习路线，91 天见证不一样的自己。群里会有专门的资深算法竞赛大佬坐阵解答大家的问题和疑问，并且会对前一天的题目进行讲解。1</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2b2zkclnj30xm0b6aat.jpg" alt></p><h2 id="活动时间"><a href="#活动时间" class="headerlink" title="活动时间"></a>活动时间</h2><p><code>2020-06-01</code> 至 <code>2020-08-30</code></p><h2 id="需要提前准备些什么？"><a href="#需要提前准备些什么？" class="headerlink" title="需要提前准备些什么？"></a>需要提前准备些什么？</h2><ul><li>数据结构与算法的基础知识。 推荐看一下大学里面的教材讲义，或者看一些入门的图书，视频等，比如《图解算法》，邓俊辉的《数据结构与算法》免费视频课程。总之， 至少<code>你要知道有哪些常见的数据结构与算法以及他们各自的特点。</code></li><li>有 Github 账号，且会使用 Github 常用操作。 比如提 issue，留言等。</li><li>有 LeetCode 账号，且会用其提交代码。</li></ul><blockquote><p>语言不限，大家可以用自己喜欢的任何语言。同时我也希望你不要纠结于语言本身。</p></blockquote><h2 id="具体形式是什么样的？"><a href="#具体形式是什么样的？" class="headerlink" title="具体形式是什么样的？"></a>具体形式是什么样的？</h2><ul><li>总共三个大的阶段</li><li>每个大阶段划分为几个小阶段</li><li>每个小阶段前会将这个小阶段的资料发到群里</li><li>每个小阶段的时间内，每天都会出关于这个阶段的题目，第二天进行解答</li></ul><p>比如：</p><ul><li>第一个大阶段是基础</li><li>基础中第一个小阶段是<code>数组，栈和队列</code>。</li><li><code>数组，栈和队列</code>正式开始前，会将资料发到群里，大家可以提前预习。</li><li>之后的每天都会围绕<code>数组，栈和队列</code>出一道题，第二天进行解答。大家可以在出题当天上 Github 上打卡。</li></ul><blockquote><p>大家遇到问题可以在群里回答，对于比较好的问题，会记录到 github issue 中，让更多的人看到。Github 仓库地址届时会在群里公布。</p></blockquote><h2 id="有微信群么？"><a href="#有微信群么？" class="headerlink" title="有微信群么？"></a>有微信群么？</h2><p>有很多小伙伴反应没有 qq，或者平时不用 qq，能否提供微信群供学习。其实我的内心是拒绝的，这会增加系统复杂度。但是随着反应的人数越来越多，我决定开发微信群。还是和 qq 群一样的收费标准，，具体看下方。</p><h2 id="如何加入微信群？"><a href="#如何加入微信群？" class="headerlink" title="如何加入微信群？"></a>如何加入微信群？</h2><p>添加我的微信，备注“91 算法”。那么怎么添加我呢？大家可以关注公众号<code>脑洞前端</code>，然后点击更多，在弹出的菜单中选择联系我即可。</p><h2 id="冲鸭"><a href="#冲鸭" class="headerlink" title="冲鸭"></a>冲鸭</h2><p>课程大纲可以<a href="https://lucifer.ren/blog/2020/05/23/91-algo/">点这里查看</a></p><p>收费标准：</p><ul><li>前 50 人免费</li><li>51 - 100 收费 5 元</li><li>101 - 500 收费 10 元</li></ul><blockquote><p>目前已经满 100 人了。</p></blockquote><p>本次活动并不是为了赚钱，而是为了给想学习的人营造一个良好的学习氛围，并且我们会对活跃的群员进行抽奖，活动基金就来源于大家的入群费。</p><p>入群截止时间： <code>2020-05-31 24:00:00</code></p>]]></content>
      
      
      <categories>
          
          <category> 力扣加加 </category>
          
          <category> 91天学算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 算法提高班 </tag>
            
            <tag> 91天学算法 </tag>
            
            <tag> 力扣加加 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回炉重铸， 91 天见证不一样的自己</title>
      <link href="/blog/2020/05/23/91-algo/"/>
      <url>/blog/2020/05/23/91-algo/</url>
      
        <content type="html"><![CDATA[<p>力扣加加，一个努力做西湖区最好的算法题解的团队。就在今天它给大家带来了《91 天学算法》，帮助大家摆脱困境，征服算法。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2atkdikgj30u70u0tct.jpg" width="50%"><p>​<a id="more"></a></p><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>为了让想学习的人能够真正学习到东西， 我打算新开一个栏目《91 天学算法》，在 91 天内来帮助那些想要学习算法，提升自己算法能力的同学，帮助大家建立完整的算法知识体系。</p><p>群里每天都会有题目，推荐大家讨论当天的题目。我们会帮助大家规划学习路线，91 天见证不一样的自己。群里会有专门的资深算法竞赛大佬坐阵解答大家的问题和疑问，并且会对前一天的题目进行讲解。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2b2zkclnj30xm0b6aat.jpg" alt></p><h2 id="活动时间"><a href="#活动时间" class="headerlink" title="活动时间"></a>活动时间</h2><p><code>2020-06-01</code> 至 <code>2020-08-30</code></p><h2 id="你能够得到什么？"><a href="#你能够得到什么？" class="headerlink" title="你能够得到什么？"></a>你能够得到什么？</h2><ol><li>显著提高你的刷题效率，让你少走弯路</li><li>掌握常见面试题的思路和解法</li><li>掌握常见套路，了解常见算法的本质，横向对比各种题目</li><li>纵向剖析一道题，多种方法不同角度解决同一题目</li></ol><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li>🈲️ 不允许经常闲聊</li><li>🈲️ 不允许发广告，软文（只能发算法相关的技术文章）</li><li>✅ 一周至少参与一次打卡</li></ul><blockquote><p>违反上述条件的人员会被强制清退</p></blockquote><h2 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h2><h3 id="基础篇（30-天）"><a href="#基础篇（30-天）" class="headerlink" title="基础篇（30 天）"></a>基础篇（30 天）</h3><ol><li>数组，队列，栈</li><li>链表</li><li>树与递归</li><li>哈希表</li><li>双指针</li></ol><h3 id="进阶篇（30-天）"><a href="#进阶篇（30-天）" class="headerlink" title="进阶篇（30 天）"></a>进阶篇（30 天）</h3><ol><li>堆</li><li>前缀树</li><li>并查集</li><li>跳表</li><li>剪枝技巧</li><li>RK 和 KMP</li><li>高频面试题</li></ol><p>…</p><h3 id="专题篇（31-天）"><a href="#专题篇（31-天）" class="headerlink" title="专题篇（31 天）"></a>专题篇（31 天）</h3><ol><li>二分法</li><li>滑动窗口</li><li>位运算</li><li>背包问题</li><li>搜索（BFS，DFS，回溯）</li><li>动态规划</li><li>分治</li><li>贪心</li></ol><p>…</p><h2 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h2><ul><li>每天会根据课程大纲的规划，出一道相关题目。</li><li>大家可以在指定的 Github 仓库中打卡（不可以抄作业哦），对于不会做的题目可以在群里提问。</li><li>第二天会对前一天的题目进行讲解。</li></ul><h2 id="奖励"><a href="#奖励" class="headerlink" title="奖励"></a>奖励</h2><ul><li>对于坚持打卡满一个月的同学，可以参加抽奖，奖品包括<code>算法模拟面试</code>，算法相关的图书等</li><li>连续打卡七天可以获得补签卡一张哦</li></ul><h2 id="冲鸭"><a href="#冲鸭" class="headerlink" title="冲鸭"></a>冲鸭</h2><p>为了大家的学习体验，防止不相关人员进群，同时为了更好地展开工作，我们决定采用 QQ 群的方式进行，希望大家能够理解哦。</p><p>对了，还有一句话，<code>前 50 个进群的小伙伴免费哦 ~</code>，50 名之后的小伙伴采取阶梯收费的形式。</p><p>收费标准：</p><ul><li>前 50 人免费</li><li>51 - 100 收费 5 元</li><li>101 - 500 收费 10 元</li></ul><blockquote><p>目前已经满 100 人了。</p></blockquote><p>想要参与的小伙伴加我的 QQ：695694307，发红包拉你进群。</p>]]></content>
      
      
      <categories>
          
          <category> 力扣加加 </category>
          
          <category> 91天学算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 算法提高班 </tag>
            
            <tag> 91天学算法 </tag>
            
            <tag> 力扣加加 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑客与画家》摘抄</title>
      <link href="/blog/2020/05/21/hacker-drawer/"/>
      <url>/blog/2020/05/21/hacker-drawer/</url>
      
        <content type="html"><![CDATA[<h2 id="14-梦寐以求的编程语言"><a href="#14-梦寐以求的编程语言" class="headerlink" title="14. 梦寐以求的编程语言"></a>14. 梦寐以求的编程语言</h2><p>让我们试着描述黑客心中梦寐以求的语言来为以上内容做个小结。</p><p>这种语言干净简练，具有<code>最高层次的抽象和互动性，而且很容易装备</code>，可以只用很少的代码就解决常见的问题。不管是什么程序，你真正要写的代码几乎都与你自己的特定设置有关，其他具有普遍性的问题都有现成的函数库可以调用。</p><p>这种语言的句法短到令人生疑。你输入的命令中，<code>没有任何一个字是多余的，甚至用到 shift 键的机会也很少</code>。</p><p>这种语言的抽象程度很高，甚至你可以快速写出一个程序的原型。然后，等到你开始优化的时候，它还提供一个<code>真正出色的性能分析器</code>，告诉你应该重点关注什么地方。你能让多重循环快得难以置信，并且在需要的地方还能直接嵌入字节码。</p><p>这种语言有大量优秀的范例可供学习，并且<code>非常符合直觉</code>，你只需要花几分钟阅读范例就能领会应该如何使用此种语言。你偶尔才需要查阅操作手册， 它很薄，里面关于限定条件和例外情况的警告寥寥无几。</p><p>这种语言内核很小，但很强大。各个<code>函数库高度独立</code>，并且和内核一样经过精心设计，它们都能很好地协同工作。语言的每个部分就像精密照相机的各种零件一样<code>完美契合</code>，不需要为了兼容性问题放弃或者保留某些功能。所有的函数库的源码都能很容易得到。这种语言能很轻松地与操作系统和其他语言开发的应用程序对话。</p><p>这种语言<code>以层的方式构建</code>。较高的抽象层透明地构建在较低的抽象层上。如果有需要的话，你可以直接使用较低的抽象层。</p><p>除了一些绝对必要隐藏的东西。这种语言的所有细节对使用者都是<code>透明</code>的。它提供的抽象能力只是为了方便你开发，而不是强迫你按照它的方式行事。事实上，它鼓励你参与它的设计，给你提供与语言创作者平等的权利。你能够对它的任何部分加以改变， 甚至包括它的语法。它尽可能<code>让你自己定义的部分与它本身定义的部分处于同等地位</code>，这种梦幻般的编程语言不仅开放源码，更开放自身的设计。</p>]]></content>
      
      
      <categories>
          
          <category> 书摘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 书摘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 1371. 每个元音包含偶数次的最长子字符串</title>
      <link href="/blog/2020/05/20/1371.find-the-longest-substring-containing-vowels-in-even-count/"/>
      <url>/blog/2020/05/20/1371.find-the-longest-substring-containing-vowels-in-even-count/</url>
      
        <content type="html"><![CDATA[<p>这道题还是蛮有意思的，我用了多种方法来解决，干货满满，点进来看看？</p><a id="more"></a><h1 id="题目地址（1371-每个元音包含偶数次的最长子字符串）"><a href="#题目地址（1371-每个元音包含偶数次的最长子字符串）" class="headerlink" title="题目地址（1371. 每个元音包含偶数次的最长子字符串）"></a>题目地址（1371. 每个元音包含偶数次的最长子字符串）</h1><p><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 &apos;a&apos;，&apos;e&apos;，&apos;i&apos;，&apos;o&apos;，&apos;u&apos; ，在子字符串中都恰好出现了偶数次。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;eleetminicoworoep&quot;</span><br><span class="line">输出：13</span><br><span class="line">解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;leetcodeisgreat&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;bcbcbc&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= s.length &lt;= 5 x 10^5</span><br><span class="line">s 只包含小写英文字母。</span><br></pre></td></tr></table></figure><h2 id="暴力法-剪枝"><a href="#暴力法-剪枝" class="headerlink" title="暴力法 + 剪枝"></a>暴力法 + 剪枝</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先拿到这道题的时候，我想到第一反应是滑动窗口行不行。 但是很快这个想法就被我否定了，因为滑动窗口（这里是可变滑动窗口）我们需要扩张和收缩窗口大小，而这里不那么容易。因为题目要求的是奇偶性，而不是类似“元音出现最多的子串”等。</p><p>突然一下子没了思路。那就试试暴力法吧。暴力法的思路比较朴素和直观。 那就是<code>双层循环找到所有子串，然后对于每一个子串，统计元音个数，如果子串的元音个数都是偶数，则更新答案，最后返回最大的满足条件的子串长度即可</code>。</p><p>这里我用了一个小的 trick。枚举所有子串的时候，我是从最长的子串开始枚举的，这样我找到一个满足条件的直接返回就行了（early return），不必维护最大值。<code>这样不仅减少了代码量，还提高了效率。</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码支持：Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s), <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s) - i + <span class="number">1</span>):</span><br><span class="line">                sub = s[j:j + i]</span><br><span class="line">                has_odd_vowel = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">for</span> vowel <span class="keyword">in</span> [<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>]:</span><br><span class="line">                    <span class="keyword">if</span> sub.count(vowel) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                        has_odd_vowel = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> has_odd_vowel: <span class="keyword">return</span>  i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：双层循环找出所有子串的复杂度是$O(n^2)$，统计元音个数复杂度也是$O(n)$，因此这种算法的时间复杂度为$O(n^3)$。</li><li>空间复杂度：$O(1)$</li></ul><h2 id="前缀和-剪枝"><a href="#前缀和-剪枝" class="headerlink" title="前缀和 + 剪枝"></a>前缀和 + 剪枝</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>上面思路中<code>对于每一个子串，统计元音个数</code>，我们仔细观察的话，会发现有很多重复的统计。那么优化这部分的内容就可以获得更好的效率。</p><p>对于这种连续的数字问题，这里我们考虑使用<a href="https://oi-wiki.org/basic/prefix-sum/" target="_blank" rel="noopener">前缀和</a>来优化。</p><p>经过这种空间换时间的策略之后，我们的时间复杂度会降低到$O(n ^ 2)$，但是相应空间复杂度会上升到$O(n)$，这种取舍在很多情况下是值得的。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码支持：Python3，Java</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    i_mapper = &#123;</span><br><span class="line">        <span class="string">"a"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">"e"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">"i"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">"o"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="string">"u"</span>: <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, s, pre, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            <span class="keyword">if</span> s[l] <span class="keyword">in</span> self.i_mapper <span class="keyword">and</span> i == self.i_mapper[s[l]]: cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (pre[r][i] - pre[l][i] + cnt) % <span class="number">2</span> != <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line"></span><br><span class="line">        pre = [[<span class="number">0</span>] * <span class="number">5</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pre</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] <span class="keyword">in</span> self.i_mapper <span class="keyword">and</span> self.i_mapper[s[i]] == j:</span><br><span class="line">                    pre[i][j] = pre[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre[i][j] = pre[i - <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n - i):</span><br><span class="line">                <span class="keyword">if</span> self.check(s, pre, j, i + j):</span><br><span class="line">                    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>Java Code：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] preSum = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> start = getIndex(s.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (start != -<span class="number">1</span>)</span><br><span class="line">            preSum[<span class="number">0</span>][start]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// preSum</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> idx = getIndex(s.charAt(i));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (idx == j)</span><br><span class="line">                    preSum[i][j] = preSum[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    preSum[i][j] = preSum[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (checkValid(preSum, s, i, i + j))</span><br><span class="line">                    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkValid</span><span class="params">(<span class="keyword">int</span>[][] preSum, String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = getIndex(s.charAt(left));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (((preSum[right][i] - preSum[left][i] + (idx == i ? <span class="number">1</span> : <span class="number">0</span>)) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'a'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'e'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'i'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'o'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'u'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n^2)$。</li><li>空间复杂度：$O(n)$</li></ul><h2 id="前缀和-状态压缩"><a href="#前缀和-状态压缩" class="headerlink" title="前缀和 + 状态压缩"></a>前缀和 + 状态压缩</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>前面的前缀和思路，我们通过空间（prefix）换取时间的方式降低了时间复杂度。但是时间复杂度仍然是平方，我们是否可以继续优化呢？</p><p>实际上由于我们只关心奇偶性，并不关心每一个元音字母具体出现的次数。因此我们可以使用<code>是奇数，是偶数</code>两个状态来表示，由于只有两个状态，我们考虑使用位运算。</p><p>我们使用 5 位的二进制来表示以 i 结尾的字符串中包含各个元音的奇偶性，其中 0 表示偶数，1 表示奇数，并且最低位表示 a，然后依次是 e，i，o，u。比如 <code>10110</code> 则表示的是包含偶数个 a 和 o，奇数个 e，i，u，我们用变量 <code>cur</code> 来表示。</p><p>为什么用 0 表示偶数？1 表示奇数？</p><p>回答这个问题，你需要继续往下看。</p><p>其实这个解法还用到了一个性质，这个性质是小学数学知识：</p><ul><li>如果两个数字奇偶性相同，那么其相减一定是偶数。</li><li>如果两个数字奇偶性不同，那么其相减一定是奇数。</li></ul><p>看到这里，我们再来看上面抛出的问题<code>为什么用 0 表示偶数？1 表示奇数？</code>。因为这里我们打算用异或运算，而异或的性质是：</p><p>如果对两个二进制做异或，会对其每一位进行位运算，如果相同则位 0，否则位 1。这和上面的性质非常相似。上面说<code>奇偶性相同则位偶数，否则为奇数</code>。因此很自然地<code>用 0 表示偶数？1 表示奇数</code>会更加方便。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>代码支持：Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        mapper = &#123;</span><br><span class="line">            <span class="string">"a"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">"e"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="string">"i"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="string">"o"</span>: <span class="number">8</span>,</span><br><span class="line">            <span class="string">"u"</span>: <span class="number">16</span></span><br><span class="line">        &#125;</span><br><span class="line">        seen = &#123;<span class="number">0</span>: <span class="number">-1</span>&#125;</span><br><span class="line">        res = cur = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> mapper:</span><br><span class="line">                cur ^= mapper.get(s[i])</span><br><span class="line">            <span class="comment"># 全部奇偶性都相同，相减一定都是偶数</span></span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> seen:</span><br><span class="line">                res = max(res, i - seen.get(cur))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                seen[cur] = i</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$。</li><li>空间复杂度：$O(n)$</li></ul><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>前缀和</li><li>状态压缩</li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://lucifer.ren/blog/2020/01/09/1310.xor-queries-of-a-subarray/">掌握前缀表达式真的可以为所欲为！</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 前缀和 </category>
          
          <category> 状态压缩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 状态压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 343. 整数拆分</title>
      <link href="/blog/2020/05/16/343.integer-break/"/>
      <url>/blog/2020/05/16/343.integer-break/</url>
      
        <content type="html"><![CDATA[<p>希望通过这篇题解让大家知道“题解区的水有多深”，让大家知道“什么才是好的题解”。</p><p>​<a id="more"></a></p><p>原题地址： <a href="https://leetcode-cn.com/problems/integer-break/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/integer-break/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个正整数  n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p>示例 1:</p><p>输入: 2<br>输出: 1<br>解释: 2 = 1 + 1, 1 × 1 = 1。<br>示例  2:</p><p>输入: 10<br>输出: 36<br>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。<br>说明: 你可以假设  n  不小于 2 且不大于 58。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我看了很多人的题解直接就是两句话，然后跟上代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">                dp[i] = max(j * dp[i - j], j * (i - j), dp[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p>这种题解说实话，只针对那些”自己会， 然后去题解区看看有没有新的更好的解法的人“。但是大多数看题解的人是那种<code>自己没思路，不会做的人</code>。那么这种题解就没什么用了。</p><p>我认为<code>好的题解应该是新手友好的，并且能够将解题人思路完整展现的题解</code>。比如看到这个题目，我首先想到了什么（对错没有关系），然后头脑中经过怎么样的筛选将算法筛选到具体某一个或某几个。我的最终算法是如何想到的，有没有一些先行知识。</p><p>当然我也承认自己有很多题解也是直接给的答案，这对很多人来说用处不大，甚至有可能有反作用，给他们一种”我已经会了“的假象。实际上他们根本不懂解题人本身原本的想法， 也许是写题解的人觉得”这很自然“，也可能”只是为了秀技“。</p><p>Ok，下面来讲下<code>我是如何解这道题的</code>。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>首先看到这道题，自然而然地先对问题进行抽象，这种抽象能力是必须的。LeetCode 实际上有很多这种穿着华丽外表的题，当你把这个衣服扒开的时候，会发现都是差不多的，甚至两个是一样的，这样的例子实际上有很多。 就本题来说，就有一个剑指 Offer 的原题<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/" target="_blank" rel="noopener">《剪绳子》</a>和其本质一样，只是换了描述方式。类似的有力扣 137 和 645 等等，大家可以自己去归纳总结。</p><blockquote><p>137 和 645 我贴个之前写的题解 <a href="https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-xi-lie-wei-yun-suan-by-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-xi-lie-wei-yun-suan-by-3/</a></p></blockquote><p><strong>培养自己抽象问题的能力，不管是在算法上还是工程上。</strong> 务必记住这句话！</p><p>数学是一门非常抽象的学科，同时也很方便我们抽象问题。为了显得我的题解比较高级，引入一些你们看不懂的数学符号也是很有必要的（开玩笑，没有什么高级数学符号啦）。</p><blockquote><p>实际上这道题可以用纯数学角度来解，但是我相信大多数人并不想看。即使你看了，大多人的感受也是“好 nb，然而并没有什么用”。</p></blockquote><p>这道题抽象一下就是：</p><p>令：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geu3kolxoyj305o03cwef.jpg" alt><br>（图 1）<br>求：<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geu3jy6mxkj305o0360sp.jpg" alt><br>（图 2）</p><h2 id="第一直觉"><a href="#第一直觉" class="headerlink" title="第一直觉"></a>第一直觉</h2><p>经过上面的抽象，我的第一直觉这可能是一个数学题，我回想了下数学知识，然后用数学法 AC 了。 数学就是这么简单平凡且枯燥。</p><p>然而如果没有数学的加持的情况下，我继续思考怎么做。我想是否可以枚举所有的情况（如图 1），然后对其求最大值（如图 2）。</p><p>问题转化为如何枚举所有的情况。经过了几秒钟的思考，我发现这是一个很明显的递归问题。 具体思考过程如下：</p><ul><li>我们将原问题抽象为 f(n)</li><li>那么 f(n) 等价于 max(1 * fn(n - 1), 2 * f(n - 2), …, (n - 1) * f(1))。</li></ul><p>用数学公式表示就是：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geu3swzc9ej30co03yaa4.jpg" alt><br>（图 3）</p><p>截止目前，是一点点数学 + 一点点递归，我们继续往下看。现在问题是不是就很简单啦？直接翻译图三为代码即可，我们来看下这个时候的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            res = max(res, max(i * self.integerBreak(n - i),i * (n - i)))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>毫无疑问，超时了。原因很简单，就是算法中包含了太多的重复计算。如果经常看我的题解的话，这句话应该不陌生。我随便截一个我之前讲过这个知识点的图。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geu3zfz89jj313p0u0wnj.jpg" alt><br>(图 4)</p><blockquote><p>原文链接：<a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md</a></p></blockquote><p>大家可以尝试自己画图理解一下。</p><blockquote><p>看到这里，有没有种殊途同归的感觉呢？</p></blockquote><h2 id="考虑优化"><a href="#考虑优化" class="headerlink" title="考虑优化"></a>考虑优化</h2><p>如上，我们可以考虑使用记忆化递归的方式来解决。只是用一个 hashtable 存储计算过的值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="meta">    @lru_cache()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            res = max(res, max(i * self.integerBreak(n - i),i * (n - i)))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>为了简单起见（偷懒起见），我直接用了 lru_cache 注解， 上面的代码是可以 AC 的。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>看到这里的同学应该发现了，这个套路是不是很熟悉？下一步就是将其改造成动态规划了。</p><p>如图 4，我们的思考方式是从顶向下，这符合人们思考问题的方式。将其改造成如下图的自底向上方式就是动态规划。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1geu4a1grbvj31eq0r0wj8.jpg" alt><br>(图 5)</p><p>现在再来看下文章开头的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">                dp[i] = max(j * dp[i - j], j * (i - j), dp[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><p>dp table 存储的是图 3 中 f(n)的值。一个自然的想法是令 dp[i] 等价于 f(i)。而由于上面分析了原问题等价于 f(n)，那么很自然的原问题也等价于 dp[n]。</p><p>而 dp[i]等价于 f(i)，那么上面针对 f(i) 写的递归公式对 dp[i] 也是适用的，我们拿来试试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 关键语句</span><br><span class="line">res = max(res, max(i * self.integerBreak(n - i),i * (n - i)))</span><br></pre></td></tr></table></figure><p>翻译过来就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i], max(i * dp(n - i),i * (n - i)))</span><br></pre></td></tr></table></figure><p>而这里的 n 是什么呢？我们说了<code>dp是自底向下的思考方式</code>，那么在达到 n 之前是看不到整体的<code>n</code> 的。因此这里的 n 实际上是 1,2,3,4… n。</p><p>自然地，我们用一层循环来生成上面一系列的 n 值。接着我们还要生成一系列的 i 值，注意到 n - i 是要大于 0 的，因此 i 只需要循环到 n - 1 即可。</p><p>思考到这里，我相信上面的代码真的是<code>不难得出</code>了。</p><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>数学抽象</li><li>递归分析</li><li>记忆化递归</li><li>动态规划</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">integerBreak</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i):</span><br><span class="line">                dp[i] = max(j * dp[i - j], j * (i - j), dp[i])</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>培养自己的解题思维很重要， 不要直接看别人的答案。而是要将别人的东西变成自己的， 而要做到这一点，你就要知道“他们是怎么想到的”，“想到这点是不是有什么前置知识”，“类似题目有哪些”。</p><p>最优解通常不是一下子就想到了，这需要你在不那么优的解上摔了很多次跟头之后才能记住的。因此在你没有掌握之前，不要直接去看最优解。 在你掌握了之后，我不仅鼓励你去写最优解，还鼓励去一题多解，从多个解决思考问题。 到了那个时候， 萌新也会惊讶地呼喊“哇塞， 这题还可以这么解啊？”。 你也会低调地发出“害，解题就是这么简单平凡且枯燥。”的声音。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>正如我开头所说，这种套路实在是太常见了。希望大家能够识别这种问题的本质，彻底掌握这种套路。另外我对这个套路也在我的新书《LeetCode 题解》中做了介绍，本书目前刚完成草稿的编写，如果你想要第一时间获取到我们的题解新书，那么请发送邮件到 <code>azl397985856@gmail.com</code>，标题著明“书籍《LeetCode 题解》预定”字样。。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> hashtable </category>
          
          <category> 动态规划 </category>
          
          <category> Medium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么eslint没有 no-magic-string？</title>
      <link href="/blog/2020/05/05/why-no-magic-string/"/>
      <url>/blog/2020/05/05/why-no-magic-string/</url>
      
        <content type="html"><![CDATA[<p>最近参加了几次公司组内的 Code Review， 发现了一些问题。其中一些问题可以通过工具（比如 eslint）解决。 我们就想着通过工具自动化的方式进行解决。 而这些工具中有一些是现成的，比如 魔法数。 大家对魔法数的看法也是莫衷一是。本文通过<code>讲解什么是魔法数，eslint 是怎么检查魔法数的，以及思考为什么eslint 偏爱数字，而不是偏爱字符串来</code> 来深入剖析一下魔法数。</p><a id="more"></a><h2 id="计算机科学中的魔法数"><a href="#计算机科学中的魔法数" class="headerlink" title="计算机科学中的魔法数"></a>计算机科学中的魔法数</h2><p>什么是魔法数？ 这里我摘取了维基百科的解释：</p><blockquote><p>程序设计中所谓的魔术数字（magic number）可能有以下含意：</p></blockquote><pre><code>•    缺乏解释或命名的独特数值•    用于识别一个文件格式或协议的一段常量或字符串，例如UNIX的特征签名•    防止误作他用的一段数值，例如UUID</code></pre><p>实际上魔法数真的是一个很古老的话题了。从我刚从业开始，就不停听到这样的词语。大家都对此深恶痛绝，不想看到别人的魔法数，但是时不时自己也会写一些魔法数。 如果你经常做算法题，肯定对此深有感受。 很多人（或许包括我自己）喜欢通过魔法数来炫技。当然我的心理倒不仅仅是炫技这么简单，也掺杂了诸如“这个很显然易见”，“这个我也不知道怎么起名字”的想法。</p><h2 id="eslint-中的魔法数"><a href="#eslint-中的魔法数" class="headerlink" title="eslint 中的魔法数"></a>eslint 中的魔法数</h2><p>eslint 有一个 rule 是 no-magic-number. 为什么没有类似的比如 no-magic-string?</p><p>我们首先来看下什么是”no-magic-number”。 根据 eslint 官方描述来看，其是通过确保数字被显式赋予一个常量，从而增加代码可读性和可维护性。</p><p>如下代码被认为是不好的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*eslint no-magic-numbers: “error”*/</span></span><br><span class="line"><span class="keyword">var</span> dutyFreePrice = <span class="number">100</span>,</span><br><span class="line">  finalPrice = dutyFreePrice + dutyFreePrice * <span class="number">0.25</span>;</span><br></pre></td></tr></table></figure><p>而这段代码被认为是好的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*eslint no-magic-numbers: “error”*/</span></span><br><span class="line"><span class="keyword">var</span> TAX = <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dutyFreePrice = <span class="number">100</span>,</span><br><span class="line">  finalPrice = dutyFreePrice + dutyFreePrice * TAX;</span><br></pre></td></tr></table></figure><p>这两段代码有什么不同？为什么下面的代码被认为是好的？</p><h2 id="一窥-eslint-源码"><a href="#一窥-eslint-源码" class="headerlink" title="一窥 eslint 源码"></a>一窥 eslint 源码</h2><p>通过阅读源码，我发现代码有这样一句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils/ast-utils.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumericLiteral</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    node.type === <span class="string">"Literal"</span> &amp;&amp;</span><br><span class="line">    (<span class="keyword">typeof</span> node.value === <span class="string">"number"</span> || <span class="built_in">Boolean</span>(node.bigint))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// no-magic-numbers.js</span></span><br><span class="line"><span class="keyword">if</span> (!isNumericLiteral(node)) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说如果字面量不是数字会被忽略。这和我们的想法<code>这条规则只会检查魔法数字，而不会检查诸如魔法字符串等</code>。</p><p>让我们时光倒流，将代码回退到 eslint 官方首次关于”no-magic-rule”的<a href="https://github.com/eslint/eslint/blob/510013c27eb917cd4c7268d5deb6301243b182cf/lib/rules/no-magic-number.js" target="_blank" rel="noopener">提交</a>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehuq8vlq1j316w0qgn1g.jpg" alt></p><p>代码大概意思是：</p><ol><li>如果是变量声明语句，就去检查是否强制使用 const。 如果是则观察语句是否为 const 声明。</li><li>对于其他情况，直接检查父节点的类型。<br>2.1. 如果检查对象内部的魔法数字，则直接报错。<br>2.2. 如果不需要检查对象类型，则进行规则过滤，即如果是<code>[“ObjectExpression”,“Property”,“AssignmentExpression”]</code> 中的一种的话也是没问题的。其他情况报错。</li></ol><p>那么上面的三种类型是什么呢？</p><p>从名字不难发现，其中 AssignmentExpression 和 ObjectExpression 属于表达式。 而 Property 则是对象属性。</p><p>ObjectExpression 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思考题：为什么 ObjectExpression 也是不被允许的？<br>AssignmentExpression 的例子：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>Property 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &#123; number: 1 &#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果设置了<code>检查对象</code>，那么上面三种情况都会报错。否则不进行报错处理。</p><h2 id="AST-Explorer"><a href="#AST-Explorer" class="headerlink" title="AST-Explorer"></a>AST-Explorer</h2><p>大家使用<a href="https://astexplorer.net/#/gist/a595f16646dbbb4184afc3880b87aa2c/276fd81226015b7782056947b70c4b9e047113c9" target="_blank" rel="noopener">AST explorer</a> 来可视化 AST。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehuqxbzngj31s30u0wod.jpg" alt></p><p>由于 eslint 使用的 ast 转化工具是 espree， 推荐大家使用 espree。 如果大家写 babel 插件的话，相应的引擎最好修改一下。</p><p>值得注意的是，上面我们用的 parent 是不会在 ast-explorer 进行显示的。原因在于其不是 ast 结构的一部分，而如果要做到，也非常容易。 前提是你懂得递归，尤其是树的递归。 如果你还不太懂树的递归， 可以关注我的 B 站<a href="https://space.bilibili.com/519510412" target="_blank" rel="noopener">LeetCode 加加的个人空间 - 哔哩哔哩 ( ゜- ゜)つロ 乾杯~ Bilibili</a></p><p>通过观察 eslint/espree 的源码也可以发现，其过程是多么的自然和简单。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gehusdyyxzj312i0ocjvf.jpg" alt></p><h2 id="Magic-String"><a href="#Magic-String" class="headerlink" title="Magic String"></a>Magic String</h2><p>实际上一个第三方的 tslint 仓库的一个<a href="https://github.com/palantir/tslint/issues/2928" target="_blank" rel="noopener">issue</a> 明确指出了想要增加”no<br>-magic-string” 的想法，只不过被仓库成员给否掉了，原因是其不够通用，除非能证明大家都需要这样一个规则。</p><p>那么问题是“为什么 no-magic-string 没有 no-magic-number 通用呢”？<a href="https://github.com/azl397985856/fe-interview/issues/122#issuecomment-623997774" target="_blank" rel="noopener">【每日一题】- 2020-05-05 - no-magic-string · Issue #122 · azl397985856/fe-interview · GitHub</a> 有一个回答，小漾给出了很好的回答。但是还没有解决疑问“为什么没有 no-magic-string”这样的规则呢？</p><p>我的观点是<code>魔法字符串也是不好的，只不过没有不好的那么明显</code>。</p><p>我们来看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"lucifer"</span>;</span><br><span class="line">a = <span class="string">"hello, "</span> + name;</span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">"add"</span>) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">"edit"</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，就可以被认定为 <code>magic string</code>。但是其在现实代码中是非常普遍的，并且不对我们造成很大的困扰。如果对其改写会是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"lucifer"</span>;</span><br><span class="line"><span class="keyword">const</span> PRFIX = <span class="string">"hello, "</span>;</span><br><span class="line"><span class="keyword">const</span> TYPE_ADD = <span class="string">"add"</span>;</span><br><span class="line"><span class="keyword">const</span> TYPE_EDIT = <span class="string">"edit"</span>;</span><br><span class="line">a = prefix + name;</span><br><span class="line"><span class="keyword">if</span> (type === TYPE_ADD) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TYPE_EDIT) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看数字：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (total &gt; <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上是我实际工作中见到过的例子，还算有代表性。 上面的代码，如果不通读代码或者事先有一些背景知识，我们根本无从知晓代码的准确含义。</p><p>还有一个地方，是数字不同于字符串的。 那就是数字可能是一个无限小数。计算机无法精确表示。 那么程序就不得不进行合理近似，而如果同一个程序不同地方采用的近似手段不同，那么就会有问题。而不使用魔法数就可以就可以避免这个问题。 举个例子：</p><p>我们需要计算一个圆的面积，可能会这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area = 3.1415 * R ** 2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">area = 3.141516 * R ** 2</span><br></pre></td></tr></table></figure><p>这样就会有问题了。 而如果我们将 PI 的值抽离到一个变量去维护，任何代码都取这个变量的值就不会有问题。那么有人可能有这样的疑问<code>字符串如果拼写错了，是不是也是一样的么？</code></p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">if (type == &apos;add&apos;) &#123;...&#125;</span><br><span class="line">// b.js</span><br><span class="line">if (type == &apos;addd&apos;) &#123;...&#125;</span><br></pre></td></tr></table></figure><p>事实上，这样的事情很有可能发生。 只不过这种问题相比于数字来说更容易被发现而已。</p><p>这么看来魔法数字确实给大家带来了很大的困扰，那么我们是否应该全面杜绝魔法数呢？</p><h2 id="取舍之间"><a href="#取舍之间" class="headerlink" title="取舍之间"></a>取舍之间</h2><p>真的魔法数字(字符串吧)就是不好的么？其实也不见得。</p><p>下面再来看一个我实际工作中碰到的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MS = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">"day"</span>) &#123;</span><br><span class="line">  MS = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">"week"</span>) &#123;</span><br><span class="line">  MS = <span class="number">7</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种代码我不知道看了多少遍了。 或许这在大家眼中已然成为了一种共识，那么这种所谓的魔法数字代码的不可读问题就不存在了。 我们仍可以轻易知道代码的含义。</p><p>如果将其进行改造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MS = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> HOURS_PER_DAY = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">const</span> MINUTES_PER_HOUR = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> SECONDs_PER_MINUTE = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">const</span> MS_PER_SECOND = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> DAYS_PER_WEEK = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">"day"</span>) &#123;</span><br><span class="line">  MS = HOURS_PER_DAY * MINUTES_PER_HOUR * SECONDs_PER_MINUTE * MS_PER_SECOND;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type === <span class="string">"week"</span>) &#123;</span><br><span class="line">  MS =</span><br><span class="line">    DAYS_PER_WEEK *</span><br><span class="line">    HOURS_PER_DAY *</span><br><span class="line">    MINUTES_PER_HOUR *</span><br><span class="line">    SECONDs_PER_MINUTE *</span><br><span class="line">    MS_PER_SECOND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码不见的要比上面的好到哪里。 <code>《程序设计实践》</code>提到了一点“变量命令不是越长越好，越具体越好，而是根据具体的限定范围”。 比如你在 queue 的 class 中定义的 size 字段可以直接叫 size ，而不是 queue_size。</p><p>那么一些社会或者编码常识何尝不是一种限定呢？ 如果是的话， 我们是否可以不用特殊限定，而回归到“魔法数”呢？</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> eslint </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纪念LeetCode项目Star突破3W</title>
      <link href="/blog/2020/04/16/thanksGiving3/"/>
      <url>/blog/2020/04/16/thanksGiving3/</url>
      
        <content type="html"><![CDATA[<p>差不多一年的时间，项目收获了第 3W 个 Star，平均差不多一天 100 左右的 star，非常感谢大家的关注和支持。</p><a id="more"></a><h2 id="30k-截图"><a href="#30k-截图" class="headerlink" title="30k 截图"></a>30k 截图</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvgnu8fk3j30se0kkdgo.jpg" alt></p><h2 id="Star-曲线"><a href="#Star-曲线" class="headerlink" title="Star 曲线"></a>Star 曲线</h2><p>Start 曲线上来看，有一点放缓。但是整体仍然是明显的上升趋势。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvg4gxal4j30rz0gugml.jpg" alt></p><p>(star 增长曲线图)</p><h2 id="在力扣宣传"><a href="#在力扣宣传" class="headerlink" title="在力扣宣传"></a>在力扣宣传</h2><p>当力扣官方也开始做<code>每日一题</code>的时候，我的心情是复杂的。怎么官方也开始学我搞每日一题了么？为了信仰（蹭热度），我也毅然决然参加了每日一题活动，贡献了几十篇题解。</p><p>三月份是满勤奖，四月份有一次忘记了，缺卡一天。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvjk32fo9j30wl0q97cj.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvjkp4y7ij307h05mt8p.jpg" alt></p><h2 id="新书即将上线"><a href="#新书即将上线" class="headerlink" title="新书即将上线"></a>新书即将上线</h2><p>新书详情戳这里：<a href="https://lucifer.ren/blog/2020/04/07/leetcode-book.intro/">《或许是一本可以彻底改变你刷 LeetCode 效率的题解书》</a>，目前正在申请书号。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvgi7rhf2j30zg0l0wii.jpg" alt></p><p>点名感谢各位作者，审阅，以及行政小姐姐。</p><h2 id="视频题解"><a href="#视频题解" class="headerlink" title="视频题解"></a>视频题解</h2><p>最近开始做视频题解了，目前更新了五个视频。和文字题解不同，视频题解可以承载的内容会更多。 <a href="https://space.bilibili.com/519510412" target="_blank" rel="noopener">https://space.bilibili.com/519510412</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvqb9gqbrj30qd0jrth0.jpg" alt></p><p>我计划更新一些文字题解很难表述的内容，当然还会提供 PPT，如果你喜欢文字，直接看 PPT 即可。</p><p>视频题解部分，我会带你拆解 LeetCode 题目，识别常见问题，掌握常见套路。</p><p>注意：这不是教你解决某一道题的题解，而是掌握解题方法和思路的题解。</p><h2 id="《力扣加加》上线啦"><a href="#《力扣加加》上线啦" class="headerlink" title="《力扣加加》上线啦"></a>《力扣加加》上线啦</h2><p>我们的官网<code>力扣加加</code>上线啦 💐💐💐💐💐，有专题讲解，每日一题，下载区和视频题解，后续会增加更多内容，还不赶紧收藏起来？地址：<a href="http://leetcode-solution.cn/" target="_blank" rel="noopener">http://leetcode-solution.cn/</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvghq7iygj30z60d040p.jpg" alt></p><p>点名感谢@三天 @CYL @Josephjinn</p><h2 id="朋友的支持"><a href="#朋友的支持" class="headerlink" title="朋友的支持"></a>朋友的支持</h2><p>很多朋友也在关注我的项目，非常开心。点名感谢 @被单-加加 @童欧巴。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvgnjszdwj30tu113ta5.jpg" alt></p><h2 id="交流群"><a href="#交流群" class="headerlink" title="交流群"></a>交流群</h2><p>交流群人数也有了很大的提升。 粉丝人数也扩充到了 7000+。交流群数目也增加到了 10 个。其中 QQ 群人数最多，有将近 1800 人。为了限制人数，我开启了收费模式，希望大家不要打我 😂。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdvgpycnp5j30tk156tah.jpg" alt></p><p>非常感谢大家一直以来的陪伴和支持，Fighting 💪。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『不要再问我头像如何变灰了，试试这几种滤镜吧！』</title>
      <link href="/blog/2020/04/12/canvas-filter/"/>
      <url>/blog/2020/04/12/canvas-filter/</url>
      
        <content type="html"><![CDATA[<p>在实际的工作中，有时候会有一些需求，让你做一些图片的滤镜效果，比如将图片变成黑白，调整图片亮度等。本文手把手教你如何实现<code>五种滤镜效果</code>，核心代码总共不到 70 行。</p><p>笔者所在的公司就有一个需求需要用到图片处理的知识，大概场景我来描述一下：</p><p>用户可以手动上传印章，并且支持给印章设置不同的显示效果，这里的效果具体指的是“线条的清晰程度”，如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqrt9ppu9j30j606pjsb.jpg" alt></p><p>这里我们使用 Canvas 来实现。如果你对 Canvas 不熟悉，建议看下之前我写的一篇文章<a href="https://cloud.tencent.com/developer/article/1494747" target="_blank" rel="noopener">100 * 100 Canvas 占用内存多大</a>，花上几分钟看完，基本上够看懂这篇文章了。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先我们先将图片绘制到 Canvas 画布上，为了简单起见，图片大小固定为 300 x 300。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"300px"</span> <span class="attr">height</span>=<span class="string">"300px"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(html)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取canvas元素</span></span><br><span class="line">ctx = <span class="built_in">document</span>.getElementById(<span class="string">"canvas"</span>).getContext(<span class="string">"2d"</span>);</span><br><span class="line"><span class="comment">//创建image对象</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="built_in">require</span>(<span class="string">"./seal.png"</span>);</span><br><span class="line"><span class="comment">//待图片加载完后，将其显示在canvas上</span></span><br><span class="line">img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">this</span>.imgData = ctx.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(js)</p><p>效果是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqtk2atryj308c08cq36.jpg" alt></p><h2 id="操作像素"><a href="#操作像素" class="headerlink" title="操作像素"></a>操作像素</h2><p>熟悉 Canvas 的应该知道上面的 this.imgData 实际上就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ImageData" target="_blank" rel="noopener">ImageData</a>类的实例，其中 imgData.data 是一个 Uint8ClampedArray， 其描述了一个一维数组，包含以 RGBA 顺序的数据，数据使用 0 至 255（包含）的整数表示。 简单来说，就是<code>图片像素信息，每四位表示一个像素单元</code>。其中每四位的信息分别是 RGBA。即第一个 Bit 标记 R，第二个 Bit 表示 G，第三个 Bit 表示 B，第四个 Bit 表示 A，第五个 Bit 又是 R…，依次类推。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqtrxj0qej314u0l8di6.jpg" alt></p><p>接下来，我们就要操作 imgData，来实现滤镜的效果。简单起见，我这里对超过 200 的值进行了一次<code>提高亮度</code>的操作。实际上这个值是 200，还是别的数字，需要我们化身”调参工程师”，不断实验才行。 并且粗暴地对 RGB 执行同样的逻辑是不合理的。更为合理的做法是对 RGB 的阀值分别进行度量，由于比较麻烦，我这里没有实现。但是如果你对效果要求比较高，那么最好可以分开度量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = <span class="keyword">this</span>.imgData.data;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (data[i] &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    data[i] = data[i] + brightness &gt; <span class="number">255</span> ? <span class="number">255</span> : data[i] + brightness;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data[i + <span class="number">1</span>] &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    data[i + <span class="number">1</span>] =</span><br><span class="line">      data[i + <span class="number">1</span>] + brightness &gt; <span class="number">255</span> ? <span class="number">255</span> : data[i + <span class="number">1</span>] + brightness;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data[i + <span class="number">2</span>] &lt; <span class="number">200</span>) &#123;</span><br><span class="line">    data[i + <span class="number">2</span>] =</span><br><span class="line">      data[i + <span class="number">2</span>] + brightness &gt; <span class="number">255</span> ? <span class="number">255</span> : data[i + <span class="number">2</span>] + brightness;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们对图片的像素进行了处理，以达到我们的目的，这样从用户感官上来看，显示效果发生了变化，大概效果如图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqu1r1ne5j308c08cdgc.jpg" alt></p><p>（清晰版）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqu205wxqj30eg0c6423.jpg" alt></p><p>（模糊版）</p><blockquote><p>如果你愿意的话，你也可以将处理好的图片进行导出，也很简单，直接调用 Canvas 实例的 <code>toDataURL</code> 方法即可，图片保存的格式也可以在这个方法中进行指定。</p></blockquote><p>日常开发中，我们还可能碰到很多其他的滤镜效果。下面介绍几个比较现常见的效果。 如果你正好用到了不妨作为参考。如果遇到了新的滤镜效果， 不妨在文末向我留言，看到后会及时回答，提前感谢你的参与。</p><p>下面介绍其他四种滤镜效果。这里只贴出核心代码，完整代码可以访问我的 <a href="https://github.com/azl397985856/canvas-filter-demo" target="_blank" rel="noopener">Github Repo</a> 进行查看。如果你嫌下载到本地麻烦，也可以在这里<a href="https://ec08f895-51be-4f77-8b7f-04fc08a9f443.ws-us02.gitpod.io/#/workspace/canvas-filter-demo" target="_blank" rel="noopener">在线安装并访问</a>，打开这个链接，分别执行<code>yarn</code>和<code>yarn start</code>即可。</p><p>以下效果均以下图为原图制作：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqrxh4p80j308c08cgm3.jpg" alt></p><h2 id="如何实现黑白效果"><a href="#如何实现黑白效果" class="headerlink" title="如何实现黑白效果"></a>如何实现黑白效果</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqu8hsknzj30rc0j0agz.jpg" alt></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="comment">// 将红黄蓝按照一定比例混合，具体比例为0.299 : 0.587 : 0.114， 这个比例需要慢慢调制。</span></span><br><span class="line">  <span class="keyword">const</span> avg = <span class="number">0.299</span> * data[i] + <span class="number">0.587</span> * data[i + <span class="number">1</span>] + <span class="number">0.114</span> * data[i + <span class="number">2</span>];</span><br><span class="line">  data[i] = data[i + <span class="number">1</span>] = data[i + <span class="number">2</span>] = avg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何实现反色效果"><a href="#如何实现反色效果" class="headerlink" title="如何实现反色效果"></a>如何实现反色效果</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqu901k5oj30r00j6wsd.jpg" alt></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">  data[i] = <span class="number">255</span> - data[i]; <span class="comment">//r</span></span><br><span class="line">  data[i + <span class="number">1</span>] = <span class="number">255</span> - data[i + <span class="number">1</span>]; <span class="comment">//g</span></span><br><span class="line">  data[i + <span class="number">2</span>] = <span class="number">255</span> - data[i + <span class="number">2</span>]; <span class="comment">//b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何给图片增加噪音"><a href="#如何给图片增加噪音" class="headerlink" title="如何给图片增加噪音"></a>如何给图片增加噪音</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqu9vz19jj30qs0j4tlh.jpg" alt></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> random = ((<span class="built_in">Math</span>.random() * <span class="number">70</span>) &gt;&gt;&gt; <span class="number">0</span>) - <span class="number">35</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">  data[i] = data[i] + random;</span><br><span class="line">  data[i + <span class="number">1</span>] = data[i + <span class="number">1</span>] + random;</span><br><span class="line">  data[i + <span class="number">2</span>] = data[i + <span class="number">2</span>] + random;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何提高图片亮度"><a href="#如何提高图片亮度" class="headerlink" title="如何提高图片亮度"></a>如何提高图片亮度</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdqualj8clj30gg0iw7ab.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdquwwljf6j30h00iwk2l.jpg" alt></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> brightness = +e.target.value;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">  data[i] = data[i] + brightness &gt; <span class="number">255</span> ? <span class="number">255</span> : data[i] + brightness;</span><br><span class="line">  data[i + <span class="number">1</span>] = data[i + <span class="number">1</span>] + brightness &gt; <span class="number">255</span> ? <span class="number">255</span> : data[i + <span class="number">1</span>] + brightness;</span><br><span class="line">  data[i + <span class="number">2</span>] = data[i + <span class="number">2</span>] + brightness &gt; <span class="number">255</span> ? <span class="number">255</span> : data[i + <span class="number">2</span>] + brightness;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文通过不到 70 行代码实现了<code>五种滤镜效果</code>，对于其他滤镜效果也可以参考这种方式来实现。还不赶紧拿上小姐姐的照片来秀一手么？</p>]]></content>
      
      
      
        <tags>
            
            <tag> Canvas </tag>
            
            <tag> 图片处理 </tag>
            
            <tag> 滤镜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>或许是一本可以彻底改变你刷 LeetCode 效率的题解书</title>
      <link href="/blog/2020/04/07/leetcode-book.intro/"/>
      <url>/blog/2020/04/07/leetcode-book.intro/</url>
      
        <content type="html"><![CDATA[<p>经过了半年时间打磨，投入诸多人力，这本 LeetCode 题解书终于快要和大家见面了。目前已经完成了大部分章节的编写工作，预计经过一段时间的打磨就会和大家见面啦 💐💐💐💐💐。</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>自 <a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">LeetCode 题解</a> （现在已经接近 30k star 了）项目被大家开始关注，就有不少出版社开始联系我写书。刚开始后的时候，我并没有这个打算，觉得写这个相对于博客形式的题解要耗费时间，且并不一定效果比博客形式的效果好。后来当我向大家提及“出版社找我写书”这件事情的时候，很多人表示“想要买书，于是我就开始打算写这样一本书。但是一个完全没有写书经验的人，独立完成一本书工作量还是蛮大的，因此我打算寻求其他志同道合人士的帮助。</p><h1 id="团队介绍"><a href="#团队介绍" class="headerlink" title="团队介绍"></a>团队介绍</h1><p>团队成员大都来自 985， 211 学校计算机系，大家经常参加算法竞赛，也坚持参加 LeetCode 周赛。在这个过程中，我们积累了很多经验，希望将这些经验分享给大家，以减少大家在刷题过程中的阻碍，让大家更有效率的刷题。 本书尤其适合那些刚刚开始刷题的人，如果你刚开始刷题，或者刷了很多题面对新题还是无法很好的解决，那么这本书肯定很适合你。最后欢迎大家加入我们的读者群和作者进行交流。</p><blockquote><p>读者群会在新书出版之后的第一时间开放。</p></blockquote><ul><li><a href="https://leetcode-cn.com/u/hlxing/" target="_blank" rel="noopener">作者 - xing</a></li><li><a href="https://leetcode-cn.com/u/fe-lucifer/" target="_blank" rel="noopener">作者 - lucifer</a></li><li><a href="https://leetcode-cn.com/u/bruceyuj/" target="_blank" rel="noopener">作者 - BY</a></li><li><a href="https://www.fanlucloud.com/" target="_blank" rel="noopener">作者 - fanlu</a></li><li><a href="https://leetcode.com/libinglimit/" target="_blank" rel="noopener">作者 - lazybing</a></li></ul><h1 id="样张"><a href="#样张" class="headerlink" title="样张"></a>样张</h1><p>这里给大家开放部分章节内容给大家，让大家尝尝鲜。当然也欢迎大家提出宝贵的建议，帮助我们写出更好的内容。</p><p>我们开放了第八章第五小节给大家看，以下是具体内容：</p><h2 id="8-5-1206-设计跳表"><a href="#8-5-1206-设计跳表" class="headerlink" title="8.5 1206. 设计跳表"></a>8.5 1206. 设计跳表</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>不使用任何库函数，设计一个跳表。</p><p>跳表是在 $O(logN)$ 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。</p><p>跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 $O(N)$。跳表的每一个操作的平均时间复杂度是 $O(logN)$，空间复杂度是 $O(N)$。</p><p>在本题中，你的设计应该要包含这些函数：</p><ul><li>bool search(int target) : 返回 target 是否存在于跳表中。</li><li>void add(int num):  插入一个元素到跳表。</li><li>bool erase(int num): 在跳表中删除一个值，如果  num  不存在，直接返回 false. 如果存在多个  num ，删除其中任意一个即可。</li></ul><p>注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。</p><p>样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Skiplist skiplist = new Skiplist();</span><br><span class="line"></span><br><span class="line">skiplist.add(1);</span><br><span class="line">skiplist.add(2);</span><br><span class="line">skiplist.add(3);</span><br><span class="line">skiplist.search(0);   // 返回 false</span><br><span class="line">skiplist.add(4);</span><br><span class="line">skiplist.search(1);   // 返回 true</span><br><span class="line">skiplist.erase(0);    // 返回 false，0 不在跳表中</span><br><span class="line">skiplist.erase(1);    // 返回 true</span><br><span class="line">skiplist.search(1);   // 返回 false，1 已被擦除</span><br></pre></td></tr></table></figure><p>约束条件：<br><code>0 &lt;= num, target &lt;= 20000</code><br>最多调用  50000  次  search, add, 以及  erase 操作。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，使用跳表会将数据存储成有序的。在数据结构当中，我们通常有两种基本的线性结构，结合有序数据，表达如下：</p><ul><li>有序链表，我们有三种基本操作：<ul><li>查找指定的数据：时间复杂度为 $O(N)$, $N$ 为数据位于链表的位置。</li><li>插入指定的数据：时间复杂度为 $O(N)$, $N$ 为数据位于链表的位置。因为插入数据之前，需要先查找到可以插入的位置。</li><li>删除指定的数据：时间复杂度为 $O(N)$, $N$ 为数据位于链表的位置。因为删除数据之前，需要先查找到可以插入的位置。</li></ul></li><li>有序数组：<ul><li>查找指定的数据：如果使用二分查找，时间复杂度为 $O(logN)$, $N$ 为数据的个数。</li><li>插入指定的数据：时间复杂度为 $O(N)$, 因为数组是顺序存储，插入新的数据时，我们需要向后移动指定位置后面的数据，这里 $N$ 为数据的个数。</li><li>删除指定的数据：时间复杂度为 $O(N)$, 因为数组是顺序存储，删除数据时，我们需要向前移动指定位置后面的数据，这里 $N$ 为数据的个数。</li></ul></li></ul><p>而神奇的跳表能够在 $O(logN)$ 时间内完成增加、删除、搜索操作。<br>下面我们分别分析增加、删除和搜索这 3 个三个基本操作。</p><h4 id="跳表的查找"><a href="#跳表的查找" class="headerlink" title="跳表的查找"></a>跳表的查找</h4><p>现在我们通过一个简单的例子来描述跳表是如何实现的。假设我们有一个有序链表如下图：<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdl834i5t2j33340ecdil.jpg" alt><br>原始方法中，查找的时间复杂度为 $O(N)$。那么如何来提高链表的查询效率呢？<br>如下图所示，我们可以从原始链表中每两个元素抽出来一个元素，加上一级索引，并且一级索引指向原始链表：<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdl81x0d7vj33340rbwjx.jpg" alt><br>如果我们想要查找 9 ，在原始链表中查找路径是 <code>1-&gt;3-&gt;4-&gt;7-&gt;9</code>, 而在添加了一级索引的查找路径是 <code>1-&gt;4-&gt;9</code>，很明显，查找效率提升了。<br>按照这样的思路，我们在第 1 级索引上再加第 2 级索引，再加第 3 级索引，以此类推，这样在数据量非常大的时候，使得我们查找数据的时间复杂度为 $O(logN)$。这就是跳表的思想，也就是我们通常所说的“空间换时间”。</p><h4 id="跳表的插入"><a href="#跳表的插入" class="headerlink" title="跳表的插入"></a>跳表的插入</h4><p>跳表插入数据看起来很简单，我们需要保持数据有序，因此，第一步我们需要像查找元素一样，找到新元素应该插入的位置，然后再插入。</p><p>但是这样会存在一个问题，如果我们一直往原始链表中插入数据，但是不更新索引，那么会导致两个索引结点之间的数据非常多，在极端情况下，跳表会退化成单链表，从而导致查找效率由 $O(logN)$ 退化为 $O(N)$。因此，我们需要在插入数据的同时，增加相应的索引或者重建索引。</p><ol><li>方案 1：每次插入数据后，将跳表的索引全部删除后重建，我们知道索引的结点个数为 $N$（在空间复杂度分析时会有明确的数学推导），那么每次重建索引，重建的时间复杂度至少是 $O(N)$ 级别，很明显不可取。</li><li>方案 2：通过随机性来维护索引。假设跳表的每一层的提升概率为 $\frac{1}{2}$ ，最理想的情况就是每两个元素提升一个元素做索引。而通常意义上，只要元素的数量足够多，且抽取足够随机的话，我们得到的索引将会是比较均匀的。尽管不是每两个抽取一个，但是对于查找效率来讲，影响并不很大。我们要知道，设计良好的数据结构往往都是用来应对大数据量的场景的。<br>因此，我们这样维护索引：<strong>随机抽取 $\frac{N}{2}$ 个元素作为 1 级索引，随机抽取 $\frac{N}{4}$ 作为 2 级索引，以此类推，一直到最顶层索引</strong>。</li></ol><p>那么具体代码该如何实现，才能够让跳表在每次插入新元素时，尽量让该元素有 $\frac{1}{2}$ 的概率建立一级索引、$\frac{1}{4}$ 的概率建立二级索引、$\frac{1}{8}$ 的概率建立三级索引，以此类推。因此，我们需要一个概率算法。</p><p>在通常的跳表实现当中，我们会设计一个 <code>randomLevel()</code> 方法，该方法会随机生成 <code>1~MAX_LEVEL</code> 之间的数 (MAX_LEVEL 表示索引的最高层数）</p><ul><li>randomLevel() 方法返回 1 表示当前插入的元素不需要建立索引，只需要存储数据到原始链表即可（概率 1/2）</li><li>randomLevel() 方法返回 2 表示当前插入的元素需要建立一级索引（概率 1/4）</li><li>randomLevel() 方法返回 3 表示当前插入的元素需要建立二级索引（概率 1/8）</li><li>randomLevel() 方法返回 4 表示当前插入的元素需要建立三级索引（概率 1/16）</li><li>……</li></ul><p>可能有的同学会有疑问，我们需要一级索引中元素的个数时原始链表的一半，但是我们 <code>randomLevel()</code> 方法返回 2（建立一级索引）的概率是 $\frac{1}{4}$, 这样是不是有问题呢？<br>实际上，只要<code>randomLevel()</code>方法返回的数大于 1，我们都会建立一级索引，而返回值为 1 的概率是 $\frac{1}{2}$。所以，建立一级索引的概率其实是$1- \frac{1}{2} = \frac{1}{2}$。同上，当 <code>randomLevel()</code> 方法返回值 <code>&gt;2</code> 时，我们会建立二级或二级以上的索引，都会在二级索引中添加元素。而在二级索引中添加元素的概率是 $1- \frac{1}{2} - \frac{1}{4} = \frac{1}{4}$。<br>以此类推，我们推导出 <code>randomLevel()</code> 符合我们的设计要求。</p><p>下面我们通过仿照 redis zset.c 的 <code>randomLevel</code> 的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># 1. SKIPLIST_P 为提升的概率，本案例中我们设置为 1/2, 如果我们想要节省空间利用效率，可以适当的降低该值，从而减少索引元素个数。在 redis 中 SKIPLIST_P 被设定为 0.25。</span></span><br><span class="line"><span class="comment"># 2. redis 中通过使用位运算来提升浮点数比较的效率，在本案例中被简化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomLevel</span><span class="params">()</span>:</span></span><br><span class="line">    level = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> random() &lt; SKIPLIST_P <span class="keyword">and</span> level &lt; MAX_LEVEL:</span><br><span class="line">        level += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure><h4 id="跳表的删除"><a href="#跳表的删除" class="headerlink" title="跳表的删除"></a>跳表的删除</h4><p>跳表的删除相对来讲稍微简单一些。我们在删除数据的同时，需要删除对应的索引结点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data: Optional[int] = None)</span>:</span></span><br><span class="line">        self._data = data <span class="comment"># 链表结点的数据域，可以为空（目的是方便创建头节点）</span></span><br><span class="line">        self._forwards = [] <span class="comment"># 存储各个索引层级中该结点的后驱索引结点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Skiplist</span>:</span></span><br><span class="line"></span><br><span class="line">    _MAX_LEVEL = <span class="number">16</span> <span class="comment"># 允许的最大索引高度，该值根据实际需求设置</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._level_count = <span class="number">1</span> <span class="comment"># 初始化当前层级为 1</span></span><br><span class="line">        self._head = ListNode()</span><br><span class="line">        self._head._forwards = [<span class="literal">None</span>] * self._MAX_LEVEL</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, target: int)</span> -&gt; bool:</span></span><br><span class="line">        p = self._head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self._level_count - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 从最高索引层级不断搜索，如果当前层级没有，则下沉到低一级的层级</span></span><br><span class="line">            <span class="keyword">while</span> p._forwards[i] <span class="keyword">and</span> p._forwards[i]._data &lt; target:</span><br><span class="line">                p = p._forwards[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p._forwards[<span class="number">0</span>] <span class="keyword">and</span> p._forwards[<span class="number">0</span>]._data == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        level = self._random_level() <span class="comment"># 随机生成索引层级</span></span><br><span class="line">        <span class="keyword">if</span> self._level_count &lt; level: <span class="comment"># 如果当前层级小于 level, 则更新当前最高层级</span></span><br><span class="line">            self._level_count = level</span><br><span class="line">        new_node = ListNode(num) <span class="comment"># 生成新结点</span></span><br><span class="line">        new_node._forwards = [<span class="literal">None</span>] * level</span><br><span class="line">        update = [self._head] * self._level_count <span class="comment"># 用来保存各个索引层级插入的位置，也就是新结点的前驱结点</span></span><br><span class="line"></span><br><span class="line">        p = self._head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self._level_count - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>): <span class="comment"># 整段代码获取新插入结点在各个索引层级的前驱节点，需要注意的是这里是使用的当前最高层级来循环。</span></span><br><span class="line">            <span class="keyword">while</span> p._forwards[i] <span class="keyword">and</span> p._forwards[i]._data &lt; num:</span><br><span class="line">                p = p._forwards[i]</span><br><span class="line"></span><br><span class="line">            update[i] = p</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(level): <span class="comment"># 更新需要更新的各个索引层级</span></span><br><span class="line">            new_node._forwards[i] = update[i]._forwards[i]</span><br><span class="line">            update[i]._forwards[i] = new_node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">erase</span><span class="params">(self, num: int)</span> -&gt; bool:</span></span><br><span class="line">        update = [<span class="literal">None</span>] * self._level_count</span><br><span class="line">        p = self._head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self._level_count - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">while</span> p._forwards[i] <span class="keyword">and</span> p._forwards[i]._data &lt; num:</span><br><span class="line">                p = p._forwards[i]</span><br><span class="line">            update[i] = p</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p._forwards[<span class="number">0</span>] <span class="keyword">and</span> p._forwards[<span class="number">0</span>]._data == num:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(self._level_count - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> update[i]._forwards[i] <span class="keyword">and</span> update[i]._forwards[i]._data == num:</span><br><span class="line">                    update[i]._forwards[i] = update[i]._forwards[i]._forwards[i]</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self._level_count &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> self._head._forwards[self._level_count]:</span><br><span class="line">            self._level_count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_random_level</span><span class="params">(self, p: float = <span class="number">0.5</span>)</span> -&gt; int:</span></span><br><span class="line">        level = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> random.random() &lt; p <span class="keyword">and</span> level &lt; self._MAX_LEVEL:</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> level</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>跳表通过建立索引提高查找的效率，是典型的“空间换时间”的思想，那么空间复杂度到底是多少呢？<br>我们假设原始链表有 $N$ 个元素，一级索引有 $\frac{N}{2}$，二级索引有 $\frac{N}{4}$，k 级索引有 $\frac{N}{2^k}$ 个元素，而最高级索引一般有 $2$ 个元素。所以，索引结点的总和是 $\frac{N}{2} + \frac{N}{2^2} + \frac{N}{2^3}+…+ 2 \approx N-2$ ，因此可以得出空间复杂度是 $O(N)$, $N$ 是原始链表的长度。</p><p>上面的假设前提是每两个结点抽出一个结点到上层索引。那么如果我们每三个结点抽出一个结点到上层索引，那么索引总和就是 $\frac{N}{3} + \frac{N}{3^2} + \frac{N}{3^3} + 9 + 3 + 1 \approx \frac{N}{2}$, 额外空间减少了一半。因此我们可以通过减少索引的数量来减少空间复杂度，但是相应的会带来查找效率一定的下降。而具体这个阈值该如何选择，则要看具体的应用场景。</p><p>另外需要注意的是，在实际的应用当中，索引结点往往不需要存储完整的对象，只需要存储对象的 key 和对应的指针即可。因此当对象比索引结点占用空间大很多时，索引结点所占的额外空间（相对原始数据来讲）又可以忽略不计了。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h5 id="查找的时间复杂度"><a href="#查找的时间复杂度" class="headerlink" title="查找的时间复杂度"></a>查找的时间复杂度</h5><p>来看看时间复杂度 $O(logN)$ 是如何推导出来的，首先我们看下图：<br><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdl82ermgfj31rr0rs77h.jpg" alt></p><p>如上图所示，此处我们假设每两个结点会抽出一个结点来作为上一级索引的结点。也就是说，原始链表有 $N$ 个元素，一级索引有 $\frac{N}{2}$，二级索引有 $\frac{N}{4}$，k 级索引有 $\frac{N}{2^k}$ 个元素，而最高级索引一般有 $2$ 个元素。 也就是说：最高级索引 $x$ 满足 $2 = N/2^x$, 由此公式可以得出 $x = \log_2(N)-1$ , 加上原始数据这一层， 跳表的总高度为 $h = \log_2(N)$。<br>那么，我们在查找过程中每一层索引最多遍历几个元素呢？从图中我们可以看出来每一层最多需要遍历 3 个结点。<br>因此，由公式 <code>时间复杂度 = 索引高度*每层索引遍历元素个数</code>， 可以得出跳表中查找一个元素的时间复杂度为 $O(3 \times \log(N))$，省略常数即为 $O(\log(N))$。</p><h5 id="插入的时间复杂度"><a href="#插入的时间复杂度" class="headerlink" title="插入的时间复杂度"></a>插入的时间复杂度</h5><p>跳表的插入分为两部分操作：</p><ol><li>寻找到对应的位置，时间复杂度为 $O(logN)$, $N$ 为链表长度。</li><li>插入数据。我们在前面已经推导出跳表索引的高度为 $logN$。 因此，我们将数据插入到各层索引中的最坏时间复杂度为 $O(logN)$。</li></ol><p>综上所述，插入操作的时间复杂度为 $O(logN)$</p><h5 id="删除的时间复杂度"><a href="#删除的时间复杂度" class="headerlink" title="删除的时间复杂度"></a>删除的时间复杂度</h5><p>跳表的删除操作和查找类似，只是需要在查找后删除对应的元素。查找操作的时间复杂度是 $logN$。那么后面删除部分代码的时间复杂度是多少呢？我们知道在跳表中，每一层索引都是一个有序的单链表，而删除单个元素的复杂度为 $O(1)$, 索引层数为 $logN$，因此删除部分代码的时间复杂度为$logN$。那么删除操作的总时间复杂度为- $O(logN) + O(logN) = 2O(logN)$。我们忽略常数部分，删除元素的时间复杂度为 $O(logN)$。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>在工业上，使用跳表的场景很多，下面做些简单的介绍，有兴趣的可以深入了解：</p><ol><li>redis 当中 zset 使用了跳表</li><li>HBase MemStore 当中使用了跳表</li><li>LevelDB 和 RocksDB 都是 LSM Tree 结构的数据库，内部的 MemTable 当中都使用了跳表</li></ol><h1 id="配套网站"><a href="#配套网站" class="headerlink" title="配套网站"></a>配套网站</h1><p>等新书发布之后，我们会在官网开辟一个区域，大家可以直接访问查看本书配套的配套代码，包括 JavaScript，Java，Python 和 C++。 也欢迎大家留言给我们自己想要支持的语言，我们会郑重考虑大家的意见。</p><p>效果大概是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdl80ojj2rj31tw0u00x1.jpg" alt></p><h1 id="预定"><a href="#预定" class="headerlink" title="预定"></a>预定</h1><p>如果你也想要第一时间获取到我们的题解新书，那么请发送邮件到 <a href="mailto:azl397985856@gmail.com" target="_blank" rel="noopener">azl397985856@gmail.com</a>，标题著明“书籍《LeetCode 题解》预定”字样。</p>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 我的书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一荐 2020-03 汇总</title>
      <link href="/blog/2020/04/07/daily-featured-2020-03/"/>
      <url>/blog/2020/04/07/daily-featured-2020-03/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8d0sktqrwj30hs07maae.jpg" alt></p><p>每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。</p><p>项目主页维护当前月份的内容，想看往期内容，可以去<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">每日一荐主仓库</a>翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。</p><a id="more"></a><h2 id="2020-03"><a href="#2020-03" class="headerlink" title="2020-03"></a>2020-03</h2><h3 id="2020-03-31-好文"><a href="#2020-03-31-好文" class="headerlink" title="2020-03-31[好文]"></a>2020-03-31[好文]</h3><p>gRPC 使用 protobuf 进行数据封装(序列化和反序列化)，同时使用 http2 进行数据传输，为什么不直接基于 TCP 传输呢？grpc 究竟和其他 rpc 框架，比如阿里的 dubbo，facebook 的 Thrift 有什么区别？这篇文章带你了解一下。</p><p>地址：<a href="https://mp.weixin.qq.com/s/GuMp4Z8oJv9K_MJxMptsSA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GuMp4Z8oJv9K_MJxMptsSA</a></p><h3 id="2020-03-30-好文"><a href="#2020-03-30-好文" class="headerlink" title="2020-03-30[好文]"></a>2020-03-30[好文]</h3><p>《吊打面试官》系列 Node.js 全栈秒杀系统。这篇文章非常详细地讲述了如何使用 nodejs 构建一个秒杀系统，文中提到的知识点，我也经常在面试中向候选人提问。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdbxfr99o9j30jb0p4405.jpg" alt></p><p><a href="https://mp.weixin.qq.com/s/LoRr76smB-M8sNp-85wdqg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LoRr76smB-M8sNp-85wdqg</a></p><h3 id="2020-03-27-库"><a href="#2020-03-27-库" class="headerlink" title="2020-03-27[库]"></a>2020-03-27[库]</h3><p>今天给大家推荐的是一个图片上传组件 - uppload。支持：</p><ul><li>20 多种选择文件的方式</li><li>10 种编辑文件的方式</li><li>支持自定义将文件发送到服务端</li><li>主题</li><li>插件</li><li>。。。</li></ul><p>更重要的是其源码写的很赞，模块划分，代码解耦，以及单元测试都非常值得学习， 感兴趣的可以研究一下。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd6c9hp23qj30u30gfgpc.jpg" alt></p><p><a href="https://github.com/elninotech/uppload" target="_blank" rel="noopener">https://github.com/elninotech/uppload</a></p><h3 id="2020-03-26-好文"><a href="#2020-03-26-好文" class="headerlink" title="2020-03-26[好文]"></a>2020-03-26[好文]</h3><p>一个外国游客来中国广州游玩，定了一家酒店，但是通过 Google 地图去找，离目的地相差几英里，原因在于 Google 使用的地图坐标系统是 WGS-84 ，而国内的比如 Baidu 地图可以很好的显示，因为其用的是 GCJ-02。一句话总结来说：</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd64j9pkdlj30ge02s3yt.jpg" alt></p><p>原文地址：<a href="https://abstractkitchen.com/blog/a-short-guide-to-chinese-coordinate-system/" target="_blank" rel="noopener">https://abstractkitchen.com/blog/a-short-guide-to-chinese-coordinate-system/</a></p><h3 id="2020-03-25-工具"><a href="#2020-03-25-工具" class="headerlink" title="2020-03-25[工具]"></a>2020-03-25[工具]</h3><p>微软开源的 Puppeteer 的衍生项目 <code>Playwirght</code>，或许能够替代 Puppeteer。 和 Puppeteer 相比，其有以下特点：</p><ul><li>弥补了 Puppeteer 的平台局限性，为所有热门渲染引擎提供类似的功能</li><li>和 Puppeteer 基本兼容，用户可以无痛（低痛）迁移</li><li>使用了隔离的 BrowserContext，而不是像 Puppeteer 一样共用一个 defaultBrowserContext。</li></ul><p>项目地址： <a href="https://github.com/microsoft/playwright" target="_blank" rel="noopener">https://github.com/microsoft/playwright</a></p><h3 id="2020-03-24-工具"><a href="#2020-03-24-工具" class="headerlink" title="2020-03-24[工具]"></a>2020-03-24[工具]</h3><p>如果你是学生党或者学术党，需要经常查找文献，那么一个文献管理工具就显得很有必要。这里推荐一个工具：Zotero。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd3of2gqywj30wi0iaqbp.jpg" alt></p><p>地址： <a href="https://www.zotero.org/" target="_blank" rel="noopener">https://www.zotero.org/</a></p><h3 id="2020-03-23-好文"><a href="#2020-03-23-好文" class="headerlink" title="2020-03-23[好文]"></a>2020-03-23[好文]</h3><p>Elasticsearch 已经火了很多年了，现在依然可以见到他们活跃的身影。笔者公司就在用，我也参与了相关开发，其使用起来很简单，但是精通起来却不容易。而很多人正好对其不熟悉，这里正好有一个非常简单易懂的中文教程：《Elasticsearch 学习：入门篇》</p><p>地址： <a href="https://www.cyhone.com/articles/introduction-of-elasticsearch/index.html" target="_blank" rel="noopener">https://www.cyhone.com/articles/introduction-of-elasticsearch/index.html</a></p><h3 id="2020-03-20-工具"><a href="#2020-03-20-工具" class="headerlink" title="2020-03-20[工具]"></a>2020-03-20[工具]</h3><p>这是一个在线服务，用来生成几何占位符，类似于 Github 的默认头像。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gd0hyqu3sij30fy069q2y.jpg" alt><br>（Github 的默认头像）</p><p>使用方式也很简单，并支持多种参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://generative-placeholders.glitch.me/image?width=600&amp;height=300&amp;img=01"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://generative-placeholders.glitch.me/image?width=600&amp;height=300&amp;img=02"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://generative-placeholders.glitch.me/image?width=600&amp;height=300&amp;img=03"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>地址： <a href="https://generative-placeholders.glitch.me/" target="_blank" rel="noopener">https://generative-placeholders.glitch.me/</a></p><h3 id="2020-03-19-好文"><a href="#2020-03-19-好文" class="headerlink" title="2020-03-19[好文]"></a>2020-03-19[好文]</h3><p>政采云的前端 leader（花名堂主） 的一个关于前端基建的分享《堂主 - 如何推动前端团队的基础设施建设 | 7500 字》。如果你的团队也在做基础建设，那么或许可以帮到你，至少可以提供一些思路。</p><p>地址： <a href="https://mp.weixin.qq.com/s/2VSa3xBpy5St8G1v0RjW9g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2VSa3xBpy5St8G1v0RjW9g</a></p><h3 id="2020-03-14-仓库"><a href="#2020-03-14-仓库" class="headerlink" title="2020-03-14[仓库]"></a>2020-03-14[仓库]</h3><p>这里有一个很有意思的仓库，专门用来做远程面试，支持白板代码，视频通话，回放等功能。效果类似之前我在使用的 showmebug。</p><p>地址： <a href="https://github.com/AgoraIO-Community/2019-Hackathon-Works-CoderLane/blob/master/README.ZH.md" target="_blank" rel="noopener">https://github.com/AgoraIO-Community/2019-Hackathon-Works-CoderLane/blob/master/README.ZH.md</a></p><h3 id="2020-03-13-仓库"><a href="#2020-03-13-仓库" class="headerlink" title="2020-03-13[仓库]"></a>2020-03-13[仓库]</h3><p>一个可以在浏览器端压缩图片的库，从而减少网络传输，进而减小服务端的压力。</p><p>地址： <a href="https://github.com/Donaldcwl/browser-image-compression" target="_blank" rel="noopener">https://github.com/Donaldcwl/browser-image-compression</a></p><h3 id="2020-03-12-仓库"><a href="#2020-03-12-仓库" class="headerlink" title="2020-03-12[仓库]"></a>2020-03-12[仓库]</h3><p>一个获取本机网卡信息的库，可以获取到 IPv4，IPv6 以及 MAC 地址。</p><p>地址： <a href="https://github.com/scravy/node-macaddress" target="_blank" rel="noopener">https://github.com/scravy/node-macaddress</a></p><h3 id="2020-03-11-仓库"><a href="#2020-03-11-仓库" class="headerlink" title="2020-03-11[仓库]"></a>2020-03-11[仓库]</h3><p>著名的知识管理平台《羽雀》就是从最开是的 CodeMirror 迁移到了 slate，slate 其实就是一个 Markdown 编辑器。</p><blockquote><p>但是羽雀最终还是转向自研道路，基于浏览器的 contenteditable 实现富文本编辑器，通过 canvas 实现表格编辑器，通过 SVG 实现思维导图编辑器。</p></blockquote><p>地址：<a href="https://github.com/slatedocs/slate" target="_blank" rel="noopener">https://github.com/slatedocs/slate</a></p><h3 id="2020-03-10-仓库"><a href="#2020-03-10-仓库" class="headerlink" title="2020-03-10[仓库]"></a>2020-03-10[仓库]</h3><p>一个可以制作类似“Github Project”效果的库。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcnvvmc8y3j30r50cpta0.jpg" alt></p><p>地址： <a href="https://github.com/lourenci/react-kanban" target="_blank" rel="noopener">https://github.com/lourenci/react-kanban</a></p><h3 id="2020-03-09-网站"><a href="#2020-03-09-网站" class="headerlink" title="2020-03-09[网站]"></a>2020-03-09[网站]</h3><p>之前给大家推荐了几个在线练习的网站，有算法的，有正则的，还有 git 的。今天介绍一个练习 SQL 语句的：</p><p>SQLZOO 是一款很好用的 SQL 练习网站，这里都是比较常用的 SQL 命令。不仅对每个命令的用法有详细解释，每个专题后面还有题目。循序渐进，LeetCode 也有 SQL 相关的题目，不过难度一般比较大，建议大家 把 SQLZOO 刷完基础 SQL 命令再去 LeetCode 刷 SQL 题目。</p><p>网站地址：<a href="https://sqlzoo.net/" target="_blank" rel="noopener">https://sqlzoo.net/</a></p><h3 id="2020-03-05-好文"><a href="#2020-03-05-好文" class="headerlink" title="2020-03-05[好文]"></a>2020-03-05[好文]</h3><p>Base64 编/解码器有不同实现，有的不相互兼容，如果使用了不兼容的实现，就会有 bug，比如典型的报错“Illegal base64 character a”。本文详细介绍了产生这个问题的原因，文章通俗易懂，适合新手阅读。</p><p><a href="https://mp.weixin.qq.com/s/SfFmct12UBc7BLdNUmBBKg" target="_blank" rel="noopener">记一个 Base64 有关的 Bug</a></p><h3 id="2020-03-03-好文"><a href="#2020-03-03-好文" class="headerlink" title="2020-03-03[好文]"></a>2020-03-03[好文]</h3><p>前端新建一个项目的时候，需要用到很多配置文件，通常是以。开头，因此我们也叫 dotfiles。这篇文章介绍了前端开发常见的 dotfiles，以及其简单用法，或许可以给你一点参考。而且我在我的 <a href="https://github.com/azl397985856/mac-setup" title="mac 装机教程" target="_blank" rel="noopener">mac 装机教程</a> 中也提到了 dotfiles，只不过那边的 dotfiles 更为广泛。</p><p>文章地址： <a href="https://lyreal666.com/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE-react-typescript%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Adotfiles/" target="_blank" rel="noopener">https://lyreal666.com/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE-react-typescript%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Adotfiles/</a></p><h3 id="2020-03-02-好文"><a href="#2020-03-02-好文" class="headerlink" title="2020-03-02[好文]"></a>2020-03-02[好文]</h3><p>原文标题《使用 TypeScript 开发 Web 应用的最佳实践》。文中基本将 TS 在日常开发中的姿势都提到了，并且总结了很多坑点，并且给出了自己的探索和思考。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfiu94lj4j30u00xttg8.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcfiuwib4fj31ao0pk44a.jpg" alt></p><p>文章地址：<a href="https://yrq110.me/post/front-end/best-practice-of-typescript-in-webapp-developing/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">https://yrq110.me/post/front-end/best-practice-of-typescript-in-webapp-developing/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>我重新整理了下自己的公众号，并且我还给它换了一个名字<code>脑洞前端</code>，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。</p><p>之后我的文章会同步到微信公众号 <code>脑洞前端</code> ，你可以关注获取最新的文章，并和我进行交流。</p><p>另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。</p><img width="300" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7he9xdtmyj30by0byaac.jpg"><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul><li>如果有想法和创意，请提<a href="https://github.com/azl397985856/daily-featured/issues" target="_blank" rel="noopener">issue</a>或者进群提</li><li>如果想贡献代码，请提<a href="https://github.com/azl397985856/daily-featured/pulls" target="_blank" rel="noopener">PR</a></li><li>如果需要修改项目中图片，<a href="https://github.com/azl397985856/daily-featured/tree/master/assets" target="_blank" rel="noopener">这里</a>存放了项目中绘制图的源代码， 大家可以用<a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a>打开进行编辑。</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="./LICENSE">Apache-2.0</a></p>]]></content>
      
      
      <categories>
          
          <category> 每日一荐 </category>
          
          <category> 2020-03 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《82 年生的金智英》</title>
      <link href="/blog/2020/04/06/82-jinzhiying/"/>
      <url>/blog/2020/04/06/82-jinzhiying/</url>
      
        <content type="html"><![CDATA[<p>《82 年生的金智英》（韩文原始名： 82년생 김지영）是一部由同名小说改编，于 2019 年 10 月 23 号在韩国上映的韩国电影。由金度英执导，郑裕美、孔刘主演。该片讲述出生于 1982 年的三十多岁平凡女性金智英，在产子后因为周围人事变化，以及家庭中婆婆等家人的言行一度造成其心理疾病，以及在其丈夫和家人的帮助下寻找自我恢复。</p><p>​<a id="more"></a></p><h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gdjxj3ncwrj30le09lwjt.jpg" alt></p><h2 id="观后感"><a href="#观后感" class="headerlink" title="观后感"></a>观后感</h2><p>金智英的生活状况和很多人一样。片子着重讲述的是女人的社会生活状况，包括但不限于被工作歧视，家庭重男轻女，社会中处于弱势位置。</p><ul><li>工作中，由于是女性，会被歧视，调侃，连升职也会变得不顺利。借用片中的台词就是“和我一起的男同事，早就升到了 xx”。</li><li>重男轻女在韩国就好像之前的中国一样。是整个社会的意识，很难从根本上得到改观。”女生就应该相夫教子等“观念已经深入人心，尤其是老一辈。</li><li>社会中处弱势位置。片中讲述了小女孩被一个男孩子盯上，吓得给公交车路人发暗号，并向爸爸发信息求救。爸爸知道了还责怪女孩子不小心，这一幕既真实又令人深思。上厕所被偷拍，以至于上厕所不得不小心翼翼。</li><li>带孩子的种种艰辛，或许带过孩子的人会感同身受吧。</li></ul><p>我看的时候弹幕一直在刷”我一定要对我的老婆好“，”只恋爱不结婚“。但是话容易说，两个人只有相互理解，尊重，才是对另一方好。否则也只是自己的一厢情愿，强加于人罢了。这样的话，与其说是对别人好，倒不如说是”给自己赎罪，减轻自己的心灵负担“的自私行为罢了。</p><p>总的来说，由于社会阅历等原因，这部片子没有给我感同身受的感觉。但是确是一部反映现实，控诉社会的好电影。</p>]]></content>
      
      
      <categories>
          
          <category> 电影 </category>
          
          <category> 观后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《饥饿站台》</title>
      <link href="/blog/2020/04/06/movie-eager-game/"/>
      <url>/blog/2020/04/06/movie-eager-game/</url>
      
        <content type="html"><![CDATA[<p>《饥饿站台》 （西班牙语：El hoyo）是一部 2019 年的西班牙科幻惊悚电影。导演为加尔德图．加兹特鲁—乌鲁蒂亚里，编剧为佩德罗．里书罗、大卫・狄索拉；由伊万·马萨格、安东尼亚·圣·胡安、佐里昂・埃奎勒、埃米利奥·布阿勒、亚莉珊卓·马桑凯主演。电影情节设于一个塔状的监狱中，囚犯从监狱中间逐渐下降的大平台拿取食物。2019 年 9 月 6 日于 2019 年多伦多国际影展举行首映。</p><a id="more"></a><h2 id="评分"><a href="#评分" class="headerlink" title="评分"></a>评分</h2><p>影评网站烂番茄的 54 条评论中，其中 45 篇给出了“新鲜”的正面评价，“新鲜度”为 83%，平均分数 7.43 分（满分 10 分）。</p><h2 id="观后感"><a href="#观后感" class="headerlink" title="观后感"></a>观后感</h2><p>这部片子是少有的可以在国内放映的”限制级“电影。其中有很多暴力血腥以及色情内容。本部片子的主线很简单，简单到“很多人看几分钟的简介就可以了解到整部片子的内容”。</p><p>这是一个具有讽刺意味的电影 - “世间只有三类人，一类高层人，一类底层人，还有一类正在坠落。” 片中用楼层的来反应阶级，片中多次有人从上面掉下来，其中掉落的时间都是月末。或许是过惯了好日子，无法再忍受底层的艰苦，而选择了死亡。</p><blockquote><p>片子有一个设定： 每个月都会重新洗牌，交换一次楼层。</p></blockquote><p>片中有合作，背叛，猜忌等人性面，这在平常的生活中很难显现。这让我想起了之前看过的《欺诈游戏》，《下一层》，以及玩过的游戏《999 逃脱系列》。人与人之间，最难建立的是信任，并且信任一旦失去便很难重新建立。如果每个人都能足够信任，就不会存在下层人被饿死的局面。 实际上，这种阶层的观念是很难消除的，这是群体意识决定的。</p><p>《乌合之众》中也反复强调过群体意识和个人意识的不同，提到“群体往往呈现出“盲目”、“冲动”、“狂热”、“轻信”的特点，而统治者又是如何利用群体的这些特点建立和巩固自身统治的”。群体意识是会被”利用“的，这种利用可能是好的方向，也可能是不好的方向。群体的力量过于巨大，如同没有被驯化的野兽一般。</p><p>我不怕鬼，但是我怕扮成“鬼”的人。</p>]]></content>
      
      
      <categories>
          
          <category> 电影 </category>
          
          <category> 观后感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 1162. 地图分析</title>
      <link href="/blog/2020/03/30/leetcode-island/"/>
      <url>/blog/2020/03/30/leetcode-island/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上有很多小岛题，虽然官方没有这个标签， 但是在我这里都差不多。不管是思路还是套路都比较类似，大家可以结合起来练习。</p><ul><li><a href="https://github.com/azl397985856/leetcode/blob/master/problems/200.number-of-islands.md" target="_blank" rel="noopener">200.number-of-islands</a></li><li><a href="https://leetcode-cn.com/problems/max-area-of-island/solution/695-dao-yu-de-zui-da-mian-ji-dfspython3-by-fe-luci/" target="_blank" rel="noopener">695.max-area-of-island</a></li></ul><p>​<a id="more"></a></p><p>原题地址：<a href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/as-far-from-land-as-possible/</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我们继续使用上面两道题的套路，即不用visited，而是原地修改。由于这道题求解的是最远的距离，而距离我们可以使用BFS来做。算法：</p><ul><li>对于每一个海洋，我们都向四周扩展，寻找最近的陆地，每次扩展steps加1。</li><li>如果找到了陆地，我们返回steps。</li><li>我们的目标就是所有steps中的最大值。</li></ul><p>实际上面算法有很多重复计算，如图中间绿色的区域，向外扩展的时候，如果其周边四个海洋的距离已经计算出来了，那么没必要扩展到陆地。实际上只需要扩展到周边的四个海洋格子就好了，其距离陆地的最近距离就是1 + 周边四个格子中到达陆地的最小距离。</p><p><img src="https://pic.leetcode-cn.com/23e21821e14238829dd7021a620895f40a8e42127cfe372e4791d025bb655afc.jpg" alt></p><p>我们考虑优化。 </p><ul><li>将所有陆地加入队列，而不是海洋。</li><li>陆地不断扩展到海洋，每扩展一次就steps加1，直到无法扩展位置。</li><li>最终返回steps即可。</li></ul><p>图解：</p><p><img src="https://pic.leetcode-cn.com/8001c1390fb0d1a402eea5010594a303651b4a09ac6ddcd12d72b5b8a9d37295.jpg" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        steps = <span class="number">-1</span></span><br><span class="line">        queue = [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(n) <span class="keyword">for</span> j <span class="keyword">in</span> range(n) <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> len(queue) == <span class="number">0</span> <span class="keyword">or</span> len(queue) == n ** <span class="number">2</span>: <span class="keyword">return</span> steps</span><br><span class="line">        <span class="keyword">while</span> len(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)): </span><br><span class="line">                x, y = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span> xi, yj <span class="keyword">in</span> [(x + <span class="number">1</span>, y), (x - <span class="number">1</span>, y), (x, y + <span class="number">1</span>), (x, y - <span class="number">1</span>)]:</span><br><span class="line">                    <span class="keyword">if</span> xi &gt;= <span class="number">0</span> <span class="keyword">and</span> xi &lt; n <span class="keyword">and</span> yj &gt;= <span class="number">0</span> <span class="keyword">and</span> yj &lt; n <span class="keyword">and</span> grid[xi][yj] == <span class="number">0</span>:</span><br><span class="line">                        queue.append((xi, yj))</span><br><span class="line">                        grid[xi][yj] = <span class="number">-1</span></span><br><span class="line">            steps += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> steps</span><br></pre></td></tr></table></figure><blockquote><p>由于没有early return，steps 其实会多算一次。 我们可以返回值减去1，也可以steps初始化为-1。这里我选择是steps初始化为-1</p></blockquote><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：$O(N ^ 2)$</li><li>空间复杂度：$O(N ^ 2)$</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>由于数组删除第一个元素（上面代码的queue.pop(0)）是$O(N)$的时间复杂度，我们可以使用deque优化，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDistance</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">     <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">     N = len(grid)</span><br><span class="line">     steps = <span class="number">-1</span></span><br><span class="line">     q = deque([(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> range(N) <span class="keyword">for</span> j <span class="keyword">in</span> range(N) <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>])</span><br><span class="line">     <span class="keyword">if</span> len(q) == <span class="number">0</span> <span class="keyword">or</span> len(q) == N ** <span class="number">2</span>:</span><br><span class="line">         <span class="keyword">return</span> steps</span><br><span class="line">     move = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line">     <span class="keyword">while</span> len(q) &gt; <span class="number">0</span>:</span><br><span class="line">         <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(q)):</span><br><span class="line">             x, y = q.popleft()</span><br><span class="line">             <span class="keyword">for</span> dx, dy <span class="keyword">in</span> move:</span><br><span class="line">                 nx, ny = x + dx, y + dy</span><br><span class="line">                 <span class="keyword">if</span> <span class="number">0</span> &lt;= nx &lt; N <span class="keyword">and</span> <span class="number">0</span> &lt;= ny &lt; N <span class="keyword">and</span> grid[nx][ny] == <span class="number">0</span>:</span><br><span class="line">                     q.append((nx, ny))</span><br><span class="line">                     grid[nx][ny] = <span class="number">-1</span></span><br><span class="line">         steps += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> steps</span><br></pre></td></tr></table></figure><p>更多题解可以访问我的LeetCode题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a>  。 目前已经接近30K star啦。</p><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的LeetCode题解</p><p><img src="https://pic.leetcode-cn.com/89ef69abbf02a2957838499a96ce3fbb26830aae52e3ab90392e328c2670cddc-file_1581478989502" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> BFS </category>
          
          <category> hashtable </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="/blog/2020/03/24/bit/"/>
      <url>/blog/2020/03/24/bit/</url>
      
        <content type="html"><![CDATA[<p>我这里总结了几道位运算的题目分享给大家，分别是 136和137， 260 和  645， 总共加起来四道题。 四道题全部都是位运算的套路，如果你想练习位运算的话，不要错过哦～～</p><a id="more"></a><h2 id="前菜"><a href="#前菜" class="headerlink" title="前菜"></a>前菜</h2><p>开始之前我们先了解下异或，后面会用到。</p><ol><li>异或的性质</li></ol><p>两个数字异或的结果<code>a^b</code>是将 a 和 b 的二进制每一位进行运算，得出的数字。 运算的逻辑是果同一位的数字相同则为 0，不同则为 1</p><ol start="2"><li>异或的规律</li></ol><ul><li><p>任何数和本身异或则为<code>0</code></p></li><li><p>任何数和 0 异或是<code>本身</code></p></li></ul><ol start="3"><li>异或运算满足交换律，即：</li></ol><p><code>a ^ b ^ c = a ^ c ^ b</code></p><p>OK，我们来看下这三道题吧。</p><h2 id="136-只出现一次的数字1"><a href="#136-只出现一次的数字1" class="headerlink" title="136. 只出现一次的数字1"></a>136. 只出现一次的数字1</h2><p>题目大意是除了一个数字出现一次，其他都出现了两次，让我们找到出现一次的数。我们执行一次全员异或即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        single_number = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            single_number ^= num</span><br><span class="line">        <span class="keyword">return</span> single_number</span><br></pre></td></tr></table></figure><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：$O(N)$，其中N为数组长度。</li><li>空间复杂度：$O(1)$</li></ul><h2 id="137-只出现一次的数字2"><a href="#137-只出现一次的数字2" class="headerlink" title="137. 只出现一次的数字2"></a>137. 只出现一次的数字2</h2><p>题目大意是除了一个数字出现一次，其他都出现了三次，让我们找到出现一次的数。 灵活运用位运算是本题的关键。</p><p>Python3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">            cnt = <span class="number">0</span>  <span class="comment"># 记录当前 bit 有多少个1</span></span><br><span class="line">            bit = <span class="number">1</span> &lt;&lt; i  <span class="comment"># 记录当前要操作的 bit</span></span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> num &amp; bit != <span class="number">0</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt % <span class="number">3</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 不等于0说明唯一出现的数字在这个 bit 上是1</span></span><br><span class="line">                res |= bit</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res - <span class="number">2</span> ** <span class="number">32</span> <span class="keyword">if</span> res &gt; <span class="number">2</span> ** <span class="number">31</span> - <span class="number">1</span> <span class="keyword">else</span> res</span><br></pre></td></tr></table></figure><ul><li>为什么Python最后需要对返回值进行判断？</li></ul><p>如果不这么做的话测试用例是[-2,-2,1,1,-3,1,-3,-3,-4,-2] 的时候，就会输出 4294967292。 其原因在于Python是动态类型语言，在这种情况下其会将符号位置的1看成了值，而不是当作符号“负数”。 这是不对的。 正确答案应该是 - 4，-4的二进制码是 1111…100，就变成 2^32-4=4294967292，解决办法就是 减去 2 ** 32 。</p><blockquote><p>之所以这样不会有问题的原因还在于题目限定的数组范围不会超过 2 ** 32</p></blockquote><p>JavaScript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> bit = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[j] &amp; bit) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt % <span class="number">3</span> != <span class="number">0</span>) res = res | bit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：$O(N)$，其中N为数组长度。</li><li>空间复杂度：$O(1)$</li></ul><h2 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645. 错误的集合"></a>645. 错误的集合</h2><p>和上面的<code>137. 只出现一次的数字2</code>思路一样。这题没有限制空间复杂度，因此直接hashmap 存储一下没问题。 不多说了，我们来看一种空间复杂度$O(1)$的解法。</p><p>由于和<code>137. 只出现一次的数字2</code>思路基本一样，我直接复用了代码。具体思路是，将nums的所有索引提取出一个数组idx，那么由idx和nums组成的数组构成singleNumbers的输入，其输出是唯二不同的两个数。</p><p>但是我们不知道哪个是缺失的，哪个是重复的，因此我们需要重新进行一次遍历，判断出哪个是缺失的，哪个是重复的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        ret = <span class="number">0</span>  <span class="comment"># 所有数字异或的结果</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            ret ^= n</span><br><span class="line">        <span class="comment"># 找到第一位不是0的</span></span><br><span class="line">        h = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(ret &amp; h == <span class="number">0</span>):</span><br><span class="line">            h &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 根据该位是否为0将其分为两组</span></span><br><span class="line">            <span class="keyword">if</span> (h &amp; n == <span class="number">0</span>):</span><br><span class="line">                a ^= n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b ^= n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [a, b]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findErrorNums</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        nums = [<span class="number">0</span>] + nums</span><br><span class="line">        idx = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            idx.append(i)</span><br><span class="line">        a, b = self.singleNumbers(nums + idx)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> a == num:</span><br><span class="line">                <span class="keyword">return</span> [a, b]</span><br><span class="line">        <span class="keyword">return</span> [b, a]</span><br></pre></td></tr></table></figure><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="260-只出现一次的数字3"><a href="#260-只出现一次的数字3" class="headerlink" title="260. 只出现一次的数字3"></a>260. 只出现一次的数字3</h2><p>题目大意是除了两个数字出现一次，其他都出现了两次，让我们找到这个两个数。</p><p>我们进行一次全员异或操作，得到的结果就是那两个只出现一次的不同的数字的异或结果。</p><p>我们刚才讲了异或的规律中有一个<code>任何数和本身异或则为0</code>， 因此我们的思路是能不能将这两个不同的数字分成两组 A 和 B。<br>分组需要满足两个条件.</p><ol><li><p>两个独特的的数字分成不同组</p></li><li><p>相同的数字分成相同组</p></li></ol><p>这样每一组的数据进行异或即可得到那两个数字。</p><p>问题的关键点是我们怎么进行分组呢？</p><p>由于异或的性质是，同一位相同则为 0，不同则为 1. 我们将所有数字异或的结果一定不是 0，也就是说至少有一位是 1.</p><p>我们随便取一个， 分组的依据就来了， 就是你取的那一位是 0 分成 1 组，那一位是 1 的分成一组。<br>这样肯定能保证<code>2. 相同的数字分成相同组</code>, 不同的数字会被分成不同组么。 很明显当然可以， 因此我们选择是 1，也就是<br>说<code>两个独特的的数字</code>在那一位一定是不同的，因此两个独特元素一定会被分成不同组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        ret = <span class="number">0</span>  <span class="comment"># 所有数字异或的结果</span></span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            ret ^= n</span><br><span class="line">        <span class="comment"># 找到第一位不是0的</span></span><br><span class="line">        h = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(ret &amp; h == <span class="number">0</span>):</span><br><span class="line">            h &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 根据该位是否为0将其分为两组</span></span><br><span class="line">            <span class="keyword">if</span> (h &amp; n == <span class="number">0</span>):</span><br><span class="line">                a ^= n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b ^= n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [a, b]</span><br></pre></td></tr></table></figure><p><strong><em>复杂度分析</em></strong></p><ul><li>时间复杂度：$O(N)$，其中N为数组长度。</li><li>空间复杂度：$O(1)$</li></ul><p>更多题解可以访问我的LeetCode题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a>  。 目前已经接近30K star啦。</p><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的LeetCode题解</p><p><img src="https://pic.leetcode-cn.com/89ef69abbf02a2957838499a96ce3fbb26830aae52e3ab90392e328c2670cddc-file_1581478989502" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文带你 AC 十道题【滑动窗口】</title>
      <link href="/blog/2020/03/16/slide-window/"/>
      <url>/blog/2020/03/16/slide-window/</url>
      
        <content type="html"><![CDATA[<p>笔者最早接触滑动窗口是<code>滑动窗口协议</code>，滑动窗口协议（Sliding Window Protocol），属于 TCP 协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。 发送方和接收方分别有一个窗口大小 w1 和 w2。窗口大小可能会根据网络流量的变化而有所不同，但是在更简单的实现中它们是固定的。窗口大小必须大于零才能进行任何操作。</p><p>我们算法中的滑动窗口也是类似，只不过包括的情况更加广泛。实际上上面的滑动窗口在某一个时刻就是固定窗口大小的滑动窗口，随着网络流量等因素改变窗口大小也会随着改变。接下来我们讲下算法中的滑动窗口。</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>滑动窗口是一种解决问题的思路和方法，通常用来解决一些连续问题。 比如 LeetCode 的 <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/209-chang-du-zui-xiao-de-zi-shu-zu-hua-dong-chua-2/" target="_blank" rel="noopener">209. 长度最小的子数组</a>。更多滑动窗口题目见下方<code>题目列表</code>。</p><h2 id="常见套路"><a href="#常见套路" class="headerlink" title="常见套路"></a>常见套路</h2><p>滑动窗口主要用来处理连续问题。比如题目求解“连续子串 xxxx”，“连续子数组 xxxx”，就应该可以想到滑动窗口。能不能解决另说，但是这种敏感性还是要有的。</p><p>从类型上说主要有：</p><ul><li>固定窗口大小</li><li>窗口大小不固定，求解最大的满足条件的窗口</li><li>窗口大小不固定，求解最小的满足条件的窗口（上面的 209 题就属于这种）</li></ul><p>后面两种我们统称为<code>可变窗口</code>。当然不管是哪种类型基本的思路都是一样的，不一样的仅仅是代码细节。</p><h3 id="固定窗口大小"><a href="#固定窗口大小" class="headerlink" title="固定窗口大小"></a>固定窗口大小</h3><p>对于固定窗口，我们只需要固定初始化左右指针 l 和 r，分别表示的窗口的左右顶点，并且保证：</p><ol><li>l 初始化为 0</li><li>初始化 r，使得 r - l + 1 等于窗口大小</li><li>同时移动 l 和 r</li><li>判断窗口内的连续元素是否满足题目限定的条件<ul><li>4.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解</li><li>4.2 如果不满足，则继续。</li></ul></li></ol><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcw0pwdhmwj308z0d53yt.jpg" alt></p><h3 id="可变窗口大小"><a href="#可变窗口大小" class="headerlink" title="可变窗口大小"></a>可变窗口大小</h3><p>对于可变窗口，我们同样固定初始化左右指针 l 和 r，分别表示的窗口的左右顶点。后面有所不同，我们需要保证：</p><ol><li>l 和 r 都初始化为 0</li><li>r 指针移动一步</li><li>判断窗口内的连续元素是否满足题目限定的条件<ul><li>4.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。并尝试通过移动 l 指针缩小窗口大小。循环执行 4.1</li><li>4.2 如果不满足，则继续。</li></ul></li></ol><p>形象地来看的话，就是 r 指针不停向右移动，l 指针仅仅在窗口满足条件之后才会移动，起到窗口收缩的效果。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcw0ouuplaj30d90d50t3.jpg" alt></p><h2 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h2><p>以下是 209 题目的代码，使用 Python 编写，大家意会即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen</span><span class="params">(self, s: int, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        l = total = <span class="number">0</span></span><br><span class="line">        ans = len(nums) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            total += nums[r]</span><br><span class="line">            <span class="keyword">while</span> total &gt;= s:</span><br><span class="line">                ans = min(ans, r - l + <span class="number">1</span>)</span><br><span class="line">                total -= nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span> <span class="keyword">if</span> ans == len(nums) + <span class="number">1</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure><h2 id="题目列表"><a href="#题目列表" class="headerlink" title="题目列表"></a>题目列表</h2><p>以下题目有的信息比较直接，有的题目信息比较隐蔽，需要自己发掘</p><ul><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/pythonjavascript-hua-dong-chuang-kou-3-wu-zhong-fu/" target="_blank" rel="noopener">【Python，JavaScript】滑动窗口（3. 无重复字符的最长子串）</a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/solution/python-hua-dong-chuang-kou-76-zui-xiao-fu-gai-zi-c/" target="_blank" rel="noopener">76. 最小覆盖子串</a></li><li><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/209-chang-du-zui-xiao-de-zi-shu-zu-hua-dong-chua-2/" target="_blank" rel="noopener">209. 长度最小的子数组</a></li><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/python-hua-dong-chuang-kou-438-zhao-dao-zi-fu-chua/" target="_blank" rel="noopener">【Python】滑动窗口（438. 找到字符串中所有字母异位词）</a></li><li><a href="https://leetcode-cn.com/problems/fruit-into-baskets/solution/904-shui-guo-cheng-lan-python3-by-fe-lucifer/" target="_blank" rel="noopener">【904. 水果成篮】（Python3）</a></li><li><a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/solution/930-he-xiang-tong-de-er-yuan-zi-shu-zu-javapython-/" target="_blank" rel="noopener">【930. 和相同的二元子数组】（Java，Python）</a></li><li><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/solution/992-k-ge-bu-tong-zheng-shu-de-zi-shu-zu-hua-dong-c/" target="_blank" rel="noopener">【992. K 个不同整数的子数组】滑动窗口（Python）</a></li><li><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/1004-zui-da-lian-xu-1de-ge-shu-iii-hua-dong-chuang/" target="_blank" rel="noopener">【1004. 最大连续 1 的个数 III】滑动窗口（Python3）</a></li><li><a href="https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697" target="_blank" rel="noopener">【1234. 替换子串得到平衡字符串】[Java/C++/Python] Sliding Window</a></li><li><a href="https://leetcode-cn.com/problems/count-number-of-nice-subarrays/solution/1248-tong-ji-you-mei-zi-shu-zu-hua-dong-chuang-kou/" target="_blank" rel="noopener">【1248. 统计「优美子数组」】滑动窗口（Python）</a></li></ul><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/" target="_blank" rel="noopener">LeetCode Sliding Window Series Discussion</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法，滑动窗口 </category>
          
          <category> 数据结构，数组 </category>
          
          <category> 数据结构，字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode 日记】85. 最大矩形</title>
      <link href="/blog/2020/03/04/85.maximal-rectangle/"/>
      <url>/blog/2020/03/04/85.maximal-rectangle/</url>
      
        <content type="html"><![CDATA[<p>这是一道 Hard 难度的题目，本题的解法很多，让我们来看一下。</p><p>​<a id="more"></a></p><p>原题地址： <a href="https://leetcode-cn.com/problems/maximal-rectangle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximal-rectangle/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><p>示例：</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>输出：6</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我在 <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-zhu-zhuang-tu-zhong-zui-da-de-ju-xing-duo-chong/" title="【84. 柱状图中最大的矩形】多种方法（Python3）" target="_blank" rel="noopener">【84. 柱状图中最大的矩形】多种方法（Python3）</a> 使用了多种方法来解决。 然而在这道题，我们仍然可以使用完全一样的思路去完成。 不熟悉的可以看下我的题解。本题解是基于那道题的题解来进行的。</p><p>拿题目给的例子来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我们逐行扫描得到 <code>84. 柱状图中最大的矩形</code> 中的 heights 数组：</p><p><img src="https://pic.leetcode-cn.com/aaa258e37c34d5028f56b1c172300c278ff439f209431010561d7b8a7d8eae2a.jpg" alt></p><p>这样我们就可以使用<code>84. 柱状图中最大的矩形</code> 中的解法来进行了，这里我们使用单调栈来解。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        n, heights, st, ans = len(heights), [<span class="number">0</span>] + heights + [<span class="number">0</span>], [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> heights[st[<span class="number">-1</span>]] &gt; heights[i]:</span><br><span class="line">                ans = max(ans, heights[st.pop(<span class="number">-1</span>)] * (i - st[<span class="number">-1</span>] - <span class="number">1</span>))</span><br><span class="line">            st.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalRectangle</span><span class="params">(self, matrix: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        heights = [<span class="number">0</span>] * n</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">"0"</span>:</span><br><span class="line">                    heights[j] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    heights[j] += <span class="number">1</span></span><br><span class="line">            ans = max(ans, self.largestRectangleArea(heights))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(M * N)$</li><li>空间复杂度：$O(N)$</li></ul><p>欢迎关注我的公众号《脑洞前端》获取更多更新鲜的 LeetCode 题解</p><p><img src="https://pic.leetcode-cn.com/89ef69abbf02a2957838499a96ce3fbb26830aae52e3ab90392e328c2670cddc-file_1581478989502" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构，单调栈 </category>
          
          <category> Hard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构，算法，LeetCode 日记，Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode 日记】 84. 柱状图中最大的矩形</title>
      <link href="/blog/2020/03/04/84.largest-rectangle-in-histogram/"/>
      <url>/blog/2020/03/04/84.largest-rectangle-in-histogram/</url>
      
        <content type="html"><![CDATA[<p>这是一道 Hard 难度的题目，本题的解法很多，让我们来看一下。</p><p>​<a id="more"></a></p><p>原题地址： <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>`<br>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gch1kvdoy5j305805oaa1.jpg" alt></p><p>以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为  [2,1,5,6,2,3]。</p><p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gch1l4m3clj305805owem.jpg" alt></p><p>图中阴影部分为所能勾勒出的最大矩形面积，其面积为  10  个单位。</p><p>示例：</p><p>输入：[2,1,5,6,2,3]<br>输出：10</p><h2 id="暴力枚举-左右端点法（TLE）"><a href="#暴力枚举-左右端点法（TLE）" class="headerlink" title="暴力枚举 - 左右端点法（TLE）"></a>暴力枚举 - 左右端点法（TLE）</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们暴力尝试<code>所有可能的矩形</code>。由于矩阵是二维图形， 我我们可以使用<code>左右两个端点来唯一确认一个矩阵</code>。因此我们使用双层循环枚举所有的可能性即可。 而矩形的面积等于<code>（右端点坐标 - 左端点坐标 + 1) * 最小的高度</code>，最小的高度我们可以在遍历的时候顺便求出。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        n, ans = len(heights), <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n != <span class="number">0</span>:</span><br><span class="line">            ans = heights[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            height = heights[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">                height = min(height, heights[j])</span><br><span class="line">                ans = max(ans, (j - i + <span class="number">1</span>) * height)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N^2)$</li><li>空间复杂度：$O(1)$</li></ul><h2 id="暴力枚举-中心扩展法（TLE）"><a href="#暴力枚举-中心扩展法（TLE）" class="headerlink" title="暴力枚举 - 中心扩展法（TLE）"></a>暴力枚举 - 中心扩展法（TLE）</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们仍然暴力尝试<code>所有可能的矩形</code>。只不过我们这一次从中心向两边进行扩展。对于每一个 i，我们计算出其左边第一个高度小于它的索引 p，同样地，计算出右边第一个高度小于它的索引 q。那么以 i 为最低点能够构成的面积就是<code>(q - p - 1) * heights[i]</code>。 这种算法毫无疑问也是正确的。 我们证明一下，假设 f(i) 表示求以 i 为最低点的情况下，所能形成的最大矩阵面积。那么原问题转化为<code>max(f(0), f(1), f(2), ..., f(n - 1))</code>。</p><p>具体算法如下：</p><ul><li>我们使用 l 和 r 数组。l[i] 表示 左边第一个高度小于它的索引，r[i] 表示 右边第一个高度小于它的索引。</li><li>我们从前往后求出 l，再从后往前计算出 r。</li><li>再次遍历求出所有的可能面积，并取出最大的。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(heights)</span><br><span class="line">        l, r, ans = [<span class="number">-1</span>] * n, [n] * n, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> heights[j] &gt;= heights[i]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            l[i] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> heights[j] &gt;= heights[i]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            r[i] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ans = max(ans, heights[i] * (r[i] - l[i] - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N^2)$</li><li>空间复杂度：$O(N)$</li></ul><h2 id="优化中心扩展法（Accepted）"><a href="#优化中心扩展法（Accepted）" class="headerlink" title="优化中心扩展法（Accepted）"></a>优化中心扩展法（Accepted）</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>实际上我们内层循环没必要一步一步移动，我们可以直接将<code>j -= 1</code> 改成 <code>j = l[j]</code>, <code>j += 1</code> 改成 <code>j = r[j]</code>。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(heights)</span><br><span class="line">        l, r, ans = [<span class="number">-1</span>] * n, [n] * n, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            j = i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> heights[j] &gt;= heights[i]:</span><br><span class="line">                j = l[j]</span><br><span class="line">            l[i] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> heights[j] &gt;= heights[i]:</span><br><span class="line">                j = r[j]</span><br><span class="line">            r[i] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ans = max(ans, heights[i] * (r[i] - l[i] - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(N)$</li></ul><h2 id="单调栈（Accepted）"><a href="#单调栈（Accepted）" class="headerlink" title="单调栈（Accepted）"></a>单调栈（Accepted）</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>实际上，读完第二种方法的时候，你应该注意到了。我们的核心是求左边第一个比 i 小的和右边第一个比 i 小的。 如果你熟悉单调栈的话，那么应该会想到这是非常适合使用单调栈来处理的场景。</p><p>为了简单起见，我在 heights 首尾添加了两个哨兵元素，这样可以减少边界处理的额外代码。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestRectangleArea</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        n, heights, st, ans = len(heights), [<span class="number">0</span>] + heights + [<span class="number">0</span>], [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">while</span> st <span class="keyword">and</span> heights[st[<span class="number">-1</span>]] &gt; heights[i]:</span><br><span class="line">                ans = max(ans, heights[st.pop(<span class="number">-1</span>)] * (i - st[<span class="number">-1</span>] - <span class="number">1</span>))</span><br><span class="line">            st.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$</li><li>空间复杂度：$O(N)$</li></ul><p>欢迎关注我的公众号《脑洞前端》获取更多更新鲜的 LeetCode 题解</p><p><img src="https://pic.leetcode-cn.com/89ef69abbf02a2957838499a96ce3fbb26830aae52e3ab90392e328c2670cddc-file_1581478989502" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构，单调栈 </category>
          
          <category> Hard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构，算法，LeetCode 日记，Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一荐 2020-01 汇总</title>
      <link href="/blog/2020/02/25/daily-featured-2020-01/"/>
      <url>/blog/2020/02/25/daily-featured-2020-01/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8d0sktqrwj30hs07maae.jpg" alt></p><p>每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。</p><p>项目主页维护当前月份的内容，想看往期内容，可以去<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">每日一荐主仓库</a>翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。</p><a id="more"></a><h2 id="2020-01"><a href="#2020-01" class="headerlink" title="2020-01"></a>2020-01</h2><h3 id="2020-01-23-资料"><a href="#2020-01-23-资料" class="headerlink" title="2020-01-23[资料]"></a>2020-01-23[资料]</h3><p>尤雨溪在多伦多的演讲《Vue 3.0 设计原则》对于想要学习 Vue3.0 或者想要直接从零开发 Vue3.0 的人来说，绝对是必读的。PPT 内容不多，几分钟就可以读完，不建议看视频，视频大概有 50 多分钟。</p><p>PPT 地址： <a href="https://docs.google.com/presentation/d/1r0HcS4baHy2c106DsZ4jA7Zt0R9u2MnRmmKIvAVuf1o/edit#slide=id.p" target="_blank" rel="noopener">https://docs.google.com/presentation/d/1r0HcS4baHy2c106DsZ4jA7Zt0R9u2MnRmmKIvAVuf1o/edit#slide=id.p</a></p><h3 id="2020-01-22-软件"><a href="#2020-01-22-软件" class="headerlink" title="2020-01-22[软件]"></a>2020-01-22[软件]</h3><p>安卓软件的开屏广告很烦人，严重影响效率。这里推荐一个安卓 APP 可以改善这种情况, 并且不需要 root，只需要开启权限即可。注意它不是万能的，不过实际使用情况来看，还是有用的。</p><p>地址： <a href="https://www.coolapk.com/apk/me.angeldevil.autoskip" target="_blank" rel="noopener">https://www.coolapk.com/apk/me.angeldevil.autoskip</a></p><h3 id="2020-01-21-好文"><a href="#2020-01-21-好文" class="headerlink" title="2020-01-21[好文]"></a>2020-01-21[好文]</h3><p>可访问性真的是一个非常重要的东西，尤其是对于有障碍人士。但是整个行业在这方面做的还完全不够，不管是技术能力，还是重视程度上。</p><p>比如我在使用钉钉软件的时候，他们的快捷键很少，这一点非常困扰我，当然类似的应用还有很多。我觉得整个行业应该注重起来这一块，将可访问性做好，要知道这也是用户体验中很重要的组成。这里有一篇文章 《Debugging your application for accessibility》， 从浅层次上讲解了可访问性的内容，以及基本实践，同时还推荐了一个叫 axe 的 chrome 扩展工具帮助你分析网页存在的可访问性问题，类似于 网页性能分析之于 lighthouse。</p><p>文章地址： <a href="https://blog.logrocket.com/debugging-application-accessibility/" target="_blank" rel="noopener">https://blog.logrocket.com/debugging-application-accessibility/</a></p><h3 id="2020-01-20-网站"><a href="#2020-01-20-网站" class="headerlink" title="2020-01-20[网站]"></a>2020-01-20[网站]</h3><p>我平时有 RSS 阅读的习惯，我使用的 Feedly 管理订阅内容。但是有的网站本身并不支持 RSS 订阅。那么一种黑科技，就是使用第三方服务帮我们转换一下，生成订阅。原理很简单，就是轮训内容变化，如果变化就通知你。当然前提你要知道“如何判断发布了新内容”，这部分 feed43 做的不错。我们利用 Feed43，将任意网页制作成 RSS 订阅源。 这里有一篇少数派的文章，大家可以参考一下： <a href="https://sspai.com/post/34320" target="_blank" rel="noopener">https://sspai.com/post/34320</a></p><p>你也可以使用 rsshub 来做同样的事情，rsshub 支持私有化部署，地址： <a href="https://docs.rsshub.app/。" target="_blank" rel="noopener">https://docs.rsshub.app/。</a></p><h3 id="2020-01-19-网站"><a href="#2020-01-19-网站" class="headerlink" title="2020-01-19[网站]"></a>2020-01-19[网站]</h3><p>给大家介绍一个 mac 软件下载网站，效果你懂的。类似的网站还有 xclient.info。</p><p>地址：<a href="https://www.macappdownload.com/" target="_blank" rel="noopener">https://www.macappdownload.com/</a></p><h3 id="2020-01-17-工具"><a href="#2020-01-17-工具" class="headerlink" title="2020-01-17[工具]"></a>2020-01-17[工具]</h3><p>如果你想开发一个 VSCode 插件，那么一个脚手架是有用的。我推荐使用官方的脚手架工具。顺便再推荐一个 vscode 插件开发指南，来自 sorrycc，地址 <a href="https://www.yuque.com/docs/share/cf6d9191-be02-4644-aef5-afc2f2f38297" target="_blank" rel="noopener">https://www.yuque.com/docs/share/cf6d9191-be02-4644-aef5-afc2f2f38297</a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gb1q8ba9s4j30f505nq3i.jpg" alt></p><p>地址： <a href="https://github.com/Microsoft/vscode-generator-code" target="_blank" rel="noopener">https://github.com/Microsoft/vscode-generator-code</a></p><h3 id="2020-01-16-工具"><a href="#2020-01-16-工具" class="headerlink" title="2020-01-16[工具]"></a>2020-01-16[工具]</h3><p>不改变任何功能的情况下给你的 docker image 瘦身。</p><p>Github 地址： <a href="https://github.com/docker-slim/docker-slim" target="_blank" rel="noopener">https://github.com/docker-slim/docker-slim</a></p><h3 id="2020-01-13-插件"><a href="#2020-01-13-插件" class="headerlink" title="2020-01-13[插件]"></a>2020-01-13[插件]</h3><p>今天推荐两个关于 Github 的 chrome 插件。</p><p>一个是用来查看 Github 提交历史的，名字是<code>Git History Browser Extension</code>，安装之后 git 文件右上角信息会多一个按钮。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaupssm2q0j31010hgn12.jpg" alt></p><p>点开之后是这种画风：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gauptpbcsoj30vm0mwjwh.jpg" alt></p><p>另外一个插件是<code>OctoLinker</code>。这个插件你可以用来方便地进行文件跳转。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaupv7x3auj30rd0e6gny.jpg" alt></p><h3 id="2020-01-09-好文"><a href="#2020-01-09-好文" class="headerlink" title="2020-01-09[好文]"></a>2020-01-09[好文]</h3><p>如果你关注 Node.js 社区，那么你一定记得 Node.js v12 一个非常重磅的功能就是，内核的 HTTP Parser 默认使用 llhttp，取代了老旧的 http-parser，性能提升了 156%。</p><p>但知其然也要知其所以然，llhttp 是如何做到这一点的呢？《llhttp 是如何使 Node.js 性能翻倍的？》进行了详细的阐述。</p><p>地址： <a href="https://zhuanlan.zhihu.com/p/100660049" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/100660049</a></p><h3 id="2020-01-08-好文"><a href="#2020-01-08-好文" class="headerlink" title="2020-01-08[好文]"></a>2020-01-08[好文]</h3><p>昨天介绍了《当你在浏览器中输入 google.com 并且按下回车之后发生了什么？》，今天推荐一篇《图解浏览器的基本工作原理》。 讲的内容主要是浏览器渲染相关的，让你在更大的视角，更细的粒度了解浏览器原理，最可贵的是文章通俗易懂，图文并茂，对于想了解浏览器原理而又找不到好的入门资料的同学来说很有用。</p><p>其中还提到了很多延伸知识，比如事件冒泡更微观角度是什么？事件的 passive：true 做了什么？为什么很多时候我们绘图不流畅以及如何实现平滑绘图？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"pointermove"</span>, event =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> events = event.getCoalescedEvents();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> event <span class="keyword">of</span> events) &#123;</span><br><span class="line">    <span class="keyword">const</span> x = event.pageX;</span><br><span class="line">    <span class="keyword">const</span> y = event.pageY;</span><br><span class="line">    <span class="comment">// draw a line using x and y coordinates.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>(使用 <code>getCoalescedEvents</code> API 来获取组合的事件，从而绘制一条平滑的曲线)</p><p>文章地址： <a href="https://zhuanlan.zhihu.com/p/47407398" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47407398</a></p><h3 id="2020-01-07-好文"><a href="#2020-01-07-好文" class="headerlink" title="2020-01-07[好文]"></a>2020-01-07[好文]</h3><p>或许目前实际上最全的《当你在浏览器中输入 google.com 并且按下回车之后发生了什么？》。文档内容不仅局限于 DNS，TCP，HTTP，CDN。发送 HTML，解析 DOM 等过程，甚至包括了物理键盘和系统中断的工作原理，系统中断，ARP 等等更为详细的内容。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gan22rkye3j30au0c5tab.jpg" alt></p><p>地址： <a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="noopener">https://github.com/skyline75489/what-happens-when-zh_CN</a></p><h3 id="2020-01-06-框架"><a href="#2020-01-06-框架" class="headerlink" title="2020-01-06[框架]"></a>2020-01-06[框架]</h3><p>前端测试正在变得越来越重要，之前也写了一篇文章<a href="https://github.com/azl397985856/frontend-test" target="_blank" rel="noopener">前端测试</a>，那么拥有一个顺手的测试框架显得越来越重要。</p><p>我个人目前在使用的测试框架是 Jest，除了 Jest 还有很多优秀的测试框架，知己知彼，百战不殆。我们看看下：</p><ul><li>Mocha：非常老牌的测试框架，使用 Jest 之前我在用</li><li>Enzyme：一个 React 测试框架，后期我不再使用了，而是转向 Jest + react-dom/test-utils</li><li>Ava</li><li>Jasmine</li><li>Cypress</li></ul><p>另外你做自动化测试的话，推荐使用 Puppeteer，如果你做组件测试的话可以考虑 Jest 的快照或者 StoryBook（一个 2015 年以来一直关注并且看好的一个框架）。</p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>我重新整理了下自己的公众号，并且我还给它换了一个名字<code>脑洞前端</code>，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。</p><p>之后我的文章会同步到微信公众号 <code>脑洞前端</code> ，你可以关注获取最新的文章，并和我进行交流。</p><p>另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。</p><img width="300" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7he9xdtmyj30by0byaac.jpg"><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul><li>如果有想法和创意，请提<a href="https://github.com/azl397985856/daily-featured/issues" target="_blank" rel="noopener">issue</a>或者进群提</li><li>如果想贡献代码，请提<a href="https://github.com/azl397985856/daily-featured/pulls" target="_blank" rel="noopener">PR</a></li><li>如果需要修改项目中图片，<a href="https://github.com/azl397985856/daily-featured/tree/master/assets" target="_blank" rel="noopener">这里</a>存放了项目中绘制图的源代码， 大家可以用<a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a>打开进行编辑。</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="./LICENSE">Apache-2.0</a></p>]]></content>
      
      
      <categories>
          
          <category> 每日一荐 </category>
          
          <category> 2020-01 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法提高班】并查集</title>
      <link href="/blog/2020/02/20/union-find/"/>
      <url>/blog/2020/02/20/union-find/</url>
      
        <content type="html"><![CDATA[<p>关于并查集的题目不少，官方给的数据是 30 道（截止 2020-02-20），但是有一些题目虽然官方没有贴<code>并查集</code>标签，但是使用并查集来说确非常简单。这类题目如果掌握模板，那么刷这种题会非常快，并且犯错的概率会大大降低，这就是模板的好处。</p><a id="more"></a><p>我这里总结了几道并查集的题目：</p><ul><li><a href="https://leetcode-cn.com/problems/friend-circles/solution/mo-ban-ti-bing-cha-ji-python3-by-fe-lucifer-2/" target="_blank" rel="noopener">547.朋友圈</a></li><li><a href="https://leetcode-cn.com/problems/accounts-merge/solution/mo-ban-ti-bing-cha-ji-python3-by-fe-lucifer-3/" target="_blank" rel="noopener">721. 账户合并</a></li><li><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/solution/mo-ban-ti-bing-cha-ji-python3-by-fe-lucifer/" target="_blank" rel="noopener">990. 等式方程的可满足性</a></li></ul><p>大家可以学了模板之后去套用一下上面的三道题，做不出来的可以看看我的题解。</p><h2 id="并查集概述"><a href="#并查集概述" class="headerlink" title="并查集概述"></a>并查集概述</h2><p>并查集算法，主要是解决图论中「动态连通性」问题的</p><p>Union-Find 算法解决的是图的动态连通性问题，这个算法本身不难，能不能应用出来主要是看你抽象问题的能力，是否能够把原始问题抽象成一个有关图论的问题。</p><p>如果你对这个算法不是很明白，推荐看一下这篇文章<a href="https://leetcode-cn.com/problems/friend-circles/solution/union-find-suan-fa-xiang-jie-by-labuladong/" target="_blank" rel="noopener">Union-Find 算法详解</a>，讲的非常详细。</p><p>你可以把并查集的元素看成部门的人，几个人可以组成一个部门个数。</p><p>并查集核心的三个方法分别是<code>union</code>, <code>find</code>, <code>connected</code>。</p><ul><li><code>union</code>: 将两个人所在的两个部门合并成一个部门（如果两个人是相同部门，实际山不需要合并）</li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc32a7x6y1j30zk0k0dki.jpg" alt><br>（图来自 labuladong）</p><ul><li><code>find</code>: 查找某个人的部门 leader</li><li><code>connnected</code>: 判断两个人是否是一个部门的</li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc32atzy3tj30zk0k0tde.jpg" alt><br>（图来自 labuladong）</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>这是一个我经常使用的模板，我会根据具体题目做细小的变化，但是大体是不变的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span>:</span></span><br><span class="line">    parent = &#123;&#125;</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化 parent 和 cnt</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x != self.parent[x]:</span><br><span class="line">            x = self.parent[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.connected(p, q): <span class="keyword">return</span></span><br><span class="line">        self.parent[self.find(p)] = self.find(q)</span><br><span class="line">        self.cnt -= <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(p) == self.find(q)</span><br></pre></td></tr></table></figure><p>如果你想要更好的性能，这个模板更适合你，相应地代码稍微有一点复杂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span>:</span></span><br><span class="line">    parent = &#123;&#125;</span><br><span class="line">    size = &#123;&#125;</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="comment"># 初始化 parent，size 和 cnt</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> x != self.parent[x]:</span><br><span class="line">            x = self.parent[x]</span><br><span class="line">            <span class="comment"># 路径压缩</span></span><br><span class="line">            self.parent[x] = self.parent[self.parent[x]];</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.connected(p, q): <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 小的树挂到大的树上， 使树尽量平衡</span></span><br><span class="line">        leader_p = self.find(p)</span><br><span class="line">        leader_q = self.find(q)</span><br><span class="line">        <span class="keyword">if</span> self.size[leader_p] &lt; self.size[leader_q]:</span><br><span class="line">            self.parent[leader_p] = leader_q</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.parent[leader_q] = leader_p</span><br><span class="line">        self.cnt -= <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">(self, p, q)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(p) == self.find(q)</span><br></pre></td></tr></table></figure><p>大家可以根据情况使用不同的模板。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪婪策略系列 - 覆盖篇</title>
      <link href="/blog/2020/02/19/leetcode-greedy/"/>
      <url>/blog/2020/02/19/leetcode-greedy/</url>
      
        <content type="html"><![CDATA[<p>贪婪策略是一种常见的算法思想，具体是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关，这点和动态规划一样。</p><p>LeetCode 上对于贪婪策略有 73 道题目。我们将其分成几个类型来讲解，截止目前我们暂时只提供<code>覆盖</code>问题，其他的可以期待我的新书或者之后的题解文章。</p><a id="more"></a><h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>我们挑选三道来讲解，这三道题除了使用贪婪法，你也可以尝试动态规划来解决。</p><ul><li><a href="https://leetcode-cn.com/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a>，困难</li><li><a href="https://leetcode-cn.com/problems/video-stitching/" target="_blank" rel="noopener">1024. 视频拼接</a>，中等</li><li><a href="https://leetcode-cn.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/" target="_blank" rel="noopener">1326. 灌溉花园的最少水龙头数目</a>，困难</li></ul><p>覆盖问题的一大特征，我们可以将其抽象为<code>给定数轴上的一个大区间 I 和 n 个小区间 i[0], i[1], ..., i[n - 1]，问最少选择多少个小区间，使得这些小区间的并集可以覆盖整个大区间。</code></p><p>我们来看下这三道题吧。</p><h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:</p><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>  从下标为 0 跳到下标为 1 的位置，跳  1  步，然后跳  3  步到达数组的最后一个位置。<br>说明:</p><p>假设你总是可以到达数组的最后一个位置。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>贪婪策略，即我们每次在可跳范围内选择可以使得跳的更远的位置，由于题目保证了<code>你总是可以到达数组的最后一个位置</code>,因此这种算法是完备的。</p><p>如下图，开始的位置是 2，可跳的范围是橙色的。然后因为 3 可以跳的更远，所以跳到 3 的位置。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc0ymvsw64j309i03xmx7.jpg" alt></p><p>如下图，然后现在的位置就是 3 了，能跳的范围是橙色的，然后因为 4 可以跳的更远，所以下次跳到 4 的位置。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc0ynd8zilj30c10390ss.jpg" alt></p><p>写代码的话，我们用 end 表示当前能跳的边界，对于上边第一个图的橙色 1，第二个图中就是橙色的 4，遍历数组的时候，到了边界，我们就重新更新新的边界。</p><blockquote><p>图来自 <a href="https://leetcode-cn.com/u/windliang/" target="_blank" rel="noopener">https://leetcode-cn.com/u/windliang/</a></p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>代码支持：Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n, cnt, furthest, end = len(nums), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            furthest = max(furthest, nums[i] + i)</span><br><span class="line">            <span class="keyword">if</span> i == end:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                end = furthest</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(N)$。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><h3 id="1024-视频拼接"><a href="#1024-视频拼接" class="headerlink" title="1024. 视频拼接"></a>1024. 视频拼接</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为  T  秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p><p>视频片段  clips[i]  都用区间进行表示：开始于  clips[i][0]  并于  clips[i][1]  结束。我们甚至可以对这些片段自由地再剪辑，例如片段  [0, 7]  可以剪切成  [0, 1] + [1, 3] + [3, 7]  三部分。</p><p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回  -1 。</p><p>示例 1：</p><p>输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10<br>输出：3<br>解释：<br>我们选中 [0,2], [8,10], [1,9] 这三个片段。<br>然后，按下面的方案重制比赛片段：<br>将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。<br>现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。<br>示例 2：</p><p>输入：clips = [[0,1],[1,2]], T = 5<br>输出：-1<br>解释：<br>我们无法只用 [0,1] 和 [0,2] 覆盖 [0,5] 的整个过程。<br>示例 3：</p><p>输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9<br>输出：3<br>解释：<br>我们选取片段 [0,4], [4,7] 和 [6,9] 。<br>示例 4：</p><p>输入：clips = [[0,4],[2,8]], T = 5<br>输出：2<br>解释：<br>注意，你可能录制超过比赛结束时间的视频。</p><p>提示：</p><p>1 &lt;= clips.length &lt;= 100<br>0 &lt;= clips[i][0], clips[i][1] &lt;= 100<br>0 &lt;= T &lt;= 100</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>贪婪策略，我们选择满足条件的最大值。和上面的不同，这次我们需要手动进行一次排序，实际上贪婪策略经常伴随着排序，我们按照 clip[0]从小到大进行排序。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc0yseg71aj30yg0i0js3.jpg" alt></p><p>如图：</p><ul><li>1 不可以，因此存在断层</li><li>2 可以</li><li>3 不行，因为不到 T</li></ul><p>我们当前的 clip 开始结束时间分别为 s，e。 上一段 clip 的结束时间是 t1，上上一段 clip 结束时间是 t2。</p><p>那么这种情况下 t1 实际上是不需要的，因为 t2 完全可以覆盖它：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc0ywpgkcsj30o604sq2w.jpg" alt></p><p>那什么样 t1 才是需要的呢？如图：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc0yxinwf7j30mc05sgll.jpg" alt></p><p>用代码来说的话就是<code>s &gt; t2 and t2 &lt;= t1</code></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>代码支持：Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">videoStitching</span><span class="params">(self, clips: List[List[int]], T: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment">#  t1 表示选取的上一个clip的结束时间</span></span><br><span class="line">        <span class="comment">#  t2 表示选取的上上一个clip的结束时间</span></span><br><span class="line">        t2, t1, cnt = <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        clips.sort(key=<span class="keyword">lambda</span> a: a[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> s, e <span class="keyword">in</span> clips:</span><br><span class="line">            <span class="comment"># s &gt; t1 已经确定不可以了， t1 &gt;= T 已经可以了</span></span><br><span class="line">            <span class="keyword">if</span> s &gt; t1 <span class="keyword">or</span> t1 &gt;= T:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> s &gt; t2 <span class="keyword">and</span> t2 &lt;= t1:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                t2 = t1</span><br><span class="line">            t1 = max(t1,e)</span><br><span class="line">        <span class="keyword">return</span> cnt <span class="keyword">if</span> t1 &gt;= T <span class="keyword">else</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：由于使用了排序（假设是基于比较的排序），因此时间复杂度为 $O(NlogN)$。</p></li><li><p>空间复杂度：$O(1)$。</p></li></ul><h3 id="1326-灌溉花园的最少水龙头数目"><a href="#1326-灌溉花园的最少水龙头数目" class="headerlink" title="1326. 灌溉花园的最少水龙头数目"></a>1326. 灌溉花园的最少水龙头数目</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>在 x 轴上有一个一维的花园。花园长度为  n，从点  0  开始，到点  n  结束。</p><p>花园里总共有  n + 1 个水龙头，分别位于  [0, 1, …, n] 。</p><p>给你一个整数  n  和一个长度为  n + 1 的整数数组  ranges ，其中  ranges[i] （下标从 0 开始）表示：如果打开点  i  处的水龙头，可以灌溉的区域为  [i -  ranges[i], i + ranges[i]] 。</p><p>请你返回可以灌溉整个花园的   最少水龙头数目  。如果花园始终存在无法灌溉到的地方，请你返回  -1 。</p><p>示例 1：</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc0z68dxoxj30bm05xjrk.jpg" alt></p><p>输入：n = 5, ranges = [3,4,1,1,0,0]<br>输出：1<br>解释：<br>点 0 处的水龙头可以灌溉区间 [-3,3]<br>点 1 处的水龙头可以灌溉区间 [-3,5]<br>点 2 处的水龙头可以灌溉区间 [1,3]<br>点 3 处的水龙头可以灌溉区间 [2,4]<br>点 4 处的水龙头可以灌溉区间 [4,4]<br>点 5 处的水龙头可以灌溉区间 [5,5]<br>只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。<br>示例 2：</p><p>输入：n = 3, ranges = [0,0,0,0]<br>输出：-1<br>解释：即使打开所有水龙头，你也无法灌溉整个花园。<br>示例 3：</p><p>输入：n = 7, ranges = [1,2,1,0,2,1,0,1]<br>输出：3<br>示例 4：</p><p>输入：n = 8, ranges = [4,0,0,0,0,0,0,0,4]<br>输出：2<br>示例 5：</p><p>输入：n = 8, ranges = [4,0,0,0,4,0,0,0,4]<br>输出：1</p><p>提示：</p><p>1 &lt;= n &lt;= 10^4<br>ranges.length == n + 1<br>0 &lt;= ranges[i] &lt;= 100</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>贪心策略，我们尽量找到能够覆盖最远（右边）位置的水龙头，并记录它最右覆盖的土地。</p><ul><li>我们使用 furthest[i] 来记录经过每一个水龙头 i 能够覆盖的最右侧土地。</li><li>一共有 n+1 个水龙头，我们遍历 n + 1 次。</li><li>对于每次我们计算水龙头的左右边界，[i - ranges[i], i + ranges[i]]</li><li>我们更新左右边界范围内的水龙头的 furthest</li><li>最后从土地 0 开始，一直到土地 n ，记录水龙头数目</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>代码支持：Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minTaps</span><span class="params">(self, n: int, ranges: List[int])</span> -&gt; int:</span></span><br><span class="line">        furthest, cnt, cur = [<span class="number">0</span>] * n, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">            l = max(<span class="number">0</span>, i - ranges[i])</span><br><span class="line">            r = min(n, i + ranges[i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(l, r):</span><br><span class="line">                furthest[j] = max(furthest[j], r)</span><br><span class="line">        <span class="keyword">while</span> cur &lt; n:</span><br><span class="line">            <span class="keyword">if</span> furthest[cur] == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            cur = furthest[cur]</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：时间复杂度取决 l 和 r，也就是说取决于 ranges 数组的值，假设 ranges 的平均大小为 Size 的话，那么时间复杂度为 $O(N * Size)$。</p></li><li><p>空间复杂度：我们使用了 furthest 数组， 因此空间复杂度为 $O(N)$。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 贪婪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法系列 </tag>
            
            <tag> 贪婪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造二叉树系列</title>
      <link href="/blog/2020/02/08/%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/"/>
      <url>/blog/2020/02/08/%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>构造二叉树是一个常见的二叉树考点，相比于直接考察二叉树的遍历，这种题目的难度会更大。截止到目前(2020-02-08) LeetCode 关于构造二叉树一共有三道题目，分别是：</p><ul><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="noopener">889. 根据前序和后序遍历构造二叉树</a></li></ul><p>今天就让我们用一个套路一举攻破他们。</p><p>​<a id="more"></a></p><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a>105. 从前序与中序遍历序列构造二叉树</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">根据一棵树的前序遍历与中序遍历构造二叉树。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">你可以假设树中没有重复的元素。</span><br><span class="line"></span><br><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们以题目给出的测试用例来讲解：<br><img src="https://pic.leetcode-cn.com/584db66158d2b497b9fdd69b5dc10c3a76db6e2c0f6cff68789cfb79807b0756.jpg" alt></p><p>前序遍历是<code>根左右</code>，因此 preorder 第一个元素一定整个树的根。由于题目说明了没有重复元素，因此我们可以通过 val 去 inorder 找到根在 inorder 中的索引 i。<br>而由于中序遍历是<code>左根右</code>，我们容易找到 i 左边的都是左子树，i 右边都是右子树。</p><p>我使用红色表示根，蓝色表示左子树，绿色表示右子树。</p><p><img src="https://pic.leetcode-cn.com/faea3d9a78c1fa623457b28c8d20e09a47bb0911d78ff53f42fab0e463a7755d.jpg" alt></p><p>根据此时的信息，我们能构造的树是这样的：</p><p><img src="https://pic.leetcode-cn.com/261696c859c562ca31dface08d3020bcd20362ab2205d614473cca02b1635eb0.jpg" alt></p><p>我们 preorder 继续向后移动一位，这个时候我们得到了第二个根节点”9“，实际上就是左子树的根节点。</p><p><img src="https://pic.leetcode-cn.com/eb8311e01ed86007b23460d6c933b53ad14bec2d63a0dc01f625754368f22376.jpg" alt></p><p>我们 preorder 继续向后移动一位，这个时候我们得到了第二个根节点”20“，实际上就是右子树的根节点。其中右子树由于个数大于 1，我们无法确定，我们继续执行上述逻辑。</p><p><img src="https://pic.leetcode-cn.com/d90dc9bae9d819da997eb67d445524c8ef39ce2a4a8defb16b5a3b6b2a0fc783.jpg" alt></p><p>根据此时的信息，我们能构造的树是这样的：</p><p><img src="https://pic.leetcode-cn.com/f8553f668bed9f897f393a24d78e4469c4b5503c4ba8c59e90dca1b19acf4de5.jpg" alt></p><p>我们不断执行上述逻辑即可。简单起见，递归的时候每次我都开辟了新的数组，这个其实是没有必要的，我们可以通过四个变量来记录 inorder 和 preorder 的起始位置即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码支持：Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 实际上inorder 和 postorder一定是同时为空的，因此你无论判断哪个都行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        i = inorder.index(root.val)</span><br><span class="line">        root.left = self.buildTree(preorder[<span class="number">1</span>:i + <span class="number">1</span>], inorder[:i])</span><br><span class="line">        root.right = self.buildTree(preorder[i + <span class="number">1</span>:], inorder[i+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：由于每次递归我们的 inorder 和 preorder 的总数都会减 1，因此我们要递归 N 次，故时间复杂度为 $O(N)$，其中 N 为节点个数。</li><li>空间复杂度：我们使用了递归，也就是借助了额外的栈空间来完成， 由于栈的深度为 N，因此总的空间复杂度为 $O(N)$，其中 N 为节点个数。</li></ul><blockquote><p>空间复杂度忽略了开辟数组的内存消耗。</p></blockquote><h2 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a>106. 从中序与后序遍历序列构造二叉树</h2><p>如果你会了上面的题目，那么这个题目对你来说也不是难事，我们来看下。</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">根据一棵树的中序遍历与后序遍历构造二叉树。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">你可以假设树中没有重复的元素。</span><br><span class="line"></span><br><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder = [9,15,7,20,3]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们以题目给出的测试用例来讲解：<br><img src="https://pic.leetcode-cn.com/fb9d700a67d70b5e68461fa1f0438d9c5c676557a776eda4cd1b196c41ce65a1.jpg" alt></p><p>后序遍历是<code>左右根</code>，因此 postorder 最后一个元素一定整个树的根。由于题目说明了没有重复元素，因此我们可以通过 val 去 inorder 找到根在 inorder 中的索引 i。<br>而由于中序遍历是<code>左根右</code>，我们容易找到 i 左边的都是左子树，i 右边都是右子树。</p><p>我使用红色表示根，蓝色表示左子树，绿色表示右子树。</p><p><img src="https://pic.leetcode-cn.com/10176eec270c90d8e0bd4640a628e9320b7d5c30f3c62ffdb1fd2800d87c6f7b.jpg" alt></p><p>根据此时的信息，我们能构造的树是这样的：</p><p><img src="https://pic.leetcode-cn.com/261696c859c562ca31dface08d3020bcd20362ab2205d614473cca02b1635eb0.jpg" alt></p><p>其中右子树由于个数大于 1，我们无法确定，我们继续执行上述逻辑。我们 postorder 继续向前移动一位，这个时候我们得到了第二个根节点”20“，实际上就是右子树的根节点。</p><p><img src="https://pic.leetcode-cn.com/e6cac2b6a956c09d977c4cfd7883268644b42bdd0531a509d24b4aafebc147c4.jpg" alt></p><p>根据此时的信息，我们能构造的树是这样的：</p><p><img src="https://pic.leetcode-cn.com/f8553f668bed9f897f393a24d78e4469c4b5503c4ba8c59e90dca1b19acf4de5.jpg" alt></p><p>我们不断执行上述逻辑即可。简单起见，递归的时候每次我都开辟了新的数组，这个其实是没有必要的，我们可以通过四个变量来记录 inorder 和 postorder 的起始位置即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码支持：Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 实际上inorder 和 postorder一定是同时为空的，因此你无论判断哪个都行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(postorder[<span class="number">-1</span>])</span><br><span class="line">        i = inorder.index(root.val)</span><br><span class="line">        root.left = self.buildTree(inorder[:i], postorder[:i])</span><br><span class="line">        root.right = self.buildTree(inorder[i+<span class="number">1</span>:], postorder[i:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：由于每次递归我们的 inorder 和 postorder 的总数都会减 1，因此我们要递归 N 次，故时间复杂度为 $O(N)$，其中 N 为节点个数。</li><li>空间复杂度：我们使用了递归，也就是借助了额外的栈空间来完成， 由于栈的深度为 N，因此总的空间复杂度为 $O(N)$，其中 N 为节点个数。</li></ul><blockquote><p>空间复杂度忽略了开辟数组的内存消耗。</p></blockquote><h2 id="889-根据前序和后序遍历构造二叉树"><a href="#889-根据前序和后序遍历构造二叉树" class="headerlink" title="889. 根据前序和后序遍历构造二叉树"></a>889. 根据前序和后序遍历构造二叉树</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">返回与给定的前序和后序遍历匹配的任何二叉树。</span><br><span class="line"></span><br><span class="line"> pre 和 post 遍历中的值是不同的正整数。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]</span><br><span class="line">输出：[1,2,3,4,5,6,7]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= pre.length == post.length &lt;= 30</span><br><span class="line">pre[] 和 post[] 都是 1, 2, ..., pre.length 的排列</span><br><span class="line">每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。</span><br></pre></td></tr></table></figure><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们以题目给出的测试用例来讲解：<br><img src="https://pic.leetcode-cn.com/584db66158d2b497b9fdd69b5dc10c3a76db6e2c0f6cff68789cfb79807b0756.jpg" alt></p><p>前序遍历是<code>根左右</code>，因此 preorder 第一个元素一定整个树的根，preorder 第二个元素（如果存在的话）一定是左子树。由于题目说明了没有重复元素，因此我们可以通过 val 去 postorder 找到 pre[1]在 postorder 中的索引 i。<br>而由于后序遍历是<code>左右根</code>，因此我们容易得出。 postorder 中的 0 到 i(包含)是左子树，preorder 的 1 到 i+1（包含）也是左子树。</p><p>其他部分可以参考上面两题。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>代码支持：Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructFromPrePost</span><span class="params">(self, pre: List[int], post: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="comment"># 实际上pre 和 post一定是同时为空的，因此你无论判断哪个都行</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        node = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        i = post.index(pre[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        node.left = self.constructFromPrePost(pre[<span class="number">1</span>:i + <span class="number">2</span>], post[:i + <span class="number">1</span>])</span><br><span class="line">        node.right = self.constructFromPrePost(pre[i + <span class="number">2</span>:], post[i + <span class="number">1</span>:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：由于每次递归我们的 postorder 和 preorder 的总数都会减 1，因此我们要递归 N 次，故时间复杂度为 $O(N)$，其中 N 为节点个数。</li><li>空间复杂度：我们使用了递归，也就是借助了额外的栈空间来完成， 由于栈的深度为 N，因此总的空间复杂度为 $O(N)$，其中 N 为节点个数。</li></ul><blockquote><p>空间复杂度忽略了开辟数组的内存消耗。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你仔细对比一下的话，会发现我们的思路和代码几乎一模一样。注意到每次递归我们的两个数组个数都会减去 1，因此我们递归终止条件不难写出，并且递归问题规模如何缩小也很容易，那就是数组总长度减去 1。</p><p>我们拿最后一个题目来说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.left = self.constructFromPrePost(pre[<span class="number">1</span>:i + <span class="number">2</span>], post[:i + <span class="number">1</span>])</span><br><span class="line">node.right = self.constructFromPrePost(pre[i + <span class="number">2</span>:], post[i + <span class="number">1</span>:<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>我们发现 pre 被拆分为两份，pre[1:i + 2]和 pre[i + 2:]。很明显总数少了 1，那就是 pre 的第一个元素。 也就是说如果你写出一个，其他一个不用思考也能写出来。</p><p>而对于 post 也一样，post[:i + 1] 和 post[i + 1:-1]，很明显总数少了 1，那就是 post 最后一个元素。</p><p>这个解题模板足够简洁，并且逻辑清晰，大家可以用我的模板试试～</p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>更多题解可以访问我的 LeetCode 题解仓库：<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a> 。 目前已经 30K star 啦。</p><p>大家也可以关注我的公众号《力扣加加》获取更多更新鲜的 LeetCode 题解</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfcuzagjalj30p00dwabs.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 算法系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的日程安排表系列</title>
      <link href="/blog/2020/02/03/leetcode-%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8%E7%B3%BB%E5%88%97/"/>
      <url>/blog/2020/02/03/leetcode-%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>《我的日程安排表》截止目前（2020-02-03）在 LeetCode 上一共有三道题，其中两个中等难度，一个困难难度,分别是：</p><ul><li><a href="https://leetcode-cn.com/problems/my-calendar-i" target="_blank" rel="noopener">729. 我的日程安排表 I</a></li><li><a href="https://leetcode-cn.com/problems/my-calendar-ii" target="_blank" rel="noopener">731. 我的日程安排表 II</a></li><li><a href="https://leetcode-cn.com/problems/my-calendar-iii" target="_blank" rel="noopener">732. 我的日程安排表 III</a></li></ul><p>另外 LeetCode 上有一个类似的系列《会议室》，截止目前（2020-02-03）有两道题目。其中一个简单一个中等，分别是：</p><ul><li><a href="https://leetcode-cn.com/problems/meeting-rooms/" target="_blank" rel="noopener">252. 会议室</a></li><li><a href="https://leetcode-cn.com/problems/meeting-rooms-ii/" target="_blank" rel="noopener">253. 会议室 II</a></li></ul><p>今天我们就来攻克它们。</p><a id="more"></a><h1 id="729-我的日程安排表-I"><a href="#729-我的日程安排表-I" class="headerlink" title="729. 我的日程安排表 I"></a>729. 我的日程安排表 I</h1><h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode-cn.com/problems/my-calendar-i" target="_blank" rel="noopener">https://leetcode-cn.com/problems/my-calendar-i</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。</p><p>MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数  x 的范围为，  start &lt;= x &lt; end。</p><p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。</p><p>每次调用 MyCalendar.book 方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false  并且不要将该日程安排添加到日历中。</p><p>请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p><p>示例 1:</p><p>MyCalendar();<br>MyCalendar.book(10, 20); // returns true<br>MyCalendar.book(15, 25); // returns false<br>MyCalendar.book(20, 30); // returns true<br>解释:<br>第一个日程安排可以添加到日历中. 第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了。<br>第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 。<br>说明:</p><p>每个测试用例，调用  MyCalendar.book  函数最多不超过  100 次。<br>调用函数  MyCalendar.book(start, end)时， start 和  end 的取值范围为  [0, 10^9]。</p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先我们考虑暴力法。每插入一个元素我们都判断其是否和已有的<code>所有</code>课程重叠。</p><p>我们定一个函数<code>intersected(calendar, calendars)</code>，其中 calendar 是即将要插入的课程，calendars 是已经插入的课程。 只要 calendar 和 calendars 中的任何一个课程有交叉，我们就返回 True，否则返回 False。</p><p>对于两个 calendar，我们的判断逻辑都是一样的。假设连个 calendar 分别是<code>[s1, e1]</code>和<code>[s2, e2]</code>。那么如果<code>s1 &gt;= e2 or s2 &lt;= e1</code>, 则两个课程没有交叉，可以预定，否则不可以。如图，1，2，3 可以预定，剩下的不可以。</p><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1gbj1o8hvivj20w20ra76f.jpg" alt="image.png"></p><p>代码是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersected</span><span class="params">(calendar, calendars)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> [start, end] <span class="keyword">in</span> calendars:</span><br><span class="line">        <span class="keyword">if</span> calendar[<span class="number">0</span>] &gt;= end <span class="keyword">or</span> calendar[<span class="number">1</span>] &lt;= start:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>复杂度分析：</p><ul><li><p>时间复杂度：$O(N^2)$。N 指的是日常安排的数量，对于每个新的日常安排，我们检查新的日常安排是否发生冲突来决定是否可以预订新的日常安排。</p></li><li><p>空间复杂度: $O(N)$。</p></li></ul><p>这个代码写出来之后整体代码就呼之欲出了，全部代码见下方代码部分。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @lc app=leetcode.cn id=729 lang=python3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [729] 我的日程安排表 I</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=start</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.calendars = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start: int, end: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">intersected</span><span class="params">(calendar, calendars)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> [start, end] <span class="keyword">in</span> calendars:</span><br><span class="line">                <span class="keyword">if</span> calendar[<span class="number">0</span>] &gt;= end <span class="keyword">or</span> calendar[<span class="number">1</span>] &lt;= start:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> intersected([start, end], self.calendars):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.calendars.append([start, end])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Your MyCalendar object will be instantiated and called as such:</span></span><br><span class="line">        <span class="comment"># obj = MyCalendar()</span></span><br><span class="line">        <span class="comment"># param_1 = obj.book(start,end)</span></span><br><span class="line">        <span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure><p>实际上我们还可以换个角度，上面的思路判断交叉部分我们考虑的是“如何不交叉”，剩下的就是交叉。我们也可以直接考虑交叉。还是上面的例子，如果两个课程交叉，那么一定满足<code>s1 &lt; e2 and e1 &gt; s2</code>。基于此，我们写出下面的代码。</p><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @lc app=leetcode.cn id=729 lang=python3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [729] 我的日程安排表 I</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=start</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.calendars = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start: int, end: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> s, e <span class="keyword">in</span> self.calendars:</span><br><span class="line">            <span class="keyword">if</span> start &lt; e <span class="keyword">and</span> end &gt; s:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.calendars.append([start, end])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Your MyCalendar object will be instantiated and called as such:</span></span><br><span class="line">        <span class="comment"># obj = MyCalendar()</span></span><br><span class="line">        <span class="comment"># param_1 = obj.book(start,end)</span></span><br><span class="line">        <span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure><h2 id="二叉查找树法"><a href="#二叉查找树法" class="headerlink" title="二叉查找树法"></a>二叉查找树法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>和上面思路类似，只不过我们每次都对 calendars 进行排序，那么我们可以通过二分查找日程安排的情况来检查新日常安排是否可以预订。如果每次插入之前都进行一次排序，那么时间复杂度会很高。如图，我们的[s1,e1], [s2,e2], [s3,e3] 是按照时间顺序排好的日程安排。我们现在要插入[s,e],我们使用二分查找，找到要插入的位置，然后和插入位置的课程进行一次比对即可，这部分的时间复杂度是 O(logN)$。</p><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1gbj28k6v4gj21100c2754.jpg" alt="image.png"></p><p>我们考虑使用平衡二叉树来维护这种动态的变化，在最差的情况时间复杂度会退化到上述的$O(N^2)$，平均情况是$O(NlogN)$，其中 N 是已预订的日常安排数。</p><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1gbj2dirnf0j20xs0fe75j.jpg" alt="image.png"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line">        self.left = self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node.start &gt;= self.end:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.right:</span><br><span class="line">                self.right = node</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> self.right.insert(node)</span><br><span class="line">        <span class="keyword">elif</span> node.end &lt;= self.start:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.left:</span><br><span class="line">                self.left = node</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> self.left.insert(node)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = Node(start, end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.root.insert(Node(start, end))</span><br></pre></td></tr></table></figure><h1 id="731-我的日程安排表-II"><a href="#731-我的日程安排表-II" class="headerlink" title="731. 我的日程安排表 II"></a>731. 我的日程安排表 II</h1><h2 id="题目地址-1"><a href="#题目地址-1" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode-cn.com/problems/my-calendar-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/my-calendar-ii</a></p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。</p><p>MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数  x 的范围为，  start &lt;= x &lt; end。</p><p>当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。</p><p>每次调用 MyCalendar.book 方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。</p><p>请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p><p>示例：</p><p>MyCalendar();<br>MyCalendar.book(10, 20); // returns true<br>MyCalendar.book(50, 60); // returns true<br>MyCalendar.book(10, 40); // returns true<br>MyCalendar.book(5, 15); // returns false<br>MyCalendar.book(5, 10); // returns true<br>MyCalendar.book(25, 55); // returns true<br>解释：<br>前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。<br>第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。<br>第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间 10。<br>第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；<br>时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。</p><p>提示：</p><p>每个测试用例，调用  MyCalendar.book  函数最多不超过  1000 次。<br>调用函数  MyCalendar.book(start, end)时， start 和  end 的取值范围为  [0, 10^9]。</p><h2 id="暴力法-1"><a href="#暴力法-1" class="headerlink" title="暴力法"></a>暴力法</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>暴力法和上述思路类似。但是我们多维护一个数组 intersectedCalendars 用来存储<strong>二次预定</strong>的日程安排。如果课程第一次冲突，我们将其加入 intersectedCalendars，如果和 intersectedCalendars 也冲突了，说明出现了三次预定，我们直接返回 False。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendarTwo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.calendars = []</span><br><span class="line">        self.intersectedCalendars = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start: int, end: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> [s, e] <span class="keyword">in</span> self.intersectedCalendars:</span><br><span class="line">            <span class="keyword">if</span> start &lt; e <span class="keyword">and</span> end &gt; s:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> [s, e] <span class="keyword">in</span> self.calendars:</span><br><span class="line">            <span class="keyword">if</span> start &lt; e <span class="keyword">and</span> end &gt; s:</span><br><span class="line">                self.intersectedCalendars.append([max(start, s), min(end, e)])</span><br><span class="line">        self.calendars.append([start, end])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="二叉查找树法-1"><a href="#二叉查找树法-1" class="headerlink" title="二叉查找树法"></a>二叉查找树法</h2><p>和上面的题目类似，我们仍然可以使用平衡二叉树来简化查找逻辑。具体可以参考<a href="https://leetcode.com/problems/my-calendar-ii/discuss/158747/Python-O(logN)" target="_blank" rel="noopener">这个 discussion</a></p><p>每次插入之前我们都需要进行一次判断，判断是否可以插入。如果不可以插入，直接返回 False，否则我们进行一次插入。 插入的时候，如果和已有的相交了，我们判断是否之前已经相交了一次，如果是返回 False，否则返回 True。关于<strong>如何判断是否和已有的相交</strong>，我们可以在 node 节点增加一个字段的方式来标记，在这里我们使用 single_overlap，True 表示产生了二次预定，False 则表示没有产生过两次及以上的预定。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        self.start = start</span><br><span class="line">        self.end = end</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.single_overlap = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendarTwo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.canInsert(start, end, self.root):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        self.root = self.insert(start, end, self.root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canInsert</span><span class="params">(self, start, end, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> end &lt;= root.start:</span><br><span class="line">            <span class="keyword">return</span> self.canInsert(start, end, root.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> start &gt;= root.end:</span><br><span class="line">            <span class="keyword">return</span> self.canInsert(start, end, root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> root.single_overlap:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> start &gt;= root.start <span class="keyword">and</span> end &lt;= root.end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.canInsert(start, root.start, root.left) <span class="keyword">and</span> self.canInsert(root.end, end, root.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, start, end, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            root = Node(start, end)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> start &gt;= root.end:</span><br><span class="line">            root.right = self.insert(start, end, root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> end &lt;= root.start:</span><br><span class="line">            root.left = self.insert(start, end, root.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.single_overlap = <span class="literal">True</span></span><br><span class="line">            a = min(root.start, start)</span><br><span class="line">            b = max(root.start, start)</span><br><span class="line">            c = min(root.end, end)</span><br><span class="line">            d = max(root.end, end)</span><br><span class="line">            root.start, root.end = b, c</span><br><span class="line">            root.left, root.right = self.insert(a, b, root.left), self.insert(c, d, root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyCalendarTwo object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyCalendarTwo()</span></span><br><span class="line"><span class="comment"># param_1 = obj.book(start,end)</span></span><br></pre></td></tr></table></figure><h1 id="732-我的日程安排表-III"><a href="#732-我的日程安排表-III" class="headerlink" title="732. 我的日程安排表 III"></a>732. 我的日程安排表 III</h1><h2 id="题目地址-2"><a href="#题目地址-2" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode-cn.com/problems/my-calendar-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/my-calendar-iii/</a></p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现一个 MyCalendar 类来存放你的日程安排，你可以一直添加新的日程安排。</p><p>MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数  x 的范围为，  start &lt;= x &lt; end。</p><p>当 K 个日程安排有一些时间上的交叉时（例如 K 个日程安排都在同一时间内），就会产生 K 次预订。</p><p>每次调用 MyCalendar.book 方法时，返回一个整数 K ，表示最大的 K 次预订。</p><p>请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p><p>示例 1:</p><p>MyCalendarThree();<br>MyCalendarThree.book(10, 20); // returns 1<br>MyCalendarThree.book(50, 60); // returns 1<br>MyCalendarThree.book(10, 40); // returns 2<br>MyCalendarThree.book(5, 15); // returns 3<br>MyCalendarThree.book(5, 10); // returns 3<br>MyCalendarThree.book(25, 55); // returns 3<br>解释:<br>前两个日程安排可以预订并且不相交，所以最大的 K 次预订是 1。<br>第三个日程安排[10,40]与第一个日程安排相交，最高的 K 次预订为 2。<br>其余的日程安排的最高 K 次预订仅为 3。<br>请注意，最后一次日程安排可能会导致局部最高 K 次预订为 2，但答案仍然是 3，原因是从开始到最后，时间[10,20]，[10,40]和[5,15]仍然会导致 3 次预订。<br>说明:</p><p>每个测试用例，调用  MyCalendar.book  函数最多不超过  400 次。<br>调用函数  MyCalendar.book(start, end)时， start 和  end 的取值范围为  [0, 10^9]。</p><h2 id="二叉查找树法-2"><a href="#二叉查找树法-2" class="headerlink" title="二叉查找树法"></a>二叉查找树法</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们仍然可以使用上述的平衡二叉树的做法。只不过我们需要额外维护一个全局的最大值“k”，表示需要多少个预定。最终我们返回 k。 同时每一个 node 我们都增加一个属性 k，用来表示局部的最大值，对于每次插入，我们将 node 的 k 和全部的 k 进行比较，取出最大值即可。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start, end, ktime=<span class="number">1</span>)</span>:</span></span><br><span class="line">        self.k = ktime</span><br><span class="line">        self.s = start</span><br><span class="line">        self.e = end</span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendarThree</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        self.k = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        self.root = self.insert(self.root, start, end, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.k</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, root, start, end, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            self.k = max(self.k, k)</span><br><span class="line">            <span class="keyword">return</span> Node(start, end, k)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> start &gt;= root.e:</span><br><span class="line">                root.right = self.insert(root.right, start, end, k)</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> end &lt;= root.s:</span><br><span class="line">                root.left = self.insert(root.left, start, end, k)</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">                a = min(root.s, start)</span><br><span class="line">                b = max(root.s, start)</span><br><span class="line">                c = min(root.e, end)</span><br><span class="line">                d = max(root.e, end)</span><br><span class="line"></span><br><span class="line">                root.left = self.insert(root.left, a, b, a == root.s <span class="keyword">and</span> root.k <span class="keyword">or</span> k)</span><br><span class="line">                root.right = self.insert(root.right, c,d, d == root.e <span class="keyword">and</span> root.k <span class="keyword">or</span> k)</span><br><span class="line">                root.k += k</span><br><span class="line">                root.s = b</span><br><span class="line">                root.e = c</span><br><span class="line">                self.k = max(root.k, self.k)</span><br><span class="line">                <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h2 id="Count-Map-法"><a href="#Count-Map-法" class="headerlink" title="Count Map 法"></a>Count Map 法</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>这个是我在看了 Discussion <a href="https://leetcode.com/problems/my-calendar-iii/discuss/176950/C%2B%2B-Map-Solution-beats-95%2B" target="_blank" rel="noopener">[C++] Map Solution, beats 95%+</a> 之后写的解法，解法非常巧妙。</p><p>我们使用一个 count map 来存储所有的预定，对于每次插入，我们执行<code>count[start] += 1</code>和<code>count[end] -= 1</code>。 count[t] 表示从 t 开始到下一个 t 我们有几个预定。因此我们需要对 count 进行排序才行。 我们维护一个最大值来 cnt 来表示需要的预定数。</p><p>比如预定[1,3]和[5,7]，我们产生一个预定即可：</p><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1gbj50c37suj212q0bcq3t.jpg" alt="image.png"></p><p>再比如预定[1,5]和[3,7]，我们需要两个预定：</p><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1gbj45oq6fhj213e0ca0tm.jpg" alt="image.png"></p><p>我们可以使用红黑树来简化时间复杂度，如果你使用的是 Java，可以直接使用现成的数据结构 TreeMap。我这里偷懒，每次都排序，时间复杂度会很高，但是可以 AC。</p><p>读到这里，你可能会发现： 这个解法似乎更具有通用型。对于第一题我们可以判断 cnt 是否小于等于 1，对于第二题我们可以判断 cnt 是否小于等于 2。</p><blockquote><p>如果你不借助红黑树等数据结构直接使用 count-map 法，即每次都进行一次排序，第一题和第二题可能会直接超时。</p></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendarThree</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = dict()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">book</span><span class="params">(self, start: int, end: int)</span> -&gt; int:</span></span><br><span class="line">        self.count[start] = self.count.get(start, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        self.count[end] = self.count.get(end, <span class="number">0</span>) - <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> sorted(self.count):</span><br><span class="line">            cur += self.count[k]</span><br><span class="line">            cnt = max(cnt, cur)</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Your MyCalendarThree object will be instantiated and called as such:</span></span><br><span class="line">        <span class="comment"># obj = MyCalendarThree()</span></span><br><span class="line">        <span class="comment"># param_1 = obj.book(start,end)</span></span><br></pre></td></tr></table></figure><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><p>LeetCode 上有一个类似的系列《会议室》，截止目前（2020-02-03）有两道题目。其中一个简单一个中等，解题思路非常类似，大家用这个解题思路尝试一下，检测一下自己是否已经掌握。两道题分别是：</p><ul><li><a href="https://leetcode-cn.com/problems/meeting-rooms/" target="_blank" rel="noopener">252. 会议室</a></li><li><a href="https://leetcode-cn.com/problems/meeting-rooms-ii/" target="_blank" rel="noopener">253. 会议室 II</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们对 LeetCode 上的专题《我的日程安排》的三道题进行了汇总。对于区间判断是否重叠，我们可以反向判断，也可以正向判断。 暴力的方法是每次对所有的课程进行判断是否重叠，这种解法可以 AC。我们也可以进一步优化，使用二叉查找树来简化时间复杂度。最后我们介绍了一种 Count-Map 方法来通用解决所有的问题，不仅可以完美解决这三道题，还可以扩展到《会议室》系列的两道题。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BigPipe和微前端</title>
      <link href="/blog/2020/02/02/bigpipe-and-micro-fe/"/>
      <url>/blog/2020/02/02/bigpipe-and-micro-fe/</url>
      
        <content type="html"><![CDATA[<p>你可能听说过 BigPipe，这是一个十多年前的技术，而 BigPipe 通常都会跟“性能优化”同时被提起。微前端也是一个很早被提出的技术，但是最近几年才开始比较流行。而目前微前端能够解决的最大的问题恐怕就是遗留系统改造。我们可以将新技术构造的系统和旧技术构造的系统完美融合到一起，彼此构建，发布，运行等不受干扰。 那么 BigPipe 究竟和微前端有什么关系呢，我为什么要把这两个放到一起来看？</p><a id="more"></a><p>回答这个问题之前，我们先来看下什么是 BigPipe，以及什么是微前端。</p><h2 id="BigPipe"><a href="#BigPipe" class="headerlink" title="BigPipe"></a>BigPipe</h2><p>BigPipe 最早上 FaceBook 用来提升自家网站性能的一个秘密武器。其核心思想在于将页面分成若干小的构件，我们称之为 pagelet。每一个构件之间并行执行。</p><p>那么 BigPipe 做了什么？和传统方式有什么不同呢？我们知道浏览器处理我们的 HTML 文档以及其中包含的 CSS，JS 等资源的时候是从上到下串行执行的。如果我们把浏览器处理的过程划分为若干阶段（stage），那么这些阶段之间有着明显的时间先后关系。那么我们能不能将其并行化，从而减少时间呢？这就是 BigPipe 的基本思想。</p><p>话不多说，我们通过一段代码来帮助大家理解,比如你的项目首页是 home.html，大概这样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.BigPipe = &#123;</span></span><br><span class="line">        render(selector, content) &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.querySelector(selector).innerHTML = content;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"pagelet1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"pagelet2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"pagelet3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器首先加载过来就是一个占位元素，这部分没有 JS 和 CSS，只有 HTML 部分，因此会很快。</p><p>之后我们慢慢填充<code>pagelet1</code>,<code>pagelet2</code>, <code>pagelet3</code>,在用户看来，就是一种“渐进式渲染”的效果。</p><p>服务端代码大概是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟真实场景</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wirteChunk</span>(<span class="params">content, delay, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            res.write(content);</span><br><span class="line">        delay);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为了简化代码，直接同步读。 强烈不建议生产环境这么做！</span></span><br><span class="line">  res.write(fs.readFileSync(__dirname + <span class="string">"/home.html"</span>).toString());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> p1 = wirteChunk(<span class="string">'&lt;script&gt;BigPipe.render("#pagelet1","hello");&lt;/script&gt;'</span>, <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">const</span> p2 = wirteChunk(<span class="string">'&lt;script&gt;BigPipe.render("#pagelet2","word");&lt;/script&gt;'</span>, <span class="number">2000</span>)</span><br><span class="line">  <span class="keyword">const</span> p3 = wirteChunk(<span class="string">'&lt;script&gt;BigPipe.render("#pagelet3","!");&lt;/script&gt;'</span>, <span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.all([p1, p2, p3]).then(res.end)</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>从这里我们可以看出，BigPipe 不是框架，不是新技术。我们只需要按照这样做就行了。 这对于页面可以细分为多个块，块之间关联不大的场景非常有用。如果还是不太明白，可以看下这篇文章 -<a href="https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919/" target="_blank" rel="noopener">bigpipe-pipelining-web-pages-for-high-performance</a></p><p>说完了 BigPipe，我们再来看一下微前端。</p><h2 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h2><p>和后端微服务类似，“微前端是一种架构风格，其中众多独立交付的前端应用组合成一个大型整体。”</p><p>如果你想做微前端，一定要能够回答出这 10 个问题。</p><ol><li>微应用的注册、异步加载和生命周期管理；</li><li>微应用之间、主从之间的消息机制；</li><li>微应用之间的安全隔离措施；</li><li>微应用的框架无关、版本无关；</li><li>微应用之间、主从之间的公共依赖的库、业务逻辑(utils)以及版本怎么管理；</li><li>微应用独立调试、和主应用联调的方式，快速定位报错（发射问题）；</li><li>微应用的发布流程；</li><li>微应用打包优化问题；</li><li>微应用专有云场景的出包方案；</li><li>渐进式升级：用微应用方案平滑重构老项目。</li></ol><p>这里有一篇文档，区别与别的微前端文章的点在于其更加靠近规范层面，而不是结合自己的业务场景做的探索。这篇文章来自于阿里团队。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9kuat53elj30u00lgdhe.jpg" alt></p><p>文章地址： <a href="https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw</a></p><p>还有一篇文章也不错，一并推荐给大家 - <a href="https://mp.weixin.qq.com/s/DVkrV_KKE9KaGSeUSenc6w" target="_blank" rel="noopener">大前端时代下的微前端架构：实现增量升级、代码解耦、独立部署</a></p><p>微前端中有一个重要的需要解决的问题是子系统之间的路由。而我们的 BigPipe 如果被当作一个个子应用的，那不就是微前端中的一个点么？BigPipe 也好，微前端也好，都是一种概念，一种指导思想。微前端是不限于技术栈的， 你可以使用传统的 ssr，也可以使用 csr，也可以使用现代 csr + ssr 等，框架也可以五花八门。 如何将这些系统组合起来，并且能够有条不紊地进行合作完成一个完整的应用？这是微前端所研究和要解决的问题。</p><p>对于微前端，我们隔离各个应用的方式有几种：</p><ol><li>iframe</li><li>类似 bigpipe 这种客户端异步加载技术</li><li>web-components</li></ol><p>不管采用哪种方式，我们的大体逻辑都是：</p><ul><li>先加载主框架</li><li>异步加载各个子应用</li></ul><p>只不过加载子应用，我们可以通过 iframe 去加载，也可以使用 web-component 去加载，也可以使用类似 bigpipe 的方式分段并行加载。我们甚至可以将这几者进行结合使用。而 iframe 和 web-compoents 顺带解决了诸如 js 和 css 等隔离的作用，而 bigPipe 只是对资源加载的一个有效控制，其本身并没有什么特殊含义，更不要说诸如 js 和 css 等隔离作用了。</p><h2 id="事物关联"><a href="#事物关联" class="headerlink" title="事物关联"></a>事物关联</h2><p>当前端有了 Nodejs 之后，我们发现可以做的事情变多了，除了 BigPipe，我们又去做 ssr，又要做 graphql，还要做微前端，海报服务，AI 等等。当你从大的视角看的时候，会发现这些技术或多或少都有交集，比如我刚才提到的 ssr。 我们知道 ssr 中有一点就是我们先返回给用户一个有内容的 html，这个 html 在服务端生成，由于在服务端生成，因此只有样式，没有绑定事件，所以后续我们需要在客户端合成事件。 如果将上面 BigPipe 的代码拿过来看的话，会发现我们的 html markup 可以看作服务端渲染内容（可以是直接写死的，也可以是服务端动态生成的）。之后我们输出后续 pagelet 的 JS 代码到前端，前端继续去执行。基于 BigPipe 我们甚至可以控制页面优先级显示。我们再继续去看的话， BFF 常见的一个功能“合并请求”在这里扮演了什么样的角色？大家可以自己想一下。当你不断从不同角度思考问题，会发现很多东西都有关联。每一个技术背后往往都会落到几个基本的原理上。了解技术初始产生背后解决的问题对于掌握一个技术来说非常重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> BigPipe </tag>
            
            <tag> 微前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Floyd-Warshall 解题模板，助你快速AC</title>
      <link href="/blog/2020/02/01/1334.find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/"/>
      <url>/blog/2020/02/01/1334.find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/</url>
      
        <content type="html"><![CDATA[<p>Floyd-Warshall 是解决任意两点间的最短路径的一种算法，LeetCode 有很多题目都用了，掌握这套解题模板帮你快速 AC。</p><a id="more"></a><h1 id="题目地址（1334-阈值距离内邻居最少的城市）"><a href="#题目地址（1334-阈值距离内邻居最少的城市）" class="headerlink" title="题目地址（1334. 阈值距离内邻居最少的城市）"></a>题目地址（1334. 阈值距离内邻居最少的城市）</h1><p><a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。</span><br><span class="line"></span><br><span class="line">返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。</span><br><span class="line"></span><br><span class="line">注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1gbh9v5ygtsj20qo0k0aap.jpg" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：城市分布图如上。</span><br><span class="line">每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：</span><br><span class="line">城市 0 -&gt; [城市 1, 城市 2] </span><br><span class="line">城市 1 -&gt; [城市 0, 城市 2, 城市 3] </span><br><span class="line">城市 2 -&gt; [城市 0, 城市 1, 城市 3] </span><br><span class="line">城市 3 -&gt; [城市 1, 城市 2] </span><br><span class="line">城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。</span><br><span class="line">示例 2：</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1gbh9vg1w43j20qo0k0js8.jpg" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入：n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：城市分布图如上。 </span><br><span class="line">每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：</span><br><span class="line">城市 0 -&gt; [城市 1] </span><br><span class="line">城市 1 -&gt; [城市 0, 城市 4] </span><br><span class="line">城市 2 -&gt; [城市 3, 城市 4] </span><br><span class="line">城市 3 -&gt; [城市 2, 城市 4]</span><br><span class="line">城市 4 -&gt; [城市 1, 城市 2, 城市 3] </span><br><span class="line">城市 0 在阈值距离 4 以内只有 1 个邻居城市。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">2 &lt;= n &lt;= 100</span><br><span class="line">1 &lt;= edges.length &lt;= n * (n - 1) / 2</span><br><span class="line">edges[i].length == 3</span><br><span class="line">0 &lt;= fromi &lt; toi &lt; n</span><br><span class="line">1 &lt;= weighti, distanceThreshold &lt;= 10^4</span><br><span class="line">所有 (fromi, toi) 都是不同的。</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题的本质就是：</p><ol><li>在一个无向图中寻找每两个城镇的最小距离，我们使用 Floyd-Warshall 算法（英语：Floyd-Warshall algorithm），中文亦称弗洛伊德算法，是解决任意两点间的最短路径的一种算法。</li><li>筛选最小距离不大于  distanceThreshold 的城镇。</li><li>统计每个城镇，其满足条件的城镇有多少个</li><li>我们找出最少的即可</li></ol><p>Floyd-Warshall 算法的时间复杂度和空间复杂度都是$O(N^3)$, 而空间复杂度可以优化到$O(N^2)$。Floyd-Warshall 的基本思想是对于每两个点之间的最小距离，要么经过中间节点 k，要么不经过，我们取两者的最小值，这是一种动态规划思想，详细的解法可以参考<a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">Floyd-Warshall 算法(wikipedia)</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码支持：Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheCity</span><span class="params">(self, n: int, edges: List[List[int]], distanceThreshold: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 构建dist矩阵</span></span><br><span class="line">        dist = [[float(<span class="string">'inf'</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span>  range(n)]</span><br><span class="line">        <span class="keyword">for</span> i, j, w <span class="keyword">in</span> edges:</span><br><span class="line">            dist[i][j] = w</span><br><span class="line">            dist[j][i] = w</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dist[i][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 过滤</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        minCnt = float(<span class="string">'inf'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> dist[i]:</span><br><span class="line">                <span class="keyword">if</span> d &lt;= distanceThreshold:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt &lt;= minCnt:</span><br><span class="line">                minCnt = cnt</span><br><span class="line">                res = i</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>Floyd-Warshall 算法</li><li>你可以将本文给的 Floyd-Warshall 算法当成一种解题模板使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 图 </category>
          
          <category> 解题模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 解题模板 </tag>
            
            <tag> 图 </tag>
            
            <tag> Floyd-Warshall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 1332. 删除回文子序列</title>
      <link href="/blog/2020/02/01/1332.remove-palindromic-subsequences/"/>
      <url>/blog/2020/02/01/1332.remove-palindromic-subsequences/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 上有很多抖机灵的题目，需要你仔细审题，否则很容易被套路。这里就有一道，我们来看下。</p><p>​<a id="more"></a></p><p>原题地址：<a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-palindromic-subsequences/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><figcaption><span>s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">返回删除给定字符串中所有字符（字符串为空）的最小删除次数。</span><br><span class="line"></span><br><span class="line">「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。</span><br><span class="line"></span><br><span class="line">「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;ababa&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：字符串本身就是回文序列，只需要删除一次。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;abb&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：&quot;abb&quot; -&gt; &quot;bb&quot; -&gt; &quot;&quot;.</span><br><span class="line">先删除回文子序列 &quot;a&quot;，然后再删除 &quot;bb&quot;。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;baabb&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：&quot;baabb&quot; -&gt; &quot;b&quot; -&gt; &quot;&quot;.</span><br><span class="line">先删除回文子序列 &quot;baab&quot;，然后再删除 &quot;b&quot;。</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;&quot;</span><br><span class="line">输出：0</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;= s.length &lt;= 1000</span><br><span class="line">s 仅包含字母 &apos;a&apos;  和 &apos;b&apos;</span><br><span class="line">在真实的面试中遇到过这道题？</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这又是一道“抖机灵”的题目，类似的题目有<a href="https://github.com/azl397985856/leetcode/blob/77db8fa47c7ee0a14b320f7c2d22f7c61ae53c35/problems/1297.maximum-number-of-occurrences-of-a-substring.md" target="_blank" rel="noopener">1297.maximum-number-of-occurrences-of-a-substring</a></p><p>由于只有 a 和 b 两个字符。其实最多的消除次数就是 2。因为我们无论如何都可以先消除全部的 1 再消除全部的 2（先消除 2 也一样），这样只需要两次即可完成。 我们再看一下题目给的一次消除的情况，题目给的例子是“ababa”，我们发现其实它本身就是一个回文串，所以才可以一次全部消除。那么思路就有了：</p><ul><li>如果 s 是回文，则我们需要一次消除</li><li>否则需要两次</li><li>一定要注意特殊情况， 对于空字符串，我们需要 0 次</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码支持：Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removePalindromeSub</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(s)</span>:</span></span><br><span class="line">            l = <span class="number">0</span></span><br><span class="line">            r = len(s) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                <span class="keyword">if</span> s[l] != s[r]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> isPalindrome(s) <span class="keyword">else</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>如果你觉得判断回文不是本题重点，也可以简单实现：</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removePalindromeSub</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> s == <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> s == s[::<span class="number">-1</span>] <span class="keyword">else</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>注意审题目，一定要利用题目条件“只含有 a 和 b 两个字符”否则容易做的很麻烦</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 字符串 </category>
          
          <category> 回文 </category>
          
          <category> Easy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 335. 路径交叉</title>
      <link href="/blog/2020/01/31/335.self-crossing/"/>
      <url>/blog/2020/01/31/335.self-crossing/</url>
      
        <content type="html"><![CDATA[<p>这是一道 Hard 难度的题目，题目的难点在于我们不可以使用额外的空间完成。让我们来看下怎么做吧。</p><p>​<a id="more"></a></p><p>原题地址：<a href="https://leetcode-cn.com/problems/self-crossing/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/self-crossing/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">给定一个含有 n 个正数的数组 x。从点 (0,0) 开始，先向北移动 x[0] 米，然后向西移动 x[1] 米，向南移动 x[2] 米，向东移动 x[3] 米，持续移动。也就是说，每次移动后你的方位会发生逆时针变化。</span><br><span class="line"></span><br><span class="line">编写一个 O(1) 空间复杂度的一趟扫描算法，判断你所经过的路径是否相交。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">┌───┐</span><br><span class="line">│   │</span><br><span class="line">└───┼──&gt;</span><br><span class="line">    │</span><br><span class="line"></span><br><span class="line">输入: [2,1,1,2]</span><br><span class="line">输出: true</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">┌──────┐</span><br><span class="line">│      │</span><br><span class="line">│</span><br><span class="line">│</span><br><span class="line">└────────────&gt;</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">┌───┐</span><br><span class="line">│   │</span><br><span class="line">└───┼&gt;</span><br><span class="line"></span><br><span class="line">输入: [1,1,1,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>符合直觉的做法是$O(N)$时间和空间复杂度的算法。这种算法非常简单，但是题目要求我们使用空间复杂度为$O(1)$的做法。</p><p>关于空间复杂度为$O(N)$的算法可以参考我之前的<a href="https://github.com/azl397985856/leetcode/blob/be15d243a3b93d7efa731d0589a54a63cbff61ae/problems/874.walking-robot-simulation.md" target="_blank" rel="noopener">874.walking-robot-simulation</a>。 思路基本是类似，只不过 obstacles（障碍物）不是固定的，而是我们不断遍历的时候动态生成的，我们每遇到一个点，就将其标记为 obstacle。随着算法的进行，我们的 obstacles 逐渐增大，最终和 N 一个量级。</p><p>我们考虑进行优化。我们仔细观察发现，如果想让其不相交，从大的范围来看只有两种情况：</p><ol><li>我们画的圈不断增大。</li><li>我们画的圈不断减少。</li></ol><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbepb3y3uwj30te1dagn5.jpg" alt><br>（有没有感觉像迷宫？）</p><p>这样我们会发现，其实我们画最新一笔的时候，并不是之前画的所有的都需要考虑，我们只需要最近的几个就可以了，实际上是最近的五个，不过不知道也没关系，我们稍后会讲解。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbepcb2ojwj30to0lamxm.jpg" alt></p><p>红色部分指的是我们需要考虑的，而剩余没有被红色标注的部分则无需考虑。不是因为我们无法与之相交，而是我们<code>一旦与之相交，则必然我们也一定会与红色标记部分相交</code>。</p><p>然而我们画的方向也是不用考虑的。比如我当前画的方向是从左到右，那和我画的方向是从上到下有区别么？在这里是没区别的，不信我帮你将上图顺时针旋转 90 度看一下：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbepgmzlopj30mk1cwwfn.jpg" alt></p><p>方向对于我们考虑是否相交没有差别。</p><p>当我们仔细思考的时候，会发现其实相交的情况只有以下几种：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbepi1aegtj30ro0o6aat.jpg" alt></p><p>这个时候代码就呼之欲出了。</p><ul><li>我们只需要遍历数组 x，假设当前是第 i 个元素。</li><li>如果 x[i] &gt;= x[i - 2] and x[i - 1] &lt;= x[i - 3]，则相交（第一种情况）</li><li>如果 x[i - 1] &lt;= x[i - 3] and x[i - 2] &lt;= x[i]，则相交（第二种情况）</li><li>如果 i &gt; 3 and x[i - 1] == x[i - 3] and x[i] + x[i - 4] == x[i - 2]，则相交（第三种情况）</li><li>如果 i &gt; 4 and x[i] + x[i - 4] &gt;= x[i - 2] and x[i - 1] &gt;= x[i - 3] - x[i - 5] <br> and x[i - 1] &lt;= x[i - 3] and x[i - 2] &gt;= x[i - 4] and x[i - 3] &gt;= x[i - 5] ，则相交（第四种情况）</li><li>否则不相交</li></ul><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>一定要画图辅助</li><li>对于这种$O(1)$空间复杂度有固定的套路。常见的有：</li></ul><ol><li>直接修改原数组</li><li>滑动窗口（当前状态并不是和之前所有状态有关，而是仅和某几个有关）。</li></ol><p>我们采用的是滑动窗口。但是难点就在于我们怎么知道当前状态和哪几个有关。对于这道题来说，画图或许可以帮助你打开思路。另外面试的时候说出$O(N)$的思路也不失为一个帮助你冷静分析问题的手段。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码支持：Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSelfCrossing</span><span class="params">(self, x: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n = len(x)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n):</span><br><span class="line">            <span class="keyword">if</span> x[i] &gt;= x[i - <span class="number">2</span>] <span class="keyword">and</span> x[i - <span class="number">1</span>] &lt;= x[i - <span class="number">3</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> x[i - <span class="number">1</span>] &lt;= x[i - <span class="number">3</span>] <span class="keyword">and</span> x[i - <span class="number">2</span>] &lt;= x[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">3</span> <span class="keyword">and</span> x[i - <span class="number">1</span>] == x[i - <span class="number">3</span>] <span class="keyword">and</span> x[i] + x[i - <span class="number">4</span>] == x[i - <span class="number">2</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">4</span> <span class="keyword">and</span> x[i] + x[i - <span class="number">4</span>] &gt;= x[i - <span class="number">2</span>] <span class="keyword">and</span> x[i - <span class="number">1</span>] &gt;= x[i - <span class="number">3</span>] - x[i - <span class="number">5</span>] \</span><br><span class="line">                    <span class="keyword">and</span> x[i - <span class="number">1</span>] &lt;= x[i - <span class="number">3</span>] <span class="keyword">and</span> x[i - <span class="number">2</span>] &gt;= x[i - <span class="number">4</span>] <span class="keyword">and</span> x[i - <span class="number">3</span>] &gt;= x[i - <span class="number">5</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> hashtable </category>
          
          <category> 就地算法 </category>
          
          <category> Hard </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 50. Pow(x, n)</title>
      <link href="/blog/2020/01/29/50.powx-n/"/>
      <url>/blog/2020/01/29/50.powx-n/</url>
      
        <content type="html"><![CDATA[<p>这是一道让我们实现系统函数的造轮子题目，我们来看下。</p><p>​<a id="more"></a></p><p>原题地址：<a href="https://leetcode-cn.com/problems/powx-n/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/powx-n/description/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">实现 pow(x, n) ，即计算 x 的 n 次幂函数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 = 1/22 = 1/4 = 0.25</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</span><br></pre></td></tr></table></figure><h2 id="解法零-遍历法"><a href="#解法零-遍历法" class="headerlink" title="解法零 - 遍历法"></a>解法零 - 遍历法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题是让我们实现数学函数<code>幂</code>，因此直接调用系统内置函数是不被允许的。</p><p>符合直觉的做法是<code>将x乘以n次</code>，这种做法的时间复杂度是$O(N)$。</p><p>经实际测试，这种做法果然超时了。测试用例通过 291/304，在 <code>0.00001\n2147483647</code>这个测试用例挂掉了。如果是面试，这个解法可以作为一种兜底解法。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>语言支持: Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">            res *= x</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="解法一-普通递归（超时法）"><a href="#解法一-普通递归（超时法）" class="headerlink" title="解法一 - 普通递归（超时法）"></a>解法一 - 普通递归（超时法）</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>首先我们要知道：</p><ul><li>如果想要求 x ^ 4，那么我们可以求 (x^2)^2</li><li>如果是奇数，会有一点不同。 比如 x ^ 5 就等价于 x * (x^2)^2。</li></ul><blockquote><p>当然 x ^ 5 可以等价于 (x ^ 2) ^ 2.5, 但是这不相当于直接调用了幂函数了么。对于整数，我们可以很方便的模拟，但是小数就不方便了。</p></blockquote><p>我们的思路就是：</p><ul><li>将 n 地板除 2，我们不妨设结果为 a</li><li>那么 myPow(x, n) 就等价于 <code>myPow(x, a) * myPow(x, n - a)</code></li></ul><p>很可惜这种算法也会超时，原因在于重复计算会比较多，你可以试一下缓存一下计算看能不能通过。</p><blockquote><p>如果你搞不清楚有哪些重复计算，建议画图理解一下。</p></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>语言支持: Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">        <span class="keyword">return</span> self.myPow(x, n // <span class="number">2</span>) * self.myPow(x, n - n // <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="解法二-优化递归"><a href="#解法二-优化递归" class="headerlink" title="解法二 - 优化递归"></a>解法二 - 优化递归</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>上面的解法每次直接 myPow 都会调用两次自己。我们不从缓存计算角度，而是从减少这种调用的角度来优化。</p><p>我们考虑 myPow 只调用一次自身可以么？ 没错，是可以的。</p><p>我们的思路就是：</p><ul><li>如果 n 是偶数，我们将 n 折半，底数变为 x^2</li><li>如果 n 是奇数， 我们将 n 减去 1 ，底数不变，得到的结果再乘上底数 x</li></ul><p>这样终于可以 AC。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>语言支持: Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">        <span class="keyword">return</span> self.myPow(x _ x, n // <span class="number">2</span>) <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> x _ self.myPow(x, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="解法三-位运算"><a href="#解法三-位运算" class="headerlink" title="解法三 - 位运算"></a>解法三 - 位运算</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们来从位（bit）的角度来看一下这道题。如果你经常看我的题解和文章的话，可能知道我之前写过几次相关的“从位的角度思考分治法”，比如 LeetCode <a href="https://leetcode-cn.com/problems/poor-pigs/description/" target="_blank" rel="noopener">458.可怜的小猪</a>。</p><p>以 x 的 10 次方举例。10 的 2 进制是 1010，然后用 2 进制转 10 进制的方法把它展成 2 的幂次的和。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbdseolzbmj30t802mjrk.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbdssrrsh6j30xp0u040e.jpg" alt></p><p>因此我们的算法就是：</p><ul><li>不断的求解 x 的 2^0 次方，x 的 2^1 次方，x 的 2^2 次方等等。</li><li>将 n 转化为二进制表示</li><li>将 n 的二进制表示中<code>1的位置</code>pick 出来。比如 n 的第 i 位为 1，那么就将 x^i pick 出来。</li><li>将 pick 出来的结果相乘</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbdtiky90rj30vq0hcab4.jpg" alt></p><p>这里有两个问题：</p><p>第一个问题是<code>似乎我们需要存储 x^i 以便后续相乘的时候用到</code>。实际上，我们并不需要这么做。我们可以采取一次遍历的方式来完成，具体看代码。</p><p>第二个问题是，如果我们从低位到高位计算的时候，我们如何判断最高位置是否为 1？我们需要一个 bitmask 来完成，这种算法我们甚至需要借助一个额外的变量。 然而我们可以 hack 一下，直接从高位到低位进行计算，这个时候我们只需要判断最后一位是否为 1 就可以了，这个就简单了，我们直接和 1 进行一次<code>与运算</code>即可。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>语言支持: Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.myPow(x, -n)</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span> == <span class="number">1</span>:</span><br><span class="line">                res *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>超时分析</li><li>hashtable</li><li>数学分析</li><li>位运算</li><li>二进制转十进制</li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode-cn.com/problems/poor-pigs/description/" target="_blank" rel="noopener">458.可怜的小猪</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbdrfn9n2wj30wn0u0dp2.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 数学 </category>
          
          <category> hashtable </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode日记】 874. 模拟行走机器人</title>
      <link href="/blog/2020/01/29/874.walking-robot-simulation/"/>
      <url>/blog/2020/01/29/874.walking-robot-simulation/</url>
      
        <content type="html"><![CDATA[<p>这是一道 LeetCode 难度为 easy 的题目，没有高深的算法，有的只是套路，我们来看下。</p><p>​<a id="more"></a></p><p>原题地址：<a href="https://leetcode-cn.com/problems/walking-robot-simulation/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/walking-robot-simulation/submissions/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：</span><br><span class="line"></span><br><span class="line">-2：向左转 90 度</span><br><span class="line">-1：向右转 90 度</span><br><span class="line">1 &lt;= x &lt;= 9：向前移动 x 个单位长度</span><br><span class="line">在网格上有一些格子被视为障碍物。</span><br><span class="line"></span><br><span class="line">第 i 个障碍物位于网格点  (obstacles[i][0], obstacles[i][1])</span><br><span class="line"></span><br><span class="line">如果机器人试图走到障碍物上方，那么它将停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。</span><br><span class="line"></span><br><span class="line">返回从原点到机器人的最大欧式距离的平方。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: commands = [4,-1,3], obstacles = []</span><br><span class="line">输出: 25</span><br><span class="line">解释: 机器人将会到达 (3, 4)</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]</span><br><span class="line">输出: 65</span><br><span class="line">解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">0 &lt;= commands.length &lt;= 10000</span><br><span class="line">0 &lt;= obstacles.length &lt;= 10000</span><br><span class="line">-30000 &lt;= obstacle[i][0] &lt;= 30000</span><br><span class="line">-30000 &lt;= obstacle[i][1] &lt;= 30000</span><br><span class="line">答案保证小于 2 ^ 31</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题之所以是简单难度，是因为其没有什么技巧。你只需要看懂题目描述，然后把题目描述转化为代码即可。</p><p>唯一需要注意的是查找障碍物的时候如果你采用的是<code>线形查找</code>会很慢，很可能会超时。</p><blockquote><p>我实际测试了一下，确实会超时</p></blockquote><ul><li>一种方式是使用排序，然后二分查找，如果采用基于比较的排序算法，那么这种算法的瓶颈在于排序本身，也就是$O(NlogN)$。</li><li>另一种方式是使用集合，将 obstacles 放入集合，然后需要的时候进行查询，查询的时候的时间复杂度为$O(1)$。</li></ul><p>这里我们采用第二种方式。</p><p>接下来我们来“翻译”一下题目。</p><ul><li>由于机器人只能往前走。因此机器人往东西南北哪个方向走取决于它的<code>朝向</code>。</li><li>我们使用枚举来表示当前机器人的<code>朝向</code>。</li><li>题目只有两种方式改变<code>朝向</code>，一种是左转（-2），另一种是右转（-1）。</li><li>题目要求的是机器人在<code>运动过程中距离原点的最大值</code>，而不是最终位置距离原点的距离。</li></ul><p>为了代码书写简单，我建立了一个直角坐标系。用<code>机器人的朝向和 x 轴正方向的夹角度数</code>来作为枚举值，并且这个度数是 <code>0 &lt;= deg &lt; 360</code>。我们不难知道，其实这个取值就是<code>0</code>, <code>90</code>,<code>180</code>,<code>270</code> 四个值。那么当 0 度的时候，我们只需要不断地 x+1，90 度的时候我们不断地 y + 1 等等。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbdnsywx97j31020r8gmt.jpg" alt></p><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>理解题意，这道题容易理解错题意，求解为<code>最终位置距离原点的距离</code></li><li>建立坐标系</li><li>使用集合简化线形查找的时间复杂度。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码支持： Python3</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">robotSim</span><span class="params">(self, commands: List[int], obstacles: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        pos = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        deg = <span class="number">90</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        obstaclesSet = set(map(tuple, obstacles))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> command <span class="keyword">in</span> commands:</span><br><span class="line">            <span class="keyword">if</span> command == <span class="number">-1</span>:</span><br><span class="line">                deg = (deg + <span class="number">270</span>) % <span class="number">360</span></span><br><span class="line">            <span class="keyword">elif</span> command == <span class="number">-2</span>:</span><br><span class="line">                deg = (deg + <span class="number">90</span>) % <span class="number">360</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> deg == <span class="number">0</span>:</span><br><span class="line">                    i = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; command <span class="keyword">and</span> <span class="keyword">not</span> (pos[<span class="number">0</span>] + <span class="number">1</span>, pos[<span class="number">1</span>]) <span class="keyword">in</span> obstaclesSet:</span><br><span class="line">                        pos[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> deg == <span class="number">90</span>:</span><br><span class="line">                    i = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; command <span class="keyword">and</span> <span class="keyword">not</span> (pos[<span class="number">0</span>], pos[<span class="number">1</span>] + <span class="number">1</span>) <span class="keyword">in</span> obstaclesSet:</span><br><span class="line">                        pos[<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> deg == <span class="number">180</span>:</span><br><span class="line">                    i = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; command <span class="keyword">and</span> <span class="keyword">not</span> (pos[<span class="number">0</span>] - <span class="number">1</span>, pos[<span class="number">1</span>]) <span class="keyword">in</span> obstaclesSet:</span><br><span class="line">                        pos[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> deg == <span class="number">270</span>:</span><br><span class="line">                    i = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> i &lt; command <span class="keyword">and</span> <span class="keyword">not</span> (pos[<span class="number">0</span>], pos[<span class="number">1</span>] - <span class="number">1</span>) <span class="keyword">in</span> obstaclesSet:</span><br><span class="line">                        pos[<span class="number">1</span>] -= <span class="number">1</span></span><br><span class="line">                        i += <span class="number">1</span></span><br><span class="line">                ans = max(ans, pos[<span class="number">0</span>] ** <span class="number">2</span> + pos[<span class="number">1</span>] ** <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> hashtable </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一行代码就可以通过 LeetCode？来看下我是怎么做到的！</title>
      <link href="/blog/2020/01/18/1227.airplane-seat-assignment-probability/"/>
      <url>/blog/2020/01/18/1227.airplane-seat-assignment-probability/</url>
      
        <content type="html"><![CDATA[<p>这是一道 LeetCode 为数不多的概率题，我们来看下。</p><p>​<a id="more"></a></p><p>原题地址：<a href="https://leetcode-cn.com/problems/airplane-seat-assignment-probability/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/airplane-seat-assignment-probability/description/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</span><br><span class="line"></span><br><span class="line">剩下的乘客将会：</span><br><span class="line"></span><br><span class="line">如果他们自己的座位还空着，就坐到自己的座位上，</span><br><span class="line"></span><br><span class="line">当他们自己的座位被占用时，随机选择其他座位</span><br><span class="line">第 n 位乘客坐在自己的座位上的概率是多少？</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：n = 1</span><br><span class="line">输出：1.00000</span><br><span class="line">解释：第一个人只会坐在自己的位置上。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: n = 2</span><br><span class="line">输出: 0.50000</span><br><span class="line">解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= n &lt;= 10^5</span><br></pre></td></tr></table></figure><h2 id="暴力递归"><a href="#暴力递归" class="headerlink" title="暴力递归"></a>暴力递归</h2><p>这是一道 LeetCode 为数不多的概率题，我们来看下。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们定义原问题为 f(n)。对于第一个人来说，他有 n 中选择，就是分别选择 n 个座位中的一个。由于选择每个位置的概率是相同的，那么选择每个位置的概率应该都是 1 / n。</p><p>我们分三种情况来讨论：</p><ul><li>如果第一个人选择了第一个人的位置（也就是选择了自己的位置），那么剩下的人按照票上的座位做就好了，这种情况第 n 个人一定能做到自己的位置</li><li>如果第一个人选择了第 n 个人的位置，那么第 n 个人肯定坐不到自己的位置。</li><li>如果第一个人选择了第 i (1 &lt; i &lt; n)个人的位置，那么第 i 个人就相当于变成了“票丢的人”，此时问题转化为 f(n - i + 1)。</li></ul><p>此时的问题转化关系如图：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gb12n0omuuj31bc0ju405.jpg" alt><br>（红色表示票丢的人）</p><p>整个过程分析：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gb12nhestaj318u0bg76f.jpg" alt></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">        res = <span class="number">1</span> / n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            res += self.nthPersonGetsNthSeat(n - i + <span class="number">1</span>) * <span class="number">1</span> / n</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>上述代码会栈溢出。</p><h2 id="暴力递归-hashtable"><a href="#暴力递归-hashtable" class="headerlink" title="暴力递归 + hashtable"></a>暴力递归 + hashtable</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们考虑使用记忆化递归来减少重复计算，虽然这种做法可以减少运行时间，但是对减少递归深度没有帮助。还是会栈溢出。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    seen = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> self.seen:</span><br><span class="line">            <span class="keyword">return</span> self.seen[n]</span><br><span class="line">        res = <span class="number">1</span> / n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            res += self.nthPersonGetsNthSeat(n - i + <span class="number">1</span>) * <span class="number">1</span> / n</span><br><span class="line">        self.seen[n] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>上面做法会栈溢出。其实我们根本不需要运行就应该能判断出栈溢出，题目已经给了数据规模是 1 &lt;= n &lt;= 10 ** 5。 这个量级不管什么语言，除非使用尾递归，不然一般都会栈溢出，具体栈深度大家可以查阅相关资料。</p><p>既然是栈溢出，那么我们考虑使用迭代来完成。 很容易想到使用动态规划来完成。其实递归都写出来，写一个朴素版的动态规划也难不到哪去，毕竟动态规划就是记录子问题，并建立子问题之间映射而已，这和递归并无本质区别。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span>, <span class="number">.5</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = <span class="number">1</span> / n</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>, i):</span><br><span class="line">                dp[i] += dp[i - j + <span class="number">1</span>] * <span class="number">1</span> / n</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><p>这种思路的代码超时了，并且仅仅执行了 35/100 testcase 就超时了。</p><h2 id="数学分析"><a href="#数学分析" class="headerlink" title="数学分析"></a>数学分析</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们还需要进一步优化时间复杂度，我们需要思考是否可以在线性的时间内完成。</p><p>我们继续前面的思路进行分析, 不难得出，我们不妨称其为等式 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n)</span><br><span class="line">= 1/n + 0 + 1/n * (f(n-1) + f(n-2) + ... + f(2))</span><br><span class="line">= 1/n * (f(n-1) + f(n-2) + ... + f(2) + 1)</span><br><span class="line">= 1/n * (f(n-1) + f(n-2) + ... + f(2) + f(1))</span><br></pre></td></tr></table></figure><p>似乎更复杂了？没关系，我们继续往下看，我们看下 f(n - 1)，我们不妨称其为等式 2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n-1) = 1/(n-1) * (f(n-2) + f(n-3) + ... + f(1))</span><br></pre></td></tr></table></figure><p>我们将等式 1 和等式 2 两边分别同时乘以 n 和 n - 1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n * f(n) = f(n-1) + f(n-2) + f(n-3) + ... + f(1)</span><br><span class="line">(n-1) * f(n-1) = f(n-2) + f(n-3) + ... + f(1)</span><br></pre></td></tr></table></figure><p>我们将两者相减：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n * f(n) - (n-1)*f(n-1) = f(n-1)</span><br></pre></td></tr></table></figure><p>我们继续将 (n-1)*f(n-1) 移到等式右边，得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n * f(n) = n * f(n-1)</span><br></pre></td></tr></table></figure><p>也就是说:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n - 1)</span><br></pre></td></tr></table></figure><p>当然前提是 n 大于 2。</p><p>既然如此，我们就可以减少一层循环， 我们用这个思路来优化一下上面的 dp 解法。这种解法终于可以 AC 了。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">        dp = [<span class="number">1</span>, <span class="number">.5</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            dp[i] = <span class="number">1</span>/n+(n<span class="number">-2</span>)/n * dp[n<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="优化数学分析"><a href="#优化数学分析" class="headerlink" title="优化数学分析"></a>优化数学分析</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>上面我们通过数学分析，得出了当 n 大于 2 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n - 1)</span><br></pre></td></tr></table></figure><p>那么是不是意味着我们随便求出一个 n 就好了？ 比如我们求出 n = 2 的时候的值，是不是就知道 n 为任意数的值了。 我们不难想出 n = 2 时候，概率是 0.5，因此只要 n 大于 1 就是 0.5 概率，否则就是 1 概率。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3:</p><p>Python3 Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthPersonGetsNthSeat</span><span class="params">(self, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">else</span> <span class="number">.5</span></span><br></pre></td></tr></table></figure><h2 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h2><ul><li>概率分析</li><li>数学推导</li><li>动态规划</li><li>递归 + mapper</li><li>栈限制大小</li><li>尾递归</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
          <category> 概率 </category>
          
          <category> 动态规划 </category>
          
          <category> 递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 概率 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原来状态机也可以用来刷 LeetCode？</title>
      <link href="/blog/2020/01/12/1262.greatest-sum-divisible-by-three/"/>
      <url>/blog/2020/01/12/1262.greatest-sum-divisible-by-three/</url>
      
        <content type="html"><![CDATA[<p>什么？ 状态机还可以用来刷 LeetCode？ 如果你还不知道，那么就快进来看看吧！</p><a id="more"></a><p>题目地址： <a href="https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/description/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,6,5,1,8]</span><br><span class="line">输出：18</span><br><span class="line">解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [4]</span><br><span class="line">输出：0</span><br><span class="line">解释：4 不能被 3 整除，所以无法选出数字，返回 0。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [1,2,3,4,4]</span><br><span class="line">输出：12</span><br><span class="line">解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= nums.length &lt;= 4 * 10^4</span><br><span class="line">1 &lt;= nums[i] &lt;= 10^4</span><br></pre></td></tr></table></figure><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一种方式是找出所有的能够被 3 整除的子集，然后挑选出和最大的。由于我们选出了所有的子集，那么时间复杂度就是 $O(2^N)$ ， 毫无疑问会超时。这里我们使用回溯法找子集，如果不清楚回溯法，可以参考我之前的题解，很多题目都用到了，比如<a href="https://github.com/azl397985856/leetcode/blob/master/problems/78.subsets.md" target="_blank" rel="noopener">78.subsets</a>。</p><p>更多回溯题目，可以访问上方链接查看（可以使用一套模板搞定）：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gatuu0yfh8j30f60c4ab3.jpg" alt></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(temp, start)</span>:</span></span><br><span class="line">            total = sum(temp)</span><br><span class="line">            <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                self.res = max(self.res, total)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">                temp.append(nums[i])</span><br><span class="line">                backtrack(temp, i + <span class="number">1</span>)</span><br><span class="line">                temp.pop(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        backtrack([], <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h2 id="减法-排序"><a href="#减法-排序" class="headerlink" title="减法 + 排序"></a>减法 + 排序</h2><p>减法的核心思想是，我们求出总和。如果总和不满足题意，我们尝试减去最小的数，使之满足题意。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这种算法的思想，具体来说就是：</p><ul><li>我们将所有的数字加起来，我们不妨设为 total</li><li>total 除以 3，得到一个余数 mod， mod 可能值有 0，1，2.</li><li>同时我们建立两个数组，一个是余数为 1 的数组 one，一个是余数为 2 的数组 two</li><li>如果 mod 为 0，我们直接返回即可。</li><li>如果 mod 为 1，我们可以减去 one 数组中最小的一个（如果有的话），或者减去两个 two 数组中最小的（如果有的话），究竟减去谁取决谁更小。</li><li>如果 mod 为 2，我们可以减去 two 数组中最小的一个（如果有的话），或者减去两个 one 数组中最小的（如果有的话），究竟减去谁取决谁更小。</li></ul><p>由于我们需要取 one 和 two 中最小的一个或者两个，因此对数组 one 和 two 进行排序是可行的，如果基于排序的话，时间复杂度大致为 $O(NlogN)$，这种算法可以通过。</p><p>以题目中的例 1 为例：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gatvdy1zb1j30u00x2wgx.jpg" alt></p><p>以题目中的例 2 为例：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gatvem1xm4j30u00xvq59.jpg" alt></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        one = []</span><br><span class="line">        two = []</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            total += num</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">                one.append(num)</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">                two.append(num)</span><br><span class="line">        one.sort()</span><br><span class="line">        two.sort()</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> total</span><br><span class="line">        <span class="keyword">elif</span> total % <span class="number">3</span> == <span class="number">1</span> <span class="keyword">and</span> one:</span><br><span class="line">            <span class="keyword">if</span> len(two) &gt;= <span class="number">2</span> <span class="keyword">and</span> one[<span class="number">0</span>] &gt; two[<span class="number">0</span>] + two[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> total - two[<span class="number">0</span>] - two[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> total - one[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> total % <span class="number">3</span> == <span class="number">2</span> <span class="keyword">and</span> two:</span><br><span class="line">            <span class="keyword">if</span> len(one) &gt;= <span class="number">2</span> <span class="keyword">and</span> two[<span class="number">0</span>] &gt; one[<span class="number">0</span>] + one[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> total - one[<span class="number">0</span>] - one[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> total - two[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="减法-非排序"><a href="#减法-非排序" class="headerlink" title="减法 + 非排序"></a>减法 + 非排序</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>上面的解法使用到了排序。 我们其实观察发现，我们只是用到了 one 和 two 的最小的两个数。因此我们完全可以在线形的时间和常数的空间完成这个算法。我们只需要分别记录 one 和 two 的最小值和次小值即可，在这里，我使用了两个长度为 2 的数组来表示，第一项是最小值，第二项是次小值。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        one = [float(<span class="string">'inf'</span>)] * <span class="number">2</span></span><br><span class="line">        two = [float(<span class="string">'inf'</span>)] * <span class="number">2</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            total += num</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> num &lt; one[<span class="number">0</span>]:</span><br><span class="line">                    t = one[<span class="number">0</span>]</span><br><span class="line">                    one[<span class="number">0</span>] = num</span><br><span class="line">                    one[<span class="number">1</span>] = t</span><br><span class="line">                <span class="keyword">elif</span> num &lt; one[<span class="number">1</span>]:</span><br><span class="line">                    one[<span class="number">1</span>] = num</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> num &lt; two[<span class="number">0</span>]:</span><br><span class="line">                    t = two[<span class="number">0</span>]</span><br><span class="line">                    two[<span class="number">0</span>] = num</span><br><span class="line">                    two[<span class="number">1</span>] = t</span><br><span class="line">                <span class="keyword">elif</span> num &lt; two[<span class="number">1</span>]:</span><br><span class="line">                    two[<span class="number">1</span>] = num</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> total</span><br><span class="line">        <span class="keyword">elif</span> total % <span class="number">3</span> == <span class="number">1</span> <span class="keyword">and</span> one:</span><br><span class="line">            <span class="keyword">if</span> len(two) &gt;= <span class="number">2</span> <span class="keyword">and</span> one[<span class="number">0</span>] &gt; two[<span class="number">0</span>] + two[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> total - two[<span class="number">0</span>] - two[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> total - one[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">elif</span> total % <span class="number">3</span> == <span class="number">2</span> <span class="keyword">and</span> two:</span><br><span class="line">            <span class="keyword">if</span> len(one) &gt;= <span class="number">2</span> <span class="keyword">and</span> two[<span class="number">0</span>] &gt; one[<span class="number">0</span>] + one[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> total - one[<span class="number">0</span>] - one[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">return</span> total - two[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我在<a href="https://lucifer.ren/blog/2019/09/19/algorthimn-fe-2/">数据结构与算法在前端领域的应用 - 第二篇</a> 中讲到了有限状态机。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gatub3vftxj30eq0bfta0.jpg" alt></p><p>状态机表示若干个状态以及在这些状态之间的转移和动作等行为的数学模型。通俗的描述状态机就是定义了一套状态変更的流程：状态机包含一个状态集合，定义当状态机处于某一个状态的时候它所能接收的事件以及可执行的行为，执行完成后，状态机所处的状态。</p><p>状态机使用非常广泛，比如正则表达式的引擎，编译器的词法和语法分析，网络协议，企业应用等很多领域都会用到。</p><p>拿本题中来说，我们从左到右扫描数组的过程，将会不断改变状态机的状态。</p><p>我们使用 state 数组来表示本题的状态：</p><ul><li>state[0] 表示 mod 为 0 的 最大和</li><li>state[1] 表示 mod 为 1 的 最大和</li><li>state[2] 表示 mod 为 1 的 最大和</li></ul><p>我们的状态转移方程就会很容易。说到状态转移方程，你可能会想到动态规划。没错！这种思路可以直接翻译成动态规划，算法完全一样。如果你看过我上面提到的文章，那么状态转移方程对你来说就会很容易。如果你不清楚，那么请往下看：</p><ul><li>我们从左往右不断读取数字，我们不妨设这个数字为 num。</li><li>如果 num % 3 为 0。 那么我们的 state[0], state[1], state[2] 可以直接加上 num（题目限定了 num 为非负）， 因为任何数字加上 3 的倍数之后，mod 3 的值是不变的。</li><li>如果 num % 3 为 1。 我们知道 state[2] + num 会变成一个能被三整除的数，但是这个数字不一定比当前的 state[0]大。 代码表示就是<code>max(state[2] + num, state[0])</code>。同理 state[1] 和 state[2] 的转移逻辑类似。</li><li>同理 num % 3 为 2 也是类似的逻辑。</li><li>最后我们返回 state[0]即可。</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        state = [<span class="number">0</span>, float(<span class="string">'-inf'</span>), float(<span class="string">'-inf'</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                state = [state[<span class="number">0</span>] + num, state[<span class="number">1</span>] + num, state[<span class="number">2</span>] + num]</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">1</span>:</span><br><span class="line">                a = max(state[<span class="number">2</span>] + num, state[<span class="number">0</span>])</span><br><span class="line">                b = max(state[<span class="number">0</span>] + num, state[<span class="number">1</span>])</span><br><span class="line">                c = max(state[<span class="number">1</span>] + num, state[<span class="number">2</span>])</span><br><span class="line">                state = [a, b, c]</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">2</span>:</span><br><span class="line">                a = max(state[<span class="number">1</span>] + num, state[<span class="number">0</span>])</span><br><span class="line">                b = max(state[<span class="number">2</span>] + num, state[<span class="number">1</span>])</span><br><span class="line">                c = max(state[<span class="number">0</span>] + num, state[<span class="number">2</span>])</span><br><span class="line">                state = [a, b, c]</span><br><span class="line">        <span class="keyword">return</span> state[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>当然这个代码还可以简化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumDivThree</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        state = [<span class="number">0</span>, float(<span class="string">'-inf'</span>), float(<span class="string">'-inf'</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            temp = [<span class="number">0</span>] * <span class="number">3</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                temp[(i + num) % <span class="number">3</span>] = max(state[(i + num) % <span class="number">3</span>], state[i] + num)</span><br><span class="line">            state = temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> state[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>贪婪法</li><li>状态机</li><li>数学分析</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>实际上，我们可以采取加法（贪婪策略），感兴趣的可以试一下。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 状态机 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode一道令人发指的陷阱题</title>
      <link href="/blog/2020/01/10/1297.maximum-number-of-occurrences-of-a-substring/"/>
      <url>/blog/2020/01/10/1297.maximum-number-of-occurrences-of-a-substring/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 有一些题目会给你设置陷阱，给你一些干扰信息。这个时候你需要小心，不要被他们带跑偏了。那么是什么样的陷阱呢？让我们来看一下！</p><a id="more"></a><h1 id="题目地址（1297-子串的最大出现次数）"><a href="#题目地址（1297-子串的最大出现次数）" class="headerlink" title="题目地址（1297. 子串的最大出现次数）"></a>题目地址（1297. 子串的最大出现次数）</h1><p><a href="https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：</span><br><span class="line"></span><br><span class="line">子串中不同字母的数目必须小于等于 maxLetters 。</span><br><span class="line">子串的长度必须大于等于 minSize 且小于等于 maxSize 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;aababcaab&quot;, maxLetters = 2, minSize = 3, maxSize = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：子串 &quot;aab&quot; 在原字符串中出现了 2 次。</span><br><span class="line">它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;aaaa&quot;, maxLetters = 1, minSize = 3, maxSize = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：子串 &quot;aaa&quot; 在原字符串中出现了 2 次，且它们有重叠部分。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;aabcabcab&quot;, maxLetters = 2, minSize = 2, maxSize = 3</span><br><span class="line">输出：3</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;abcde&quot;, maxLetters = 2, minSize = 3, maxSize = 3</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= s.length &lt;= 10^5</span><br><span class="line">1 &lt;= maxLetters &lt;= 26</span><br><span class="line">1 &lt;= minSize &lt;= maxSize &lt;= min(26, s.length)</span><br><span class="line">s 只包含小写英文字母。</span><br></pre></td></tr></table></figure><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>题目给的数据量不是很大，为 1 &lt;= maxLetters &lt;= 26，我们试一下暴力法。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力法如下：</p><ul><li>先找出所有满足长度大于等于 minSize 且小于等于 maxSize 的所有子串。（平方的复杂度）</li><li>对于 maxLetter 满足题意的子串，我们统计其出现次数。时间复杂度为 O(k),其中 k 为子串长度</li><li>返回最大的出现次数</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Pythpn Code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxFreq</span><span class="params">(self, s: str, maxLetters: int, minSize: int, maxSize: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        letters = set()</span><br><span class="line">        cnts = dict()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - minSize + <span class="number">1</span>):</span><br><span class="line">            length = minSize</span><br><span class="line">            <span class="keyword">while</span> i + length &lt;= n <span class="keyword">and</span> length &lt;= maxSize:</span><br><span class="line">                t = s[i:i + length]</span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> t:</span><br><span class="line">                    <span class="keyword">if</span> len(letters) &gt; maxLetters:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    letters.add(c)</span><br><span class="line">                <span class="keyword">if</span> len(letters) &lt;= maxLetters:</span><br><span class="line">                    cnts[t] = cnts.get(t, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                    res = max(res, cnts[t])</span><br><span class="line">                letters.clear()</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>上述代码会超时。我们来利用剪枝来优化。</p><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>还是暴力法的思路，不过我们在此基础上进行一些优化。首先我们需要仔细阅读题目，如果你足够细心或者足够有经验，可能会发现其实题目中 maxSize 没有任何用处，属于干扰信息。</p><p>也就是说我们没有必要统计<code>长度大于等于 minSize 且小于等于 maxSize 的所有子串</code>，而是统计长度为 minSize 的所有字串即可。原因是，如果一个大于 minSize 长度的字串若是满足条件，那么该子串其中必定有至少一个长度为 minSize 的字串满足条件。因此一个大于 minSize 长度的字串出现了 n 次，那么该子串其中必定有一个长度为 minSize 的子串出现了 n 次。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3，Java：</p><p>Python Code：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">maxFreq</span><span class="params">(self, s: str, maxLetters: int, minSize: int, maxSize: int)</span> -&gt; int:</span></span><br><span class="line">        counter, res = &#123;&#125;, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(s) - minSize + <span class="number">1</span>):</span><br><span class="line">            sub = s[i : i + minSize]</span><br><span class="line">            <span class="keyword">if</span> len(set(sub)) &lt;= maxLetters:</span><br><span class="line">                counter[sub] = counter.get(sub, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">                res = max(res, counter[sub])</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure><p>Java Code：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxFreq</span><span class="params">(String s, <span class="keyword">int</span> maxLetters, <span class="keyword">int</span> minSize, <span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Integer&gt; counter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - minSize + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        String substr = s.substring(i, i + minSize);</span><br><span class="line">        <span class="keyword">if</span> (checkNum(substr, maxLetters)) &#123;</span><br><span class="line">            <span class="keyword">int</span> newVal = counter.getOrDefault(substr, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            counter.put(substr, newVal);</span><br><span class="line">            res = Math.max(res, newVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkNum</span><span class="params">(String substr, <span class="keyword">int</span> maxLetters)</span> </span>&#123;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; substr.length(); i++)</span><br><span class="line">        set.add(substr.charAt(i));</span><br><span class="line">    <span class="keyword">return</span> set.size() &lt;= maxLetters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>滑动窗口</li><li>识别题目干扰信息</li><li>看题目限制条件，对于本题有用的信息是<code>1 &lt;= maxLetters &lt;= 26</code></li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>我们也可以使用滑动窗口来解决，感兴趣的可以试试看。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 陷阱题 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>掌握前缀表达式真的可以为所欲为！</title>
      <link href="/blog/2020/01/09/1310.xor-queries-of-a-subarray/"/>
      <url>/blog/2020/01/09/1310.xor-queries-of-a-subarray/</url>
      
        <content type="html"><![CDATA[<p>前缀表达式是一种非常常见和重要的知识点，如果你还不知道，那就赶紧点进来看看吧！</p><a id="more"></a><h1 id="题目地址（1310-子数组异或查询）"><a href="#题目地址（1310-子数组异或查询）" class="headerlink" title="题目地址（1310. 子数组异或查询）"></a>题目地址（1310. 子数组异或查询）</h1><p><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xor-queries-of-a-subarray</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。</span><br><span class="line"></span><br><span class="line">对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。</span><br><span class="line"></span><br><span class="line">并返回一个包含给定查询 queries 所有结果的数组。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]</span><br><span class="line">输出：[2,7,14,8]</span><br><span class="line">解释：</span><br><span class="line">数组中元素的二进制表示形式是：</span><br><span class="line">1 = 0001</span><br><span class="line">3 = 0011</span><br><span class="line">4 = 0100</span><br><span class="line">8 = 1000</span><br><span class="line">查询的 XOR 值为：</span><br><span class="line">[0,1] = 1 xor 3 = 2</span><br><span class="line">[1,2] = 3 xor 4 = 7</span><br><span class="line">[0,3] = 1 xor 3 xor 4 xor 8 = 14</span><br><span class="line">[3,3] = 8</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]</span><br><span class="line">输出：[8,0,4,4]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= arr.length &lt;= 3 * 10^4</span><br><span class="line">1 &lt;= arr[i] &lt;= 10^9</span><br><span class="line">1 &lt;= queries.length &lt;= 3 * 10^4</span><br><span class="line">queries[i].length == 2</span><br><span class="line">0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length</span><br></pre></td></tr></table></figure><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>最直观的思路是双层循环即可，果不其然超时了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xorQueries</span><span class="params">(self, arr: List[int], queries: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line"> res = []</span><br><span class="line">        <span class="keyword">for</span> (L, R) <span class="keyword">in</span> queries:</span><br><span class="line">            i = L</span><br><span class="line">            xor = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= R:</span><br><span class="line">                xor ^= arr[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            res.append(xor)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>比较常见的是前缀和，这个概念其实很容易理解，即一个数组中，第 n 位存储的是数组前 n 个数字的和。</p><p>对 [1,2,3,4,5,6] 来说，其前缀和可以是 pre=[1,3,6,10,15,21]。我们可以使用公式 pre[𝑖]=pre[𝑖−1]+nums[𝑖]得到每一位前缀和的值，从而通过前缀和进行相应的计算和解题。其实前缀和的概念很简单，但困难的是如何在题目中使用前缀和以及如何使用前缀和的关系来进行解题。</p><p>这道题是前缀对前缀异或，我们利用了异或的性质 <code>x ^ y ^ x = y</code>。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqll5r048j30fm0bfglz.jpg" alt></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码支持 Python3，Java，C++：</p><p>Python Code：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @lc app=leetcode.cn id=1218 lang=python3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [1218] 最长定差子序列</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=start</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xorQueries</span><span class="params">(self, arr: List[int], queries: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">pre = [<span class="number">0</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">            pre.append(pre[i] ^ arr[i])</span><br><span class="line">        <span class="keyword">for</span> (L, R) <span class="keyword">in</span> queries:</span><br><span class="line">            res.append(pre[L] ^ pre[R + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure><p>Java Code：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] xorQueries(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span>[] preXor = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">      preXor[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)</span><br><span class="line">          preXor[i] = preXor[i - <span class="number">1</span>] ^ arr[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[queries.length];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">int</span> left = queries[i][<span class="number">0</span>], right = queries[i][<span class="number">1</span>];</span><br><span class="line">          res[i] = arr[right] ^ preXor[right] ^ preXor[left];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>C++ Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xorQueries(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            arr[i]^=arr[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;temp :queries)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[<span class="number">0</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                res.push_back(arr[temp[<span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(arr[temp[<span class="number">0</span>]<span class="number">-1</span>]^arr[temp[<span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>异或的性质 x ^ y ^ x = y</li><li>前缀表达式</li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">303. 区域和检索 - 数组不可变</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaql7eqyg6j30u00ft0vx.jpg" alt></p><ul><li><a href="https://lucifer.ren/blog/2019/12/11/leetcode-1186/">1186.删除一次得到子数组最大和</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 前缀表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构快速盘点</title>
      <link href="/blog/2020/01/03/basic-data-structure/"/>
      <url>/blog/2020/01/03/basic-data-structure/</url>
      
        <content type="html"><![CDATA[<p>这篇文章不是讲解数据结构的文章，而是结合现实的场景帮助大家<code>理解和复习</code>数据结构与算法，<br>如果你的数据结构基础很差，建议先去看一些基础教程，再转过来看。</p><p>本篇文章的定位是侧重于前端的，通过学习前端中实际场景的数据结构，从而加深大家对数据结构的理解和认识。</p><a id="more"></a><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><p>数据结构我们可以从逻辑上分为线性结构和非线性结构。线性结构有<br>数组，栈，链表等， 非线性结构有树，图等。</p><blockquote><p>其实我们可以称树为一种半线性结构。</p></blockquote><p>需要注意的是，线性和非线性不代表存储结构是线性的还是非线性的，这两者没有任何关系，它只是一种逻辑上的划分。<br>比如我们可以用数组去存储二叉树。</p><p>一般而言，有前驱和后继的就是线性数据结构。比如数组和链表。其实一叉树就是链表。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是最简单的数据结构了，很多地方都用到它。 比如有一个数据列表等，用它是再合适不过了。<br>其实后面的数据结构很多都有数组的影子。</p><p>我们之后要讲的栈和队列其实都可以看成是一种<code>受限</code>的数组, 怎么个受限法呢？我们后面讨论。</p><p>我们来讲几个有趣的例子来加深大家对数组这种数据结构的理解。</p><h4 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h4><p>Hooks 的本质就是一个数组， 伪代码：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji13k55rj30m80bsq3j.jpg" alt></p><p>那么为什么 hooks 要用数组？ 我们可以换个角度来解释，如果不用数组会怎么样？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. Use the name state variable</span></span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">"Mary"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. Use an effect for persisting the form</span></span><br><span class="line">  useEffect(<span class="function"><span class="keyword">function</span> <span class="title">persistForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    localStorage.setItem(<span class="string">"formData"</span>, name);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. Use the surname state variable</span></span><br><span class="line">  <span class="keyword">const</span> [surname, setSurname] = useState(<span class="string">"Poppins"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. Use an effect for updating the title</span></span><br><span class="line">  useEffect(<span class="function"><span class="keyword">function</span> <span class="title">updateTitle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = name + <span class="string">" "</span> + surname;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于数组的方式，Form 的 hooks 就是 [hook1, hook2, hook3, hook4],<br>我们可以得出这样的关系， hook1 就是[name, setName] 这一对，<br>hook2 就是 persistForm 这个。</p><p>如果不用数组实现，比如对象，Form 的 hooks 就是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'key1'</span>: hook1,</span><br><span class="line">  <span class="string">'key2'</span>: hook2,</span><br><span class="line">  <span class="string">'key3'</span>: hook3,</span><br><span class="line">  <span class="string">'key4'</span>: hook4,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题是 key1，key2，key3，key4 怎么取呢？</p><p>关于 React hooks 的本质研究，更多请查看<a href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" target="_blank" rel="noopener">React hooks: not magic, just arrays</a></p><p>React 将<code>如何确保组件内部hooks保存的状态之间的对应关系</code>这个工作交给了<br>开发人员去保证，即你必须保证 HOOKS 的顺序严格一致，具体可以看 React 官网关于 Hooks Rule 部分。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种受限的序列，它只能够操作队尾和队首，并且只能只能在队尾添加元素，在队首删除元素。</p><p>队列作为一种最常见的数据结构同样有着非常广泛的应用， 比如消息队列</p><blockquote><p>“队列”这个名称,可类比为现实生活中排队（不插队的那种）</p></blockquote><p>在计算机科学中, 一个 队列(queue) 是一种特殊类型的抽象数据类型或集合。集合中的实体按顺序保存。</p><p>队列基本操作有两种:</p><ul><li>向队列的后端位置添加实体，称为入队</li><li>从队列的前端位置移除实体，称为出队。</li></ul><p>队列中元素先进先出 FIFO (first in, first out)的示意：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji2c8g4uj30b107lmxa.jpg" alt></p><p>(图片来自 <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/queue/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/queue/README.zh-CN.md</a>)</p><p>我们前端在做性能优化的时候，很多时候会提到的一点就是“HTTP 1.1 的队头阻塞问题”，具体来说<br>就是 HTTP2 解决了 HTTP1.1 中的队头阻塞问题，但是为什么 HTTP1.1 有队头阻塞问题，HTTP2 究竟怎么解决的很多人都不清楚。</p><p>其实“队头阻塞”是一个专有名词，不仅仅这里有，交换器等其他都有这个问题，引起这个问题的根本原因是使用了<code>队列</code>这种数据结构。</p><p>对于同一个 tcp 连接，所有的 http1.0 请求放入队列中，只有前一个<code>请求的响应</code>收到了，然后才能发送下一个请求，这个阻塞主要发生在客户端。</p><p>这就好像我们在等红绿灯，即使旁边绿灯亮了，你的这个车道是红灯，你还是不能走，还是要等着。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji2whipnj30gf0e2dgm.jpg" alt></p><p><code>HTTP/1.0</code> 和 <code>HTTP/1.1</code>:<br>在<code>HTTP/1.0</code> 中每一次请求都需要建立一个 TCP 连接，请求结束后立即断开连接。<br>在<code>HTTP/1.1</code> 中，每一个连接都默认是长连接(persistent connection)。对于同一个 tcp 连接，允许一次发送多个 http1.1 请求，也就是说，不必等前一个响应收到，就可以发送下一个请求。这样就解决了 http1.0 的客户端的队头阻塞，而这也就是<code>HTTP/1.1</code>中<code>管道(Pipeline)</code>的概念了。<br>但是，<code>http1.1规定，服务器端的响应的发送要根据请求被接收的顺序排队</code>，也就是说，先接收到的请求的响应也要先发送。这样造成的问题是，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送。也会造成队头阻塞。<br>可见，http1.1 的队首阻塞发生在服务器端。</p><p>如果用图来表示的话，过程大概是：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji30r665j31210d83zr.jpg" alt></p><p><code>HTTP/2</code> 和 <code>HTTP/1.1</code>:</p><p>为了解决<code>HTTP/1.1</code>中的服务端队首阻塞，<code>HTTP/2</code>采用了<code>二进制分帧</code> 和 <code>多路复用</code> 等方法。<br><code>二进制分帧</code>中，帧是<code>HTTP/2</code>数据通信的最小单位。在<code>HTTP/1.1</code>数据包是文本格式，而<code>HTTP/2</code>的数据包是二进制格式的，也就是二进制帧。采用帧可以将请求和响应的数据分割得更小，且二进制协议可以更高效解析。<code>HTTP/2</code>中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装。<br><code>多路复用</code>用以替代原来的序列和拥塞机制。在<code>HTTP/1.1</code>中，并发多个请求需要多个 TCP 链接，且单个域名有 6-8 个 TCP 链接请求限制。在<code>HHTP/2</code>中，同一域名下的所有通信在单个链接完成，仅占用一个 TCP 链接，且在这一个链接上可以并行请求和响应，互不干扰。</p><blockquote><p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">此网站</a>可以直观感受<code>HTTP/1.1</code>和<code>HTTP/2</code>的性能对比。</p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈也是一种受限的序列，它只能够操作栈顶，不管入栈还是出栈，都是在栈顶操作。</p><p>在计算机科学中, 一个 栈(stack) 是一种抽象数据类型,用作表示元素的集合,具有两种主要操作:</p><p>push, 添加元素到栈的顶端(末尾);<br>pop, 移除栈最顶端(末尾)的元素.<br>以上两种操作可以简单概括为“后进先出(LIFO = last in, first out)”。</p><p>此外,应有一个 peek 操作用于访问栈当前顶端(末尾)的元素。（只返回不弹出）</p><blockquote><p>“栈”这个名称,可类比于一组物体的堆叠(一摞书,一摞盘子之类的)。</p></blockquote><p>栈的 push 和 pop 操作的示意:</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji3d1m8oj30lh0f074v.jpg" alt></p><p>(图片来自 <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/stack/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/stack/README.zh-CN.md</a>)</p><p>栈在很多地方都有着应用，比如大家熟悉的浏览器就有很多栈，其实浏览器的执行栈就是一个基本的栈结构，从数据结构上说，它就是一个栈。<br>这也就解释了，我们用递归的解法和用循环+栈的解法本质上是差不多。</p><p>比如如下 JS 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">  bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>真正执行的时候，内部大概是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji3jo8ozj30v70hi0u8.jpg" alt></p><blockquote><p>我画的图没有画出执行上下文中其他部分（this 和 scope 等）， 这部分是闭包的关键，而我这里不是将闭包的，是为了讲解栈的。</p></blockquote><blockquote><p>社区中有很多“执行上下文中的 scope 指的是执行栈中父级声明的变量”说法，这是完全错误的， JS 是词法作用域，scope 指的是函数定义时候的父级，和执行没关系</p></blockquote><p>栈常见的应用有进制转换，括号匹配，栈混洗，中缀表达式（用的很少），后缀表达式（逆波兰表达式）等。</p><blockquote><p>合法的栈混洗操作，其实和合法的括号匹配表达式之间存在着一一对应的关系，<br>也就是说 n 个元素的栈混洗有多少种，n 对括号的合法表达式就有多少种。感兴趣的可以查找相关资料</p></blockquote><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种最基本数据结构，熟练掌握链表的结构和常见操作是基础中的基础。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji3xxu0kj30bm01lglg.jpg" alt></p><p>(图片来自： <a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/linked-list/traversal" target="_blank" rel="noopener">https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/linked-list/traversal</a>)</p><h4 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h4><p>很多人都说 fiber 是基于链表实现的，但是为什么要基于链表呢，可能很多人并没有答案，那么我觉得可以把这两个点（fiber 和链表）放到一起来讲下。</p><p>fiber 出现的目的其实是为了解决 react 在执行的时候是无法停下来的，需要一口气执行完的问题的。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji494wa9j30rc0c0wez.jpg" alt></p><p>图片来自 Lin Clark 在 ReactConf 2017 分享</p><p>上面已经指出了引入 fiber 之前的问题，就是 react 会阻止优先级高的代码（比如用户输入）执行。因此 fiber<br>打算自己自建一个<code>虚拟执行栈</code>来解决这个问题，这个虚拟执行栈的实现是链表。</p><p>Fiber 的基本原理是将协调过程分成小块，一次执行一块，然乎将运算结果保存起来，并判断是否有时间（react 自己实现了一个类似 requestIdleCallback 的功能）继续执行下一块。<br>如果有时间，则继续。 否则跳出，让浏览器主线程歇一会，执行别的优先级高的代码。</p><p>当协调过程完成（所有的小块都运算完毕）， 那么就会进入提交阶段， 真正的进行副作用（side effect）操作，比如更新 DOM，这个过程是没有办法取消的，原因就是这部分有副作用。</p><p>问题的关键就是将协调的过程划分为一块块的，最后还可以合并到一起，有点像 Map／Reduce。</p><p>React 必须重新实现遍历树的算法，从依赖于<code>内置堆栈的同步递归模型</code>，变为<code>具有链表和指针的异步模型</code>。</p><blockquote><p>Andrew 是这么说的： 如果你只依赖于[内置]调用堆栈，它将继续工作直到堆栈为空。。。</p></blockquote><p>如果我们可以随意中断调用堆栈并手动操作堆栈帧，那不是很好吗？<br>这就是 React Fiber 的目的。 <code>Fiber 是堆栈的重新实现，专门用于 React 组件</code>。 你可以将单个 Fiber 视为一个<code>虚拟堆栈帧</code>。</p><p>react fiber 大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fiber = &#123;</span><br><span class="line">  tag: HOST_COMPONENT,</span><br><span class="line">  type: <span class="string">"div"</span>,</span><br><span class="line">  <span class="keyword">return</span>: parentFiber,</span><br><span class="line">  children: childFiber,</span><br><span class="line">  sibling: childFiber,</span><br><span class="line">  alternate: currentFiber,</span><br><span class="line">  stateNode: <span class="built_in">document</span>.createElement(<span class="string">"div"</span>),</span><br><span class="line">  props: &#123; <span class="attr">children</span>: [], <span class="attr">className</span>: <span class="string">"foo"</span> &#125;,</span><br><span class="line">  partialState: <span class="literal">null</span>,</span><br><span class="line">  effectTag: PLACEMENT,</span><br><span class="line">  effects: []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从这里可以看出 fiber 本质上是个对象，使用 parent，child，sibling 属性去构建 fiber 树来表示组件的结构树，<br>return, children, sibling 也都是一个 fiber，因此 fiber 看起来就是一个链表。</p><blockquote><p>细心的朋友可能已经发现了， alternate 也是一个 fiber， 那么它是用来做什么的呢？<br>它其实原理有点像 git， 可以用来执行 git revert ,git commit 等操作，这部分挺有意思，我会在我的《从零开发 git》中讲解</p></blockquote><p>想要了解更多的朋友可以看<a href="https://github.com/dawn-plex/translate/blob/master/articles/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree.md" target="_blank" rel="noopener">这个文章</a></p><p>如果可以翻墙， 可以看<a href="https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">英文原文</a></p><p><a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec" target="_blank" rel="noopener">这篇文章</a>也是早期讲述 fiber 架构的优秀文章</p><p>我目前也在写关于《从零开发 react 系列教程》中关于 fiber 架构的部分，如果你对具体实现感兴趣，欢迎关注。</p><h2 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h2><p>那么有了线性结构，我们为什么还需要非线性结构呢？ 答案是为了高效地兼顾静态操作和动态操作。大家可以对照各种数据结构的各种操作的复杂度来直观感受一下。</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树的应用同样非常广泛，小到文件系统，大到因特网，组织架构等都可以表示为树结构，而在我们前端眼中比较熟悉的 DOM 树也是一种树结构，而 HTML 作为一种 DSL 去描述这种树结构的具体表现形式。如果你接触过 AST，那么 AST 也是一种树，XML 也是树结构。。。树的应用远比大多数人想象的要得多。</p><p>树其实是一种特殊的<code>图</code>，是一种无环连通图，是一种极大无环图，也是一种极小连通图。</p><p>从另一个角度看，树是一种递归的数据结构。而且树的不同表示方法，比如不常用的<code>长子 + 兄弟</code>法，对于<br>你理解树这种数据结构有着很大用处， 说是一种对树的本质的更深刻的理解也不为过。</p><p>树的基本算法有前中后序遍历和层次遍历，有的同学对前中后这三个分别具体表现的访问顺序比较模糊，其实当初我也是一样的，后面我学到了一点，你只需要记住：<code>所谓的前中后指的是根节点的位置，其他位置按照先左后右排列即可</code>。比如前序遍历就是<code>根左右</code>, 中序就是<code>左根右</code>，后序就是<code>左右根</code>， 很简单吧？</p><p>我刚才提到了树是一种递归的数据结构，因此树的遍历算法使用递归去完成非常简单，幸运的是树的算法基本上都要依赖于树的遍历。 但是递归在计算机中的性能一直都有问题，因此掌握不那么容易理解的”命令式地迭代”遍历算法在某些情况下是有用的。如果你使用迭代式方式去遍历的话，可以借助上面提到的<code>栈</code>来进行，可以极大减少代码量。</p><blockquote><p>如果使用栈来简化运算，由于栈是 FILO 的，因此一定要注意左右子树的推入顺序。</p></blockquote><p>树的重要性质：</p><ul><li>如果树有 n 个顶点，那么其就有 n - 1 条边，这说明了树的顶点数和边数是同阶的。</li><li>任何一个节点到根节点存在<code>唯一</code>路径, 路径的长度为节点所处的深度</li></ul><p>实际使用的树有可能会更复杂，比如使用在游戏中的碰撞检测可能会用到四叉树或者八叉树。以及 k 维的树结构 <code>k-d 树</code>等。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gajhqov8pjj306y06mweo.jpg" alt><br>（图片来自 <a href="https://zh.wikipedia.org/wiki/K-d%E6%A0%91）" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/K-d%E6%A0%91）</a></p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>二叉树是节点度数不超过二的树，是树的一种特殊子集，有趣的是二叉树这种被限制的树结构却能够表示和实现所有的树，<br>它背后的原理正是<code>长子 + 兄弟</code>法，用邓老师的话说就是<code>二叉树是多叉树的特例，但在有根且有序时，其描述能力却足以覆盖后者</code>。</p><blockquote><p>实际上， 在你使用<code>长子 + 兄弟</code>法表示树的同时，进行 45 度角旋转即可。</p></blockquote><p>一个典型的二叉树：</p><p>标记为 7 的节点具有两个子节点, 标记为 2 和 6; 一个父节点,标记为 2,作为根节点, 在顶部,没有父节点。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaji4vav1hj308m07baa6.jpg" alt></p><p>(图片来自 <a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/README.zh-CN.md" target="_blank" rel="noopener">https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/tree/README.zh-CN.md</a>)</p><p>对于一般的树，我们通常会去遍历，这里又会有很多变种。</p><p>下面我列举一些二叉树遍历的相关算法:</p><ul><li><a href="../problems/94.binary-tree-inorder-traversal.md">94.binary-tree-inorder-traversal</a></li><li><a href="../problems/102.binary-tree-level-order-traversal.md">102.binary-tree-level-order-traversal</a></li><li><a href="../problems/103.binary-tree-zigzag-level-order-traversal.md">103.binary-tree-zigzag-level-order-traversal</a></li><li><a href="../problems/144.binary-tree-preorder-traversal.md">144.binary-tree-preorder-traversal</a></li><li><a href="../problems/145.binary-tree-postorder-traversal.md">145.binary-tree-postorder-traversal</a></li><li><a href="../problems/199.binary-tree-right-side-view.md">199.binary-tree-right-side-view</a></li></ul><p>相关概念：</p><ul><li>真二叉树 （所有节点的度数只能是偶数，即只能为 0 或者 2）</li></ul><p>另外我也专门开设了<a href="./binary-tree-traversal.md">二叉树的遍历</a>章节, 具体细节和算法可以去那里查看。</p><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>堆其实是一种优先级队列，在很多语言都有对应的内置数据结构，很遗憾 javascript 没有这种原生的数据结构。<br>不过这对我们理解和运用不会有影响。</p><p>堆的特点：</p><ul><li>在一个 最小堆(min heap) 中, 如果 P 是 C 的一个父级节点, 那么 P 的 key(或 value)应小于或等于 C 的对应值.<br>正因为此，堆顶元素一定是最小的，我们会利用这个特点求最小值或者第 k 小的值。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji593urzj30ca07yjro.jpg" alt></p><ul><li>在一个 最大堆(max heap) 中, P 的 key(或 value)大于 C 的对应值。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaji5rurzpj30ct0abgm4.jpg" alt></p><p>需要注意的是优先队列不仅有堆一种，还有更复杂的，但是通常来说，我们会把两者做等价。</p><p>相关算法：</p><ul><li><a href="../problems/295.find-median-from-data-stream.md">295.find-median-from-data-stream</a></li></ul><h5 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h5><p>二叉排序树（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。</p><p>二叉查找树具有下列性质的二叉树：</p><ul><li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点。</li></ul><p>对于一个二叉查找树，常规操作有插入，查找，删除，找父节点，求最大值，求最小值。</p><p>二叉查找树，之所以叫查找树就是因为其非常适合查找，举个例子，<br>如下一颗二叉查找树，我们想找节点值小于且最接近 58 的节点，搜索的流程如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaji6etgvwj30rs0mudhi.jpg" alt><br>（图片来自 <a href="https://www.geeksforgeeks.org/floor-in-binary-search-tree-bst/）" target="_blank" rel="noopener">https://www.geeksforgeeks.org/floor-in-binary-search-tree-bst/）</a></p><p>另外我们二叉查找树有一个性质是： <code>其中序遍历的结果是一个有序数组</code>。<br>有时候我们可以利用到这个性质。</p><p>相关题目：</p><ul><li><a href="../problems/98.validate-binary-search-tree.md">98.validate-binary-search-tree</a></li></ul><h5 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h5><p>平衡树是计算机科学中的一类数据结构，为改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了平衡树。</p><p>在这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。</p><p>一些数据库引擎内部就是用的这种数据结构，其目标也是将查询的操作降低到 logn（树的深度），可以简单理解为<code>树在数据结构层面构造了二分查找算法</code>。</p><p>基本操作：</p><ul><li><p>旋转</p></li><li><p>插入</p></li><li><p>删除</p></li><li><p>查询前驱</p></li><li><p>查询后继</p></li></ul><h6 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h6><p>是最早被发明的自平衡二叉查找树。在 AVL 树中，任一节点对应的两棵子树的最大高度差为 1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是 {\displaystyle O(\log {n})} O(\log{n})。增加和删除元素的操作则可能需要借由一次或多次树旋转，以实现树的重新平衡。AVL 树得名于它的发明者 G. M. Adelson-Velsky 和 Evgenii Landis，他们在 1962 年的论文 An algorithm for the organization of information 中公开了这一数据结构。 节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子 1、0 或 -1 的节点被认为是平衡的。带有平衡因子 -2 或 2 的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。</p><h6 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h6><p>在 1972 年由鲁道夫·贝尔发明，被称为”对称二叉 B 树”，它现代的名字源于 Leo J. Guibas 和 Robert Sedgewick 于 1978 年写的一篇论文。红黑树的结构复杂，但它的操作有着良好的最坏情况运行时间，并且在实践中高效：它可以在 {\displaystyle O(\log {n})} O(\log{n})时间内完成查找，插入和删除，这里的 n 是树中元素的数目</p><h4 id="字典树-前缀树"><a href="#字典树-前缀树" class="headerlink" title="字典树(前缀树)"></a>字典树(前缀树)</h4><p>又称 Trie 树，是一种树形结构。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gajj0g78e6j30al06qwfc.jpg" alt></p><p>(图来自 <a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin</a>)<br>它有 3 个基本性质：</p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符；</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><h5 id="immutable-与-字典树"><a href="#immutable-与-字典树" class="headerlink" title="immutable 与 字典树"></a>immutable 与 字典树</h5><p><code>immutableJS</code>的底层就是<code>share + tree</code>. 这样看的话，其实和字典树是一致的。</p><p>相关算法：</p><ul><li><a href="../problems/208.implement-trie-prefix-tree.md">208.implement-trie-prefix-tree</a></li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>前面讲的数据结构都可以看成是图的特例。 前面提到了二叉树完全可以实现其他树结构，<br>其实有向图也完全可以实现无向图和混合图，因此有向图的研究一直是重点考察对象。</p><p>图论〔Graph Theory〕是数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系，用点代表事物，用连接两点的线表示相应两个事物间具有这种关系。</p><h4 id="图的表示方法"><a href="#图的表示方法" class="headerlink" title="图的表示方法"></a>图的表示方法</h4><ul><li>邻接矩阵(常见)</li></ul><p>空间复杂度 O(n^2),n 为顶点个数。</p><p>优点：</p><ol><li><p>直观，简单。</p></li><li><p>适用于稠密图</p></li><li><p>判断两个顶点是否连接，获取入度和出度以及更新度数，时间复杂度都是 O(1)</p></li></ol><ul><li>关联矩阵</li><li>邻接表</li></ul><p>对于每个点，存储着一个链表，用来指向所有与该点直接相连的点<br>对于有权图来说，链表中元素值对应着权重</p><p>例如在无向无权图中：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaji793gchj30k00akq48.jpg" alt><br>（图片来自 <a href="https://zhuanlan.zhihu.com/p/25498681）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25498681）</a></p><p>可以看出在无向图中，邻接矩阵关于对角线对称，而邻接链表总有两条对称的边<br>而在有向无权图中：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaji7giyerj30k00aq0ux.jpg" alt></p><p>（图片来自 <a href="https://zhuanlan.zhihu.com/p/25498681）" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25498681）</a></p><h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><p>图的遍历就是要找出图中所有的点，一般有以下两种方法：</p><ol><li>深度优先遍历：(Depth First Search, DFS)</li></ol><p>深度优先遍历图的方法是，从图中某顶点 v 出发， 不断访问邻居， 邻居的邻居直到访问完毕。</p><ol start="2"><li>广度优先搜索：(Breadth First Search, BFS)</li></ol><p>广度优先搜索，可以被形象地描述为 “浅尝辄止”，它也需要一个队列以保持遍历过的顶点顺序，以便按出队的顺序再去访问这些顶点的邻接顶点。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一荐 2019-12 汇总</title>
      <link href="/blog/2020/01/01/daily-featured-2019-12/"/>
      <url>/blog/2020/01/01/daily-featured-2019-12/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8d0sktqrwj30hs07maae.jpg" alt></p><p>每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。</p><p>项目主页维护当前月份的内容，想看往期内容，可以去<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">每日一荐主仓库</a>翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。</p><a id="more"></a><h2 id="2019-12"><a href="#2019-12" class="headerlink" title="2019-12"></a>2019-12</h2><h3 id="2019-12-31-见闻"><a href="#2019-12-31-见闻" class="headerlink" title="2019-12-31[见闻]"></a>2019-12-31[见闻]</h3><p>今天是我的生日，祝我生日快乐 🎂 ～～～～</p><p>一般公司的卫生间贴的都是公司信息或心灵鸡汤，但是谷歌卫生间贴的是<code>如何找到代码 Bug</code>，不得不感叹“这实在是太硬核了”！</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gab8f97lcej30ci0m8dhh.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gab8ffahw3j30ek0hlmyg.jpg" alt></p><h3 id="2019-12-24-技巧"><a href="#2019-12-24-技巧" class="headerlink" title="2019-12-24[技巧]"></a>2019-12-24[技巧]</h3><p>今天是平安夜，苹果 🍎 和圣诞礼物 🎁 都收到了么？</p><p>今天给大家推荐的是一个 linux 中非常常见的命令 <code>grep</code> 的常用用法。</p><p>图版本：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga81dnom82j30xc0l0afr.jpg" alt></p><p>文字版本：</p><p>Matches patterns in input text.Supports simple patterns and regular expressions.</p><ul><li><p>Search for an exact string:<br>grep search_string path/to/file</p></li><li><p>Search in case-insensitive mode:<br>grep -i search_string path/to/file</p></li><li><p>Search recursively (ignoring non-text files) in current directory for an exact string:<br>grep -RI search_string .</p></li><li><p>Use extended regular expressions (supporting ?, +, {}, () and |):<br>grep -E ^regex$ path/to/file</p></li><li><p>Print 3 lines of [C]ontext around, [B]efore, or [A]fter each match:<br>grep -C|B|A 3 search_string path/to/file</p></li><li><p>Print file name with the corresponding line number for each match:<br>grep -Hn search_string path/to/file</p></li><li><p>Use the standard input instead of a file:<br>cat path/to/file | grep search_string</p></li><li><p>Invert match for excluding specific strings:<br>grep -v search_string</p></li></ul><h3 id="2019-12-23-学习方法"><a href="#2019-12-23-学习方法" class="headerlink" title="2019-12-23[学习方法]"></a>2019-12-23[学习方法]</h3><p>很多人问我如何保持高效率。 首先要说的是我的效率并不是很高，这也就是我为什么还在不断学习提高效率的原因之一。那么既然有人问了我就班门弄斧回答一下，大家有什么好的方法和技巧欢迎提出来交流。</p><p>为了让自己保持高效率，我自己开了一个仓库记录了自己保持“高效率”的方式。希望可以给大家启发，本仓库内容持续更新～</p><p>仓库大纲：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6fqk9vrpj30ar09tgmp.jpg" alt></p><p>仓库截图：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ga6fr6o5gkj30fz0qm77n.jpg" alt></p><p>仓库地址：<a href="https://github.com/azl397985856/To-Be-Productive" target="_blank" rel="noopener">https://github.com/azl397985856/To-Be-Productive</a></p><h3 id="2019-12-20-新闻"><a href="#2019-12-20-新闻" class="headerlink" title="2019-12-20[新闻]"></a>2019-12-20[新闻]</h3><p>Facebook 发布 Hermes， 一个新的专门用于 React Native 的 JS 引擎。</p><p>文章地址：<a href="https://facebook.github.io/react-native/blog/2019/07/17/hermes" target="_blank" rel="noopener">https://facebook.github.io/react-native/blog/2019/07/17/hermes</a></p><h3 id="2019-12-19-好文"><a href="#2019-12-19-好文" class="headerlink" title="2019-12-19[好文]"></a>2019-12-19[好文]</h3><p>很多高级语言有自动的垃圾回收器，比如 JS，JAVA，Go 等。其会自动地进行垃圾回收工作，而不必像诸如 C 和 C++那样手动分配和清除内存。</p><p>对于 old space 的垃圾回收算法有一个是标记清除，从一个根对象开始对于所有可达的对象进行标记，剩下的就是不可达的，我们将其进行清除，本文讲解了三色标记法（黑色，白色和灰色），三色标记法本质上进行一次 DFS，并将内存对象分到三个部分，DFS 完成之后清除不可达的内存（白色）。这篇文章以动画形式讲解了三色标记法的具体过程。</p><p>文章（《一张图了解三色标记法》）地址：<a href="http://idiotsky.top/2017/08/16/gc-three-color/" target="_blank" rel="noopener">http://idiotsky.top/2017/08/16/gc-three-color/</a></p><h3 id="2019-12-18-教程"><a href="#2019-12-18-教程" class="headerlink" title="2019-12-18[教程]"></a>2019-12-18[教程]</h3><p>哈弗大学 CS50 系列，内容持续更新，现在最新的是 2019 年。 你可以跟着教程来重新学习 CS 基础。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9zz364qkfj308d0c2dgk.jpg" alt></p><p>地址：<a href="https://cs50.harvard.edu/college/" target="_blank" rel="noopener">https://cs50.harvard.edu/college/</a></p><h3 id="2019-12-17-网站"><a href="#2019-12-17-网站" class="headerlink" title="2019-12-17[网站]"></a>2019-12-17[网站]</h3><p>Learn Git Branching 是一个交互式学习 Git 的网站。沙盒里你能执行相应的命令，还能看到每个命令的执行情况； 通过一系列刺激的关卡挑战，逐步深入的学习 Git 的强大功能，在这个过程中你可能还会发现一些有意思的事情。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9yvse4btrj30z80hhjua.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9yvtbimcaj30zf0ppq51.jpg" alt></p><p>地址： <a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a></p><h3 id="2019-12-16-新闻"><a href="#2019-12-16-新闻" class="headerlink" title="2019-12-16[新闻]"></a>2019-12-16[新闻]</h3><p>最新版本的 Chrome 和 Firefo 浏览器取消 EV 证书的显示。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ybrc3mf7j30mp09a0ty.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ybrl2cyuj30mp09agmz.jpg" alt></p><p>只有用户点击了锁 🔒，才会显示出 EV 证书的信息。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ybutylm2j30ep0ant9k.jpg" alt></p><p>为什么会这样？想要知道答案的可以点击原文阅读。</p><p>原文地址：<a href="https://www.bleepingcomputer.com/news/software/chrome-and-firefox-changes-spark-the-end-of-ev-certificates/" target="_blank" rel="noopener">Chrome and Firefox Changes Spark the End of EV Certificates</a></p><h3 id="2019-12-13-类库"><a href="#2019-12-13-类库" class="headerlink" title="2019-12-13[类库]"></a>2019-12-13[类库]</h3><p>loki 是一个 React Storybook 组件回归测试工具。React Storybook 是一个我 15 年就开始关注的一个工具，本身的设计思想我比较喜欢。现在除了支持 React，也支持 React Native，Vue，Angular 等，甚至最新的 Svelte 也支持。</p><p>loki Github 地址： <a href="https://github.com/oblador/loki" target="_blank" rel="noopener">https://github.com/oblador/loki</a></p><h3 id="2019-12-12-技巧"><a href="#2019-12-12-技巧" class="headerlink" title="2019-12-12[技巧]"></a>2019-12-12[技巧]</h3><p>Angular 的 Commit Message Conventions 是一套很流行的 Commit Message 规约。简单方便，一目了然，更重要的是这种约定化如果形成一种默契，不管对于之后查看，还是生成各种外部资料（比如 CHNAGELOG）都是非常方便的。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9sr6iuanij30hs0rhacw.jpg" alt></p><p>详细信息： <a href="https://gist.github.com/stephenparish/9941e89d80e2bc58a153" target="_blank" rel="noopener">https://gist.github.com/stephenparish/9941e89d80e2bc58a153</a></p><p>相关工具也有很多，我个人使用的是<a href="https://github.com/commitizen?type=source" title="Commitizen" target="_blank" rel="noopener">Commitizen</a></p><h3 id="2019-12-11-好文"><a href="#2019-12-11-好文" class="headerlink" title="2019-12-11[好文]"></a>2019-12-11[好文]</h3><p>文章标题 《花椒前端基于 WebAssembly 的 H.265 播放器研发》，本文从背景介绍，技术调研，实际方案到最后的实践效果，完整地讲述了通过 <code>wasm</code> 将 H.265 应用到不支持其的浏览器的过程。干货满满，其架构图画的也是我比较喜欢的风格。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9rmc1qkp1j30k00co0tx.jpg" alt></p><p>文章地址： <a href="https://zhuanlan.zhihu.com/p/73772711" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73772711</a></p><h3 id="2019-12-10-技巧"><a href="#2019-12-10-技巧" class="headerlink" title="2019-12-10[技巧]"></a>2019-12-10[技巧]</h3><p>我们有时候需要在终端访问一些国外的资源。我目前采取的措施主要是给终端设置 proxy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias proxy=&apos;export all_proxy=socks5://127.0.0.1:1086&apos;</span><br><span class="line">alias unproxy=&apos;unset all_proxy&apos;</span><br></pre></td></tr></table></figure><p>其中<code>socks5://127.0.0.1:1086</code>是我的本机的正向代理地址。</p><p>如下是使用效果：<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pep3a663j30nc0nek3l.jpg" alt></p><p>如图显示我们代理成功了，而且我们可以方便的在不想要代理的时候去掉代理。</p><h3 id="2019-12-09-类库"><a href="#2019-12-09-类库" class="headerlink" title="2019-12-09[类库]"></a>2019-12-09[类库]</h3><p>对于前端，我们经常需要将组件进行可视化的展示。在 Vue 中，我们通常会用 <a href="https://github.com/docsifyjs/docsify" title="docsify" target="_blank" rel="noopener">docsify</a> 或者 <a href="https://github.com/vuejs/vuepress" title="vuepress" target="_blank" rel="noopener">vuepress</a> 等。而对于 react 比较有名的有 <a href="https://github.com/storybookjs/storybook" title="storybook" target="_blank" rel="noopener">storybook</a> 和 <a href="https://github.com/doczjs/docz" title="docz" target="_blank" rel="noopener">docz</a>。</p><p>当然这并不是绝对的，比如 storybook 也在支持 vue 和 webcomponents。</p><h3 id="2019-12-06-技能"><a href="#2019-12-06-技能" class="headerlink" title="2019-12-06[技能]"></a>2019-12-06[技能]</h3><p>在分析 CPU、内存、磁盘等的性能指标时，有几种工具是高频出现的，如 top、vmstat、pidstat，这里稍微总结一下:</p><p>CPU：top、vmstat、pidstat、sar、perf、jstack、jstat；<br>内存：top、free、vmstat、cachetop、cachestat、sar、jmap；<br>磁盘：top、iostat、vmstat、pidstat、du/df；<br>网络：netstat、sar、dstat、tcpdump；<br>应用：profiler、dump 分析。<br>排查 Java 应用的线上异常或者分析应用代码瓶颈，可以使用阿里开源的 Arthas ，nodejs 应用可以使用 alinode</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9jphsv3t0j30u01b5tbj.jpg" alt></p><h3 id="2019-12-05-好文"><a href="#2019-12-05-好文" class="headerlink" title="2019-12-05[好文]"></a>2019-12-05[好文]</h3><p>如果你想做微前端，一定要能够回答出这 10 个问题。</p><ol><li>微应用的注册、异步加载和生命周期管理；</li><li>微应用之间、主从之间的消息机制；</li><li>微应用之间的安全隔离措施；</li><li>微应用的框架无关、版本无关；</li><li>微应用之间、主从之间的公共依赖的库、业务逻辑(utils)以及版本怎么管理；</li><li>微应用独立调试、和主应用联调的方式，快速定位报错（发射问题）；</li><li>微应用的发布流程；</li><li>微应用打包优化问题；</li><li>微应用专有云场景的出包方案；</li><li>渐进式升级：用微应用方案平滑重构老项目。</li></ol><p>今天推荐的这个文档，区别与别的微前端文章的点在于其更加靠近规范层面，而不是结合自己的业务场景做的探索。这篇文章来自于阿里团队。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9kuat53elj30u00lgdhe.jpg" alt></p><p>文章地址： <a href="https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rYNsKPhw2zR84-4K62gliw</a></p><h3 id="2019-12-04-工具"><a href="#2019-12-04-工具" class="headerlink" title="2019-12-04[工具]"></a>2019-12-04[工具]</h3><p>相信大家使用 shell 的时候，会经常碰到忘记的 option，或者某一个用法记不清楚。遇到这种问题通常我们会用 man 或者命令提供的–help 查看用法。 这里给大家介绍另外一种工具<code>tldr</code>, 它是一个将 man page 进行简化，将大家常用的用法总结出来的工具。</p><p>安全也非常简单，只需要 <code>npm install -g</code>(前提是你必须安装 node)， 如果你不想安装也没有关系，它还提供了<a href="https://tldr.ostera.io/" target="_blank" rel="noopener">web 版</a>。另外你也可以参考这里<a href="https://github.com/tldr-pages/tldr-node-client#configuration" target="_blank" rel="noopener">定制你的主题</a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9jmo8sh8jj30ic0ei3zt.jpg" alt></p><p>仓库地址： <a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">https://github.com/tldr-pages/tldr</a></p><h3 id="2019-12-03-技巧"><a href="#2019-12-03-技巧" class="headerlink" title="2019-12-03[技巧]"></a>2019-12-03[技巧]</h3><p>今天给大家介绍的是<code>Google高级搜索技巧</code>。我们经常使用搜索引擎搜索一些东西，不管是遇到问题想寻求解决方案也好，想学习一些新东西也好，掌握一定的搜索技巧是可以让你搜索的过程事半功倍，尤其是常用的技巧一定要记住。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9dy1kml11j30u02pkdsk.jpg" alt></p><h3 id="2019-12-02-软件"><a href="#2019-12-02-软件" class="headerlink" title="2019-12-02[软件]"></a>2019-12-02[软件]</h3><p>我们公司在使用的一个完全开源的堡垒机，是符合 4A 的专业运维审计系统。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9i8em5x8sj31ht0u0td1.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9i8et0f9hj31mk0u0ten.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9i8ey12vhj31i60u0taw.jpg" alt></p><p>地址： <a href="https://github.com/jumpserver/jumpserver" target="_blank" rel="noopener">https://github.com/jumpserver/jumpserver</a></p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>我重新整理了下自己的公众号，并且我还给它换了一个名字<code>脑洞前端</code>，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。</p><p>之后我的文章会同步到微信公众号 <code>脑洞前端</code> ，你可以关注获取最新的文章，并和我进行交流。</p><p>另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。</p><img width="300" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7he9xdtmyj30by0byaac.jpg"><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul><li>如果有想法和创意，请提<a href="https://github.com/azl397985856/daily-featured/issues" target="_blank" rel="noopener">issue</a>或者进群提</li><li>如果想贡献代码，请提<a href="https://github.com/azl397985856/daily-featured/pulls" target="_blank" rel="noopener">PR</a></li><li>如果需要修改项目中图片，<a href="https://github.com/azl397985856/daily-featured/tree/master/assets" target="_blank" rel="noopener">这里</a>存放了项目中绘制图的源代码， 大家可以用<a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a>打开进行编辑。</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="./LICENSE">Apache-2.0</a></p>]]></content>
      
      
      <categories>
          
          <category> 每日一荐 </category>
          
          <category> 2019-12 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>致作者</title>
      <link href="/blog/2019/12/11/to-author/"/>
      <url>/blog/2019/12/11/to-author/</url>
      
        <content type="html"><![CDATA[<p>写给我敬爱的作者们，关于“云写书”的初衷，愿景，规划以及具体细节。</p><a id="more"></a><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>建立作者群，让大家参与进来的目的有三个。</p><ol><li>缩短写作的周期</li></ol><p>我希望这本书尽快与大家见面，毕竟时间就是金钱，一个人的力量还是很有限的，目前计划作者控制在2-10个人，参与人数不限制。</p><ol start="2"><li>结识志同道合的朋友，将来可以继续合作</li></ol><p>本来计划写别的书的，只是突然觉得LeetCode题解这块受众更大，大家普遍希望有这么一本书，因此才决定先写这本。我也希望之后写别的书的时候大家也可以在一起合作。</p><ol start="3"><li>更好地推广</li></ol><p>作者们也可以起到很好地宣传作用，毕竟是自己深度参与的书，大家宣传的意愿很会有的。</p><h2 id="愿景"><a href="#愿景" class="headerlink" title="愿景"></a>愿景</h2><p>背靠着 Github LeetCode排名第一的项目，再加上多个媒体平台的宣传推广，我个人觉得市场还是有的，另外市面上的多是以数据结构和算法为基础进行讲解，而不是LeetCode题解方面，这方面我认为是一个缺口。</p><p>另外我看了很多相关的资料，包括电子书，实体书以及博客，官方articles等，决定要不就是不够系统，要不就是不够通俗易懂。</p><p><code>我的受众群体是想找工作的LeetCode新手，帮助他们攻克一些高频题目，掌握解题技巧，更加有效率地刷题</code></p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><ul><li>2019-10 建立初步的成员名单，制定写作规范，联系LeetCode官方授权</li><li>2019-11 分配章节给大家，大家分别书写</li><li>2019-12 汇总大家的文章，进行审阅 &amp; 校验</li></ul><h2 id="Code-Style"><a href="#Code-Style" class="headerlink" title="Code Style"></a>Code Style</h2><p>TODO</p><h2 id="文章格式"><a href="#文章格式" class="headerlink" title="文章格式"></a>文章格式</h2><p>TODO</p><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>这个是我之前写的大纲，需要微调， 大家可以先大概看一下 <a href="https://lucifer.ren/blog/2019/10/03/draft/">https://lucifer.ren/blog/2019/10/03/draft/</a></p><h2 id="样张"><a href="#样张" class="headerlink" title="样张"></a>样张</h2><ul><li><p><a href="https://lucifer.ren/blog/2019/09/22/reverseList/">一文搞懂《链表反转》</a></p></li><li><p><a href="https://lucifer.ren/blog/2019/09/21/rotate-list/">文科生都能看懂的循环移位算法</a></p></li><li><p><a href="https://lucifer.ren/blog/2019/09/20/LSS/">一文看懂《最大子序列和问题》</a></p></li></ul><h2 id="如何参与"><a href="#如何参与" class="headerlink" title="如何参与"></a>如何参与</h2><p>要参加写作的， 给出你写过的文章，最好LeetCode或者算法相关，然后等待我审核，写文章的时候语言要求python，不会的可以花几个小时学习一下。</p><p>另外需要提供三种语言(分别是JS，Java和Python)的代码到我新建的一个<a href="https://github.com/leetcode-book/leetcode-solutions/tree/master/ch01" target="_blank" rel="noopener">仓库</a>中，专门给这本书放源码，按照语言和章节划分一下。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g88ad0upwwj30ta08pwfv.jpg" alt></p><p>作者们别忘记让我拉你进组织，我们的组织是<code>https://github.com/leetcode-book</code></p><p>如果语言有什么困难，直接群里沟通，我相信语言不是问题。 另外大家写题解的时候，一定少用语言特有的东西。</p><blockquote><p>有能力的欢迎提供其他语言的代码实现</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> LeetCode题解书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用web-component搭建企业级组件库</title>
      <link href="/blog/2019/12/11/web-components-enterprize/"/>
      <url>/blog/2019/12/11/web-components-enterprize/</url>
      
        <content type="html"><![CDATA[<p>前端目前比较主流的框架有react，vuejs，angular等。 我们通常去搭建组件库的时候都是基于某一种框架去搭建，比如ant-design是基于react搭建的UI组件库，而elementUI则是基于vuejs搭建的组件库。</p><p>虽然目前社区有相关工具，提供框架之间的转化服务，比如讲vuejs组件转化为react组件。但是毕竟是不同的框架，有不同的标准。因此框架api发生变动，那么你就需要重写转化逻辑，显然是不灵活的，因此我们暂不讨论这种情况。作为公司而言，就需要为不同的框架写不同的组件库，尽管逻辑都是一样的。</p><p>另外如果框架升级，比如从1.x升级到2.x，那么对应组件库就需要升级，如果公司的组件库有很多（vuejs，react，angular等），那么这种升级的概率就会更大。</p><a id="more"></a><h2 id="什么是web-component？"><a href="#什么是web-component？" class="headerlink" title="什么是web-component？"></a>什么是web-component？</h2><p>那么有没有更好的方案，一次编写，到处使用呢？</p><p>答案就是借助web component。</p><p>Web Components 是一系列加入<code>w3c</code>的HTML和DOM的特性，使得开发者可以创建可复用的组件。</p><p>由于web components是由w3c组织去推动的，因此它很有可能在不久的将来成为浏览器的一个标配。</p><p>Web Components 主要由以下四个部分组成：</p><ul><li>Custom Elements – 定义新html元素的api</li><li>Shadow DOM – Encapsulated DOM and styling, with composition</li><li>HTML Imports – Declarative methods of importing HTML documents into other documents</li><li>HTML Templates – The <code>&lt;template&gt;</code> element, which allows documents to contain inert chunks of DOM</li></ul><h2 id="web-component有什么优点"><a href="#web-component有什么优点" class="headerlink" title="web-component有什么优点"></a>web-component有什么优点</h2><p>使用web components搭建组件库能够带来什么好处呢？<br>前面说了，web components 是w3c推动的一系列的规范，它是一个标准。</p><p>如果我们使用web components的api 开发一个组件，这个组件是脱离框架存在的，也就是说<br>你可以在任何框架中使用它，当然也可以直接在原生js中使用。</p><p>我们无须为不同的框架编写不同的组件库。</p><p>使用web components编写的组件库的基本使用方法大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"/build/duiba.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 运营位组件 --&gt;</span><br><span class="line">&lt;operation-list&gt;<span class="xml"><span class="tag">&lt;/<span class="name">operation-list</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>毫不夸张地说， <code>web components</code> 就是未来。</p><p>但是web components的api还是相对复杂的，因此用原生的api开发web components还是<br>相对比较复杂的，就好像你直接用原生canvas api去开发游戏一样。</p><p>下面我们介绍下用于简化web components开发的库。</p><h2 id="polymer"><a href="#polymer" class="headerlink" title="polymer"></a>polymer</h2><p>polymer是我接触的第一个web componment开发库，那已经是很多年前的往事了。</p><blockquote><p>Build modern apps using web components</p></blockquote><p>更多介绍<a href="https://github.com/Polymer/polymer" target="_blank" rel="noopener">polymer</a></p><h2 id="stencil"><a href="#stencil" class="headerlink" title="stencil"></a>stencil</h2><p>stencil是在polymer之后出现的一个库。<br>第一次接触时在Polymer Summit 2017的分享上，这里贴下地址<a href="https://youtu.be/UfD-k7aHkQE" target="_blank" rel="noopener">Using Web Components in Ionic - Polymer Summit 2017</a>。</p><blockquote><p>Stencil is a tool developers use to create Web Components with some powerful features baked in, but it gets out of the way at runtime.</p></blockquote><p>那么powerful features具体指的是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Virtual DOM</span><br><span class="line">Async rendering (inspired by React Fiber)</span><br><span class="line">Reactive data-binding</span><br><span class="line">TypeScript</span><br><span class="line">JSX</span><br></pre></td></tr></table></figure><p>它也是一个用于生成web compoennt的tool。 不同的是她提供了更多的特性(Reactive data-binding,TypeScript,JSX, virtual dom)以及更强的性能(virtual dom, Async rendering).</p><p>细心的人可能已经发现了，我将Virtual DOM既归为特性，又归为性能，没错！ Virtual DOM提供了一种到真实dom的映射，使得开发者不必关心真实dom，从这个层面讲它是特性。 </p><p>从虚拟dom之间的diff，并将diff info patch到real dom（调和）的过程来看，它是性能。</p><p>用stencil开发web components体验大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Prop, State &#125; <span class="keyword">from</span> <span class="string">'@stencil/core'</span>;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  tag: <span class="string">'my-component'</span>,</span><br><span class="line">  styleUrl: <span class="string">'my-component.scss'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Indicate that name should be a property on our new component</span></span><br><span class="line">  @Prop() first: string;</span><br><span class="line"></span><br><span class="line">  @Prop() last: string;</span><br><span class="line"></span><br><span class="line">  @State() isVisible: boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        Hello, my name is &#123;<span class="keyword">this</span>.first&#125; &#123;<span class="keyword">this</span>.last&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>这是我基于<a href="https://github.com/ionic-team/stencil" target="_blank" rel="noopener">stenciljs</a> + <a href="https://github.com/storybooks/storybook" target="_blank" rel="noopener">storybook</a>写的一个小例子。大家可以clone，并运行查看效果。</p><p><a href="https://github.com/azl397985856/duiba-components" target="_blank" rel="noopener">duiba-components</a></p><p>通过这样搭建的企业级组件库，就可以轻松地为不同业务线提供基础组件库，而不必担心使用者（各个业务方）的技术栈。</p><p>将来业务方的框架升级（比如vue1升级到vue2），我们的组件库照样可以使用。</p><p>可以想象，如果es标准发展地够好，web components 等规范也足够普及，无框架时代将会到来。</p><blockquote><p>无框架，不代表不使用库。</p></blockquote><p>只需要借助工具库就可以开发足够通用的组件，也不需要babel这样的转换器，更不需要各种polyfill。<br>那么开发者大概会非常幸福吧，可惜这样的日子不可能存在，但是离这个目标足够近也是极好的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 组件化 </category>
          
          <category> web-component </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 组件化 </tag>
            
            <tag> web-component </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>累死累活干不过一个写PPT的</title>
      <link href="/blog/2019/12/11/ppt-data/"/>
      <url>/blog/2019/12/11/ppt-data/</url>
      
        <content type="html"><![CDATA[<p>无论是身处什么行业什么领域，数据分析越来越成为一向必不可少的技能，<br>而运用数据思维进行决策更能产生形成高质量的决策结果。</p><p>随着互联网的不断发展和物联网设备的不断普及，我们日常生活中的各种数据被存储下来，让我们可以通过定量分析数据，利用数据实现更好的决策制定。</p><a id="more"></a><p>现在越来越多的公司开始注重这一块，一方面自建数据体系，一方面去买一些数据。而对于我们个人似乎还没有意识到或者开始挖掘数据对我们的价值。</p><p>笔者最近的工作大都是做一些基础设施搭建和流程优化相关的工作。<br>这部分工作对很多人来说都是“隐形”的，对上层使用者来说很难有很大的感知。<br>对于领导来说，如果你只是闷头去做事情，他们也是很难知道你干的怎么样，如果这之间再加上<br>你没有什么反馈，就会给同事和领导一种“不靠谱”的感觉。</p><p>因此给予反馈和直观展示自己劳动成果的能力就显得非常重要。<br>然而如果你能很好展示自己的劳动成果，那么只需要将这个给老板看就是一种很好很直观的反馈。</p><p>这篇文章，我们来谈一下，如何量化我们的工作，如何将我们的工作成果展示出来。<br>如何让同事，让领导体会到我们工作的成果。我会通过几个例子来帮助大家快速理解，以及掌握这门“技术”<br>。</p><p>《让数据开口说话》是我给这篇文章的标题，让数据开口说话，你就可以少说一点，并且摆数据就是摆事实，<br>数据带来的说服力要比你说的话强很多。</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是一个对技术充满兴趣的程序员, 擅长前端工程化，前端性能优化，前端标准化等。</p><p>做过.net， 搞过 Java，现在是一名前端工程师。</p><p>除了我的本职工作外，我会在开源社区进行一些输出和分享，GitHub 共计获得 1.5W star。比较受欢迎的项目有<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">leetcode 题解</a> , <a href="https://github.com/azl397985856/fe-interview" target="_blank" rel="noopener">宇宙最强的前端面试指南</a> 和<br><a href="https://github.com/azl397985856/automate-everything" target="_blank" rel="noopener">我的第一本小书</a></p><h2 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h2><p>如果让数据开头说话，那么首先第一步你要有数据。</p><p>因此我们的第一步就是收集数据，那么在这之前你需要知道你需要什么数据。<br>这部分的内容随着每个人任务不同肯定是不一样的。因此有着很大的灵活性，</p><p>有一个指导思想就是对关键指标分解。<br>比如我现在要做打包时间进行优化，那么打包时间由哪些时间决定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打包时间 =  阶段1 时间 + 阶段2 时间 + 阶段3 时间</span><br></pre></td></tr></table></figure><p>我们减少打包时间肯定要减少其中一个或多个。</p><p>有时候我们无法找到这种简单的分解，那就教大家另外一个技巧：运用对比。</p><p>一方面可以基于时间进行对比，比如环比增长，同比增长等数据都是这么来的。</p><p>另一方面我们可以基于用户属性进行对比，比如用户年龄，性别，偏好，操作系统类型，<br>地域属性等。</p><p>下面我举几个例子。</p><h3 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h3><p>假如你被分配了一个任务。让你对项目的打包过程进行优化。</p><ul><li><p>你需要对打包时间进行优化，减少打包的时间</p></li><li><p>你需要对打包的最终产物进行优化，减少打出的包的包体大小。</p></li><li><p>将打包变得尽可能的简单，也就说尽量减少人为的操作过程。</p></li></ul><p>你接到了这样一个任务，你会如何去做？</p><p>这里我们不考虑具体的具体思路和细节。 假设你的架构思路，方案规划，各种 fallback 已经想好了。<br>我们如何通过上面提到的让数据说话的角度来收集数据呢？ 换句话说，我们需要收集哪些数据？</p><h4 id="打包时间"><a href="#打包时间" class="headerlink" title="打包时间"></a>打包时间</h4><p>对于打包时间的数据，最简单的我们计算一下总体的打包时间。</p><p>最后我们只需要对比优化前后的总体打包时间差异即可。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds546t088j30ec05dq3e.jpg" alt></p><p>这对于老板来说可能已经够了，但是这缺乏一些精确性，我们无法知道通过优化了哪个环节进行<br>减少了打包时间。 因此一种简单的改进是将打包划分为多个阶段，每个阶段分别进行统计计时 ⌛️ 。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds547ajtij30gs07q74w.jpg" alt></p><h4 id="包的大小"><a href="#包的大小" class="headerlink" title="包的大小"></a>包的大小</h4><p>包的大小的数据其实和上面讲的打包时间思路类似。</p><p>我们当然可以只统计总体包大小。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds548de0gj30cy05fmxc.jpg" alt></p><p>但是为了获得更加灵活的定制和更加精确的范围我们可以对包进行一定的划分。<br>这个划分可以是业务纬度，也可以是纯技术纬度。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54a42mjj30f005z3zb.jpg" alt></p><h4 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h4><p>这部分比较简单，我们只需要简单地统计手动操作的次数即可。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54azmgwj30f005i3yu.jpg" alt></p><p>通过收集以上的数据，我们就可以用数据来表示我们的成果，让数据说话，关于如何<br>使用这些数据，我们稍后讨论。</p><h3 id="页面加载性能优化"><a href="#页面加载性能优化" class="headerlink" title="页面加载性能优化"></a>页面加载性能优化</h3><p>假如你被分配了一个任务。让你对项目的页面加载速度进行优化。<br>你会怎么做？</p><p>这个任务有点太宽泛了，更多的时候会有一些更精确的指标，<br>比如将网络状态为<code>fast 3G</code>的<code>中端机型</code>的白屏时间降低到<code>3s以内</code>。</p><h4 id="timing"><a href="#timing" class="headerlink" title="timing"></a>timing</h4><p>性能优化的第一步就是测量，没有测量就没有优化。我们不能为了优化而优化， 而是看到了某些点需要优化才去优化的。 而发现这个点一个重要的方式就是要靠测量。</p><p>说到测量，普遍接受的方式是，在浏览器中进行打点，将浏览器打开网页的过程看作是一个旅行。<br>那么我们每到一个地方就拍张带有时间的照片（事件），最后我们对这些照片按照时间进行排列， 然后分析哪部分是我们的瓶颈点等。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54bnum5j30i70avdhp.jpg" alt="performance-api"></p><p>有了这些 timing 我们可以很方便的计算各项性能指标。我们还可以自定义一些我们关心的指标，比如请求时间（成功和失败分开统计），较长 js 操作时间，或者比较重要的功能等。</p><p>总之收集到这些数据之后，我们只需要根据我们的需求去定制一些指标即可。</p><p>这样我们就很容易展示出这样的画面：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54dcbs2j30eh074gm6.jpg" alt="render-perf"></p><h3 id="人效提升"><a href="#人效提升" class="headerlink" title="人效提升"></a>人效提升</h3><p>假如你是一个项目的管理者，上级分配给你一个任务，要在未来几个季度去做“研发效率提升”，<br>也就是提高“交付速度”。 你会怎么做这件事？</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>这个事情是比较主观的了，因此我们切实需要一些可以量化的东西来辅助我们。</p><p>我们考虑将需求进行拆分，变成一个个任务。一个需求可能有多个任务。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54e97btj309z0960ta.jpg" alt></p><p>我们考虑对每一个任务进行计时，而不是需求，因为需求有太大的差异。<br>我们可以针对任务进行分类，然后我们的目标就可以变成“减少同类任务的交付时长”。</p><p>但是这种粒度似乎还是有点大。我们可以采取标签的形式，对任务进行交叉分类。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54fb9nfj30ay09874x.jpg" alt></p><p>任务纬度可能还是有点太大，我们可以采取更小的粒度划分，比如模块和组件。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54gb6a0j30ly0akabf.jpg" alt></p><p>这样我们的统计纬度就丰富起来了，我们不仅可以总体进行统计分析，我们还可以根据 tag 和 tag 的组合进行汇总。</p><p>比如一个典型的统计结果大概是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- task1 (tagA)</span><br><span class="line"> - module1 (tagA)</span><br><span class="line">   - component1 (tagB)</span><br><span class="line">   - component2 (tagA)</span><br><span class="line"> - module2 (tagB)</span><br><span class="line"> - module3 (tagB)</span><br><span class="line">- task2 (tagA)</span><br><span class="line">- task3 (tagC)</span><br></pre></td></tr></table></figure><p>比如这里有一种 tag 叫“是否复用了以前的代码”，<br>那么我们就很容易统计出组件复用率，也就很容易很直观地知道前后的差距了。</p><h3 id="用户拉新和留存"><a href="#用户拉新和留存" class="headerlink" title="用户拉新和留存"></a>用户拉新和留存</h3><p>再比如我们需要做“用户拉新和留存”，我们应该怎么做？</p><p>这个留做思考题，大家可以思考一下。</p><p>我这里抛砖引玉一下，比如我们的统计纬度可以是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 用户访问时长 (tagA)</span><br><span class="line">- 跳出率 (tagB)</span><br><span class="line">- 新用户 (tagA)</span><br><span class="line">- 流失的老用户 (tagB)</span><br><span class="line">- 地址位置 (tagA)</span><br></pre></td></tr></table></figure><p>假如我的 tag 有两个分别是 用户 id 和时间， 我们就可以方便地统计每个用户的活动数据趋势。</p><h2 id="让数据说话"><a href="#让数据说话" class="headerlink" title="让数据说话"></a>让数据说话</h2><p>有了数据，我们如何通过数据来增强表现力呢？</p><p>一种非常有效的措施是可视化。现在的可视化引擎和工具有很多，功能也非常复杂。</p><p>但是我发现我个人需要的就那么几个，可能大家每个人需要的种类不大一样，<br>但是我相信作为个人，你需要的种类不会很多。因此自己根据自身的实际情况，<br>挑选适合自己的几种类型，做到迎刃有余就足够了。</p><p>对于我而言，我常用的是饼图，用来表示分布关系。 曲线图用来表示趋势。<br>用柱状图表示对比+趋势。用热度图表示离散的数据分布等等。</p><p>我们可以使用一些现有的成熟的产品来帮助我们将刚才我们收集到的数据转化为各种图表，<br>比如 <a href="https://www.canva.com/" target="_blank" rel="noopener">画布</a></p><blockquote><p>这个网站能做的图表种类比较少。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54h7bnqj311u0fotbt.jpg" alt></p><p>当然作为一名前端我们也可以自己写代码去更灵活地展示我们的数据，比如<a href="https://d3js.org/" target="_blank" rel="noopener">D3</a><br>或者百度的<a href="https://echarts.baidu.com/" target="_blank" rel="noopener">echarts</a></p><blockquote><p>任何类型的图表都可以做，只有你想不到，没有它做不到。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54j1tkej30zf0fx1kx.jpg" alt></p><p>相对折中一点，我们可以选择支持代码定制的一些产品，在特殊情况我们可以自定义。</p><h2 id="累死累活干不过做-PPT-的"><a href="#累死累活干不过做-PPT-的" class="headerlink" title="累死累活干不过做 PPT 的"></a>累死累活干不过做 PPT 的</h2><p>有了这些数据图表，是时候写一份 PPT 来秀一下了。</p><p>一种方式是使用你电脑的办公软件或者一些在线的幻灯片制作工具做，<br>比如<a href="https://slides.com/" target="_blank" rel="noopener">slides</a> 。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54k60j2j313b0iqwip.jpg" alt></p><p>另一种方式通过写代码的方式实现，作为程序员我推荐使用第二种。<br>这里推荐一款<code>nodejs cli 工具</code> <a href="https://github.com/ksky521/nodeppt" target="_blank" rel="noopener">nodeppt</a>,<br>还有另外一个<code>JS 框架</code> <a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">reveal.js</a> 。<br>上面提到的 slides 背后的原理就是它。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54lsifcj312l0ih7wh.jpg" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章我主要讲述了如何量化我们的工作，并将我们的工作成果展示出来。<br>从而摆脱“干了很多事情，却说不出来，甚至功劳被人无情拿走的尴尬局面”。</p><p>首先我们将了如何收集数据，收集数据的一些技巧，这里通过几个实际工作的例子，分别是“打包优化”，“性能优化”，“人效提升”，<br>“用户留存” ，来帮助大家理解这个<br>过程，掌握这个技巧。</p><p>有了数据之后，我们需要通过一些手段将其数据展示出来，给人直观的感受，最好有视觉冲击感。<br>这里我推荐了几个工具和平台，大家可以根据自己的情况选择。</p><p>最后结合我们实际情况，PPT 是一个很好的展示自己的东西，不管是晋升还是宣传都是很好的方式，<br>这里我也推荐了几个产品，帮助大家更快更好地将图表展示出来。</p><p>让数据开口说话，你就可以少说一点，并且摆数据就是摆事实，<br>数据带来的说服力要比你说的话强很多。</p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>最近我重新整理了下自己的公众号，并且我还给他换了一个名字《脑洞前端》，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解前端是我的目标。</p><p>之后我的文章同步到微信公众号 脑洞前端 ，您可以关注获取最新的文章，或者和我进行交流。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds4sh51a6j30km0komyv.jpg" width="50%" height="50%" alt="gongzhonghao" align="center"><h2 id="交流群"><a href="#交流群" class="headerlink" title="交流群"></a>交流群</h2><p>现在还是初级阶段，需要大家的意见和反馈，为了减少沟通成本，我组建了交流群。大家可以扫码进入</p><h3 id="QQ-群"><a href="#QQ-群" class="headerlink" title="QQ 群"></a>QQ 群</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54ma44fj306a082q36.jpg" alt="qq-group-chat"></p><h3 id="微信群"><a href="#微信群" class="headerlink" title="微信群"></a>微信群</h3><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds5735kizj30e80e80tb.jpg" width="50%" height="50%" alt="JavaScript" align="center"><p>(由于微信的限制，100 个人以上只能邀请加入， 你可以添加我的机器人回复“大前端”拉你进群)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技能 </tag>
            
            <tag> PPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值得关注的技术类大会</title>
      <link href="/blog/2019/12/11/tech-conf/"/>
      <url>/blog/2019/12/11/tech-conf/</url>
      
        <content type="html"><![CDATA[<p>作为一个技术人，怎么能不参加和关注几场技术大会呢？让我们来看下那些你不能错过的技术大会吧。</p><a id="more"></a><h2 id="JSConf"><a href="#JSConf" class="headerlink" title="JSConf"></a>JSConf</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7d50s2862j30r10iwjrx.jpg" alt><br><a href="https://jsconf.com/" target="_blank" rel="noopener">地址</a></p><h2 id="React-Conf"><a href="#React-Conf" class="headerlink" title="React Conf"></a>React Conf</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wabkh6lyj31gk0a5jrl.jpg" alt><br><a href="https://conf.reactjs.org/" target="_blank" rel="noopener">地址</a></p><h2 id="Google-IO"><a href="#Google-IO" class="headerlink" title="Google IO"></a>Google IO</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7d51qe2drj31200h674i.jpg" alt><br><a href="https://events.google.com/io/" target="_blank" rel="noopener">地址</a></p><h2 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7d52bgjgpj30sm0hr76u.jpg" alt><br><a href="http://d2forum.alibaba-inc.com/#/index?_k=ug35gm" target="_blank" rel="noopener">地址</a></p><h2 id="QCon"><a href="#QCon" class="headerlink" title="QCon"></a>QCon</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7d52uctmoj31110hiwhd.jpg" alt><br><a href="https://www.infoq.com/qcon/" target="_blank" rel="noopener">地址</a></p><h2 id="更多技术大会"><a href="#更多技术大会" class="headerlink" title="更多技术大会"></a>更多技术大会</h2><ul><li><a href="https://juejin.im/events" target="_blank" rel="noopener">https://juejin.im/events</a></li><li><a href="https://segmentfault.com/events" target="_blank" rel="noopener">https://segmentfault.com/events</a></li><li><a href="https://www.huodongxing.com" target="_blank" rel="noopener">https://www.huodongxing.com</a></li><li><a href="https://www.bagevent.com" target="_blank" rel="noopener">https://www.bagevent.com</a></li><li><a href="https://www.hdb.com" target="_blank" rel="noopener">https://www.hdb.com</a></li><li><a href="https://www.meetup.com" target="_blank" rel="noopener">https://www.meetup.com</a></li><li>…</li></ul><p>欢迎大家补充～</p>]]></content>
      
      
      <categories>
          
          <category> 技术大会 </category>
          
          <category> JSConf </category>
          
          <category> React Conf </category>
          
          <category> Google IO </category>
          
          <category> D2 </category>
          
          <category> QCon </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术大会 </tag>
            
            <tag> JSConf </tag>
            
            <tag> Google IO </tag>
            
            <tag> D2 </tag>
            
            <tag> QCon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【RFC】XXX 公司监控体系需求与技术调研</title>
      <link href="/blog/2019/12/11/rfc-monitor/"/>
      <url>/blog/2019/12/11/rfc-monitor/</url>
      
        <content type="html"><![CDATA[<p>线上问题回溯困难，无法快速准确重现问题，导致客户满意度下降，影响团队交付效率和质量，建立完善的监控体系可以很好的解决这个问题。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>线上问题回溯困难，无法快速准确重现问题，导致客户满意度下降，影响团队交付效率和质量。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>期望有一套工具，系统或者平台，可以满足：</p><ol><li>在收到用户反馈的时候能够快速重现问题并解决。</li><li>测试同学发现问题，不需要花费大量事件和开发人员重现，沟通，以及记录问题重现路径等</li><li>线上发现问题可以进行告警，防止大规模用户有问题，并且不能及时感知和解决。</li><li>缩短团队内部 BUG 修复的闭环流程，减少非本质复杂度问题的干扰，快速将问题聚焦到具体的代码。</li></ol><p>带着上面的需求，我们来看下市面上已有的经典方案， 在这里挑选几个具有代表性的。</p><h2 id="市面上已有的方案对比"><a href="#市面上已有的方案对比" class="headerlink" title="市面上已有的方案对比"></a>市面上已有的方案对比</h2><h3 id="LogRocket"><a href="#LogRocket" class="headerlink" title="LogRocket"></a>LogRocket</h3><p>一句话概括： 用看录像的方式重现问题。</p><p>官网地址： <a href="https://logrocket.com/" target="_blank" rel="noopener">https://logrocket.com/</a></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8nsefw6j31ji0braaj.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8mp9lp5j31bc0qr410.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8myz28pj31su0u0ta3.jpg" alt></p><p>更多功能： <a href="https://docs.logrocket.com/docs" target="_blank" rel="noopener">https://docs.logrocket.com/docs</a></p><h4 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8kqmquvj313k0opwfb.jpg" alt></p><h4 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8lgqwlgj30rg0n3wf0.jpg" alt></p><h3 id="Sentry"><a href="#Sentry" class="headerlink" title="Sentry"></a>Sentry</h3><p>一句话概括： 开源，强大的监控平台。</p><p>官网地址： <a href="https://sentry.io/" target="_blank" rel="noopener">https://sentry.io/</a></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>功能较多，提供了较多的概念和功能，比如 Context，ENvironments，Breadcrumbs 等。另外其和 CI，CD 集成地也非常好。 详细内容： <a href="https://docs.sentry.io/workflow/releases/?platform=node" target="_blank" rel="noopener">https://docs.sentry.io/workflow/releases/?platform=node</a></p><p>另外其支持的平台和扩展功能非常多，如果对这部分有特殊要求，Sentry 无疑是优先考虑的选择。</p><h4 id="接入方式-1"><a href="#接入方式-1" class="headerlink" title="接入方式"></a>接入方式</h4><ul><li>Sign up for an account</li><li>Install your SDK</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using yarn</span></span><br><span class="line">$ yarn add @sentry/node@5.8.0</span><br></pre></td></tr></table></figure><ul><li>Configure it</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sentry = <span class="built_in">require</span>(<span class="string">"@sentry/node"</span>);</span><br><span class="line">Sentry.init(&#123; <span class="attr">dsn</span>: <span class="string">"https://&lt;key&gt;@sentry.io/&lt;project&gt;"</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="价格-1"><a href="#价格-1" class="headerlink" title="价格"></a>价格</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w8qipkskj30x10jt758.jpg" alt></p><h3 id="FunDebug"><a href="#FunDebug" class="headerlink" title="FunDebug"></a>FunDebug</h3><p>一句话概括：国内知名度较高的监控工具，国内业务这块很有竞争力。</p><p><a href="https://www.fundebug.com/" target="_blank" rel="noopener">https://www.fundebug.com/</a></p><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>支持小程序，小游戏。多种现成的报警方式，支持 WebHook，智能报警（同样的代码产生的同一个错误，在不同浏览器上的报错信息是各不相同的），内置团队协作工具。</p><h4 id="接入方式-2"><a href="#接入方式-2" class="headerlink" title="接入方式"></a>接入方式</h4><p>这里以 Vue 项目为例。</p><ol><li><p>免费注册</p></li><li><p>创建项目</p></li><li><p>配置</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install fundebug-javascript fundebug-vue --save</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fundebug <span class="keyword">from</span> <span class="string">"fundebug-javascript"</span>;</span><br><span class="line"><span class="keyword">import</span> fundebugVue <span class="keyword">from</span> <span class="string">"fundebug-vue"</span>;</span><br><span class="line">fundebug.init(&#123;</span><br><span class="line">  apikey: <span class="string">"API-KEY"</span></span><br><span class="line">&#125;);</span><br><span class="line">fundebugVue(fundebug, Vue);</span><br></pre></td></tr></table></figure><h4 id="价格-2"><a href="#价格-2" class="headerlink" title="价格"></a>价格</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8w9mhtq44j30x60mb3z3.jpg" alt></p><h2 id="其他后期可能功能点"><a href="#其他后期可能功能点" class="headerlink" title="其他后期可能功能点"></a>其他后期可能功能点</h2><ol><li><p>性能监控</p></li><li><p>用户行为监控（已经有埋点，不不确定是否可以 Cover 这个需求）</p></li></ol><h2 id="自研"><a href="#自研" class="headerlink" title="自研"></a>自研</h2><p>假设我们已经做好了我们自己的监控平台，我们需要对公司内部甚至外部宣传我们的监控平台，我们会怎么进行宣传。</p><p>然后带着这些东西，我们进行规划，技术选型，排期，写代码，测试，上线。</p><h3 id="宣传语"><a href="#宣传语" class="headerlink" title="宣传语"></a>宣传语</h3><ol><li>接入方便，侵入性小</li><li>支持多端，扩展性强（支持多种框架定制接入），完美契合业务发展</li><li>打通客服系统，开发直接对接到客户，免去了中间对接的信息缺失和时间损耗。</li><li>重现率高，能够准确重现用户的现场情况</li><li>打通报警系统</li><li>打通调试平台<br>…</li></ol><h3 id="优劣分析"><a href="#优劣分析" class="headerlink" title="优劣分析"></a>优劣分析</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>完美契合我们自身的业务，后期好维护和增添功能</p><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><p>如果功能需要做的超出市面，需要耗费巨大的人力和财力。</p><p>如果市面上不断发展，功能不能断完善，内部如果想要这样的功能要么继续追赶，要不买一套商用的，但是之前的努力岂不是白费了。除非内部两套系统，但是这种模式未免太反直觉。</p><h3 id="架构与选型"><a href="#架构与选型" class="headerlink" title="架构与选型"></a>架构与选型</h3><p>对外都宣传完了，我们需要具体开始进行架构与选型了。</p><h4 id="定义对外接口"><a href="#定义对外接口" class="headerlink" title="定义对外接口"></a>定义对外接口</h4><p>我们对外宣传的目标是<code>接入方便，侵入性小</code>。因此一定要简洁，这里参考了以上几个平台的写法，其实这几个平台的都是大同小异。</p><ol><li>注册应用获取 AppId</li><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save @lucifer/monitor</span><br></pre></td></tr></table></figure><ol start="3"><li>引用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> monitor <span class="keyword">from</span> <span class="string">"@lucifer/monitor"</span>;</span><br><span class="line">monitor.init(&#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    name: <span class="string">""</span>,</span><br><span class="line">    email: <span class="string">""</span>,</span><br><span class="line">    mobile: <span class="string">""</span>,</span><br><span class="line">    isVIP: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  appId: <span class="string">"lucifer520"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>多端和多框架支持</li></ol><p>Vue：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue form <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> monitor <span class="keyword">from</span> <span class="string">'@lucifer/connectors/vue'</span>;</span><br><span class="line">monitor.init(&#123;</span><br><span class="line">    user: &#123;</span><br><span class="line">        name: <span class="string">''</span>,</span><br><span class="line">        email: <span class="string">''</span>,</span><br><span class="line">        mobile: <span class="string">''</span>,</span><br><span class="line">        isVIP: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    appId: <span class="string">'lucifer520'</span></span><br><span class="line">&#125;)</span><br><span class="line">monitor.use(Vue)</span><br></pre></td></tr></table></figure><p>Wechat：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> monitor <span class="keyword">from</span> <span class="string">"@lucifer/connectors/wechat"</span>;</span><br><span class="line">monitor.init(&#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    name: <span class="string">""</span>,</span><br><span class="line">    email: <span class="string">""</span>,</span><br><span class="line">    mobile: <span class="string">""</span>,</span><br><span class="line">    isVIP: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  appId: <span class="string">"lucifer520"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="定义内部接口"><a href="#定义内部接口" class="headerlink" title="定义内部接口"></a>定义内部接口</h4><p>架构图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xj6xnibej30xd0hzgo5.jpg" alt></p><p>接口系统交互图会在详细设计中给出，这里只给出大致范围：</p><ul><li>logs 服务器和告警平台的交互接口</li><li>rules 的规则解析</li><li>logs 的解析</li><li>构建系统对接</li><li>调试系统对接</li><li>…</li></ul><h4 id="业务形态特点"><a href="#业务形态特点" class="headerlink" title="业务形态特点"></a>业务形态特点</h4><ul><li>数据量会随着采集规模增大而增加，因此预估用户数量以及增长速度对系统架构设计有很大影响</li><li>终端的上报策略对影响很大，断网，弱网等情况如何上报也对结果有影响</li></ul><h4 id="框架选型-amp-规范-amp-约定"><a href="#框架选型-amp-规范-amp-约定" class="headerlink" title="框架选型 &amp; 规范 &amp; 约定"></a>框架选型 &amp; 规范 &amp; 约定</h4><p>暂无</p><h2 id="其他解决方案"><a href="#其他解决方案" class="headerlink" title="其他解决方案"></a>其他解决方案</h2><ul><li>Badjs</li><li>FrontJS</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> RFC </tag>
            
            <tag> 技术调研 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞懂《链表反转》</title>
      <link href="/blog/2019/12/11/reverseList/"/>
      <url>/blog/2019/12/11/reverseList/</url>
      
        <content type="html"><![CDATA[<p>翻转链表一直都是热门题目，笔者就在某大型互联网公司的面试题中碰到过这种题目，这种题目很常常见，相对应的变形和扩展也很多，今天我们就来攻克它吧。</p><a id="more"></a><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>反转链表是这个系列中最简单的了，没有别的要求，就是将一个链表从头到尾进行反转，最后返回反转后的链表即可。</p><p>我们来看一个 LeetCode 题目, <a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a>, 官方难度为 Easy。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">反转一个单链表。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line">进阶:</span><br><span class="line">你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>链表的翻转过程，初始化一个为 null 的 previous node（prev），然后遍历链表的同时，当前 node （curr）的下一个（next）指向前一个 node（prev）， 在改变当前 node 的指向之前，用一个临时变量记录当前 node 的下一个 node（curr.next). 即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ListNode temp = curr.next;</span><br><span class="line">curr.next = prev;</span><br><span class="line">prev = curr;</span><br><span class="line">curr = temp;</span><br></pre></td></tr></table></figure><p>举例如图：翻转整个链表 1-&gt;2-&gt;3-&gt;4-&gt;null -&gt; 4-&gt;3-&gt;2-&gt;1-&gt;null</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54nob8uj31400u00tx.jpg" alt></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我们直接来看下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cur = head;</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="keyword">const</span> next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不再赘述，如果不理解，想看更多更详细内容，请参考我的<a href="https://github.com/azl397985856/leetcode/blob/master/problems/206.reverse-linked-list.md" target="_blank" rel="noopener">LeetCode 题解 - 206.reverse-linked-list</a></p><h2 id="分组反转"><a href="#分组反转" class="headerlink" title="分组反转"></a>分组反转</h2><p>这个题目和上面的有点类似，只不过我们并不是从头到尾反转，而是每 k 个为一组进行反转。LeetCode 同样有原题<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a>官方难度为 Hard。</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</span><br><span class="line"></span><br><span class="line">k 是一个正整数，它的值小于或等于链表的长度。</span><br><span class="line"></span><br><span class="line">如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span><br><span class="line"></span><br><span class="line">示例 :</span><br><span class="line"></span><br><span class="line">给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line"></span><br><span class="line">当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">说明 :</span><br><span class="line"></span><br><span class="line">你的算法只能使用常数的额外空间。</span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们的思路还是一样的，我们把每 k 位的位置当成是尾节点即可。 我们的任务就是每次反转头尾之间的所有节点，<br>然后将链表重新拼起来即可。 我们先来写一下<code>反转头尾之间的所有节点</code>这个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 翻转head到tail之间的部分，不包括head和tail</span></span><br><span class="line"><span class="comment">// 返回原链表的第一个元素，也就是翻转后的最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head, tail</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">let</span> cur = head.next;</span><br><span class="line">  first = cur;</span><br><span class="line">  <span class="keyword">let</span> pre = head; <span class="comment">// 这里就是翻转不包括head的原因，否则就是head.pre了（当然我们没有pre指针）</span></span><br><span class="line">  <span class="comment">// 这里就是翻转不包括tail的原因，否则就是tail.next了。</span></span><br><span class="line">  <span class="keyword">while</span> (cur !== tail) &#123;</span><br><span class="line">    <span class="keyword">const</span> next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拼接</span></span><br><span class="line">  head.next = pre;</span><br><span class="line">  first.next = cur;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的反转不包括 head 和 tail，并不是我一开始的思路，但是在慢慢想的过程，发现这样写代码会更优雅。</p><p>上面的代码如果是 head 是我们的头节点，tail 是 null，那么就等效于上面的那道题。也就是说我们的这个 k 分组是上面题目的一般形式，当 k 为链表长度的时候，就会变成上面那道题了。</p><p>还有一点不同的是，我们每次反转之后都要对链表进行拼接，这是上面那个反转所没有的，这里要注意一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head.next = pre;</span><br><span class="line">first.next = cur;</span><br></pre></td></tr></table></figure><p>这里是对每一组（<code>k个nodes</code>）进行翻转，</p><ol><li><p>先分组，用一个<code>count</code>变量记录当前节点的个数</p></li><li><p>用一个<code>start</code> 变量记录当前分组的起始节点位置的前一个节点</p></li><li><p>用一个<code>end</code>变量记录要翻转的最后一个节点位置</p></li><li><p>翻转一组（<code>k个nodes</code>）即<code>(start, end) - start and end exclusively</code>。</p></li><li><p>翻转后，<code>start</code>指向翻转后链表, 区间<code>（start，end）</code>中的最后一个节点, 返回<code>start</code> 节点。</p></li><li><p>如果不需要翻转，<code>end</code> 就往后移动一个（<code>end=end.next</code>)，每一次移动，都要<code>count+1</code>.</p></li></ol><p>如图所示 步骤 4 和 5： 翻转区间链表区间<code>（start， end）</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54ol1rcj30zd0qxmxy.jpg" alt="reverse linked list range in (start, end)"></p><p>举例如图，<code>head=[1,2,3,4,5,6,7,8], k = 3</code></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54qkdnkj312u0u0n2u.jpg" alt="reverse k nodes in linked list"></p><blockquote><p><strong>NOTE</strong>: 一般情况下对链表的操作，都有可能会引入一个新的<code>dummy node</code>，因为<code>head</code>有可能会改变。这里<code>head 从1-&gt;3</code>,<br><code>dummy (List(0))</code>保持不变。</p></blockquote><p>这种做法的时间复杂度为 O(n)，空间复杂度为 O(1)。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseKGroupsLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="keyword">null</span> || k == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">      &#125;</span><br><span class="line">      ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">      dummy.next = head;</span><br><span class="line"></span><br><span class="line">      ListNode start = dummy;</span><br><span class="line">      ListNode end = head;</span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (end != <span class="keyword">null</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// group</span></span><br><span class="line">        <span class="keyword">if</span> (count % k == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// reverse linked list (start, end]</span></span><br><span class="line">          start = reverse(start, end.next);</span><br><span class="line">          end = start.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          end = end.next;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * reverse linked list from range (start, end), return last node.</span></span><br><span class="line"><span class="comment">     * for example:</span></span><br><span class="line"><span class="comment">     * 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8</span></span><br><span class="line"><span class="comment">     * |           |</span></span><br><span class="line"><span class="comment">     * start       end</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * After call start = reverse(start, end)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 0-&gt;3-&gt;2-&gt;1-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8</span></span><br><span class="line"><span class="comment">     *          |  |</span></span><br><span class="line"><span class="comment">     *       start end</span></span><br><span class="line"><span class="comment">     *       first</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode start, ListNode end)</span> </span>&#123;</span><br><span class="line">      ListNode curr = start.next;</span><br><span class="line">      ListNode prev = start;</span><br><span class="line">      ListNode first = curr;</span><br><span class="line">      <span class="keyword">while</span> (curr != end)&#123;</span><br><span class="line">        ListNode temp = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      start.next = prev;</span><br><span class="line">      first.next = curr;</span><br><span class="line">      <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python3 代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        start = dummy</span><br><span class="line">        end = head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> count % k == <span class="number">0</span>:</span><br><span class="line">                start = self.reverse(start, end.next)</span><br><span class="line">                end = start.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = end.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        prev, curr = start, start.next</span><br><span class="line">        first = curr</span><br><span class="line">        <span class="keyword">while</span> curr != end:</span><br><span class="line">            temp = curr.next</span><br><span class="line">            curr.next = prev</span><br><span class="line">            prev = curr</span><br><span class="line">            curr = temp</span><br><span class="line">        start.next = prev</span><br><span class="line">        first.next = curr</span><br><span class="line">        <span class="keyword">return</span> first</span><br></pre></td></tr></table></figure><p>JavaScript 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转head到tail之间的部分，不包括head和tail</span></span><br><span class="line"><span class="comment">// 返回原链表的第一个元素，也就是翻转后的最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span>(<span class="params">head, tail</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">let</span> cur = head.next;</span><br><span class="line">  first = cur;</span><br><span class="line">  <span class="keyword">let</span> pre = head; <span class="comment">// 这里就是翻转不包括head的原因</span></span><br><span class="line">  <span class="keyword">while</span> (cur !== tail) &#123;</span><br><span class="line">    <span class="comment">// 这里就是翻转不包括tail的原因</span></span><br><span class="line">    <span class="keyword">const</span> next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    cur = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拼接</span></span><br><span class="line">  head.next = pre;</span><br><span class="line">  first.next = cur;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;ListNode&#125;</span> <span class="variable">head</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;ListNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseKGroup = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || k === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> dummy = &#123;</span><br><span class="line">    next: head,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> start = dummy;</span><br><span class="line">  <span class="keyword">let</span> end = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (end !== <span class="literal">null</span>) &#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span> (cnt % k !== <span class="number">0</span>) &#123;</span><br><span class="line">      end = end.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      start = reverseList(start, end.next);</span><br><span class="line">      end = start.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里不再赘述，如果不理解，想看更多更详细内容，请参考我的<a href="https://github.com/azl397985856/leetcode/blob/master/problems/25.reverse-nodes-in-k-groups-cn.md" target="_blank" rel="noopener">LeetCode 题解 - 25.reverse-nodes-in-k-groups-cn</a></p><h2 id="分组反转-增强版"><a href="#分组反转-增强版" class="headerlink" title="分组反转 - 增强版"></a>分组反转 - 增强版</h2><p>这道题目来自字节跳动面试题。</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>要求从后往前以k个为一组进行翻转。</p><p>例子，1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8, k = 3,</p><p>从后往前以k=3为一组，</p><p>6-&gt;7-&gt;8 为一组翻转为8-&gt;7-&gt;6，<br>3-&gt;4-&gt;5为一组翻转为5-&gt;4-&gt;3.<br>1-&gt;2只有2个nodes少于k=3个，不翻转。<br>最后返回： 1-&gt;2-&gt;5-&gt;4-&gt;3-&gt;8-&gt;7-&gt;6</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这里的思路跟从前往后以<code>k</code>个为一组进行翻转类似，可以进行预处理：</p><ol><li><p>翻转链表</p></li><li><p>对翻转后的链表进行从前往后以k为一组翻转。</p></li><li><p>翻转步骤2中得到的链表。</p></li></ol><p>例子：<code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8, k = 3</code></p><ol><li><p>翻转链表得到：<code>8-&gt;7-&gt;6-&gt;5-&gt;4-&gt;3-&gt;2-&gt;1</code></p></li><li><p>以k为一组翻转： <code>6-&gt;7-&gt;8-&gt;3-&gt;4-&gt;5-&gt;2-&gt;1</code></p></li><li><p>翻转步骤#2链表： <code>1-&gt;2-&gt;5-&gt;4-&gt;3-&gt;8-&gt;7-&gt;6</code></p></li></ol><h2 id="类似题目"><a href="#类似题目" class="headerlink" title="类似题目"></a>类似题目</h2><ul><li><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> LeetCode </category>
          
          <category> 链表反转 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 字节跳动 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文科生都能看懂的循环移位算法</title>
      <link href="/blog/2019/12/11/rotate-list/"/>
      <url>/blog/2019/12/11/rotate-list/</url>
      
        <content type="html"><![CDATA[<p>循环移位问题真的是一个特别经典的问题了，今天我们就来攻克它。</p><p>循环移位的表现形式有很多种，就数据结构来说包括<code>数组</code>，<code>字符串</code>，<code>链表</code>等。就算法来说，有<code>包含问题</code>，<code>直接移动问题</code>，还有<code>查找问题</code>等。</p><p>虽然表现形式有很多，但是本质都是一样的，因为从逻辑上来讲其实他们都是线性数据结构，那么让我们来看一下吧。</p><a id="more"></a><h2 id="数组循环移位"><a href="#数组循环移位" class="headerlink" title="数组循环移位"></a>数组循环移位</h2><p>LeetCode 和 编程之美等都有这道题目，题目难度为 Easy。<a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">LeeCode 链接</a></p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</span><br><span class="line">要求使用空间复杂度为 O(1) 的 原地 算法。</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54rgugtj30o8048mxf.jpg" alt></p><h3 id="不符合题意的解法"><a href="#不符合题意的解法" class="headerlink" title="不符合题意的解法"></a>不符合题意的解法</h3><p>如果你拿到这道题没有思路，不要紧张，因为你不是一个人。</p><p>让我们先不要管题目的时间和空间复杂度的限制， 来用最最普通的方式实现它，看能不能得出一点思路。</p><p>最简单的做法就是新开辟一个完全一样的数组，然后每次移动的时候从 copy 的数组中取即可，由于新开辟的数组不会被改变，因此这种做法可行，我们直接看下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RShift</span>(<span class="params">list, k</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 空间复杂度O(n)</span></span><br><span class="line">  <span class="comment">// 时间复杂度O(n)</span></span><br><span class="line">  <span class="keyword">const</span> copy = [...list];</span><br><span class="line">  <span class="keyword">const</span> n = list.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    list[(k + i) % n] = copy[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们还可以优化一下，如果 k 是 N 的倍数，实际上是不需要做任何移动的，因此直接返回即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RShift</span>(<span class="params">list, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = list.length;</span><br><span class="line">  <span class="keyword">if</span> (k % n === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 剩下代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们需要覆盖原来的数组，那么原来的数组中的数据就会缺失，因此我们最简单的就是开辟一个<br>完全一样的数组，这样就避免了问题，但是这样的空间复杂度是 N。我们有没有办法优化这个过程呢？</p><p>而且如果 k 是负数呢？ 这其实在考察我们思考问题的严谨性。</p><p>除此之外，我们还应该思考：</p><ul><li>k 的范围是多少？如果很大，我的算法还有效么？</li><li>n 的范围是多少？如果很大，我的算法还有效么?</li></ul><p>上面两个问题的答案都是<code>有效</code>。 因为 k 就算再大，我们只需要求模，求模的值当成新的 k 即可。<br>因此 k 最大不过就是 n。 如果 n 很大，由于我们的算法是 O(N)的复杂度，也就是线性，这个复杂度还是比较理想的。</p><h3 id="时间换空间"><a href="#时间换空间" class="headerlink" title="时间换空间"></a>时间换空间</h3><p>我们来试一下常数空间复杂度的解法，这种做法思路很简单，我们只需要每次移动一位，移动 k 次即可，移动一次的时间复杂度是 1，k 次共用一个变量即可，因此总的空间复杂度可以降低到 1。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54ruiucj30pw0bemyf.jpg" alt></p><p>我们来看下代码，这次我们把上面提到的 k 为负数的情况考虑进去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RShift</span>(<span class="params">list, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = list.length;</span><br><span class="line">  <span class="keyword">if</span> (k % n === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="built_in">Math</span>.abs(k &gt; <span class="number">0</span> ? k % n : n + (k % n));</span><br><span class="line">  <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cnt--) &#123;</span><br><span class="line">    t = list[n - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 右移一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      list[i] = list[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    list[<span class="number">0</span>] = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然上面的解法是常数空间复杂度，但是时间复杂度是 O(N * K)，K 取值不限制的话，就是 O(N^2)，<br>还是不满足题意。不过没关系，我们继续思考。</p><p>我们再来看一种空间换时间的做法，这种做法的思路是拼接一个完全一样的数组到当前数组的尾部，然后问题就转化为<code>截取数组使之满足右移的效果</code>，这样的时间复杂度 O(N),空间复杂度是 O(N).</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54sbcbnj30jm0403yb.jpg" alt></p><p>我们看下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RShift</span>(<span class="params">list, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = list.length;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="built_in">Math</span>.abs(k &gt; <span class="number">0</span> ? k % n : n + (k % n));</span><br><span class="line">  <span class="keyword">return</span> list.concat([...list]).slice(n - i, n * <span class="number">2</span> - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈哈，虽然离题目越来越远了，但是扩展了思路，也不错，这就是刷题的乐趣。</p><h3 id="三次翻转法"><a href="#三次翻转法" class="headerlink" title="三次翻转法"></a>三次翻转法</h3><p>我们来看下另外一种方法 - 经典的<code>三次翻转法</code>，我们可以这么做：</p><ul><li>先把[0, n - k - 1]翻转</li><li>然后把[n - k, n - 1]翻转</li><li>最后把[0, n - 1]翻转</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54tbiz3j30dd072wec.jpg" alt></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">list, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    t = list[start];</span><br><span class="line">    list[start] = list[end];</span><br><span class="line">    list[end] = t;</span><br><span class="line">    start++;</span><br><span class="line">    end--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RShift</span>(<span class="params">list, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = list.length;</span><br><span class="line">  <span class="keyword">if</span> (k % n === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  reverse(list, <span class="number">0</span>, n - k - <span class="number">1</span>);</span><br><span class="line">  reverse(list, n - k, n - <span class="number">1</span>);</span><br><span class="line">  reverse(list, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里给一个简单的数学证明：</p><ul><li><p>对于[0, n - k - 1] 部分，我们翻转一次后新的坐标 y 和之前的坐标 x 的关系可以表示为<code>y = n - 1 - k - x</code></p></li><li><p>对于[n - k, n -1] 部分，我们翻转一次后新的坐标 y 和之前的坐标 x 的关系可以表示为<code>y = 2 * n - 1 - k - x</code></p></li><li><p>最后我们整体进行翻转的时候，新的坐标 y 和之前的坐标 x 的关系可以表示为</p><ol><li><code>y = n - 1 - (n - 1 - k - x)</code> 即 <code>y = k + x</code> (0 &lt;= x &lt;= n - k - 1)</li><li><code>y = n - 1 - (2 * n - 1 - k - x)</code> 即 <code>y = k + x - n</code> (n - k &lt;= x &lt;= n - 1)</li></ol></li></ul><p>正好满足我们的位移条件。</p><p>这种做法时间复杂度是 O(N)空间复杂度 O(1)，终于满足了我们的要求。</p><h2 id="字符串循环移位"><a href="#字符串循环移位" class="headerlink" title="字符串循环移位"></a>字符串循环移位</h2><p>字符串和数组真的是一模一样，因为字符串也可以看成是字符序列，因此字符串就是数组。本质上来说，它和数组循环移位题目没有任何区别， 现在让我们来通过一道题来感受下。</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串 s1 和 s2，要求判定 s2 是否能被 s1 循环移位得到的字符串包含。比如，给定 s1 = AABCD 和 s2 = CDAA，返回 true 。 给定 s1 = ABCD，s2 = ACBD， 则返回 false。</p><blockquote><p>题目来自《编程之美》</p></blockquote><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>s1 我们每次移动一位，然后判断逐一判断以每一个位置开头的字符串是否包含 s2，如果包含则返回 true，否则继续匹配。</p><p>这种做法很暴力，时间复杂度 O(n^2)，在 n 特别大的时候不是很有效。</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RIncludes</span>(<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = s1.length;</span><br><span class="line">  <span class="keyword">const</span> m = s2.length;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> p1; <span class="comment">// s1的指针</span></span><br><span class="line">  <span class="keyword">let</span> p2; <span class="comment">// s2的指针</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    t = s1[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      s1[j] = s1[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s1[n - <span class="number">1</span>] = t;</span><br><span class="line">    p1 = <span class="number">0</span>;</span><br><span class="line">    p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; n &amp;&amp; p2 &lt; m) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s1[p1] === s2[p2]) &#123;</span><br><span class="line">        p1++;</span><br><span class="line">        p2++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p2 === m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="巧用模运算"><a href="#巧用模运算" class="headerlink" title="巧用模运算"></a>巧用模运算</h3><p>另外一种方法就是上面那种空间换时间的方式，我们将两个 s1 连接到一起，然后直接双指针即可，这里不再赘述。</p><p>这种方法虽然巧妙，但是我们花费了额外的 N 的空间，能否不借助额外的空间呢？答案是可以的，我们可以假想已经存在了另外一个相同的 s1，并且我们将它连接到 s1 的末尾。注意这里是假想，实际不存在，因此空间复杂度是 O(1)。那么如何实现呢？</p><p>答案还是利用求模。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RIncludes</span>(<span class="params">s1, s2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = s1.length;</span><br><span class="line">  <span class="keyword">const</span> m = s2.length;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> p1; <span class="comment">// s1的指针</span></span><br><span class="line">  <span class="keyword">let</span> p2; <span class="comment">// s2的指针</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    p1 = i; <span class="comment">// 这一行代码变了</span></span><br><span class="line">    p2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt; <span class="number">2</span> * n &amp;&amp; p2 &lt; m) &#123;</span><br><span class="line">      <span class="comment">// 不需要循环移动一位了，也就是说省了一个N的循环</span></span><br><span class="line">      <span class="keyword">if</span> (s1[p1 % n] === s2[p2]) &#123;</span><br><span class="line">        <span class="comment">// 这一行代码变了</span></span><br><span class="line">        p1++;</span><br><span class="line">        p2++;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p2 === m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，这道题就告一段落了，大家如果有别的方法，也欢迎在评论区留言。</p><h2 id="链表循环移位"><a href="#链表循环移位" class="headerlink" title="链表循环移位"></a>链表循环移位</h2><p>链表不同于前面的数组和字符串，我们来个题目感受一下。</p><p>这里出一个 LeetCode 题目，官方难度为中等难度的一个题 - <a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">61. 旋转链表</a></p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4</span><br><span class="line">输出: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>其实这个思路简单，就是先找到<code>断点</code>，然后重新拼接链表即可。这个断点其实就是第<code>n - k % n</code>个节点， 其中 k 为右移的位数，n 为链表长度。这里取模的原因和上面一样，为了防止 k 过大做的无谓运算。但是这道题目限定了 k 是非负数，那么我们就不需要做这个判断了。</p><p>如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds54v6q7cj30ce04nt8j.jpg" alt></p><p>代码也很简单，我们来看下。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotateRight = <span class="function"><span class="keyword">function</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">let</span> p1 = head;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (p1 &amp;&amp; p1.next) &#123;</span><br><span class="line">    p1 = p1.next;</span><br><span class="line">    n++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cur = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> p2 = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cur &lt; n - (k % n)) &#123;</span><br><span class="line">    p2 = p2.next;</span><br><span class="line">    cur++;</span><br><span class="line">  &#125;</span><br><span class="line">  p1.next = head;</span><br><span class="line">  res = p2.next;</span><br><span class="line">  p2.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li>循环移位的有序数组，查找某一个值，要求时间复杂度为 O(logn)<blockquote><p>这道题我在<a href="https://github.com/azl397985856/fe-interview/blob/master/docs/topics/algorthimn/cycle-sorted-array.md" target="_blank" rel="noopener">《每日一题》</a>出过</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 数组 </category>
          
          <category> 字符串 </category>
          
          <category> LeetCode </category>
          
          <category> 循环移位 </category>
          
          <category> 链表 </category>
          
          <category> 编程之美 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 循环移位 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 编程之美 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纪念LeetCode项目Star突破2W</title>
      <link href="/blog/2019/12/11/thanksGaving-2/"/>
      <url>/blog/2019/12/11/thanksGaving-2/</url>
      
        <content type="html"><![CDATA[<p>假期这几天我买了《逆转裁判 123》合集，面对着这香喷喷的冷饭吃了半天。从 GBA 玩到 NDS，从 NDS 玩到 3DS, 现在 NS 虽然没有出新作有点遗憾。不过有了高清重制，也当是个回忆和收藏了 🎉🎉</p><a id="more"></a><p>目前打通了第一第二关，剩下的过一段时间再玩好啦 😁<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppozhetbj30u01ppdjp.jpg" alt></p><p>回到正题，就在今天，我的《leetcode 题解》项目成功突破 2w star， 并且现在 Github 搜索关键字”LeetCode”我的项目已经排名第一啦，这是继 1W star 之后的第二个巨大突破，非常感谢大家一路以来的支持和陪伴。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7q10kli5lj310m0fm74y.jpg" alt></p><p>最近在写一本关于LeetCode题解的书，有很多人表示想买，这无形之中给了我很大的压力，名字还没定，暂时给它取一个代号《攻克 LeetCode》。 </p><h2 id="新书《攻克-LeetCode》"><a href="#新书《攻克-LeetCode》" class="headerlink" title="新书《攻克 LeetCode》"></a>新书《攻克 LeetCode》</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppnnvb7yj305i04b744.jpg" alt></p><p>这里是<a href="https://lucifer.ren/blog/2019/10/03/draft/">《攻克 LeetCode》的草稿目录</a>，目前有 20 章的内容，本书要讲的内容就是 LeetCode 上反复出现的算法，经过我进一步提炼，抽取数百道题目在这里进行讲解，帮助大家理清整体思绪，从而高效率地刷题，做到事半功倍。我这里总结了 7 个常见的数据结构和 7 个常见的算法以及 5 个常见的算法思想。</p><p>7 个数据结构分别是： <code>数组，栈，队列，链表，二叉树，散列表，图</code></p><p>7 个算法分别是：<code>二分法，递归，回溯法，排序，双指针，滑动窗口，并查集</code></p><p>5 个算法思想分别是：<code>分治，贪心，深度优先遍历，广度优先遍历，动态规划</code></p><p>只有掌握了这些基础的数据结构和算法，更为复杂的算法才能得心应手，事半功倍。而 LeetCode 的题目虽然不断出新，但是最终用到的算法永远是那几个，很多题目都是穿着新的衣服的老面孔了。大家学好这些基础套路之后会更加明白这个道理。</p><p>后期可能会有大幅度修改，希望大家提出宝贵意见，以特别的方式参与到这本书的编写中来。</p><h2 id="2W-star截图"><a href="#2W-star截图" class="headerlink" title="2W star截图"></a>2W star截图</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7r4ef4fwej30rm0ld75g.jpg" alt></p><h2 id="Star-曲线"><a href="#Star-曲线" class="headerlink" title="Star 曲线"></a>Star 曲线</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pom0rbu6j30p00f1glo.jpg" alt></p><p>(star 增长曲线图)</p><h2 id="知乎引流"><a href="#知乎引流" class="headerlink" title="知乎引流"></a>知乎引流</h2><p><a href="https://github.com/azl397985856/leetcode/blob/master/thanksGiving.md" target="_blank" rel="noopener">上次</a>主要讲了项目从开始建立到拥有 1W star 的经历，本次书接前文，继续讲一下后面的故事。</p><p>上回提到知乎上的“量子位”在帮我做宣传，引入了不小的流量。 我就想为什么不自己去拉流量呢？我自己以作者的角度去回答一些问题岂不是更好，更受欢迎么？于是我就开始在知乎上回答问题，很开心其中一个还获得了专业认可。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7poxozmrmj30jw0gl0tp.jpg" alt></p><p>事实上并没有我想的那么好，我回答了两个 LeetCode 话题的内容，虽然也有几百的点赞和感谢，但是这离我的目标还差很远。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pox4k95zj309q0b1mxa.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7poz07qsrj30jk0h4q3y.jpg" alt></p><p>但是转念一想，我知乎刚起步，也没什么粉丝，并且写答案的时间也就一个月左右，这样想就好多了。 我相信将来会有更多的人看到我的答案，然后加入进来。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pozi8bfrj308907w747.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppnep24xj30to0pwaar.jpg" alt></p><h2 id="建立自己的博客"><a href="#建立自己的博客" class="headerlink" title="建立自己的博客"></a>建立自己的博客</h2><p>现在我发表的文章都是在各大平台。这有一个很大的问题就是各个平台很难满足你的需求，比如按照标签，按照日期进行归档。 甚至很多平台的阅读体验很差，比如没有导航功能，广告太多等。因此我觉得自己搭建一个博客还是很有必要的，这个渠道也为我吸引了少部分的流量，目前添加的主要内容大概有：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pp2i0818j308m07awej.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pp2vru72j30800hct8p.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pp34fjowj307z08za9y.jpg" alt></p><p>总体上来说效果还是不错的，之后的文章会在博客首发，各个平台也会陆续更新，感兴趣的可以来个 RSS 订阅，订阅方式已经在<a href="https://lucifer.ren/blog/2019/09/30/daily-featured-2019-09/">《每日一荐 - 九月刊》</a>里面介绍了。</p><h2 id="GithubDaily-的-推荐"><a href="#GithubDaily-的-推荐" class="headerlink" title="GithubDaily 的 推荐"></a>GithubDaily 的 推荐</h2><p>GithubDaily 转载了量子位的文章也为我的仓库涨了至少几百的 star，非常感谢。GithubDaily 是一个拥有 3W 多读者的公众号，大家有兴趣的可以关注一波。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pp8r6isnj30kl0eq3yo.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pp9drlz0j30j90arq31.jpg" alt></p><h2 id="其他自媒体的推荐"><a href="#其他自媒体的推荐" class="headerlink" title="其他自媒体的推荐"></a>其他自媒体的推荐</h2><p>一些其他自媒体也会帮忙推广我的项目</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppmlm7gyj30u00y10v5.jpg" alt></p><h2 id="口耳相传"><a href="#口耳相传" class="headerlink" title="口耳相传"></a>口耳相传</h2><p>我后来才知道竟然有海外华侨和一些华人社区都能看到我了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppm3upr0j30ky0mmmxv.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ppk0hlauj30ss1bmq5d.jpg" alt><br>（一亩三分地是一个集中讨论美国加拿大留学的论坛）</p><p>另外通过朋友之间口耳相传的介绍也变得越来越多。</p><p>非常感谢大家一直以来的陪伴和支持，我们一起努力，加油 💪。</p><p>如果你还没有加入我们，看了这篇文章想加入，那么可以访问我的项目主页 <a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">leetcode 题解</a><br>我在这里等着你。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是如何刷 LeetCode 的？</title>
      <link href="/blog/2019/12/11/how-am-I-conque-leetcode/"/>
      <url>/blog/2019/12/11/how-am-I-conque-leetcode/</url>
      
        <content type="html"><![CDATA[<p>我就是那个 @量子位 答案里面提到的“lucifer 小哥哥”。</p><p>我本人从开始准备算法以来，大概经过了几个月的时间，这期间自己成长了很多，从刷题菜鸡，到现在对刷题套路，题型有了自己的理解，感受还是蛮多的。我本人不是算法高手，算是勤能补拙类型。不过经过几个月的学习和练习，不仅面试变得更加得心应手，而且在工作中写更容易写出干净优雅，性能好的代码。</p><a id="more"></a><p>我将自己这几个月的刷题经历都整理了下来，除了给出思路和关键点，还横向地对知识点进行整理，尽量做到<code>一题多解，多题同解</code>。 现在GitHub仓库有18k+的✨ ， 欢迎大家关注。仓库地址： <a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">azl397985856/leetcode</a></p><p>那么今天我就来回答一下这个问题，谈一下<code>我是怎么刷leetcode的</code>。</p><p>对于我来说，<code>刷题的过程其实就是学习数据结构和算法的过程</code>， 不仅仅是为了刷题而刷题，这样你才能感受到<code>刷题的乐趣</code>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53igz8vj30dw0780ta.jpg" alt></p><h2 id="第一遍按tag刷，第二遍一题多解，多题同解"><a href="#第一遍按tag刷，第二遍一题多解，多题同解" class="headerlink" title="第一遍按tag刷，第二遍一题多解，多题同解"></a>第一遍按tag刷，第二遍一题多解，多题同解</h2><p>个人建议，第一遍刷的时候可以先快速按照tag过一遍，快速感受一下常见数据结构和算法的套路，这样自己有一个感性的认识。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53je363j30ay0i5mz1.jpg" alt></p><p>第二遍我们就不能像第一遍那样了，这个阶段我们需要多个角度思考问题，尽量做到<code>一题多解，多题同解</code>。我们需要对问题的本质做一些深度的理解，将来碰到类似的问题我们才能够触类旁通。</p><p>但是很多人做了几遍，碰到新题还是没有任何头绪，这是一个常见的问题，这怎么办呢？ 我们继续往下看。</p><h2 id="艾宾浩斯记忆曲线"><a href="#艾宾浩斯记忆曲线" class="headerlink" title="艾宾浩斯记忆曲线"></a>艾宾浩斯记忆曲线</h2><p>总结并记忆是学习以及刷题过程中非常重要的一环，<br>不管哪个阶段，我们都需要做对应的总结，这样将来我们再回过头看的时候，才能够快读拾起来。</p><p>信息输入大脑后，遗忘也就随之开始了。遗忘率随时间的流逝而先快后慢，特别是在刚刚识记的短时间里，遗忘最快，这就是著名的艾宾浩斯遗忘曲线。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53kft2xj306404475i.jpg" alt></p><p>anki就是根据<code>艾宾浩斯记忆曲线</code>开发的一个软件，它是一个使记忆变得容易的学习软件。因为它是一个自定义多功能的记忆方式，可以大大减少你的学习时间，也可以大大提高 你的学习容量。 对于我本人而言，我在anki里面写了很多leetcode题目和套路的Card，然后anki会自动帮我安排复习时间，大大减少我的认知负担，提高了我的复习效率。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53l94m8j3069069t9l.jpg" alt></p><p>这个是我的<a href="https://github.com/azl397985856/leetcode/blob/master/assets/anki/leetcode.apkg" target="_blank" rel="noopener">anki card</a> 大家可以直接导入使用，但是还是建议大家自己制作卡片，毕竟每个人情况不一样，并且制作卡片的过程也是记忆的过程。</p><p>使用方法：</p><p>anki - 文件 - 导入 - 下拉格式选择“打包的 anki集合”，然后选中你下载好的文件，确定即可。</p><p>更多关于anki使用方法的请查看<a href="https://apps.ankiweb.net/" target="_blank" rel="noopener">anki官网</a></p><p>目前已更新卡片一览（仅列举正面）</p><ul><li>二分法解决问题的关键点是什么，相关问题有哪些?</li><li>如何用栈的特点来简化操作， 涉及到的题目有哪些？</li><li>双指针问题的思路以及相关题目有哪些？</li><li>滑动窗口问题的思路以及相关题目有哪些？</li><li>回溯法解题的思路以及相关题目有哪些？</li><li>数论解决问题的关键点是什么，相关问题有哪些?</li><li>位运算解决问题的关键点是什么，相关问题有哪些?</li></ul><h2 id="殊途同归"><a href="#殊途同归" class="headerlink" title="殊途同归"></a>殊途同归</h2><p>大家刷了很多题之后，就会发现来来回回，题目就那么几种类型，因此掌握已有题目类型是多么重要。那样leetcode出题的老师，很多也是在原有的题目基础上做了适当<code>扩展</code>（比如two-sum,two-sum2,three-sum, four-sum等等）或者<code>改造</code>（使得不那么一下子看出问题的本质，比如猴子吃香蕉问题）。</p><p>其中算法，主要是以下几种：</p><ul><li>基础技巧：分治、二分、贪心</li><li>排序算法：快速排序、归并排序、计数排序</li><li>搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等</li><li>图论：最短路径、最小生成树</li><li>动态规划：背包问题、最长子序列</li></ul><p>数据结构，主要有如下几种：</p><ul><li>数组与链表：单 / 双向链表</li><li>栈与队列</li><li>哈希表</li><li>堆：最大堆 ／ 最小堆</li><li>树与图：最近公共祖先、并查集</li><li>字符串：前缀树（字典树） ／ 后缀树</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53mf21xj30k00jxago.jpg" alt><br>(图片来自leetcode)</p><h2 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h2><p>做到了以上几点，我们还需要坚持。这个其实是最难的，不管做什么事情，坚持都是最重要也是最难的。</p><p>为了督促自己，同时帮助大家成长，我在群里举办《每日一题》活动，每日一题是在交流群（包括微信和qq）里进行的一种活动，大家一起 解一道题，这样讨论问题更加集中，会得到更多的反馈。而且 这些题目可以被记录下来，日后会进行筛选添加到仓库的题解模块。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53n8tz2j30p80nrtau.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53o630kj315f0i8wn4.jpg" alt></p><p>大家如果发现自己很难坚持下去，也可以加入我的群聊，我们互相监督。 另外我还专门组建了slack群，有兴趣的可以加群后在群里喊即可。</p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>大家可以关注我的公众号《脑洞前端》，公众号后台回复“大前端”，拉你进《大前端面试宝典 - 图解前端群》。回复“leetcode”，拉你进《leetcode题解交流群》</p><p>最后祝大家刷题愉快，拿到自己心仪的offer。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> LeetCode </category>
          
          <category> 学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/blog/2019/12/11/ibinhouse/"/>
      <url>/blog/2019/12/11/ibinhouse/</url>
      
        <content type="html"><![CDATA[<p>信息输入大脑后，遗忘也就随之开始了。遗忘率随时间的流逝而先快后慢，特别是在刚刚识记的短时间里，遗忘最快，这就是著名的艾宾浩斯遗忘曲线。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>零基础的前端开发初学者应如何系统地学习？</title>
      <link href="/blog/2019/12/11/how-am-I-learn-fe/"/>
      <url>/blog/2019/12/11/how-am-I-learn-fe/</url>
      
        <content type="html"><![CDATA[<p>回想四年前我刚入行的时候，那时候很多人对于前端的看法是“切图，画页面，有个编辑器+浏览器就能干，门槛低”，现在已经完全不是那样了，可以说现在的前端这个职业的门槛虽然还是没怎么变，但是整个行业的门槛提升了，换句话说就是整个行业对于前端这个职位要求更高了，对于前端小白的需求量降低，对于高级前端的需求量还在上升，甚至是供小于求的局面。从市场经济学角度上讲你只有进入到高级级别，才能真正吃到行业的红利。  因此想要入行的朋友要先想清楚，不要头脑发热，如果你想清楚了，那么请继续往下看。<br>说实话，现在的前端大环境对初学者来说实在有点不友好，学习资料鱼龙混杂，良莠不齐，有质量很高的学习资料，也有谬论，前后不一，观点错误，或者讲述不清晰的。 更可怕的是质量低下的文章有时候更受欢迎，因此需要大家有很好的甄别能力，但这对于初学者来说实在有些困难，我在这里就来谈一下 <code>初学者如何少走弯路，并且系统性地学习前端</code>。</p><a id="more"></a><h2 id="兴趣是最好的老师"><a href="#兴趣是最好的老师" class="headerlink" title="兴趣是最好的老师"></a>兴趣是最好的老师</h2><p>兴趣不管对于学习什么来说都是最好的老师。当然前端也不例外，如果你对这一门感兴趣，绝对会对你有很大的帮助。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53pi54uj307n0533zi.jpg" alt></p><p>关于如何培养兴趣，我提一点，你可以尝试去做一些小的“发明创造”，从而激发自己内心的“成就感”。这些小发明可以是一些小工具，小页面。你可以从开源社区，比如Github或者一些论坛，甚至自己的生活中收集一些创作素材。对于我来说，我就做过一个“前端开发工作流”的软件，“siri”， “小门神”等，从而带来成就感，提升自己的兴趣。</p><h2 id="权威，权威，还是权威"><a href="#权威，权威，还是权威" class="headerlink" title="权威，权威，还是权威"></a>权威，权威，还是权威</h2><p>其实技术越往上走，越会关注标准，关注协议等更上层和抽象的东西。而制定这些协议和标准的人往往都是世界上的“殿堂级”程序员，因此关注这些东西对于他们来说就是权威，对他们来说就非常很重要，但是这对于初学者来说似乎还比较遥远。那么初学者如何对接“权威”呢？<br>刚才提到了网上的学习资料参差不齐，这其实对于入门学习来说是很不利的，就像童年时期对于整个人生的影响一样，入门阶段对于整个前端开发生涯的影响也是巨大的。关于如何初学者如何对接权威，我这里总结了以下三点：<br>看一些权威的书籍，包括前端基础，软件工程以及算法等。这里不太建议看太老的，毕竟技术的发展是很快的，以前非常经典的书并一定适合看了，尤其是初学者而言。这里前端方面我重点推荐两本书，一本是《你不知道的JS》，一本是《JavaScript语言精粹》。除了前端，你还可以看一些软工类的书，我个人比较喜欢的有《程序员修炼之道》等，算法类的有《图解算法》，《编程之美》等。其他的我就不一一赘述了，想要更多书单的可以私信我。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53qfn9kj305g075q4a.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53rhdv2j307405hdhv.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53sd7z6j305j071abq.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53ssxrrj3069069q3o.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53taxn9j3069069gn7.jpg" alt></p><ul><li>查权威资料。 这里我推荐两个，一个是<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN</a>的文章，真的是又全面又专业，绝对是前端开发必备神器，哪里不会点哪里。 另外推荐一个<a href="https://developers.google.com/web/fundamentals/" target="_blank" rel="noopener">Google开发者</a> ， 里面干货很多，绝对权威。<br>这里顺便再安利一个软件，用来查文档什么的，简直如虎添翼，这个软件的名字是Dash，大家可以把自己常用的框架，类库等导进去，想用的时候直接查询即可，比去网上搜更快更高效，这个软件对于定制的支持度也是蛮高的，谁用谁知道。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53ud6lbj311e0hbac8.jpg" alt><br>（大家可以看到我下载了很多documentation）</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53vpntmj311f0lpgs5.jpg" alt><br>（你可以直达某一个documentation搜索，也可以全局搜索，甚至可以搜goole和stackoverflow，是不是很贴心？）</p><ul><li>关注一些圈内权威人士。 我一般会关注几个圈内比较知名的人的知乎，微博和twitter。这是我关注的<a href="https://github.com/azl397985856?tab=following" target="_blank" rel="noopener">Github的权威人士列表</a>。其实这些都是公开的，你也可以点开我的知乎，微博资料看我或者大佬们关注了谁。</li></ul><h2 id="做一些完整的简单项目"><a href="#做一些完整的简单项目" class="headerlink" title="做一些完整的简单项目"></a>做一些完整的简单项目</h2><p>大家可以尝试做一些简单的项目，不要嫌简单。 在做的过程往往能发现很多问题，如果有问题那这正好是自己提高的机会。 如果你觉得很简单，也没有关系，你可以思考一下，我有没有可能做的更好？我能不能把这些东西封装起来，建立更高一层的抽象（A New Level of Abstraction），做到DRY(Don’t Repeat Yourself)。<br>接下来就是关于怎么找项目。 你可以找个正式工作或者实习来做，也可以自己找一些小项目来练手， 比较常见的练手项目有模仿某个网站，APP或者搭建自己的个人主页，博客系统等。做好了不仅可以当敲门砖，说不定会收益很长时间呢。实在没有什么项目练手，这里再推荐一个网站，你可以再上面打怪升级。<a href="https://user-gold-cdn.xitu.io/2019/9/15/16d34514876b8c4d" target="_blank" rel="noopener">freecodecamp</a><br>现在你已经掌握了前端开发的基本概念和技能，那么如何做到更进一步，持续成长，做到高级呢？我相信这是很多人的疑问，下面我们就来看一下。</p><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p>你可能已经听过过大前端这个词，我这里不是劝退你哦。以下内容很高能，不过很多知识点不知道没关系，因为就算是工作了很多年了老手也很难了解其中的大半知识点。<br>我个人为了让自己巩固知识，同时也为了帮助他人，总结了大前端下的30多个主题内容，内容覆盖大前端的方方面面，虽然是从面试角度出发，但是你用来提升自己，查缺补漏也是很有用的。</p><p>多图预警：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53wloptj304m0gsq3j.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53wyi87j304u0g0q38.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53xg7qnj308807et8u.jpg" alt></p><p>拿《编程题》主题来说，我总结了各大公司常考的几十道题目。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53ydbowj30d70hs765.jpg" alt></p><p>对于其他主题也是一样，我都会尽可能地深度讲解和剖析，并且从多方面理解，我相信这是在市面上很少见的。</p><p>而且我还画了很多图，来帮助大家理解一些抽象的知识点。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53zeayjj30mx0i4jys.jpg" alt></p><p>项目地址： <a href="https://lucifer.ren/fe-interview/#/">https://lucifer.ren/fe-interview/#/</a>   欢迎围观。</p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds540ejvxj309o041weh.jpg" alt></p><p>实话实说，很多优秀的思想，规范，写法我都是从优秀的开源项目中学来的。 我会不定期阅读一些优秀的开源项目源码，也会参与到开源的工作中去，这给我自己带来了很大的提升。 不仅技术得到了提升，团队协作，规范化等方面也有了质的提高，另外还认识了一些优秀的人。四年来，我阅读了很多优秀的源码，也尝试自己去造一些轮子，并开源出去，回馈社区。</p><h2 id="输入-输出"><a href="#输入-输出" class="headerlink" title="输入 + 输出"></a>输入 + 输出</h2><p>前面重点讲述的是输入。 其实学习的过程不仅仅是输入，输出也是很好的学习方法。 输出的形式有很多，比如写博客，讲给别人，开源出去让别人用等。 这其实是很好的学习机会，这种学习方法可以让你的成长速度呈指数型增长，因此千万不要小看它。 我会通过以练代学的方式来学习，比如我学习React，我会迅速看文档，然后写demo，最后我会自己<a href="https://github.com/azl397985856/mono-react" target="_blank" rel="noopener">《从零实现React》</a>来内化它。</p><p>我还会定期做总结，写文章，写开源项目，做分享等，目的一方面是影响他人，另一方面是成长自己。</p><h2 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h2><p>选择了技术这条路，就要做好持续学习，每日精进的准备，跟上时代潮流是很有必要的。</p><ul><li>日报周报。 大家可以订阅一些前端方面的日报周报，这方面其实有很多，这里只推荐一个我常看的一个<a href="https://javascriptweekly.com" target="_blank" rel="noopener">JavaScript周刊</a>。我自己也出了一款<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">《每日一荐》</a>, 每天推荐一个优秀的开源项目，优秀文章， 周一到周五我们不见不散。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds5425gxxj30r20ghwhz.jpg" alt></p><ul><li>深度参与开源项目。 关于如何参与开源项目其实可以另起一篇文章了，这里不再赘述，感性的话，我会再写一篇文章，大家记得关注我就好。</li><li>定期总结，技术输出。 我的习惯是对于学习的内容定期和不定期地进行总结。 比如最近我在总结的[《leetcode题解》]（现在有18k+ ✨了）(<a href="https://github.com/azl397985856/leetcode)，[《大前端面试宝典》](https://github.com/azl397985856/fe-interview)" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode)，[《大前端面试宝典》](https://github.com/azl397985856/fe-interview)</a></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds5432xphj30k00jxago.jpg" alt></p><blockquote><p>千万不要觉得算法对前端不重要，算法，网络，操作系统属于基础，从事相关工作的都应该认真学习，打好基础才行。</p></blockquote><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>大家可以关注我的公众号《脑洞前端》，公众号后台回复“大前端”，拉你进《大前端面试宝典 - 图解前端群》。回复“leetcode”，拉你进《leetcode题解交流群》</p><p>最后祝大家在前端的路上越走越远。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 学习方法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 学习方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从老鼠试毒问题来看二分法</title>
      <link href="/blog/2019/12/11/laoshushidu/"/>
      <url>/blog/2019/12/11/laoshushidu/</url>
      
        <content type="html"><![CDATA[<p>很多人对于二分法的理解比较片面，之前碰到一个题目，从一个先升序后降序的数列中，比如 1 2 3 7 4 3 2 中运用二分法去查找一个给定的元素，很多人说根本不能二分，因为没有排序。其实 这道题完全可以使用二分查找进行解答， 如果你觉得不可以的话，很可能对二分法理解还比较片面。  这里以另外一个更加有趣（至少我认为）的例子来讲解一下二分法。</p><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>面试题： 有1000个一模一样的瓶子，其中有1瓶是毒药，老鼠喝了有毒的会在24h之后死亡。求最少需要多少老鼠才能在24h里找到有毒的那瓶。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>这道题的解法有很多，今天我们来聊下用二分法来解这道题。 这道题似乎和我们看的的常见的二分法有很大的区别，但是仔细想一下， 二分法本质是将问题的规模缩小到原有的一半，带着这样的思想我们再来看一下。类似的，三分法就是将问题规模缩小为原来的1/3. </p><p>我们先对1000个瓶子进行编号，从1-1000这样子。 不过我们不是通过我们大家平时生活中使用的十进制，而是使用再计算机中使用的二进制， 同时让大家感受一下二进制的魅力。</p><p>为了方便讲解，我们假设不是1000个瓶子，而是4个。</p><p>我们来编一下号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 // #1</span><br><span class="line">01 // #2</span><br><span class="line">10 // #3</span><br><span class="line">11 // #4</span><br></pre></td></tr></table></figure><p>我们的目标是找到哪个瓶子有毒，换句话说我们目标是找到有毒瓶子的编号，再换句话说我们的目标是<br>找到有毒瓶子的3个bit分别是什么，是0还是1.</p><p>比如有毒的是3号瓶子，那么我们就是想确认第一个bit是0，第二个bit是1，第三个bit是1，即011，转化为10进制就是3号。</p><p>那么如何确定每一个bit是什么呢？   回想一下，我们手上有老鼠，老鼠有两个state，alive 或者 died，这就是我们拥有的全部。</p><p>接下来我们逐一对瓶子进行分组，分组的依据就是每一个bit的值。</p><p>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 00 01     #g1:1  第一个bit是0</span><br><span class="line">// 10 11     #g1:2  第一个bit是1</span><br><span class="line">// 00 10     #g2:1  第二个bit是0</span><br><span class="line">// 01 11     #g2:2  第二个bit是1</span><br></pre></td></tr></table></figure><p>我们来找第一个老鼠#1 来喝g:1:1, 如果他死了，那么毒就在这一组，也就是说毒的第一个bit是0，否则是1</p><p>我们来找第二个老鼠#2 来喝g:2:1, 如果他死了，那么毒就在这一组，也就是说毒的第二个bit是0，否则是1</p><p>所以我们可以看出, 两只老鼠就搞定了，我们按照这个思路，可以推到出1000个瓶子只需要10个瓶子, 即  log2 1000， 2的10次方是1024，因此10个老鼠够了，如果1025个瓶子的话，就需要11个老鼠了。</p><p>如果你仔细思考的话，不难看出，我们是在用老鼠喝了水之后的反应（生或死）来进行判断每一个bit的数字，不管生死，我们总能得出这个bit的值，是0还是1.  因此每使用一只老鼠我们都将问题规模缩小为原来的1／2. 这是典型的二分法。</p><h3 id="这是最优解么"><a href="#这是最优解么" class="headerlink" title="这是最优解么"></a>这是最优解么</h3><p>是的，这是最优解，如果你愿意用严格的数学来证明的话，你可以试一下数学归纳法。  如果你想感性的判断一下的话，可以继续往下读。</p><p>什么是最优解？  最优解就是要让未知世界无机可乘，也就是说在最坏的情况下得到最优（现实世界都是未知的）。上面的例子，不管小老鼠是生还是死，我们都可以将问题规模缩小到1/2. 也就是说最坏的情况就是最好的情况，也就是说没有最坏情况。</p><p>那么我们是否可以将问题规模缩小的1／3 或者更小呢？</p><h3 id="我们可以三分么"><a href="#我们可以三分么" class="headerlink" title="我们可以三分么"></a>我们可以三分么</h3><p>简单来说，不可以， 因为老鼠只有两种observable state， 即alive， died. 假如我们有10个小球，其中有一个是异常的，其他9个都是一样的，我们怎么才能通过最少的称量来确定是哪一个异常，是重还是轻？ 这个时候我们就可以使用三分法了，为什么？因为天平有三个state， 平衡，左倾，右倾，使得我们”有可能“ 将问题规模缩小为1/3， 事实上，确实可以实现将问题规模缩小到1/3。</p><p>我会在之后的文章中进行讲解小球的问题最优策略， 并解释为什么这是最优策略。 </p><h3 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h3><p>基于比较的排序都无法逃脱nlogn时间复杂度的命运，这是为什么？能否利用本篇文章的思想进行解释？</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【LeetCode题解】1186.删除一次得到子数组最大和</title>
      <link href="/blog/2019/12/11/leetcode-1186/"/>
      <url>/blog/2019/12/11/leetcode-1186/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 1186题，最大子数组的进阶版本。</p><a id="more"></a><h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。</span><br><span class="line"></span><br><span class="line">换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。</span><br><span class="line"></span><br><span class="line">注意，删除一个元素后，子数组 不能为空。</span><br><span class="line"></span><br><span class="line">请看示例：</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：arr = [1,-2,0,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：arr = [1,-2,-2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们直接选出 [3]，这就是最大和。</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：arr = [-1,-1,-1,-1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。</span><br><span class="line">     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">1 &lt;= arr.length &lt;= 10^5</span><br><span class="line">-10^4 &lt;= arr[i] &lt;= 10^4</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h3><p>符合知觉的做法是求出所有的情况，然后取出最大的。 我们只需要两层循环接口，外循环用于确定我们丢弃的元素，内循环用于计算subArraySum。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">maximumSum</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">      res = arr[<span class="number">0</span>]</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">maxSubSum</span><span class="params">(arr, skip)</span>:</span></span><br><span class="line">          res = maxSub = float(<span class="string">"-inf"</span>)</span><br><span class="line">         </span><br><span class="line">          <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">              <span class="keyword">if</span> i == skip:</span><br><span class="line">                  <span class="keyword">continue</span></span><br><span class="line">              maxSub = max(arr[i], maxSub + arr[i])</span><br><span class="line">              res = max(res, maxSub)</span><br><span class="line">          <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 这里循环到了len(arr)项，表示的是一个都不删除的情况</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr) + <span class="number">1</span>):</span><br><span class="line">          res = max(res, maxSubSum(arr, i))</span><br><span class="line">      <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="空间换时间"><a href="#空间换时间" class="headerlink" title="空间换时间"></a>空间换时间</h3><p>上面的做法在LC上会TLE， 因此我们需要换一种思路，既然超时了，我们是否可以从空间换时间的角度思考呢？我们可以分别从头尾遍历，建立两个subArraySub的数组l和r。 其实这个不难想到，很多题目都用到了这个技巧。</p><p>具体做法：</p><ul><li>一层遍历， 建立l数组，l[i]表示从左边开始的以arr[i]结尾的subArraySum的最大值</li><li>一层遍历， 建立r数组，r[i]表示从右边开始的以arr[i]结尾的subArraySum的最大值</li><li>一层遍历， 计算 l[i - 1] + r[i + 1] 的最大值 <blockquote><p>l[i - 1] + r[i + 1]的含义就是删除arr[i]的子数组最大值</p></blockquote></li><li>上面的这个步骤得到了删除一个的子数组最大值， 不删除的只需要在上面循环顺便计算一下即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumSum</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        l = [arr[<span class="number">0</span>]] * n</span><br><span class="line">        r = [arr[n - <span class="number">1</span>]] * n</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">        res = arr[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            l[i] = max(l[i - <span class="number">1</span>] + arr[i], arr[i])</span><br><span class="line">            res = max(res, l[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            r[i] = max(r[i + <span class="number">1</span>] + arr[i], arr[i])</span><br><span class="line">            res = max(res, r[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">            res = max(res, l[i - <span class="number">1</span>] + r[i + <span class="number">1</span>])</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>上面的算法虽然时间上有所改善，但是正如标题所说，空间复杂度是O(n),有没有办法改进呢？答案是使用动态规划。</p><p>具体过程：</p><ul><li>定义max0，表示以arr[i]结尾且一个都不漏的最大子数组和</li><li>定义max1，表示以arr[i]或者arr[i - 1]结尾，可以漏一个的最大子数组和</li><li>遍历数组，更新max1和max0（注意先更新max1，因为max1用到了上一个max0）</li><li>其中<code>max1 = max(max1 + arr[i], max0)</code>, 即删除arr[i - 1]或者删除arr[i]</li><li>其中<code>max0 = max(max0 + arr[i], arr[i])</code>， 一个都不删除</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @lc app=leetcode.cn id=1186 lang=python3</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># [1186] 删除一次得到子数组最大和</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=start</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumSum</span><span class="params">(self, arr: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># DP</span></span><br><span class="line">        max0 = arr[<span class="number">0</span>]</span><br><span class="line">        max1 = arr[<span class="number">0</span>]</span><br><span class="line">        res = arr[<span class="number">0</span>]</span><br><span class="line">        n = len(arr)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> max0</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># 先更新max1，再更新max0，因为max1用到了上一个max0</span></span><br><span class="line">            max1 = max(max1 + arr[i], max0)</span><br><span class="line">            max0 = max(max0 + arr[i], arr[i])</span><br><span class="line">            res = max(res, max0, max1)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @lc code=end</span></span><br></pre></td></tr></table></figure><h2 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h2><ul><li>空间换时间</li><li>头尾双数组</li><li>动态规划</li></ul><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><ul><li><a href="https://github.com/azl397985856/leetcode/blob/master/problems/42.trapping-rain-water.md" target="_blank" rel="noopener">42.trapping-rain-water</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零打造一个舒服的Mac开发环境 - 装机篇</title>
      <link href="/blog/2019/12/11/mac-setup-for-fe/"/>
      <url>/blog/2019/12/11/mac-setup-for-fe/</url>
      
        <content type="html"><![CDATA[<p>前两天新买的16寸mac pro到手了。 本来想直接将旧电脑的数据做一个迁移，但是有同学反应想看“如何从零打造一个舒适的开发环境”，于是就有了这篇文章。</p><a id="more"></a><h2 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g994m51omoj30u01ppn1d.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g994ny143uj30p40nctad.jpg" alt></p><h2 id="配置和价格"><a href="#配置和价格" class="headerlink" title="配置和价格"></a>配置和价格</h2><p>在正式开始之前，我们先来介绍下主机的配置。</p><ul><li>2.3GHz 8-core 9th-generation Intel Core i9 processor</li><li>Turbo Boost up to 4.8GHz</li><li>AMD Radeon Pro 5500M with 4GB of GDDR6 memory</li><li>32GB 2666MHz DDR4 memory</li><li>1TB SSD storage¹</li><li>16-inch Retina display with True Tone</li><li>Touch Bar and Touch ID</li><li>Four Thunderbolt 3 ports</li></ul><p>这个电脑要比15寸的pro重100多克，扬声器，显卡要比15寸的更加好一点，touch bar重也将ESC和TouchID做成了实体键，最关键的是和15寸价格一样，我这个配置下来价格是<code>RMB 25,135</code> 。</p><h2 id="如何从零打造一个舒适的开发环境"><a href="#如何从零打造一个舒适的开发环境" class="headerlink" title="如何从零打造一个舒适的开发环境"></a>如何从零打造一个舒适的开发环境</h2><ul><li><a href="https://github.com/azl397985856/mac-setup" target="_blank" rel="noopener">文字版</a></li><li><a href="https://www.bilibili.com/video/av76756338" target="_blank" rel="noopener">视频版P1&amp;P2</a></li></ul><blockquote><p>视频录制的声音比较小</p></blockquote><h2 id="Next"><a href="#Next" class="headerlink" title="Next"></a>Next</h2><p>本期视频只是一个简单的装机，以及系统配置。并不涉及到软件的深度使用，如果感兴趣可以给我留言，我会在之后给大家带来相关的攻略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> 装机 </tag>
            
            <tag> 必备软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一荐 2019-11 汇总</title>
      <link href="/blog/2019/12/11/daily-featured-2019-11/"/>
      <url>/blog/2019/12/11/daily-featured-2019-11/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8d0sktqrwj30hs07maae.jpg" alt></p><p>每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。</p><p>项目主页维护当前月份的内容，想看往期内容，可以去<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">每日一荐主仓库</a>翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。</p><a id="more"></a><h2 id="2019-11"><a href="#2019-11" class="headerlink" title="2019-11"></a>2019-11</h2><h3 id="2019-11-29-网站"><a href="#2019-11-29-网站" class="headerlink" title="2019-11-29[网站]"></a>2019-11-29[网站]</h3><p>之前我在每日一题出了一道题<a href="https://github.com/azl397985856/fe-interview/issues/16" target="_blank" rel="noopener"> 2019-08-16 - 怎么在浏览器中操作本地的文件</a>。 一个可行的思路就是在本地创建一个服务器，比如 node 服务器，浏览器操作发送请求到服务器，然后 node 去操作本地文件。</p><p>现在 Chrome 支持 native fs api，使得这个过程原生支持，想要体验的可以访问这里 <a href="https://labs.vaadin.com/native-fs/" target="_blank" rel="noopener">https://labs.vaadin.com/native-fs/</a> ， 如果你愿意，你可以将它添加为 Chrome APP。</p><h3 id="2019-11-28-工具"><a href="#2019-11-28-工具" class="headerlink" title="2019-11-28[工具]"></a>2019-11-28[工具]</h3><p>今天给大家推荐的工具是效率类软件 Alfred 的灵魂 workflows（工作流）。</p><p>以下是我使用频率比较高的 workflow，使用频率低的会被我定期清理掉。</p><blockquote><p>我自己制作的工作流不在这里展示和推荐</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9dintchy7j30950ay74e.jpg" alt></p><p>下载地址：</p><ul><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/ChromeBookmarks.alfredworkflow" target="_blank" rel="noopener">Chrome Bookmarks</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/Colors.alfredworkflow" target="_blank" rel="noopener">Colors</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11Dash.alfredworkflow" target="_blank" rel="noopener">Dash</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/KillProcess.alfredworkflow" target="_blank" rel="noopener">Kill Process</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/RamdaDocs.alfredworkflow" target="_blank" rel="noopener">RamdaDocs</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/TerminalFinder.alfredworkflow" target="_blank" rel="noopener">TerminalFinder</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/YosemiteiOSSimulator.alfredworkflow" target="_blank" rel="noopener">Yosemite iOS Simulator</a></p></li><li><p><a href="https://github.com/azl397985856/daily-featured/tree/master/assets/2019-11/Youdao.alfredworkflow" target="_blank" rel="noopener">Youdao</a></p></li></ul><h3 id="2019-11-27-软件"><a href="#2019-11-27-软件" class="headerlink" title="2019-11-27[软件]"></a>2019-11-27[软件]</h3><p>mac 端不能右键新建文件，这在某些时候不是很方便。 没有这个软件的时候，我是在编辑器中新建或者是使用 touch 命令。 使用了这个<code>New File Menu</code>软件之后多了一种更方便的选择，你可以直接右键新建，Just Like Windows Users。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9b8meuak2j30gu04yaa8.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9b8k1tqqdj30od0f7n3b.jpg" alt></p><p>地址： <a href="https://apps.apple.com/cn/app/new-file-menu/id1064959555?l=en&amp;mt=12" target="_blank" rel="noopener">https://apps.apple.com/cn/app/new-file-menu/id1064959555?l=en&amp;mt=12</a></p><h3 id="2019-11-26-网站"><a href="#2019-11-26-网站" class="headerlink" title="2019-11-26[网站]"></a>2019-11-26[网站]</h3><p>一个网站，可以分析的 Github 仓库，采用手绘风格，对于厌倦了标准图形的我来说简直是耳目一新的感觉。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9aj5o2tu5j30qv0pmgmq.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9aj7mseg4j30qr0cyjrn.jpg" alt></p><p>项目地址： <a href="https://repo-analytics.github.io/" target="_blank" rel="noopener">https://repo-analytics.github.io/</a></p><h3 id="2019-11-25-技巧"><a href="#2019-11-25-技巧" class="headerlink" title="2019-11-25[技巧]"></a>2019-11-25[技巧]</h3><p>Chrome 开发者工具有非常好用但是却鲜为人知的功能。今天给大家介绍一个功能 - 代码覆盖率。 指的是你下载的代码有多少是被执行了的，这在做性能优化的时候很有用。如果一些代码根本没执行，就可以延迟加载。</p><p>使用方法：</p><ul><li><code>Ctrl+Shift+P</code> for windows <code>CMD+Shift+P</code> for mac</li><li>输入 coverage， 选择如图的选项，并确定。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9a2gz99paj30f504hglj.jpg" alt></p><p>然后你就能看到检测结果了：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g9a2h750eij30fk0563yl.jpg" alt></p><h3 id="2019-11-22-工具"><a href="#2019-11-22-工具" class="headerlink" title="2019-11-22[工具]"></a>2019-11-22[工具]</h3><p>Github Large File Storage （简称 git-lfs）, 可以用来存储大文件，比如上 GB 的大文件，相比于传统的 Github 存储，这种方式空间更大，速度更快，并且工作流程和传统 Git flow 并无二致。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g95pqj3vo9j30rs0gowec.jpg" alt></p><p>地址：<a href="https://git-lfs.github.com/" target="_blank" rel="noopener">https://git-lfs.github.com/</a></p><h3 id="2019-11-21-娱乐"><a href="#2019-11-21-娱乐" class="headerlink" title="2019-11-21[娱乐]"></a>2019-11-21[娱乐]</h3><p>文章标题 【The skeptic’s guide to interpreting developer marketing speak 🗺️】 - 暂翻译为【如何翻译开发人员的营销术语】</p><p>里面讲了各种开发人员常用的营销术语，以及对应我们应该怎么去解读 ta。比如：</p><ul><li><code>现代化</code> 就是说<code>刚刚git init</code></li><li><code>AI加持</code> 就是说<code>无数的if else switch case语句</code></li><li><code>最小化</code> 就是说<code>没有测试用例，没有例子</code></li><li><code>跨平台</code> 就是说<code>我听说Electron可以跨平台，于是我就用它写了</code></li><li>…</li></ul><p>文章地址： <a href="https://changelog.com/posts/the-skeptics-guide-to-interpreting-developer-marketing-speak" target="_blank" rel="noopener">https://changelog.com/posts/the-skeptics-guide-to-interpreting-developer-marketing-speak</a></p><h3 id="2019-11-20-工具"><a href="#2019-11-20-工具" class="headerlink" title="2019-11-20[工具]"></a>2019-11-20[工具]</h3><p>微信的一个插件，功能有很多。 不过目前已经不再维护了。</p><ul><li>消息自动回复</li><li>消息防撤回</li><li>远程控制(已支持语音)</li><li>微信多开</li><li>第二次登录免认证</li><li>聊天置底功能(类似置顶)</li><li>微信窗口置顶</li><li>会话多选删除</li><li>自动登录开关</li><li>通知中心快捷回复</li><li>聊天窗口表情包复制 &amp; 存储<br>…</li></ul><p>我用的比较多的功能恐怕就是双开和防撤回了。</p><ul><li><p>消息防撤回<br><img src="http://upload-images.jianshu.io/upload_images/965383-30cbea645661e627.gif?imageMogr2/auto-orient/strip" alt="消息防撤回.gif"></p></li><li><p>微信多开<br><img src="http://upload-images.jianshu.io/upload_images/965383-51d8eae02d48fda9.gif?imageMogr2/auto-orient/strip" alt="微信多开.gif"></p></li></ul><p>仓库地址：<a href="https://github.com/TKkk-iOSer/WeChatPlugin-MacOS/tree/master" target="_blank" rel="noopener">https://github.com/TKkk-iOSer/WeChatPlugin-MacOS/tree/master</a></p><h3 id="2019-11-19-工具"><a href="#2019-11-19-工具" class="headerlink" title="2019-11-19[工具]"></a>2019-11-19[工具]</h3><p>JS 依赖检测工具，可以用来生成图片，可视化程度很高，还可以做成自动化，集成到 CI CD ，支持 CommonJS，AMD 和 ES Module。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g92f3pun36j30h90awt8w.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g92f3yps0zj30a905g745.jpg" alt></p><p>项目地址： <a href="https://github.com/pahen/madge" target="_blank" rel="noopener">https://github.com/pahen/madge</a></p><h3 id="2019-11-18-娱乐"><a href="#2019-11-18-娱乐" class="headerlink" title="2019-11-18[娱乐]"></a>2019-11-18[娱乐]</h3><p>今天给大家推荐一个在线 nokia 短信图片生成器，可以自己输入短语，一键生成。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g91bohz6xyj30hc0j9di2.jpg" alt></p><p>网站地址： <a href="https://zzkia.noddl.me:8020/" target="_blank" rel="noopener">https://zzkia.noddl.me:8020/</a></p><h3 id="2019-11-15-网站"><a href="#2019-11-15-网站" class="headerlink" title="2019-11-15[网站]"></a>2019-11-15[网站]</h3><p>有的什么我们需要在 Google Play 上下载软件，但是苦于没有通畅的网络(关于如何获取畅通的网络我在 2019-11-01 讲到，感兴趣可以翻过去看看)。因此一个 Google Play 镜像就很重要了。 这就如同我们 npm 和 cnpm 的关系。我们可以在这里直接下载 apkx。</p><blockquote><p>apkx 需要特殊的安装工具，或者一些小技巧才能安装。</p></blockquote><p>网站地址： <a href="https://apkpure.com/" target="_blank" rel="noopener">https://apkpure.com/</a></p><h3 id="2019-11-14-技巧"><a href="#2019-11-14-技巧" class="headerlink" title="2019-11-14[技巧]"></a>2019-11-14[技巧]</h3><p>很多时候我们会看到一些英文的简写。比如邮件，IM 等，这些简称能够帮我们提高沟通效率，如果你不知道一些常见的简写，沟通的时候就难免有障碍，以下是一些常见的简写，欢迎补充。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8wp5bq01zj30hs18xn0d.jpg" alt></p><h3 id="2019-11-13-技巧"><a href="#2019-11-13-技巧" class="headerlink" title="2019-11-13[技巧]"></a>2019-11-13[技巧]</h3><p>今天要分享的是关于 Bash 中历史记录那些事。</p><ul><li>第一个要介绍的是<code>history</code>, history is an alias for fc -l 1,你可以通过这个命令来查看最近你使用的命令。 然后你可以用!n(n 指的是 history 命令返回的命令编号)再次执行。其中有许多缩写，最有用的就是 !$， 用于指代上次键入的参数，!! 可以指代上次键入的命令。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8vi04t5qnj307j02baa0.jpg" alt></p><ul><li><p>第二个要介绍的是历史搜索<code>ctrl + r</code>, 然后输入你想搜索的关键字即可</p></li><li><p>第三个要介绍的是<code>上下方向键</code>，你可以通过他在历史记录中上下移动。即按下上返回当前上一个命名，按下下返回当前下一个命令。</p></li><li><p>还有一个小插曲，似乎和历史有那么一点点关系。 就是<code>cd -</code>,切换到上一次的工作路径</p></li></ul><p>如果你还知道什么和历史记录相关的命令，欢迎大家补充。</p><h3 id="2019-11-12-技巧"><a href="#2019-11-12-技巧" class="headerlink" title="2019-11-12[技巧]"></a>2019-11-12[技巧]</h3><p>dig 命令是常用的域名查询工具，可以用来测试域名系统工作是否正常。</p><p>如下<code>dig lucifer.ren</code>， 可以发现很多信息，包括域名最终解析到了到了另外一个域名<code>azl397985856.github.io</code>, IP 是<code>185.199.108.153</code>.</p><p>这个工具在很多情况下非常有用，尤其是对于喜欢命令行的你来说。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ugp99e01j30hj0d8mxo.jpg" alt></p><p>其实 dig 是<code>usr/bin</code>下的一个可执行文件，更多用法请<code>man dig</code>查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ <span class="built_in">type</span> dig</span><br><span class="line"><span class="comment"># dig is /usr/bin/dig</span></span><br></pre></td></tr></table></figure><h3 id="2019-11-11-分享"><a href="#2019-11-11-分享" class="headerlink" title="2019-11-11[分享]"></a>2019-11-11[分享]</h3><p>今天是双十一，大家剁手快乐。</p><p>今天给大家分享一下前一段时间刚刚举行的大会<code>React Conf 2019</code>，这个是 React 最高规模的技术会议。喜欢 React 的小伙伴千万不要错过了，这里有全套视频。</p><p>地址：<a href="https://www.youtube.com/playlist?list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLPxbbTqCLbGHPxZpw4xj_Wwg8-fdNxJRh</a></p><h3 id="2019-11-08-好文"><a href="#2019-11-08-好文" class="headerlink" title="2019-11-08[好文]"></a>2019-11-08[好文]</h3><p>前几天读了一篇文章《Scaling webapps for newbs &amp; non-techies》，文章从最简单的单体应用，逐步讲到大型应用架构，不仅讲的通俗易懂，并且图画的也非常好，是我喜欢的风格。 很期待他的第二篇《the cloud for newbs and non-techies》。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pr18vd6ij30jg0bu74f.jpg" alt><br>（A single server + database）<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pr1kkny7j30jg0al74f.jpg" alt><br>（Adding a Reverse Proxy）</p><p>文章地址： <a href="https://arcentry.com/blog/scaling-webapps-for-newbs-and-non-techies/" target="_blank" rel="noopener">https://arcentry.com/blog/scaling-webapps-for-newbs-and-non-techies/</a></p><h3 id="2019-11-07-学习方法"><a href="#2019-11-07-学习方法" class="headerlink" title="2019-11-07[学习方法]"></a>2019-11-07[学习方法]</h3><p>前一段时间看了一篇文章 -《如何构建自己的产品知识库》。这篇文章的亮点在于其所提到的技巧能够横向类比到任何领域。换句话说你可以按照它将的方法构建你自己的知识库。</p><p>里面有一句话<code>产品知识体系是对产品知识搜集、筛选、整理后形成的知识组合，并且这些知识能够用于解决实际遇到的问题。</code> 学习任何知识又何尝不是呢？很多人问我学习方法，其实这个东西非常地系统，很难通过几个技巧完成，也很难在短期内看到很明显的效果。大家可以看一下，说不定对你的学习和生活所有启发，即便你不是一个产品经理。</p><p>文章地址: <a href="https://www.toutiao.com/a6738596936057618951/" target="_blank" rel="noopener">https://www.toutiao.com/a6738596936057618951/</a></p><blockquote><p>后期如果有机会的话，我也会分享一下自己的学习方法</p></blockquote><h3 id="2019-11-06-工具"><a href="#2019-11-06-工具" class="headerlink" title="2019-11-06[工具]"></a>2019-11-06[工具]</h3><p>像 PS 和 Sketch 一样，figma 也是一个设计工具，和其他相比团队显得更简单，这点有点像蓝湖。做设计的同学要了解起来了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8nh14xlj6j30tn0fbdhb.jpg" alt></p><p>地址： <a href="https://www.figma.com/" target="_blank" rel="noopener">https://www.figma.com/</a></p><h3 id="2019-11-05-观点"><a href="#2019-11-05-观点" class="headerlink" title="2019-11-05[观点]"></a>2019-11-05[观点]</h3><p>VSCode 和 MDN 进行了官方联动，<a href="https://code.visualstudio.com/updates/v1_38#_mdn-reference-for-html-and-css" target="_blank" rel="noopener">详情</a>.</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8mx8cmd5vj30lh0eo0vr.jpg" alt></p><p>再也不用跳出 IDE 用 Dash 查了。 用 Alfred + Dash 虽然方便，但是不免有一种<code>应用跳出</code>的感觉。现在就很方便了，如果之后有更多的联动支持，相信体验会越来越好。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8mxbj2wh4j30fn0dfaah.jpg" alt></p><h3 id="2019-11-04-好文"><a href="#2019-11-04-好文" class="headerlink" title="2019-11-04[好文]"></a>2019-11-04[好文]</h3><p>最近几年啊，我本人也看了很多关于微服务的介绍，理念，落地等技术文章，今天给大家推荐一篇阿里飞冰团队发布的技术文，这或许是最简单的微服务落地技术文章。这篇文章详细讲述了业务场景，并详细记录了解决问题的过程以及对比了业界的一些解决方案，管中窥豹，让读者慢慢走进微服务，从这篇文章可以学习到<code>icestark</code>这个微服务的解决方案是怎么从从到有再到落地产生实际业务价值的。</p><p>文章地址： <a href="https://zhuanlan.zhihu.com/p/88449415#h5o-9" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/88449415#h5o-9</a></p><h3 id="2019-11-01-工具"><a href="#2019-11-01-工具" class="headerlink" title="2019-11-01[工具]"></a>2019-11-01[工具]</h3><p>身为一个程序员，科学上网是标配。市面上免费的软件大多不稳定，出了问题很难及时解决。 自建服务器虽然好，但是还是有一点繁琐的，尤其是碰到了“开会”，IP 端口就会被封锁，自己处理就比较麻烦了。</p><p>今天给大家推荐一下 SSNG 的订阅功能，有了这个订阅地址就相当于有了无数的<code>自建服务器</code>，然后你可以在不同的节点之间进行切换。一般而言，我会对服务器进行测速，然后选择速度最快，如果某一个服务器挂了，我只需要一键切换到另外一个即可，无需额外操作。</p><p>市面上有很多这种订阅服务，这里推荐一个付费的服务 <a href="https://my.kynetwork.asia/aff.php?aff=12225&gid=8" target="_blank" rel="noopener">KyCloud</a>，挺便宜的，我订阅的是 45／季度，平均一个月 15，50G 流量，基本对于我来说非常够用了。</p><p>使用方式也非常简单，只需要以下三步即可。</p><ol><li>下载对应客户端</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8icx1bv11j30980bcgls.jpg" alt></p><ol start="2"><li>点击复制订阅地址</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8icwarcwmj30a70a0wef.jpg" alt></p><ol start="3"><li>将地址粘贴到客户端</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8icygoun8j30ec058aag.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8icz2pwwuj30d704vjr9.jpg" alt></p><p>提示： 你也可以像我一样测速，然后根据速度选择节点。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8iczzsgq4j308s05ot8s.jpg" alt></p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>我重新整理了下自己的公众号，并且我还给它换了一个名字<code>脑洞前端</code>，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。</p><p>之后我的文章会同步到微信公众号 <code>脑洞前端</code> ，你可以关注获取最新的文章，并和我进行交流。</p><p>另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。</p><img width="300" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7he9xdtmyj30by0byaac.jpg">]]></content>
      
      
      <categories>
          
          <category> 每日一荐 </category>
          
          <category> 2019-11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《LeetCode题解攻略》 - 草稿目录</title>
      <link href="/blog/2019/12/11/draft/"/>
      <url>/blog/2019/12/11/draft/</url>
      
        <content type="html"><![CDATA[<p>这个我为自己的新书写的一个目录，计划在一星期左右定下来大体目录，然后投入完善，希望大家多提意见，你的意见很可能会影响到这本书的内容，期待你以特别的方式参与进来，此致敬礼。</p><a id="more"></a><h2 id="1-准备知识"><a href="#1-准备知识" class="headerlink" title="1. 准备知识"></a>1. 准备知识</h2><h3 id="1-1-学习这本书之前需要什么基础"><a href="#1-1-学习这本书之前需要什么基础" class="headerlink" title="1.1 学习这本书之前需要什么基础"></a>1.1 学习这本书之前需要什么基础</h3><p>很多人觉得算法很难，需要很多公式以及数学知识。 其实并不是这样的，除非你是做算法岗位，否则并不会要求你对数学，几何学，概率学有多深的造诣，其实更看重的是分析问题，解决问题的能力和基础编码能力。</p><p>但是我们不排除LeetCode有一些数学题目，我们会在后面的章节中讲到，但是说实话LeetCode的数学题目不会涉及很难的数学知识。而且通常我们也可以通过变通的方式解决，比如LeetCode有一道水壶倒水的问题，以下是题目描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个装满水的 8 升满壶和两个分别是 5 升、3 升的空壶，请想个优雅的办法，使得其中一个水壶恰好装 4 升水，每一步的操作只能是倒空或倒满。</span><br></pre></td></tr></table></figure><p>这道题我们可以用GCD（最大公约数）解决，如果你不知道这个数学知识点也没问题。 我们可以通过BFS来解决，其实学习算法尤其是刷LeetCode只需要我们掌握简单的数学知识，高中的数学知识通常来说就足够了。</p><p>另外一个大家需要掌握的数学知识是关于后面要讲的复杂度分析，这里需要一点简单的数学知识，不过不要担心，非常简单，不会有高等数学的内容。</p><p>学习本书最好你对一种编程语言比较熟悉，出于读者的受众群体和代码简洁性，我选取了Python作为本书的主要编程语言，如果大家对Python不熟悉也没有关系，我会尽量少使用语言特有的语法糖，从而减少大家对于语言层面的认知负担。 另外Python被誉为最容易入门的语言之一也是实至名归，大家可以放心。 退一步讲，语言不应该成为我们学习算法的障碍，不是么？那让我们一起进入LeetCode的世界吧！</p><h3 id="1-2-基础数据结构和算法"><a href="#1-2-基础数据结构和算法" class="headerlink" title="1.2 基础数据结构和算法"></a>1.2 基础数据结构和算法</h3><p>在真正的刷题之前，我们一定要先打好基础，学好基本的数据结构和算法，然后以练代学进行提升和消化。</p><p>从广义上来说，数据结构其实就是数据的存储结构，算法就是操作数据的方法。而平时以及本书所探讨的其实是更为狭义角度的数据结构和算法。其实指的是某些非常典型的数据结构和算法，比如数组，链表，栈，队列，树，图等数据结构，以及二分法，动态规划，快速排序等经典的算法。</p><p>数据结构是为算法所服务的，而算法是要建立在某一种或者几种数据结构之上才可以发挥作用，这两个是相辅相成的关系。某些算法一定要建立在某种数据结构之上才行，相信你读完这本书会对这句话产生更为深刻的印象。</p><p>本书要讲的内容就是在LeetCode上反复出现的算法，经过进一步提炼，抽取近百道题目在这里进行讲解，帮助大家理清整体结构，从而高效率地刷题。</p><p>我这里总结了 7 个常见的数据结构和 7 个常见的算法以及 5 个常见的算法思想。</p><p>7 个数据结构分别是： <code>数组，栈，队列，链表，二叉树，散列表，图</code></p><p>7 个算法分别是：<code>二分法，递归，回溯法，排序，双指针，滑动窗口，并查集</code></p><p>5 个算法思想分别是：<code>分治，贪心，深度优先遍历，广度优先遍历，动态规划</code></p><p>只有掌握了这些基础的数据结构和算法，更为复杂的算法才能得心应手，刷题才会事半功倍。而LeetCode的题目虽然不断出新，但是最终用到的算法永远是那几个，很多题目都是穿着新衣服的老面孔了。大家学好这些基础套路之后会更加明白这个道理。</p><h3 id="1-3-如何刷LeetCode"><a href="#1-3-如何刷LeetCode" class="headerlink" title="1.3 如何刷LeetCode"></a>1.3 如何刷LeetCode</h3><h4 id="Leetcode网站使用方法"><a href="#Leetcode网站使用方法" class="headerlink" title="Leetcode网站使用方法"></a>Leetcode网站使用方法</h4><p>LeetCode官网收录了许多互联网公司的算法题目，一度被称为刷题神器，今天我们就来介绍下如何使用LeetCode网站，以下所讲述的内容都是以力扣中国为例。</p><p>LeetCode目前有1000多道题目，并且一直持续更新，其中有一些是带锁的，需要会员才能查看。 最上面标签栏的Problems，给出了四个分类：Algorithms、Database、Shell和Concurrency，分别表示算法题、数据库题、Shell和并发题，第一个就是我们所需要刷的算法题，并发是2019年才添加的新的模块。</p><p>点开Algorithms后，我们可以看到一列题目的列表，每个题目都有一个序号，后面的接受率（Acceptance）表示提交的正确率，Difficulty表示难易程度。这里有个小技巧，衡量一道题目难不难除了看难度之外，还可以看下接受率，接受率越低代表题目越难，这个指标有时候比难度更靠谱。</p><p>LeetCode按难易程度分成了三个级别，分别是Easy、Medium和Hard。</p><ul><li>Easy 通常不需要太多思考和也不会有复杂的细节，比较特别适合新手或者拿来热身。</li><li>Medium级别就会有些难度，一般都会涉及到经典的算法，需要一定的思考。</li><li>Hard级别是最难的，有些时候是算法本身的难度，有些时候特别需要你考虑到各种细节。</li></ul><p>你可以对题目进行筛选和排序。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ueyinaxij30oy0c6wet.jpg" alt></p><p>如果我们只想要找某一类型的题，可以通过Tags或Company来筛选。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8uez7f9tsj30aj0pggm3.jpg" alt></p><p>另外我们在做某一题时，觉得还想再做一个类似的，可以点击题目描述下方Show Similar Problems或Tags来找到相似的问题。</p><p>每个题目都有各自的Discuss区域。在这里，许多人都把自己的思路和代码放到了上面，你可以发贴提问，也可以回复别人，里面大神很多，题解质量都很高，如果实在没有思路或者想看下有没有更好的思路可以来逛一下。通常来说我建议你优先看Post或者投票最多的。</p><p>点开某一个题目，会跳转到具体题目详情页面，你可以在右侧的代码区切换选择自己需要的编程语言。</p><p>代码编写完了之后，不要急着提交，先可以测试运行下（Run Code），你可以多写几个测试用力跑一下，没有问题再提交，要知道比赛的时候错误提交要加时间的。 我们可以点开More Details查看详细运行结果信息。</p><p>每道题旁边的My Submissions可以找到自己的对于该题的提交情况，这里可以看到自己过去所有的提交，点Accepted 或 Wrong Answer就可以查看自己过去提交的代码情况，包括代码是什么，跑的时间以及时间分布图等。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8uf5vjtkuj30yj0hfjrm.jpg" alt></p><p>以上就是LeetCode的主要功能，希望通过这一节内容能让你对LeetCode网站有所了解，从而更快地进行刷题。</p><h4 id="应该怎么刷LeetCode"><a href="#应该怎么刷LeetCode" class="headerlink" title="应该怎么刷LeetCode"></a>应该怎么刷LeetCode</h4><p>我本人从开始准备算法以来刷了很多题，自己成长了很多，从刷题菜鸡，到现在对刷题套路，题型有了自己的理解，感受还是蛮多的。我本人不是算法高手，算是勤能补拙类型。不过经过几个月的学习和练习，不仅面试变得更加得心应手，而且在工作中写更容易写出干净优雅，性能好的代码。</p><p>对于我来说，刷题的过程其实就是学习数据结构和算法的过程， 不仅仅是为了刷题而刷题，这样你才能感受到刷题的乐趣。刷题至少要刷两遍，理想情况是根据自己的遗忘曲线刷多次，这个我后面也会讲到。</p><ol><li>第一遍按tag刷</li></ol><p>建议第一遍刷的时候可以先快速按照tag过一遍，快速感受一下常见数据结构和算法的套路，这样自己有一个感性的认识。</p><ol start="2"><li>第二遍一题多解，多题同解</li></ol><p>第二遍我们就不能像第一遍那样了，这个阶段我们需要多个角度思考问题，尽量做到一题多解，多题同解。我们需要对问题的本质做一些深度的理解，将来碰到类似的问题我们才能够触类旁通。</p><p>但是很多人做了几遍，碰到新题还是没有任何头绪，这是一个常见的问题，这怎么办呢？ </p><p>总结并记忆是学习以及刷题过程中非常重要的一环， 不管哪个阶段，我们都需要做对应的总结，这样将来我们再回过头看的时候，才能够快读拾起来。</p><p>anki就是根据<a href="./ibinhouse.md">艾宾浩斯记忆曲线</a>开发的一个软件，它是一个使记忆变得更容易的学习软件。支持深度自定义。 对于我本人而言，我在anki里面写了很多LeetCode题目和套路的Card，然后anki会自动帮我安排复习时间，大大减少我的认知负担，提高了我的复习效率。大家可以在书后的附录中下载anki卡片。</p><p>目前已更新卡片一览（仅列举正面）</p><ul><li>二分法解决问题的关键点是什么，相关问题有哪些?</li><li>如何用栈的特点来简化操作， 涉及到的题目有哪些？</li><li>双指针问题的思路以及相关题目有哪些？</li><li>滑动窗口问题的思路以及相关题目有哪些？</li><li>回溯法解题的思路以及相关题目有哪些？</li><li>数论解决问题的关键点是什么，相关问题有哪些?</li><li>位运算解决问题的关键点是什么，相关问题有哪些?</li></ul><p>大家刷了很多题之后，就会发现来来回回，题目就那么几种类型，因此掌握已有题目类型是多么重要。那样LeetCode出题的老师，很多也是在原有的题目基础上做了适当扩展（比如two-sum,two-sum2,three-sum, four-sum等等）或者改造（使得不那么一下子看出问题的本质，比如猴子吃香蕉问题）。</p><p>其中算法，主要是以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">基础技巧：分治、二分、贪心</span><br><span class="line">排序算法：快速排序、归并排序、计数排序</span><br><span class="line">搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等</span><br><span class="line">图论：最短路径、最小生成树</span><br><span class="line">动态规划：背包问题、最长子序列</span><br></pre></td></tr></table></figure><p>数据结构，主要有如下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数组与链表：单 / 双向链表</span><br><span class="line">栈与队列</span><br><span class="line">哈希表</span><br><span class="line">堆：最大堆 ／ 最小堆</span><br><span class="line">树与图：最近公共祖先、并查集</span><br><span class="line">字符串：前缀树（字典树） ／ 后缀树</span><br></pre></td></tr></table></figure><p>做到了以上几点，我们还需要坚持。这个其实是最难的，不管做什么事情，坚持都是最重要也是最难的。</p><p>为了督促自己，同时帮助大家成长，我在群里举办《每日一题》活动，每日一题是在交流群（包括微信和qq）里进行的一种活动，大家一起 解一道题，这样讨论问题更加集中，会得到更多的反馈。而且 这些题目可以被记录下来，日后会进行筛选添加到仓库的题解模块， 感兴趣的可以到书后的附录部分进群交流。</p><h3 id="1-4-复杂度分析"><a href="#1-4-复杂度分析" class="headerlink" title="1.4 复杂度分析"></a>1.4 复杂度分析</h3><p>想学算法，首先要学的第一件事就是如何判断一个算法的好坏。 好的程序有很多的评判标准，包括但不限于可读性，扩展性性能等。 这里我们来看其中一种 - 性能。 坏的程序可能性能也很好，但是好的程序通常性能都比较好。那么如何分析一个算法的性能好坏呢？这就是我们要讲的复杂度分析，所有的数据结构教程都会把这个放在前面来讲，不仅仅是因为他们是基础，更因为他们真的非常重要。学会了复杂度分析，你才能够对你的算法进行分析，从而帮助你写出复杂度更优的算法。</p><p>那么怎么样才能衡量一个算法代码的执行效率呢？</p><p>如下是一个从1加到n的一个算法，这个算法用了一层循环来完成，并且借助了一个变量res来完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(n)</span>:</span></span><br><span class="line">  res = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    res += i</span><br><span class="line">  <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>我们将这个方法从更微观的角度来进行分析，上述代码会执行n次循环体的内容，每一次执行都是常数时间，我们不妨假设执行的时间是x。我们假设赋值语句<code>res = 0</code>和<code>return res</code>的时间分别为y和z   那么执行的总时间我们约等于 n * x + y + z, 我们<code>粗略</code>将x，y和z都看成一样的，我们得出总时间为 (n + 2) * x 换句话说算法的时间和数据的规模成正比。</p><p>实际上，这更是一种叫做大O表示法的基本思想, 它是一种描述算法性能的记法，这种描述和编译系统、机器结构、处理器的快慢等因素无关。 这种描述的参数是n，表示数据的规模。 这里的O表示量级（order），比如说“二分查找是$O(logN)$的”，也就是说它需要“通过 logn量级的操作去查找一个规模为n的数据结构（通常是数组）”。这种渐进地估计对算法的理论分析和大致比较是非常有价值，可以很快地对算法进行一个大致地估算。例如，一个拥有较小常数项的 $O(N^2)$算法在规模n较小的情况下可能比一个高常数项的$O(N)$算法运行得更快。但是随着n足够大以后，具有较慢上升函数的算法必然工作得更快，因此在采用大O标记复杂度的时候，可以忽略系数。</p><p>我们还应该区分算法的最好情况，最坏情况和平均情况，但是这不在本书的讨论范畴，本书的所有复杂度均指的是平均复杂度。</p><p>那么如何分析一个算法的复杂度呢？下面我们介绍几种常见时间复杂度，几乎所有的算法的复杂度都是以下中的一种</p><p>我对时间复杂度进行了一个小的分类。</p><ul><li>第一类是常数阶。</li></ul><p>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cnt = <span class="number">1</span></span><br><span class="line">l = <span class="number">0</span></span><br><span class="line">r = len(list) - <span class="number">1</span></span><br><span class="line"><span class="comment"># 不管这种代码有多少行，都是常数复杂度，即$O(1)$,因此系数是被忽略的。</span></span><br></pre></td></tr></table></figure><ul><li>第二类是 n,n^2,n^3 …</li></ul><p>一个简单的方法是<code>关注循环执行次数最多的那一段代码就好了</code>，这段执行次数最多的代码执行次数的n的量级，就是整个算法的时间复杂度。即如果是一层N的循环，那么时间复杂度就是$O(N)$, 如果嵌套了两层N的循环，那么时间复杂度就是$O(N^2)$，依次类推。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        mapper = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i] <span class="keyword">in</span> mapper):</span><br><span class="line">                <span class="keyword">return</span> [mapper[target - nums[i]], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mapper[nums[i]] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>如上代码，我们进行了一层的循环，那么时间复杂度就是$O(N^2)$</p><ul><li>第三类是对数阶。 logn  nlogn</li></ul><p>这同样是一种非常常见的复杂度，多见于二分查找和一些排序算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numRescueBoats</span><span class="params">(self, people: List[int], limit: int)</span> -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(people) - <span class="number">1</span></span><br><span class="line">        people.sort()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            total = people[l] + people[r]</span><br><span class="line">            <span class="keyword">if</span> total &gt; limit:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (l == r):</span><br><span class="line">            <span class="keyword">return</span> res + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>上面的代码是一个典型的二分查找，其时间复杂度是logn</p><ul><li>第四类是指数阶 2^n</li></ul><p>指数的增长已经非常恐怖了，一个典型的例子是fabnicca数列的递归实现版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>如果你把上述的计算过程看成树的一个节点，那么整个计算过程就像是一颗很大的树。这棵树有很多的重复计算，大致算下来的话，是2^n。</p><ul><li>第五类是对数阶 n！</li></ul><p>我们知道n个不相同的数字的全排列有n!个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorrail</span><span class="params">(n)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> n * factorrail(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>很明显上面的代码就是n!</p><p>下面给出上面列举的几种常见的时间复杂度的趋势图对比，大家直观感受一下。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8o458x4cvj311e0u00tk.jpg" alt><br>（各种复杂度的渐进趋势对比）</p><p>从算法可以分析出时间复杂度，相反题目的时间复杂度要求，我们甚至可以猜测出可能用到的算法，比如算法要求logn，那么就有可能是二分法。</p><p>空间复杂度分析比时间复杂度分析要简单地多,常见的空间复杂度有$O(1)$、$O(N)$、$O(N^2)$、$O(logN)$、$O(logN)$、$O(N!)$这样的对数阶复杂度基本不会有，关于空间复杂度这里不做更多介绍了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>时间复杂度是算法的基石，学习它对于我们学习后面的章节有很大的帮助。 我们引入了大O表示法来衡量算法的好坏。接着通过若干实例了解了各种时间复杂度，其实对于复杂度，掌握上面提到的几种常见的就已经够应付绝大多数场合了。</p><p>通过上面的学习，相信你对评估一个算法的时间复杂度有了初步的了解。随着学习的深入，相信你会对复杂度分析有着更为深入的理解。</p><h2 id="2-数学之美"><a href="#2-数学之美" class="headerlink" title="2. 数学之美"></a>2. 数学之美</h2><p>LeetCode中有很多数学问题，截止到本书出版，LeetCode中有数学标签的题目一共是159，在所有标签的分类中排名第3。这些题目中有些是包着数学外衣的伪数学问题，还有一些是真正数学问题。这需要大家有着极强的分辨能力。不要被数学两个字吓住了，本章不会讲非常复杂的数学概念和公式，实际上你只需要一些高中数学知识即可。</p><p>除非是面试算法岗位，笔试和面试题才会涉及到一些比较复杂度的数学知识，比如微积分，线性代数，概率论，信息论等。</p><p>虽然有的题目可以用数学公式轻松解决，但是这并不意味你需要对数学有很深的造诣。举例来说，LeetCode 69.实现开方，就是一道可以使用纯数学方法 - <code>牛顿迭代法</code>来解决的一道题，但是你完全可以使用二分法解决，尽管效率远远不及<code>牛顿迭代法</code>，实际上现在的计算器计算开方也不是二分法计算的。但是这通常是一个加分项，如果你可以通过别的方法解决，也未尝不可。</p><p>很多题目一眼看上去就是个数学问题，如果你尝试使用数学的角度没有什么思路或者解不出来的时候，可以考虑换最常规，最符合直觉的做法，当然做之前要估算一下数据范围和时间，不要写完才发现超时。</p><p>有些题目只是涉及到一些数学名词，并且会在题目中详细地进行解释。 比如关于质数性质，阶乘性质的题目，还有一些造轮子题目，比如实现Pow等。还有一些干脆定义一个数学概念，让你去做。比如开心数，回文数，丑数等。</p><p>我们这章主要讲解纯数学问题，需要用到一些数学的性质类的题目，这或许是大家更想要看的。</p><h3 id="2-1-N-SUM-题目"><a href="#2-1-N-SUM-题目" class="headerlink" title="2.1 N-SUM 题目"></a>2.1 N-SUM 题目</h3><p>LeetCode上有很多经典的系列问题，今天我们就来看一下N-SUM系列问题。</p><h3 id="2-2-连续整数和"><a href="#2-2-连续整数和" class="headerlink" title="2.2 连续整数和"></a>2.2 连续整数和</h3><p>这是一个非常经典，被各种收录的一个题目，这道题好在虽然简单，但是却可以从多个纬度进行解决，非常适合用来查考一个人的真实水平，一些比较大的公司也会用它来进行算法面试的第一道题。</p><h3 id="2-3-最大数"><a href="#2-3-最大数" class="headerlink" title="2.3 最大数"></a>2.3 最大数</h3><h3 id="2-4-分数到小数"><a href="#2-4-分数到小数" class="headerlink" title="2.4 分数到小数"></a>2.4 分数到小数</h3><h3 id="2-5-最大整除子集"><a href="#2-5-最大整除子集" class="headerlink" title="2.5 最大整除子集"></a>2.5 最大整除子集</h3><h3 id="2-6-质数排列"><a href="#2-6-质数排列" class="headerlink" title="2.6 质数排列"></a>2.6 质数排列</h3><ol><li>质数</li></ol><ol start="2"><li>全排列</li></ol><h3 id="2-8-快乐数"><a href="#2-8-快乐数" class="headerlink" title="2.8 快乐数"></a>2.8 快乐数</h3><blockquote><p>这类题目是给定一个定义（情景），让你实现算法找出满足特定条件的数字</p></blockquote><h2 id="3-回文的艺术"><a href="#3-回文的艺术" class="headerlink" title="3. 回文的艺术"></a>3. 回文的艺术</h2><p>回文是很多教材中被提到的一个题目，通常是用来学习栈的一个练习题，LeetCode中有关回文的题目也是蛮多的，单从数据结构上来看就有字符串，数字和链表。今天我们就结合几个LeetCode题目来攻克它。</p><h3 id="3-1-回文字符串"><a href="#3-1-回文字符串" class="headerlink" title="3.1 回文字符串"></a>3.1 回文字符串</h3><h3 id="3-2-回文链表"><a href="#3-2-回文链表" class="headerlink" title="3.2 回文链表"></a>3.2 回文链表</h3><h3 id="3-3-回文数字"><a href="#3-3-回文数字" class="headerlink" title="3.3 回文数字"></a>3.3 回文数字</h3><h3 id="3-4-回文总数"><a href="#3-4-回文总数" class="headerlink" title="3.4 回文总数"></a>3.4 回文总数</h3><h2 id="4-游戏之乐"><a href="#4-游戏之乐" class="headerlink" title="4. 游戏之乐"></a>4. 游戏之乐</h2><p>我很喜欢玩游戏，实际上很多游戏背后都是有很多算法存在的，我们通过LeetCode上一些关于游戏的题目来一窥究竟吧，虽然这里的题目和实际游戏用到的算法难度差很多，但是这里的基本思想是一样的。</p><h3 id="4-1-生命游戏"><a href="#4-1-生命游戏" class="headerlink" title="4.1 生命游戏"></a>4.1 生命游戏</h3><h3 id="4-2-报数"><a href="#4-2-报数" class="headerlink" title="4.2 报数"></a>4.2 报数</h3><h3 id="4-3-数独游戏"><a href="#4-3-数独游戏" class="headerlink" title="4.3 数独游戏"></a>4.3 数独游戏</h3><h2 id="5-BFS-amp-DFS"><a href="#5-BFS-amp-DFS" class="headerlink" title="5. BFS &amp; DFS"></a>5. BFS &amp; DFS</h2><p>这是LeetCode后期新增的一个板块，题目还比较少。</p><h2 id="6-二分法"><a href="#6-二分法" class="headerlink" title="6. 二分法"></a>6. 二分法</h2><p>二分法真的是一个非常普遍的算法了，更严格的说其实是一种思想，如果把二改成N其实就是一种分治思想。LeetCode关于二分法的题目实在太多了，我们挑选几个代表性的来感受一下，LeetCode到底是如何考察我们二分法的。</p><h3 id="6-1-你真的了解二分法么？"><a href="#6-1-你真的了解二分法么？" class="headerlink" title="6.1 你真的了解二分法么？"></a>6.1 你真的了解二分法么？</h3><h3 id="6-2-一些显然的二分"><a href="#6-2-一些显然的二分" class="headerlink" title="6.2 一些显然的二分"></a>6.2 一些显然的二分</h3><h3 id="6-3-隐藏的二分法"><a href="#6-3-隐藏的二分法" class="headerlink" title="6.3 隐藏的二分法"></a>6.3 隐藏的二分法</h3><p>二进制和二分法？</p><blockquote><p>744 吃香蕉 循环数组 数学开方  等等</p></blockquote><h3 id="6-4-寻找峰值"><a href="#6-4-寻找峰值" class="headerlink" title="6.4 寻找峰值"></a>6.4 寻找峰值</h3><h2 id="7-神奇的比特"><a href="#7-神奇的比特" class="headerlink" title="7. 神奇的比特"></a>7. 神奇的比特</h2><p>前菜： 如何将一个IP地址用一个字节存储，支持序列化和反序列化操作。</p><p>计算机是用过二进制来表示信息的，有时候我们从二进制思考问题，会发现一个全新的世界。</p><h3 id="7-1-那些特立独行的数字"><a href="#7-1-那些特立独行的数字" class="headerlink" title="7.1 那些特立独行的数字"></a>7.1 那些特立独行的数字</h3><h3 id="7-2-桶中摸黑白球"><a href="#7-2-桶中摸黑白球" class="headerlink" title="7.2 桶中摸黑白球"></a>7.2 桶中摸黑白球</h3><h3 id="7-3-实现加法"><a href="#7-3-实现加法" class="headerlink" title="7.3 实现加法"></a>7.3 实现加法</h3><h3 id="7-4-二进制-1-的个数"><a href="#7-4-二进制-1-的个数" class="headerlink" title="7.4 二进制 1 的个数"></a>7.4 二进制 1 的个数</h3><h3 id="7-5-悲惨的老鼠"><a href="#7-5-悲惨的老鼠" class="headerlink" title="7.5 悲惨的老鼠"></a>7.5 悲惨的老鼠</h3><h2 id="8-设计题"><a href="#8-设计题" class="headerlink" title="8. 设计题"></a>8. 设计题</h2><p>有时候我们面对的不是一个算法题，而是一个设计题目，这种题目比较开放，让你自己设计数据结构和算法。这比限定数据结构和算法更能考察一个人综合运用知识的能力，是一个经常被拿来进行面试的一类题目。</p><h3 id="8-1-设计-LRU"><a href="#8-1-设计-LRU" class="headerlink" title="8.1 设计 LRU"></a>8.1 设计 LRU</h3><h3 id="8-2-设计-LFU"><a href="#8-2-设计-LFU" class="headerlink" title="8.2 设计 LFU"></a>8.2 设计 LFU</h3><h3 id="8-3-最小栈"><a href="#8-3-最小栈" class="headerlink" title="8.3 最小栈"></a>8.3 最小栈</h3><h3 id="8-4-队列实现栈"><a href="#8-4-队列实现栈" class="headerlink" title="8.4 队列实现栈"></a>8.4 队列实现栈</h3><h3 id="8-5-设计-Trie-树"><a href="#8-5-设计-Trie-树" class="headerlink" title="8.5 设计 Trie 树"></a>8.5 设计 Trie 树</h3><h2 id="9-双指针"><a href="#9-双指针" class="headerlink" title="9. 双指针"></a>9. 双指针</h2><p>双指针的题目真的非常多，可以看出这个是一个重要重要的知识点。在实际使用过程中，我将双指针问题分为两种，一种是头尾双指针，一种是快慢双指针。</p><h3 id="9-1-头尾指针"><a href="#9-1-头尾指针" class="headerlink" title="9.1 头尾指针"></a>9.1 头尾指针</h3><h4 id="9-1-1-盛水问题"><a href="#9-1-1-盛水问题" class="headerlink" title="9.1.1 盛水问题"></a>9.1.1 盛水问题</h4><h4 id="9-1-2-两数相加-2"><a href="#9-1-2-两数相加-2" class="headerlink" title="9.1.2 两数相加 2"></a>9.1.2 两数相加 2</h4><h3 id="9-2-快慢指针"><a href="#9-2-快慢指针" class="headerlink" title="9.2 快慢指针"></a>9.2 快慢指针</h3><h4 id="9-2-1-删除有序数组的重复元素"><a href="#9-2-1-删除有序数组的重复元素" class="headerlink" title="9.2.1 删除有序数组的重复元素"></a>9.2.1 删除有序数组的重复元素</h4><h4 id="9-2-2-链表中的快慢指针"><a href="#9-2-2-链表中的快慢指针" class="headerlink" title="9.2.2 链表中的快慢指针"></a>9.2.2 链表中的快慢指针</h4><h2 id="10-查表与动态规划"><a href="#10-查表与动态规划" class="headerlink" title="10. 查表与动态规划"></a>10. 查表与动态规划</h2><p>如果说递归是从问题的结果倒推，直到问题的规模缩小到寻常。 那么动态规划就是从寻常入手， 逐步扩大规模到最优子结构。 这句话需要一定的时间来消化, 如果不理解，可以过一段时间再来看。</p><p>递归的解决问题非常符合人的直觉，代码写起来比较简单。但是我们通过分析（可以尝试画一个递归树），可以看出递归在缩小问题规模的同时可能会 重复计算。 279.perfect-squares 中 我通过递归的方式来解决这个问题，同时内部维护了一个缓存 来存储计算过的运算，那么我们可以减少很多运算。 这其实和动态规划有着异曲同工的地方。</p><h3 id="10-1-爬楼梯"><a href="#10-1-爬楼梯" class="headerlink" title="10.1 爬楼梯"></a>10.1 爬楼梯</h3><h3 id="10-2-聪明的盗贼"><a href="#10-2-聪明的盗贼" class="headerlink" title="10.2 聪明的盗贼"></a>10.2 聪明的盗贼</h3><p>六（七）个版本，带你一步步进化，走向极致</p><h3 id="10-3-不同路径"><a href="#10-3-不同路径" class="headerlink" title="10.3 不同路径"></a>10.3 不同路径</h3><h3 id="10-4-硬币找零"><a href="#10-4-硬币找零" class="headerlink" title="10.4 硬币找零"></a>10.4 硬币找零</h3><h3 id="10-5-最短编辑距离"><a href="#10-5-最短编辑距离" class="headerlink" title="10.5 最短编辑距离"></a>10.5 最短编辑距离</h3><h2 id="11-滑动窗口"><a href="#11-滑动窗口" class="headerlink" title="11. 滑动窗口"></a>11. 滑动窗口</h2><p>你可能听过TCP的滑动窗口，这里要讲的滑动窗口其实思想是一样的，这里要讲的滑动窗口通常被用在处理连续数组或者字符的问题上。</p><h3 id="最长连续不重复子串"><a href="#最长连续不重复子串" class="headerlink" title="最长连续不重复子串"></a>最长连续不重复子串</h3><h3 id="最短子数组之和"><a href="#最短子数组之和" class="headerlink" title="最短子数组之和"></a>最短子数组之和</h3><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><h2 id="12-博弈"><a href="#12-博弈" class="headerlink" title="12. 博弈"></a>12. 博弈</h2><p>博弈，词语解释是局戏、围棋、赌博。 现代数学中有博弈论，亦名“对策论”、“赛局理论”，属应用数学的一个分支， 表示在多决策主体之间行为具有相互作用时，各主体根据所掌握信息及对自身能力的认知，做出有利于自己的决策的一种行为理论。</p><p>这类问题通常没那么直接和好下手，需要你进行一定的推演才能发现问题的本质。</p><h3 id="12-1-alec"><a href="#12-1-alec" class="headerlink" title="12.1 alec"></a>12.1 alec</h3><h3 id="12-2-Nim"><a href="#12-2-Nim" class="headerlink" title="12.2 Nim"></a>12.2 Nim</h3><h3 id="12-3-486-预测赢家"><a href="#12-3-486-预测赢家" class="headerlink" title="12.3 486. 预测赢家"></a>12.3 486. 预测赢家</h3><h2 id="13-股票系列"><a href="#13-股票系列" class="headerlink" title="13. 股票系列"></a>13. 股票系列</h2><p>LeetCode上有很多经典的系列问题，今天我们就来看一下这个股票系列问题。</p><h3 id="13-1-股票买卖的最佳时机-1"><a href="#13-1-股票买卖的最佳时机-1" class="headerlink" title="13.1 股票买卖的最佳时机 1"></a>13.1 股票买卖的最佳时机 1</h3><h3 id="13-2-股票买卖的最佳时机-2"><a href="#13-2-股票买卖的最佳时机-2" class="headerlink" title="13.2 股票买卖的最佳时机 2"></a>13.2 股票买卖的最佳时机 2</h3><h3 id="13-3-股票买卖的最佳时机-3"><a href="#13-3-股票买卖的最佳时机-3" class="headerlink" title="13.3 股票买卖的最佳时机 3"></a>13.3 股票买卖的最佳时机 3</h3><h3 id="13-4-股票买卖的最佳时机-4"><a href="#13-4-股票买卖的最佳时机-4" class="headerlink" title="13.4 股票买卖的最佳时机 4"></a>13.4 股票买卖的最佳时机 4</h3><h2 id="14-分治法"><a href="#14-分治法" class="headerlink" title="14. 分治法"></a>14. 分治法</h2><p>分治是一种非常重要的算法思想，而不是一个算法。和具体算法不同，算法思想在任何数据结构下都可以使用。</p><h3 id="14-1-合并-K-个排序链表"><a href="#14-1-合并-K-个排序链表" class="headerlink" title="14.1 合并 K 个排序链表"></a>14.1 合并 K 个排序链表</h3><h3 id="14-2-数组中的第-K-个最大元素"><a href="#14-2-数组中的第-K-个最大元素" class="headerlink" title="14.2 数组中的第 K 个最大元素"></a>14.2 数组中的第 K 个最大元素</h3><h3 id="14-3-搜索二维矩阵"><a href="#14-3-搜索二维矩阵" class="headerlink" title="14.3 搜索二维矩阵"></a>14.3 搜索二维矩阵</h3><h2 id="15-贪心法"><a href="#15-贪心法" class="headerlink" title="15. 贪心法"></a>15. 贪心法</h2><p>贪心或许是最难的一种算法思想了。</p><h3 id="15-1-跳跃游戏"><a href="#15-1-跳跃游戏" class="headerlink" title="15.1 跳跃游戏"></a>15.1 跳跃游戏</h3><h3 id="15-2-任务调度器"><a href="#15-2-任务调度器" class="headerlink" title="15.2 任务调度器"></a>15.2 任务调度器</h3><h2 id="16-回溯"><a href="#16-回溯" class="headerlink" title="16. 回溯"></a>16. 回溯</h2><p>这是一种非常暴力的搜索算法，优点是书写简单有固定模板，且适用范围很广。</p><h3 id="16-1-求组合数-1"><a href="#16-1-求组合数-1" class="headerlink" title="16.1 求组合数 1"></a>16.1 求组合数 1</h3><h3 id="16-2-求组合数-2"><a href="#16-2-求组合数-2" class="headerlink" title="16.2 求组合数 2"></a>16.2 求组合数 2</h3><h3 id="16-3-求所有子集"><a href="#16-3-求所有子集" class="headerlink" title="16.3 求所有子集"></a>16.3 求所有子集</h3><h3 id="16-4-全排列"><a href="#16-4-全排列" class="headerlink" title="16.4 全排列"></a>16.4 全排列</h3><h3 id="16-5-海岛问题"><a href="#16-5-海岛问题" class="headerlink" title="16.5 海岛问题"></a>16.5 海岛问题</h3><h2 id="17-一些有趣的题目"><a href="#17-一些有趣的题目" class="headerlink" title="17. 一些有趣的题目"></a>17. 一些有趣的题目</h2><p>这里让我们来看一下LeetCode上那些惊人的算法。</p><h3 id="17-1-求众数"><a href="#17-1-求众数" class="headerlink" title="17.1 求众数"></a>17.1 求众数</h3><h3 id="17-2-手撕排序"><a href="#17-2-手撕排序" class="headerlink" title="17.2 手撕排序"></a>17.2 手撕排序</h3><h3 id="17-3-星期几"><a href="#17-3-星期几" class="headerlink" title="17.3 星期几"></a>17.3 星期几</h3><h3 id="17-4-量筒问题"><a href="#17-4-量筒问题" class="headerlink" title="17.4 量筒问题"></a>17.4 量筒问题</h3><h3 id="17-5-实现开方"><a href="#17-5-实现开方" class="headerlink" title="17.5 实现开方"></a>17.5 实现开方</h3><h3 id="17-6-4的次方"><a href="#17-6-4的次方" class="headerlink" title="17.6 4的次方"></a>17.6 4的次方</h3><h2 id="18-一些通用解题模板"><a href="#18-一些通用解题模板" class="headerlink" title="18. 一些通用解题模板"></a>18. 一些通用解题模板</h2><p>不仅是平时做工程项目，刷题的过程也非常讲究风格一致，如果有一些非常优秀的模板可以直接拿来用，一方便减少做题时间和出错的可能，另一方面做题风格一致有利于自己回顾。 如果你是在面试，相信一定也会为你加分不少。</p><h3 id="18-1-二分法"><a href="#18-1-二分法" class="headerlink" title="18.1 二分法"></a>18.1 二分法</h3><h3 id="18-2-回溯法"><a href="#18-2-回溯法" class="headerlink" title="18.2 回溯法"></a>18.2 回溯法</h3><h3 id="18-3-递归"><a href="#18-3-递归" class="headerlink" title="18.3 递归"></a>18.3 递归</h3><h3 id="18-4-并查集"><a href="#18-4-并查集" class="headerlink" title="18.4 并查集"></a>18.4 并查集</h3><ul><li>朋友圈</li><li>计算小岛数2</li></ul><h2 id="19-融会贯通"><a href="#19-融会贯通" class="headerlink" title="19. 融会贯通"></a>19. 融会贯通</h2><p>这里我们要把本书降到的知识进行融会贯通，纵向上我们不满足于一种解法，我们尝试使用多种解法去解决。 横向上我们需要去总结哪些题目和这道题目类似。</p><p>这通常被用在第二遍刷LeetCode的过程中。</p><h3 id="19-1-最大子序列和问题"><a href="#19-1-最大子序列和问题" class="headerlink" title="19.1 最大子序列和问题"></a>19.1 最大子序列和问题</h3><h3 id="19-2-循环移位问题"><a href="#19-2-循环移位问题" class="headerlink" title="19.2 循环移位问题"></a>19.2 循环移位问题</h3><h3 id="19-3-k-问题"><a href="#19-3-k-问题" class="headerlink" title="19.3 k 问题"></a>19.3 k 问题</h3><h2 id="20-解题技巧-amp-面试技巧"><a href="#20-解题技巧-amp-面试技巧" class="headerlink" title="20. 解题技巧&amp;面试技巧"></a>20. 解题技巧&amp;面试技巧</h2><p>在水平知识一样的情况下，如果能够LeetCode上效率更好？如何面试的时候加分，这是本章我们要探讨的主要内容。</p><ul><li>一定要看限制条件，很多时候限制条件起到了提示的作用，并且可以帮助你过滤错误答案</li></ul><h2 id="21-参考"><a href="#21-参考" class="headerlink" title="21. 参考"></a>21. 参考</h2>]]></content>
      
      
      <categories>
          
          <category> 书 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 书 </tag>
            
            <tag> 草稿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《一文看懂浏览器事件循环》</title>
      <link href="/blog/2019/12/11/event-loop/"/>
      <url>/blog/2019/12/11/event-loop/</url>
      
        <content type="html"><![CDATA[<p>实际上浏览器的事件循环标准是由 HTML 标准规定的，具体来说就是由whatwg规定的，具体内容可以参考<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener">event-loops in browser</a>。而NodeJS中事件循环其实也略有不同，具体可以参考<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#what-is-the-event-loop" target="_blank" rel="noopener">event-loops in nodejs</a></p><p>我们在讲解<code>事件模型</code>的时候，多次提到了事件循环。 <code>事件</code>指的是其所处理的对象就是事件本身，每一个浏览器都至少有一个事件循环，一个事件循环至少有一个任务队列。<code>循环</code>指的是其永远处于一个“无限循环”中。不断将注册的回调函数推入到执行栈。</p><p>那么事件循环究竟是用来做什么的？浏览器的事件循环和NodeJS的事件循环有什么不同？让我们从零开始，一步一步探究背后的原因。</p><a id="more"></a><h2 id="为什么要有事件循环"><a href="#为什么要有事件循环" class="headerlink" title="为什么要有事件循环"></a>为什么要有事件循环</h2><h3 id="JS引擎"><a href="#JS引擎" class="headerlink" title="JS引擎"></a>JS引擎</h3><p>要回答这个问题，我们先来看一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>以上一段简单的JS代码，究竟是怎么被浏览器执行的？</p><p>首先，浏览器想要执行JS脚本，需要一个“东西”，将JS脚本（本质上是一个纯文本），变成一段机器可以理解并执行的计算机指令。这个“东西”就是JS引擎，它实际上会将JS脚本进行编译和执行，整个过程非常复杂，这里不再过多介绍，感兴趣可以期待下我的V8章节，如无特殊说明，以下都拿V8来举例子。</p><p>有两个非常核心的构成，<code>执行栈</code>和<code>堆</code>。执行栈中存放正在执行的代码，堆中存放变量的值，通常是不规则的。</p><p>当V8执行到<code>a()</code>这一行代码的时候，a会被压入栈顶。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ltfr1pfij307j06gt8h.jpg" alt></p><p>在a的内部，我们碰到了<code>b()</code>，这个时候b被压入栈顶。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lth4pggfj307906rwe9.jpg" alt></p><p>在b的内部，我们又碰到了<code>c()</code>，这个时候c被压入栈顶。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ltert9f5j307i06p0si.jpg" alt></p><p>c执行完毕之后，会从栈顶移除。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lth4pggfj307906rwe9.jpg" alt></p><p>函数返回到b，b也执行完了，b也从栈顶移除。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ltfr1pfij307j06gt8h.jpg" alt></p><p>同样a也会被移除。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ltkvl983j3079068q2p.jpg" alt></p><p>整个过程用动画来表示就是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lx8oasxag30gn09y0wq.gif" alt><br>(<a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gYygpIHt9CmZ1bmN0aW9uIGIoKSB7CgljKCk7Cn0KZnVuY3Rpb24gYSgpIHsKCWIoKTsKfQphKCk7!!!" target="_blank" rel="noopener">在线观看</a>)</p><p>这个时候我们还没有涉及到<code>堆内存</code>和<code>执行上下文栈</code>，一切还比较简单，这些内容我们放到后面来讲。</p><h3 id="DOM-和-WEB-API"><a href="#DOM-和-WEB-API" class="headerlink" title="DOM 和 WEB API"></a>DOM 和 WEB API</h3><p>现在我们有了可以执行JS的引擎，但是我们的目标是<code>构建用户界面</code>，而传统的前端用户界面是基于DOM构建的，因此我们需要引入DOM。DOM是<code>文档对象模型</code>，其提供了一系列JS可以直接调用的接口，理论上其可以提供其他语言的接口，而不仅仅是JS。 而且除了DOM接口可以给JS调用，浏览器还提供了一些WEB API。 DOM也好，WEB API也好，本质上和JS没有什么关系，完全不一回事。JS对应的ECMA规范，V8用来实现ECMA规范，其他的它不管。 这也是JS引擎和JS执行环境的区别，V8是JS引擎，用来执行JS代码，浏览器和Node是JS执行环境，其提供一些JS可以调用的API即<code>JS bindings</code>。</p><p>由于浏览器的存在，现在JS可以操作DOM和WEB API了，看起来是可以构建用户界面啦。 有一点需要提前讲清楚，V8只有栈和堆，其他诸如事件循环，DOM，WEB API它一概不知。原因前面其实已经讲过了，因为V8只负责JS代码的编译执行，你给V8一段JS代码，它就从头到尾一口气执行下去，中间不会停止。</p><p>另外这里我还要继续提一下，JS执行栈和渲染线程是相互阻塞的。为什么呢？ 本质上因为JS太灵活了，它可以去获取DOM中的诸如坐标等信息。 如果两者同时执行，就有可能发生冲突，比如我先获取了某一个DOM节点的x坐标，下一时刻坐标变了。 JS又用这个“旧的”坐标进行计算然后赋值给DOM，冲突便发生了。 解决冲突的方式有两种：</p><ol><li>限制JS的能力，你只能在某些时候使用某些API。 这种做法极其复杂，还会带来很多使用不便。</li><li>JS和渲染线程不同时执行就好了，一种方法就是现在广泛采用的<code>相互阻塞</code>。 实际上这也是目前浏览器广泛采用的方式。</li></ol><h3 id="单线程-or-多线程-or-异步"><a href="#单线程-or-多线程-or-异步" class="headerlink" title="单线程 or 多线程 or 异步"></a>单线程 or 多线程 or 异步</h3><p>前面提到了<code>你给V8一段JS代码，它就从头到尾一口气执行下去，中间不会停止</code>。 为什么不停止，可以设计成可停止么，就好像C语言一样？</p><p>假设我们需要获取用户信息，获取用户的文章，获取用的朋友。</p><h4 id="单线程无异步"><a href="#单线程无异步" class="headerlink" title="单线程无异步"></a>单线程无异步</h4><p>由于是单线程无异步，因此我们三个接口需要采用同步方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetchUserInfoSync().then(doSomethingA); <span class="comment">// 1s</span></span><br><span class="line">fetchMyArcticlesSync().then(doSomethingB);<span class="comment">// 3s</span></span><br><span class="line">fetchMyFriendsSync().then(doSomethingC);<span class="comment">// 2s</span></span><br></pre></td></tr></table></figure><p>由于上面三个请求都是同步执行的，因此上面的代码会先执行<code>fetchUserInfoSync</code>，一秒之后执行<code>fetchMyArcticlesSync</code>，再过三秒执行<code>fetchMyFriendsSync</code>。 最可怕的是我们刚才说了<code>JS执行栈和渲染线程是相互阻塞的</code>。 因此用户就在这期间根本无法操作，界面无法响应，这显然是无法接受的。</p><h4 id="多线程无异步"><a href="#多线程无异步" class="headerlink" title="多线程无异步"></a>多线程无异步</h4><p>由于是多线程无异步，虽然我们三个接口仍然需要采用同步方式，但是我们可以将代码分别在多个线程执行，比如我们将这段代码放在三个线程中执行。</p><p>线程一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetchUserInfoSync().then(doSomethingA); <span class="comment">// 1s</span></span><br></pre></td></tr></table></figure><p>线程二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetchMyArcticlesSync().then(doSomethingB); <span class="comment">// 3s</span></span><br></pre></td></tr></table></figure><p>线程三：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetchMyFriendsSync().then(doSomethingC); <span class="comment">// 2s</span></span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1g9lzjslxcaj20lr08nmy3.jpg" alt="1575538849801.jpg"></p><p>由于三块代码同时执行，因此总的时间最理想的情况下取决与最慢的时间，也就是3s，这一点和使用异步的方式是一样的（当然前提是请求之间无依赖）。为什么要说最理想呢？由于三个线程都可以对DOM和堆内存进行访问，因此很有可能会冲突，冲突的原因和我上面提到的JS线程和渲染线程的冲突的原因没有什么本质不同。因此最理想情况没有任何冲突的话是3s，但是如果有冲突，我们就需要借助于诸如<code>锁</code>来解决，这样时间就有可能高于3s了。 相应地编程模型也会更复杂，处理过锁的程序员应该会感同身受。</p><h4 id="单线程-异步"><a href="#单线程-异步" class="headerlink" title="单线程 + 异步"></a>单线程 + 异步</h4><p>如果还是使用单线程，改成异步是不是会好点？问题的是关键是如何实现异步呢？这就是我们要讲的主题 - <code>事件循环</code>。</p><h2 id="事件循环究竟是怎么实现异步的？"><a href="#事件循环究竟是怎么实现异步的？" class="headerlink" title="事件循环究竟是怎么实现异步的？"></a>事件循环究竟是怎么实现异步的？</h2><p>我们知道浏览器中JS线程只有一个，如果没有事件循环，就会造成一个问题。 即如果JS发起了一个异步IO请求，在等待结果返回的这个时间段，后面的代码都会被阻塞。 我们知道JS主线程和渲染进程是相互阻塞的，因此这就会造成浏览器假死。 如何解决这个问题？ 一个有效的办法就是我们这节要讲的<code>事件循环</code>。</p><p>其实<code>事件循环就是用来做调度的，浏览器和NodeJS中的事件循坏就好像操作系统的调度器一样。</code>操作系统的调度器决定何时将什么资源分配给谁。对于有线程模型的计算机，那么操作系统执行代码的最小单位就是线程，资源分配的最小单位就是进程，代码执行的过程由操作系统进行调度，整个调度过程非常复杂。  我们知道现在很多电脑都是多核的，为了让多个core同时发挥作用，即没有一个core是特别闲置的，也没有一个core是特别累的。操作系统的调度器会进行某一种神秘算法，从而保证每一个core都可以分配到任务。 这也就是我们使用NodeJS做集群的时候，Worker节点数量通常设置为core的数量的原因，调度器会尽量将每一个Worker平均分配到每一个core，当然这个过程并不是确定的，即不一定调度器是这么分配的，但是很多时候都会这样。</p><p>了解了操作系统调度器的原理，我们不妨继续回头看一下事件循环。 事件循环本质上也是做调度的，只不过调度的对象变成了JS的执行。事件循环决定了V8什么时候执行什么代码。<code>V8只是负责JS代码的解析和执行，其他它一概不知。</code>浏览器或者NodeJS中触发事件之后，到事件的监听函数被V8执行这个时间段的所有工作都是事件循环在起作用。</p><p>我们来小结一下：</p><ol><li>对于V8来说，它有：</li></ol><ul><li>调用栈（call stack）<blockquote><p>这里的单线程指的是只有一个call stack。只有一个call stack 意味着同一时间只能执行一段代码。</p></blockquote></li><li>堆（heap）</li></ul><ol start="2"><li>对于浏览器运行环境来说：</li></ol><ul><li>WEB API</li><li>DOM API</li><li>任务队列</li></ul><blockquote><p>事件来触发事件循环进行流动</p></blockquote><p>以如下代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">setTimeout(b, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>执行过程是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lxcn39hhg30go080dj1.gif" alt><br>(<a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gYygpIHt9CmZ1bmN0aW9uIGIoKSB7CgljKCk7Cn0KZnVuY3Rpb24gYSgpIHsKCXNldFRpbWVvdXQoYiwgMjAwMCkKfQphKCk7!!!" target="_blank" rel="noopener">在线观看</a>)</p><p>因此事件循环之所以可以实现异步，是因为碰到异步执行的代码“比如fetch，setTimeout”，浏览器会将用户注册的回调函数存起来，然后继续执行后面的代码。等到未来某一个时刻，“异步任务”完成了，会触发一个事件，浏览器会将“任务的详细信息”作为参数传递给之前用户绑定的回调函数。具体来说，就是将用户绑定的回调函数推入浏览器的执行栈。</p><p>但并不是说随便推入的，只有浏览器将当然要执行的JS脚本“一口气”执行完，要”换气“的时候才会去检查有没有要被处理的“消息”。<br>如果于则将对应消息绑定的回调函数推入栈。当然如果没有绑定事件，这个事件消息实际上会被丢弃，不被处理。比如用户触发了一个click事件，但是用户没有绑定click事件的监听函数，那么实际上这个事件会被丢弃掉。</p><p>我们来看一下加入用户交互之后是什么样的，拿点击事件来说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.on(<span class="string">'button'</span>, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'You clicked the button!'</span>);    </span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Click the button!"</span>);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Welcome to loupe."</span>);</span><br></pre></td></tr></table></figure><p>上述代码每次点击按钮，都会发送一个事件，由于我们绑定了一个监听函数。因此每次点击，都会有一个点击事件的消息产生，浏览器会在“空闲的时候”对应将用户绑定的事件处理函数推入栈中执行。</p><p>伪代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">queue.processNextMessage()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动画演示：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lxzvlth0g30go07yhc7.gif" alt><br>(<a href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank" rel="noopener">在线观看</a>)</p><h3 id="加入宏任务-amp-微任务"><a href="#加入宏任务-amp-微任务" class="headerlink" title="加入宏任务&amp;微任务"></a>加入宏任务&amp;微任务</h3><p>我们来看一个更复制的例子感受一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>上面的代码会输出：1、5、3、4、2。 如果你想要非常严谨的解释可以参考 whatwg 对其进行的描述 -<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">event-loop-processing-model</a>。</p><p>下面我会对其进行一个简单的解释。</p><ul><li>浏览器首先执行宏任务，也就是我们script（仅仅执行一次）</li><li>完成之后检查是否存在微任务，然后不停执行，直到清空队列</li><li>执行宏任务</li></ul><p>其中：</p><p>宏任务主要包含：setTimeout、setInterval、setImmediate、I/O、UI交互事件</p><p>微任务主要包含：Promise、process.nextTick、MutaionObserver 等</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9hfldyzj2j30g909xt8z.jpg" alt></p><p>有了这个知识，我们不难得出上面代码的输出结果。</p><p>由此我们可以看出，<code>宏任务&amp;微任务</code>只是实现异步过程中，我们对于信号的处理顺序不同而已。如果我们不加区分，全部放到一个队列，就不会有<code>宏任务&amp;微任务</code>。这种人为划分优先级的过程，在某些时候非常有用。</p><h3 id="加入执行上下文栈"><a href="#加入执行上下文栈" class="headerlink" title="加入执行上下文栈"></a>加入执行上下文栈</h3><p>说到执行上下文，就不得不提到<code>浏览器执行JS函数其实是分两个过程的</code>。一个是创建阶段<code>Creation Phase</code>,一个是执行阶段<code>Execution Phase</code>。</p><p>同执行栈一样，浏览器每遇到一个函数，也会将当前函数的执行上下文栈推入栈顶。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> n = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(num + n)</span><br><span class="line">&#125;</span><br><span class="line">c(num);</span><br><span class="line">&#125;</span><br><span class="line">b(num);</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>遇到上面的代码。 首先会将a的压入执行栈，我们开始进行创建阶段<code>Creation Phase</code>， 将a的执行上下文压入栈。然后初始化a的执行上下文，分别是VO，ScopeChain（VO chain）和 This。 从这里我们也可以看出，this其实是动态决定的。VO指的是<code>variables, functions 和 arguments</code>。 并且执行上下文栈也会同步随着执行栈的销毁而销毁。</p><p>伪代码表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EC  = &#123;</span><br><span class="line">    <span class="string">'scopeChain'</span>: &#123; &#125;,</span><br><span class="line">    <span class="string">'variableObject'</span>: &#123; &#125;,</span><br><span class="line">    <span class="string">'this'</span>: &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lyjjb6ecj30mh0c0aa2.jpg" alt></p><p>我们来重点看一下ScopeChain(VO chain)。如上图的执行上下文大概长这个样子，伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">global.VO = &#123;</span><br><span class="line">    a: pointer to a(),</span><br><span class="line">    scopeChain: [global.VO]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.VO = &#123;</span><br><span class="line">    b: pointer to b(),</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">    scopeChain: [a.VO, global.VO]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.VO = &#123;</span><br><span class="line">c: pointer to c(),</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">scopeChain: [b.VO, a.VO, global.VO]</span><br><span class="line">&#125;</span><br><span class="line">c.VO = &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">n: <span class="number">3</span></span><br><span class="line">scopeChain: [c.VO, b.VO, a.VO, global.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引擎查找变量的时候，会先从VOC开始找，找不到会继续去VOB…，直到GlobalVO，如果GlobalVO也找不到会返回<code>Referrence Error</code>，整个过程类似原型链的查找。</p><p>值得一提的是，JS是词法作用域，也就是静态作用域。换句话说就是作用域取决于代码定义的位置，而不是执行的位置，<code>这也就是闭包产生的本质原因</code>。 如果上面的代码改造成下面的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">a()</span><br><span class="line">b()</span><br><span class="line">c()</span><br></pre></td></tr></table></figure><p>或者这种：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">c();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">b();</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><p>其执行上下文栈虽然都是一样的，但是其对应的scopeChain则完全不同，因为函数定义的位置发生了变化。拿上面的代码片段来说,c.VO会变成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c.VO = &#123;</span><br><span class="line">scopeChain: [c.VO, global.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说其再也无法获取到a和b中的VO了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这篇文章，希望你对单线程，多线程，异步，事件循环，事件驱动等知识点有了更深的理解和感悟。除了这些大的层面，我们还从执行栈，执行上下文栈角度讲解了我们代码是如何被浏览器运行的，我们顺便还解释了作用域和闭包产生的本质原因。</p><p>最后我总结了一个浏览器运行代码的整体原理图，希望对你有帮助：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9lzm6dww0j30kw0pjt8s.jpg" alt></p><p>下一节<code>浏览器的事件循环和NodeJS的事件循环有什么不同</code>, 敬请期待～</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.logrocket.com/a-complete-guide-to-the-node-js-event-loop/" target="_blank" rel="noopener">Node.js event loop - logrocket</a></li><li><a href="https://nodejs.org/de/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">event-loop - nodejs.org</a></li><li><a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/" target="_blank" rel="noopener">what-is-the-execution-context-in-javascript</a></li><li><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener">Event Loop in JS - youtube </a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器 </tag>
            
            <tag> 事件循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一荐 2019-10 汇总</title>
      <link href="/blog/2019/12/11/daily-featured-2019-10/"/>
      <url>/blog/2019/12/11/daily-featured-2019-10/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8d0sktqrwj30hs07maae.jpg" alt></p><p>每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。</p><p>项目主页维护当前月份的内容，想看往期内容，可以去<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">每日一荐主仓库</a>翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。</p><a id="more"></a><h2 id="2019-10"><a href="#2019-10" class="headerlink" title="2019-10"></a>2019-10</h2><h3 id="2019-10-31-技能"><a href="#2019-10-31-技能" class="headerlink" title="2019-10-31[技能]"></a>2019-10-31[技能]</h3><p>虽然我们不是专门的网络工程师，但是不免在实际工作以及面试中会需要这方面的知识，当然这是浅层的即可。如果完全不知道，那么对于一些网络性能优化问题肯定是没有概念，从而无从下手的。</p><p>网上关于HTTP协议的文章很多，面试的时候关于HTTP三大版本的差异也是热门考点。这篇文章就通俗易懂地解释了<code>HTTP/2与HTTP/3 的新特性</code>, 相比于之前，为什么要推出新的协议，核心解决了什么问题？有什么不足？ 这些东西网上资料要么就是太专业，要么就是太笼统和人云亦云，这篇文章是相对比较适合新手读的一个文章。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8gfh4xbabj30kp09y3yq.jpg" alt></p><p>文章地址： <a href="https://segmentfault.com/a/1190000020714686#articleHeader16" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020714686#articleHeader16</a></p><h3 id="2019-10-30-类库"><a href="#2019-10-30-类库" class="headerlink" title="2019-10-30[类库]"></a>2019-10-30[类库]</h3><p>很多年前我自己写过一个简陋的<code>pub/sub库</code>, 这个仓库甚至被一些人在用。很多时候我们需要用到这种灵活的<code>pub/sub</code>功能，这个时候我们就会自己实现，或者用一些开源的。 今天给大家介绍的就是鼎鼎大名的Jason Miller写的一个<code>tiny event pub sub implement</code>，代码就几十行，不仅注释详实，而且给出了丰富的类型定义，代码简单易懂，非常适合学习。</p><p>代码地址： <a href="https://github.com/developit/mitt/blob/master/src/index.js" target="_blank" rel="noopener">https://github.com/developit/mitt/blob/master/src/index.js</a></p><h3 id="2019-10-29-网站"><a href="#2019-10-29-网站" class="headerlink" title="2019-10-29[网站]"></a>2019-10-29[网站]</h3><p>上一次给大家分享了一个常用正则的VSCode插件（2019-10-11期），另外的<a href="https://lucifer.ren/fe-interview/#/?id=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f">《大前端面试宝典》</a>也讲到了正则的学习，并给出了我认为非常不错的学习资料。</p><p>今天我继续给大家介绍几个正则学习&amp;练习的网站。</p><ul><li><p><a href="https://alf.nu/RegexGolf" target="_blank" rel="noopener">Regex Golf</a> 是一个有名的正则练习网站，会根据你的正则打分，难度偏高。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8e747lxbtj30xp08w3yn.jpg" alt></p></li><li><p><a href="https://regexone.com/lesson/introduction_abcs" target="_blank" rel="noopener">regexone</a> 是一个交互友好，面向新手的一个正则练习网站，可以交互式地学习正则，右边还贴心地给出了Notes，另外语言不同其实正则规范也不太一样，这个网站给出了不同语言的正则讲解，很用心。值得一题的是，里面的资料非常新，最新的<code>/u- interpret the regular expression as unicode codepoints</code> 都有。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8e77k79czj30wm0kwmyy.jpg" alt></p></li><li><p><a href="https://regexr.com/" target="_blank" rel="noopener">regexr</a>这个不是练习的， 是用来可视化的， 和之前的<a href="https://regexper.com/" target="_blank" rel="noopener">regexper</a>有点像，就连域名都差不多，不过这个用户体验是真的棒。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8e7a58pt9j31gw0oogn4.jpg" alt></p></li><li><p><a href="http://play.inginf.units.it/#/" target="_blank" rel="noopener">The regular expression game</a> 是一个过关类型的正则练习网站，有意思的是它可以根据你写的正则匹配程度进行打分，即使你没有全部匹配也是可以得分的。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8e7doryfpj30wv0exdgu.jpg" alt></p></li></ul><h3 id="2019-10-28-工具"><a href="#2019-10-28-工具" class="headerlink" title="2019-10-28[工具]"></a>2019-10-28[工具]</h3><p>这个是人称贺老的百姓网贺师俊<code>Hax</code>整理的一份<code>中文技术活动日程</code>， 这些活动有几个特点：</p><ul><li>技术活动的主要语言是中文</li><li>技术活动的主要参与者是程序员</li><li>技术活动的主要日程接受公开报名</li><li>技术活动具有一定规模</li></ul><p>目前这个仓库仅有个简陋的 <code>yaml 数据文件</code>，记录<code>技术活动的时间和一些信息</code>。后续希望能加入一个更好的查询界面。活动组织者可直接修改数据文件并提交PR，或提交issue描述一下活动情况。活动组织者也可以 watch 本仓库，这样当有变动时（通常是会议信息更新），可以收到通知。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8ankjskagj30rb0fs74l.jpg" alt></p><p>仓库地址：<a href="https://github.com/hax/chinese-tech-conf-schedule" target="_blank" rel="noopener">https://github.com/hax/chinese-tech-conf-schedule</a></p><h3 id="2019-10-25-工具"><a href="#2019-10-25-工具" class="headerlink" title="2019-10-25[工具]"></a>2019-10-25[工具]</h3><p>今天给大家推荐的是一个我个人非常喜欢的一个<code>好用且免费图床工具</code> - <a href="https://apps.apple.com/cn/app/ipic-markdown-%E5%9B%BE%E5%BA%8A-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%B7%A5%E5%85%B7/id1101244278?mt=12" target="_blank" rel="noopener">IPic</a>。 这个工具不仅内置免费的微博图床,还可以自己定义，我本人还添加了腾讯云的COS</p><p>使用起来也非常简单，直接复制图片，然后点击对应的图片即可，另外值得一提的是它本身还支持直接生成MardDown链接，这对经常用MarkDown写作的我来说绝对是一个非常实用的功能。</p><p>另外它还搭配了一个软件<a href="https://apps.apple.com/cn/app/ipic-mover/id1183822957?mt=12" target="_blank" rel="noopener">IPic Mover</a>用来迁移图床，比如你的文章里面都是新浪图床，只需要一键就可以瞬间迁移到别的平台，比如腾讯云COS。 不过这个搭配的工具是收费的，但是有免费体验时间。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g89bcu7rihj30ha0zkwgi.jpg" alt></p><h3 id="2019-10-24-技能"><a href="#2019-10-24-技能" class="headerlink" title="2019-10-24[技能]"></a>2019-10-24[技能]</h3><p>今天是1024程序员节，祝广大的程序员们节日快乐。🎩🎩🎩🎩🎩🎩</p><p>之前给大家介绍了一款跨平台的Web平台技术栈检测工具Wappalyzer。这几天我看了下他的源码，觉得很不错，于是就想着推荐给大家。</p><p>Wappalyzer的整体架构非常有意思，这里讲一下我发现的主要特点，更多细节等待着你的探索。</p><ul><li>平台相关的代码放在drivers文件夹下，公共的代码在src/wappalyzer.js</li><li>特地写了validate脚本来检测代码。</li><li>将检测逻辑抽离到了src/app.json中， 以配置文件的形式存放（这个json文件结构设计地很精巧，应该是花了心思的）</li><li>主要采用正则来检测应用</li><li>考虑到间接引用，比如框架A引用了B，那么检测到了A也会把B带上</li></ul><p>如果想快速上手可以看下ta提供的<a href="https://github.com/AliasIO/Wappalyzer/blob/master/src/wappalyzer.spec.js" target="_blank" rel="noopener">测试用例</a>，非常简洁。</p><p>Github地址： <a href="https://github.com/AliasIO/Wappalyzer" target="_blank" rel="noopener">https://github.com/AliasIO/Wappalyzer</a></p><h3 id="2019-10-23-网站"><a href="#2019-10-23-网站" class="headerlink" title="2019-10-23[网站]"></a>2019-10-23[网站]</h3><p>今天给广大的前端朋友们介绍一个在线做题的网站，可以瞬间在线知道答案，而且不需要登陆，一共58道题目，不知道后续会不会更新。 这个网站的题目我看了其实没有什么新意，但是不需要登陆而是直接使用LocalStorage来存储你的答题情况对用户来说很轻量，给我的感觉很好，感兴趣的可以试一下。 </p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87wixe9u2j30gk0f93yu.jpg" alt></p><p>(题目列表)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g87wji13epj30ht0ket8v.jpg" alt></p><p>(题目详情)</p><p>网址： <a href="https://quiz.typeofnan.dev/" target="_blank" rel="noopener">https://quiz.typeofnan.dev/</a></p><h3 id="2019-10-22-观点"><a href="#2019-10-22-观点" class="headerlink" title="2019-10-22[观点]"></a>2019-10-22[观点]</h3><p>前一段时间王思聪的股权遭到了冻结，据中新经纬记者计算，王思聪名下冻结股权价值合计已经超过8445万元。</p><p>“这种情况一般是王思聪欠别人钱，别人追讨，作为诉讼保全措施冻结的。”金杜律师事务所律师李量接受虎嗅采访时说，“王思聪欠钱可以是直接欠，或和贾跃亭一样，给别人提供担保，承担了连带责任。”</p><p>但是实际上这种冻结对于王思聪来说根本起不到作用，他会有很多方法来免除所谓的强制执行，他只要将自己的股权先一步将股权质押给万达集团，这样<code>质押权人就对被保全的股份有优先权</code>, 换句话说这<code>对王思聪来说这种冻结根本无效</code>。</p><p>现实中有很多这样的事情，这些规则似乎是在<code>限制那些“能力不足”的人，而对社会上这些“制造规则的人”无能为力</code>。更可悲的是，很多人对这些不知道，不关注。其实越是贫穷的家庭，越是生活在社会底层的人，他们的后代，大概率还会是穷人。其实，我们奋斗的目标无非就是：让子女一出生就站在了别人的肩膀上！</p><h3 id="2019-10-21-效率"><a href="#2019-10-21-效率" class="headerlink" title="2019-10-21[效率]"></a>2019-10-21[效率]</h3><p>我是一个有着轻微强迫症的人，社交软件的小红点有时候会打乱我的节奏，将我从专注模式(Focus Mode)强制转化为发散模式（Diffuse Mode）。 这两种模式适合我们做不同类型的工作，因此掌控小红点，避免这种不希望的模式切换是提高效率的一个有效途径。</p><p>我的做法是：</p><ul><li>手机静音</li><li>电脑关闭红点提醒</li></ul><p>mac电脑可以在系统偏好设置 - 通知 - 对应APP - 将标记应用程序的勾去掉</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g82fq7pugoj30hj09vmzb.jpg" alt></p><p>一般而言，你也不用担心会错过什么东西，因为右侧通知还是会有的，比如钉钉的会议提醒等。</p><p>经过这样的设置，你就可以自由切换两种模式，而不会被频繁打断，当然还是会有人来打断你，这个问题我们以后再讲。</p><h3 id="2019-10-18-类库"><a href="#2019-10-18-类库" class="headerlink" title="2019-10-18[类库]"></a>2019-10-18[类库]</h3><p>UMI的官方定位是<code>可插拔的企业级 react 应用框架</code>。其作者云谦也是Ant-Design，dvajs的核心贡献者，同时也是我早期关注的人之一。这个项目的价值绝对不亚于更受大家欢迎的dvajs，是一个值得学习的项目。</p><p>说白了，Umi 和 create-react-app（cra）类似，就是现有技术栈的组合，封装细节，让开发者用起来更简单，只写业务代码就可以了，它有几个特点：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g81gv20dydj30rd0g7gq3.jpg" alt></p><ul><li>零配置就是默认选型都给你做好了。</li><li>开箱即用就是技术栈都固化了。</li><li>约定大于配置，开发模式也固化好了。</li></ul><p>下图是云谦介绍umi的定位的时候贴的一张架构图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hiqa9s0wj30u00l0ac7.jpg" alt></p><p>项目地址：<a href="https://github.com/umijs/umi" target="_blank" rel="noopener">https://github.com/umijs/umi</a></p><h3 id="2019-10-17-工具"><a href="#2019-10-17-工具" class="headerlink" title="2019-10-17[工具]"></a>2019-10-17[工具]</h3><p>之前分享过《2019-09-23 - 为什么一行80个字符是一个值得遵守的规范，即使你拥有4k显示器？》，里面提到了并排窗口的问题。 多个显示器确实可以提高效率，如果你能高效地利用每一个显示器，效果会更棒。</p><blockquote><p>配合4k大屏显示器效果更棒</p></blockquote><p>今天介绍的这款工具就是一款窗口布局工具，能够快速修改当前窗口大小并放置在指定位置，Moom 默认操作点设立在了窗口左上角的绿色按钮上，将鼠标hover在绿钮上就会弹出一个选择菜单，里面有五种尺寸可选，单击选项即可变化窗口大小，并能将窗口移动到指定位置。</p><blockquote><p>搭配使用快捷键效果更棒</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g80yebwmr2j30u10fwdhw.jpg" alt></p><h3 id="2019-10-16-工具"><a href="#2019-10-16-工具" class="headerlink" title="2019-10-16[工具]"></a>2019-10-16[工具]</h3><p>今天给大家推荐的是一款非常好用的Chrome插件，可以用来查看网站是由什么技术栈构建的。其实类似的软件也有别的，但是这个是我使用过的最好的一个。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z2wky65hj30d5093gln.jpg" alt></p><p>（这个是其官网的检测结果）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7z2wyx0jzj30db09374b.jpg" alt></p><p>（这个是GitHub的检测结果）</p><p>项目主页： <a href="https://www.wappalyzer.com" target="_blank" rel="noopener">https://www.wappalyzer.com</a></p><h3 id="2019-10-15-技能"><a href="#2019-10-15-技能" class="headerlink" title="2019-10-15[技能]"></a>2019-10-15[技能]</h3><p>今天给大家分享一个微信小技巧，据说有的人还不知道，所以今天就把它分享出来，大家如果有什么微信使用小技巧也欢迎在下方进行评论。</p><p>今天的小技巧是<code>判断对方是否把你拉黑或者删除</code>:</p><ol><li>给对方转账，是好友会让你输入密码，不是好友都不用你输入密码，直接弹出下图，整个过程好友不知情的！</li></ol><ul><li>如果拉黑会提示： <code>请确认你和他（她）的好友关系是否正常</code></li><li>如果删除，则会提示： <code>你不是收款方的好友</code></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ynsya4cmj306m05wt8l.jpg" alt></p><ol start="2"><li>点开好友名片，如果显示左图，说明她真的没有发过一条朋友圈。若显示右图，点开个人相册却什么也看不到，那么你有可能被删除、拉黑、朋友圈屏蔽，或者发过朋友圈但设为私密了。</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7yns7ad9uj30k00f0aal.jpg" alt></p><p>为了搞清楚对方是删除还是屏蔽，你就可以用到开头转账的那一招啦！</p><h3 id="2019-10-14-好文"><a href="#2019-10-14-好文" class="headerlink" title="2019-10-14[好文]"></a>2019-10-14[好文]</h3><p>如果想做一些高级的东西，编译是一个绕不过的坎，Babel是一个前端的转义工具，Babel有着自己的插件系统，这是个系列文章，通过这个系列你可以学到AST，以及Babel插件相关的东西，并且你可以自己动手写一个Babel插件。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7xhj17ovfj30kv0hhmxq.jpg" alt></p><p>文章地址： </p><ul><li><a href="https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation/" target="_blank" rel="noopener">Step-by-step guide for writing a custom babel transformation</a></li><li><a href="https://lihautan.com/creating-custom-javascript-syntax-with-babel/" target="_blank" rel="noopener">Creating custom JavaScript syntax with Babel</a></li></ul><h3 id="2019-10-12-工具"><a href="#2019-10-12-工具" class="headerlink" title="2019-10-12[工具]"></a>2019-10-12[工具]</h3><p>前端在调试兼容性样式的时候是一个很头疼的问题，各个浏览器以及同一个浏览器不同版本支持的css都是不同的，比如有些不支持Grid，有些不支持cal函数。如果你自己根据这些去修改代码肯定是非常低效的，这个Chrome插件就是解决这样的问题，你可以在高级的浏览器上调试，自行禁用一些css特性来debug。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ucx8rqutj30dv05sq2v.jpg" alt></p><p>仓库地址： <a href="https://github.com/keithclark/css-feature-toggle-devtools-extension" target="_blank" rel="noopener">https://github.com/keithclark/css-feature-toggle-devtools-extension</a></p><p>chrome插件地址： <a href="https://chrome.google.com/webstore/detail/css-feature-toggles/aeinmfddnniiloadoappmdnffcbffnjg" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/css-feature-toggles/aeinmfddnniiloadoappmdnffcbffnjg</a></p><h3 id="2019-10-11-工具"><a href="#2019-10-11-工具" class="headerlink" title="2019-10-11[工具]"></a>2019-10-11[工具]</h3><p>常用正则大全, 支持vscode扩展插件</p><p>值得一提的是它支持VSCode插件形式使用：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7u0yqfy5nj30jn0eg0t4.jpg" alt></p><p>目前有57个正则：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7u0zximv9j30b80g3dgg.jpg" alt></p><p>插件地址： <a href="https://github.com/any86/any-rule" target="_blank" rel="noopener">https://github.com/any86/any-rule</a></p><h3 id="2019-10-10-技能"><a href="#2019-10-10-技能" class="headerlink" title="2019-10-10[技能]"></a>2019-10-10[技能]</h3><p>傅里叶变换是一种在各个领域都经常使用的数学工具。这个网站将为你介绍傅里叶变换能干什么，为什么傅里叶变换非常有用，以及你如何利用傅里叶变换干漂亮的事。傅立叶变换有很多实际的应用，比如MP3的原理，MP3是如何将声波转化为二进制，并如何进行压缩的？ 比如JPEG的原理等。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7s4pz83xyj30x50kpt9s.jpg" alt></p><p>这个文章（网站）是我见过傅立叶变换最直观的一个解释之一，并且支持交互式操作。 </p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7s4pm4mooj307404j0sl.jpg" alt></p><p>网站地址： <a href="http://www.jezzamon.com/fourier/zh-cn.html" target="_blank" rel="noopener">http://www.jezzamon.com/fourier/zh-cn.html</a></p><h3 id="2019-10-09-工具"><a href="#2019-10-09-工具" class="headerlink" title="2019-10-09[工具]"></a>2019-10-09[工具]</h3><p>VSCode是我经常使用的一个软件，结合自己的开发习惯我也会增加很多配置和插件等，如何将这些插件进行备份以便将来换电脑可以及时同步过来，这里关于VScode的配置我用的是VSCode <a href="https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync" target="_blank" rel="noopener">setting sync 插件</a>。</p><p>这个需要结合Gist使用，具体使用方式请查看官方文档：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7r455m0zmj30i909dq36.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7r4cvxwb5j30rw0gc74r.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7r4db2zxbj30tf0kcgm9.jpg" alt></p><p>其实我有一个专门的<a href="https://github.com/azl397985856/dev-config" target="_blank" rel="noopener">开发常用配置文件备份仓库</a>用来存放这些东西，这是我的仓库存放的配置，这样我即使换了电脑也能很快地用到我最舒服的配置。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7r4nhzmjgj30a808ajrb.jpg" alt></p><p>如果大家没有更好的方式，不妨采用这种方式，如果你有更好的方式欢迎给我留言。</p><h3 id="2019-10-08-工具"><a href="#2019-10-08-工具" class="headerlink" title="2019-10-08[工具]"></a>2019-10-08[工具]</h3><p>今天是国庆结束的第一天，大家假期玩的怎么样？ 希望大家可以尽快从假期的状态中转变回来。今天给大家推荐一个我个人使用比较多的一个功能，就是<code>剪贴板历史</code>。</p><p>我在使用手机的时候（笔者使用的是安卓机），会经常复制一些文字或者图片，然后进行粘贴，有时候会需要粘贴之前复制的一个东西，因此剪贴板历史就显得很重要，手机上我用的就是<code>搜索输入法自带的剪贴板历史功能</code>。</p><p>而在电脑上我使用的是Alfred自带的<code>剪贴板历史</code>功能，只不过默认不开启，你需要去配置一下才行。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pqb232pxj30w50fvdgy.jpg" alt></p><p>然后你就可以查看你的剪贴板历史了：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pqbppfxrj30hg0cn0tt.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7pqc0f7tbj30g40bv75d.jpg" alt></p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>我重新整理了下自己的公众号，并且我还给它换了一个名字<code>脑洞前端</code>，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。</p><p>之后我的文章会同步到微信公众号 <code>脑洞前端</code> ，你可以关注获取最新的文章，并和我进行交流。</p><p>另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。</p><img width="300" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7he9xdtmyj30by0byaac.jpg">]]></content>
      
      
      <categories>
          
          <category> 每日一荐 </category>
          
          <category> 2019-10 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/blog/2019/12/11/bloom-filter/"/>
      <url>/blog/2019/12/11/bloom-filter/</url>
      
        <content type="html"><![CDATA[<p>假设你现在要处理这样一个问题，你有一个网站并且拥有<code>很多</code>访客，每当有用户访问时，你想知道这个ip是不是第一次访问你的网站。你会怎么做呢？</p><a id="more"></a><h3 id="hashtable-可以么"><a href="#hashtable-可以么" class="headerlink" title="hashtable 可以么"></a>hashtable 可以么</h3><p>一个显而易见的答案是将所有的ip用hashtable存起来，每次访问都去hashtable中取，然后判断即可。但是题目说了网站有<code>很多</code>访客，<br>假如有10亿个用户访问过，每个ip的长度是4 byte，那么你一共需要4 * 1000000000 = 4000000000Bytes = 4G , 如果是判断URL黑名单，<br>由于每个URL会更长，那么需要的空间可能会远远大于你的期望。</p><h3 id="bit"><a href="#bit" class="headerlink" title="bit"></a>bit</h3><p>另一个稍微难想到的解法是bit， 我们知道bit有0和1两种状态，那么用来表示存在，不存在再合适不过了。</p><p>加入有10亿个ip，我们就可以用10亿个bit来存储，那么你一共需要 1 * 1000000000 = (4000000000 / 8) Bytes = 128M, 变为原来的1/32,<br>如果是存储URL这种更长的字符串，效率会更高。 </p><p>基于这种想法，我们只需要两个操作，set(ip) 和 has(ip)</p><p>这样做有两个非常致命的缺点：</p><ol><li>当样本分布极度不均匀的时候，会造成很大空间上的浪费</li></ol><blockquote><p>我们可以通过散列函数来解决</p></blockquote><ol start="2"><li>当元素不是整型（比如URL）的时候，BitSet就不适用了</li></ol><blockquote><p>我们还是可以使用散列函数来解决， 甚至可以多hash几次</p></blockquote><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器其实就是<code>bit + 多个散列函数</code>,  如果经过多次散列的值再bit上都为1，那么可能存在(可能有冲突)。 如果<br>有一个不为1，那么一定不存在（一个值经过散列函数得到的值一定是唯一的），这也是布隆过滤器的一个重要特点。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds53hxbw7j31dw0j2wgm.jpg" alt="bloom-filter-url"></p><h3 id="布隆过滤器的应用"><a href="#布隆过滤器的应用" class="headerlink" title="布隆过滤器的应用"></a>布隆过滤器的应用</h3><ol><li><p>网络爬虫<br>判断某个URL是否已经被爬取过</p></li><li><p>K-V数据库 判断某个key是否存在</p></li></ol><p>比如Hbase的每个Region中都包含一个BloomFilter，用于在查询时快速判断某个key在该region中是否存在。</p><ol start="3"><li>钓鱼网站识别</li></ol><p>浏览器有时候会警告用户，访问的网站很可能是钓鱼网站，用的就是这种技术</p><blockquote><p>从这个算法大家可以对 tradeoff(取舍) 有更入的理解。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 布隆过滤器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器事件模型</title>
      <link href="/blog/2019/12/11/browser-event/"/>
      <url>/blog/2019/12/11/browser-event/</url>
      
        <content type="html"><![CDATA[<p>我想你很可能听说过<code>事件驱动</code>, 但是事件驱动到底是什么？为什么说浏览器是事件驱动的呢？为什么 NodeJS 也是事件驱动的 ？ 两者是一回事么？</p><p>实际上不管是浏览器还是 Nodejs 都是事件驱动的，都有自己的事件模型。在这里，我们只讲解浏览器端的事件模型，如果对 Nodejs 事件模型感兴趣的，请期待我的 Nodejs 部分的讲解。</p><a id="more"></a><h2 id="什么是事件驱动"><a href="#什么是事件驱动" class="headerlink" title="什么是事件驱动"></a>什么是事件驱动</h2><p>事件驱动通俗地来说就是<code>什么都抽象为事件</code>。</p><ul><li>一次点击是一个事件</li><li>键盘按下是一个事件</li><li>一个网络请求成功是一个事件</li><li>页面加载是一个事件</li><li>页面报错是一个事件</li><li>… </li></ul><p>浏览器依靠事件来驱动APP运行下去，如果没有了事件驱动，那么APP会直接从头到尾运行完，然后结束，事件驱动是浏览器的基石。</p><p>本篇文章不讲解事件循环的内容，事件循环部分会在本章的其他章节讲解，敬请期待。</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>其实现实中的红绿灯就是一种事件，它告诉我们现在是红灯状态，绿灯状态，还是黄灯状态。 我们需要根据这个事件自己去完成一些操作，比如红灯和黄灯我们需要等待，绿灯我们可以过马路。</p><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1g8yigxmdlwj204k048t8t.jpg" alt="WeChatf64afbca051509ddcf379077490e9a2e.png"></p><p>下面我们来看一个最简单的浏览器端的事件：</p><p>html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Change color<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>js代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'button clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很简单，我们在button上注册了一个事件，这个事件的handler是一个我们定义的匿名函数。当用户点击了这个被注册了事件的button的时候，这个我们定义好的匿名函数就会被执行。</p><h2 id="如何绑定事件"><a href="#如何绑定事件" class="headerlink" title="如何绑定事件"></a>如何绑定事件</h2><p>我们有三种方法可以绑定事件，分别是<code>行内绑定</code>，<code>直接赋值</code>，用<code>addEventListener</code>。</p><ul><li>内联</li></ul><blockquote><p>这个方法非常不推荐</p></blockquote><p>html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"handleClick()"</span>&gt;</span>Press me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在script标签内写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'button clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接赋值</li></ul><p>和我上面举的例子一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'button'</span>);</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'button clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法有两个缺点</p><ol><li>不能添加多个同类型的handler<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">btn.onclick = functionA;</span><br><span class="line">btn.onclick = functionB;</span><br></pre></td></tr></table></figure></li></ol><p>这样只有functionB有效，这可以通过<code>addEventListener</code>来解决。</p><ol start="2"><li>不能控制在哪个阶段来执行，这个会在后面将事件捕获/冒泡的时候讲到。这个同样可以通过<code>addEventListener</code>来解决。</li></ol><p>因此addEventListener横空出世，这个也是目前推荐的写法。</p><ul><li>addEventListener</li></ul><p>旧版本的<code>addEventListener</code>第三个参数是bool，新版版的第三个参数是对象，这样方便之后的扩展，承载更多的功能, 我们来重点介绍一下它。</p><p>addEventListener可以给Element，Document，Window，甚至XMLHttpRequest等绑定事件，当指定的事件发生的时候，绑定的回调函数就会被以某种机制进行执行，这种机制我们稍后就会讲到。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, options]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture]);</span><br><span class="line">target.addEventListener(type, listener[, useCapture, wantsUntrusted  ]); <span class="comment">// Gecko/Mozilla only</span></span><br></pre></td></tr></table></figure><p>type是你想要绑定的事件类型，常见的有click, scroll, touch, mouseover等，旧版本的第三个参数是bool，表示是否是捕获阶段，默认是false，即默认为冒泡阶段。新版本是一个对象，其中有capture（和上面功能一样），passive和once。 once用来执行是否只执行一次，passive如果被指定为true表示永远不会执行<code>preventDefault()</code>,这在实现丝滑柔顺的滚动的效果中很重要。更多请参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners" target="_blank" rel="noopener">Improving scrolling performance with passive listeners</a></p><h2 id="框架中的事件"><a href="#框架中的事件" class="headerlink" title="框架中的事件"></a>框架中的事件</h2><p>实际上，我们现在大多数情况都是用框架来写代码，因此上面的情况其实在现实中是非常少见的，我们更多看到的是框架封装好的事件，比如React的合成事件，感兴趣的可以看下这几篇文章。</p><ul><li><a href="https://reactjs.org/docs/events.html" target="_blank" rel="noopener">React SyntheticEvent</a></li><li><a href="https://developer.51cto.com/art/201907/599732.htm" target="_blank" rel="noopener">Vue和React的优点分别是什么？两者的最核心差异对比是什么？</a></li></ul><p>虽然我们很少时候会接触到原生的事件，但是了解一下事件对象，事件机制，事件代理等还是很有必要的，因为框架的事件系统至少在这方面还是一致的，这些内容我们接下来就会讲到。</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>所有的事件处理函数在被浏览器执行的时候都会带上一个事件对象，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handleClick);</span><br></pre></td></tr></table></figure><p>这个e就是事件对象，即<code>event object</code>。 这个对象有一些很有用的属性和方法，下面举几个常用的属性和方法。</p><ul><li><p>属性</p><ol><li><p>target</p></li><li><p>x, y等位置信息</p></li><li><p>timeStamp</p></li><li><p>eventPhase</p><p>…</p></li></ol></li><li><p>方法</p><ol><li><p>preventDefault 用于阻止浏览器的默认行为，比如a标签会默认进行跳转，form会默认校验并发送请求到action指定的地址等</p></li><li><p>stopPropagation 用于阻止事件的继续冒泡行为，后面讲事件传播的时候会提到。</p><p>…</p><h2 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h2></li></ol></li></ul><p>前面讲到了事件默认是绑定到冒泡阶段的，如果你显式令useCapture为true，则会绑定到捕获阶段。</p><p>事件捕获很有意思，以至于我会经常出事件的题目加上一点事件传播的机制，让候选人进行回答，这很能体现一个人的水平。了解事件的传播机制，对于一些特定问题有着非常大的作用。</p><p>一个Element上绑定的事件触发了，那么其实会经过三个阶段。</p><ul><li>第一个阶段 - 捕获阶段</li></ul><p>从最外层即HTML标签开始，检查当前元素有没有绑定对应捕获阶段事件，如果有则执行，没有则继续往里面传播，这个过程递归执行直到触达<code>触发这个事件的元素</code>为止。</p><p>伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">capture</span>(<span class="params">e, currentElement</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (currentElement.listners[e.type] !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">currentElement.listners[e.type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(e))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pass down</span></span><br><span class="line"><span class="keyword">if</span> (currentElement !== e.target) &#123;</span><br><span class="line"><span class="comment">// getActiveChild用于获取当前事件传播链路上的子节点</span></span><br><span class="line">capture(e, getActiveChild(currentElement, e))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">bubble(e, currentElement)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个Event对象由引擎创建</span></span><br><span class="line">capture(<span class="keyword">new</span> Event(), <span class="built_in">document</span>.querySelector(<span class="string">'html'</span>))</span><br></pre></td></tr></table></figure><ul><li>第二个阶段 - 目标阶段</li></ul><p>上面已经提到了，这里省略了。</p><ul><li>第三个阶段 - 冒泡阶段</li></ul><p>从<code>触发这个事件的元素</code>开始，检查当前元素有没有绑定对应冒泡阶段事件，如果有则执行，没有则继续往里面传播，这个过程递归执行直到触达HTML为止。</p><p>伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">e, currentElement</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (currentElement.listners[e.type] !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">currentElement.listners[e.type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn(e))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// returning</span></span><br><span class="line"><span class="keyword">if</span> (currentElement !== <span class="built_in">document</span>.querySelector(<span class="string">'html'</span>)) &#123;</span><br><span class="line">bubble(e, currentElement.parent)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的过程用图来表示为：</p><p><img src="http://ww1.sinaimg.cn/large/e9f490c8ly1g8yif1i5hzj20fs0eewfi.jpg" alt></p><p>如果你不希望事件继续冒泡，可以用之前我提到的<code>stopPropagation</code>。</p><p>伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">e, currentElement</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> stopped = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">stopped = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (currentElement.listners[e.type] !== <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">currentElement.listners[e.type].forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">fn(&#123;</span><br><span class="line">...e,</span><br><span class="line">stopPropagation: cb</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (stopped) <span class="keyword">return</span>;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// returning</span></span><br><span class="line"><span class="keyword">if</span> (currentElement !== <span class="built_in">document</span>.querySelector(<span class="string">'html'</span>)) &#123;</span><br><span class="line">bubble(e, currentElement.parent)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>利用上面提到的事件冒泡机制，我们可以选择做一些有趣的东西。 举个例子：</p><p>我们有一个如下的列表，我们想在点击对应列表项的时候，输出是点击了哪个元素。</p><p>HTML代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JS代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>).addEventListener(<span class="string">'click'</span>, e =&gt; <span class="built_in">console</span>.log(e.target.innerHTML))</span><br></pre></td></tr></table></figure><p><a href="https://codepen.io/zhipenglu/pen/JjjePQJ?editors=1111" target="_blank" rel="noopener">在线地址</a></p><p>上面说了<code>addEventListener</code>会默认绑定到冒泡阶段，因此事件会从目标阶段开始，向外层冒泡，到我们绑定了事件的ul上，ul中通过事件对象的target属性就能获取到是哪一个元素触发的。</p><blockquote><p>“事件会从目标阶段开始”，并不是说事件没有捕获阶段，而是我们没有绑定捕获阶段，我描述给省略了。</p></blockquote><p>我们只给外层的ul绑定了事件处理函数，但是可以看到li点击的时候，实际上会打印出对应li的内容（1，2，3或者4）。 我们无须给每一个li绑定事件处理函数，不仅从代码量还是性能上都有一定程度的提升。</p><p>这个有趣的东西，我们给了它一个好听的名字“事件代理”。在实际业务中我们会经常使用到这个技巧，这同时也是面试的高频考点。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事件其实不是浏览器特有的，和JS语言也没有什么关系，这也是我为什么没有将其划分到JS部分的原因。很多地方都有事件系统，但是各种事件模型又不太一致。</p><p>我们今天讲的是浏览器的事件模型，浏览器基于事件驱动，将很多东西都抽象为事件，比如用户交互，网络请求，页面加载，报错等，可以说事件是浏览器正常运行的基石。</p><p>我们在使用的框架都对事件进行了不同程度的封装和处理，除了了解原生的事件和原理，有时候了解一下框架本身对事件的处理也是很有必要的。</p><p>当发生一个事件的时候，浏览器会初始化一个事件对象，然后将这个事件对象按照一定的逻辑进行传播，这个逻辑就是事件传播机制。 我们提到了事件传播其实分为三个阶段，按照时间先后顺序分为捕获阶段，目标阶段和冒泡阶段。开发者可以选择监听不同的阶段，从而达到自己想要的效果。</p><p>事件对象有很多属性和方法，允许你在事件处理函数中进行读取和操作，比如读取点击的坐标信息，阻止冒泡等。</p><p>最后我们通过一个例子，说明了如何利用冒泡机制来实现<code>事件代理</code>。</p><p>本文只是一个浏览器事件机制的科普文，并没有也不会涉及到很多细节。希望这篇文章能让你对浏览器时间有更深的理解，如果你对nodejs时间模型感兴趣，请期待我的nodejs事件模型。 事件循环和事件循环也有千丝万缕的联系，如果有时间，我会出一篇关于时间循环的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
          <category> 事件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 事件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一荐 2019-09 汇总</title>
      <link href="/blog/2019/12/11/daily-featured-2019-09/"/>
      <url>/blog/2019/12/11/daily-featured-2019-09/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8d0sktqrwj30hs07maae.jpg" alt></p><p>每天给你推荐一个新奇，好玩，高品质的开源库，好文，观点或言论等。</p><p>项目主页维护当前月份的内容，想看往期内容，可以去<a href="https://github.com/azl397985856/daily-featured" target="_blank" rel="noopener">每日一荐主仓库</a>翻到下方历史汇总部分，然后选择自己感兴趣的月份点进去即可。</p><a id="more"></a><h2 id="2019-09"><a href="#2019-09" class="headerlink" title="2019-09"></a>2019-09</h2><h3 id="2019-09-30-工具"><a href="#2019-09-30-工具" class="headerlink" title="2019-09-30[工具]"></a>2019-09-30[工具]</h3><p>今天是 9 月的最后一天，明天就是十一了，提前祝大家国庆节快乐 ～～～ 🎉🎉🎉🎉🎉🎉🎉 ！</p><p>今天再来给大家安利 6 个 chrome 扩展程序，排名不分先后。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7hccis83hj30g30gl3z1.jpg" alt></p><ol><li>Proxy SwitchyOmega</li></ol><p>此扩展为 SwitchySharp 的升级版，可替代 SwitchyPlus 或 Proxy Switchy. 可轻松快捷地管理和切换多个代理设置，是一个我使用多年的一个插件，配合 PAC 食用味道更好。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hcjh2gmjj30hs0b43ym.jpg" alt></p><p><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">下载地址</a></p><ol start="2"><li>OneTab</li></ol><p>节省高达 95％的内存，并减轻标签页混乱现象。 有些标签关了舍不得，不关太多看的很乱并且更关键的是占用内存。有了这个工具就不存在这些问题了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7hchdk0tyj30hs0b4js1.jpg" alt></p><p><a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall" target="_blank" rel="noopener">下载地址</a></p><ol start="3"><li>AdBlock Plus</li></ol><p>Adblock Plus 是世界上最流行的浏览器扩展，世界各地有数百万用户在使用它。这是一个社区驱动的开源项目，有数百名志愿者为 Adblock Plus 的成功作出了贡献，以实现所有烦人的广告被自动阻挡。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hcm4giztj30u70anjs2.jpg" alt></p><p><a href="https://chrome.google.com/webstore/search/AdBlock" target="_blank" rel="noopener">下载地址</a></p><ol start="4"><li>Multi-highlight</li></ol><p>普通的网页搜索只能一个一个搜索，不能同时搜索多个关键字，这个扩展提供了这种功能上的扩展。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7hcoq78bhj30hs0b4q3i.jpg" alt></p><p><a href="https://chrome.google.com/webstore/detail/multi-highlight/pfgfgjlejbbpfmcfjhdmikihihddeeji" target="_blank" rel="noopener">下载地址</a></p><ol start="5"><li>HTML5 Outliner</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7hcpx8en4j30hs09vmxp.jpg" alt></p><p>我平时再看文章或者文档的时候习惯先看一遍目录或者大纲，然后再决定我到底要不要看，看哪里。我相信很多人和我一样有着同样的习惯。但是很多网站，包括 infoq，知乎等大网站这方面都做的比较差。下图是我的个人博客的大纲功能：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7hcwcm5wgj30uo0prq5e.jpg" alt></p><p>因此这款工具对于我这种人来说就非常重要了，他能根据当前网页的结果快速生成大纲，并且支持锚点功能，当然它也有很多覆盖不到的情况，因为标题的种类实现太多了，大家完全可以写一个<code>div class = &#39;header&#39;</code>从而让这个工具无用武之地。 这也从侧面说明了语义化的重要性，不仅对于障碍人士重要，对于无障碍人士也有很大的意义。</p><p><a href="https://chrome.google.com/webstore/detail/html5-outliner/afoibpobokebhgfnknfndkgemglggomo" target="_blank" rel="noopener">下载地址</a></p><ol start="6"><li>眼睛护航</li></ol><p>把网页背景变成眼睛保护色或适合夜晚阅读的夜间模式，一些无法变色的小区块可以通过单击进行变色。到了晚上将自动从绿色护眼模式变为夜间阅读模式。当然，也可以手动强制使用绿色模式或夜间模式。</p><p>这在一些体验差的网站上极为重要，还有一些大量使用亮瞎眼的颜色网站也有很好的作用，类似提升阅读体验的扩展还有<a href="https://chrome.google.com/webstore/detail/simpread-reader-view/ijllcpnolfcooahcekpamkbidhejabll?hl=zh-CN" target="_blank" rel="noopener">简悦</a>。</p><p><a href="https://chrome.google.com/webstore/detail/care-your-eyes/fidmpnedniahpnkeomejhnepmbdamlhl" target="_blank" rel="noopener">下载地址</a></p><h3 id="2019-09-29-工具"><a href="#2019-09-29-工具" class="headerlink" title="2019-09-29[工具]"></a>2019-09-29[工具]</h3><p>如果你是一个站长，那么你一定需要一个网站速度测试工具。</p><p>你的用户如果都是中国用户，那么用<a href="http://tool.chinaz.com/speedtest/lucifer.ren" target="_blank" rel="noopener">站长工具-国内测试</a>应该就够用了。 如果你的用户有海外的话，可以试试<a href="https://tool.chinaz.com/speedworld/" target="_blank" rel="noopener">站长工具-国际测试</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7eb8e0j03j30lc0ftq3q.jpg" alt><br>(国内测速)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7eb8xtac5j30kn097dfz.jpg" alt><br>(国际测试)</p><blockquote><p>不得不吐槽下，网站体验做的不太好，而且广告有点多。</p></blockquote><p>另外还有一个网站，不过这个只能够测试国内的网速，<a href="https://www.17ce.com/" target="_blank" rel="noopener">17ce</a>的体验做的稍微好一点，广告也没有那么显眼，如果你的客户只是国内，不妨考虑这个。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ebbwxvykj31340l53z8.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ebcj8p59j30xq0hcq3l.jpg" alt></p><p>最后介绍一个国外的网站<a href="https://tools.pingdom.com" target="_blank" rel="noopener">pingdom</a>，如果客户是全球的，可以考虑用这个，这个是这几个中用户体验做的最好的。给出的技术指标比较多一点，但是他没有区域分布热力图, 并且支持的区域也不多。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7ebja8fm6j30vy0aft93.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ebgcr1elj30uf0llaay.jpg" alt><br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7ebhmc7iij30v20nh74w.jpg" alt></p><h3 id="2019-09-27-类库"><a href="#2019-09-27-类库" class="headerlink" title="2019-09-27[类库]"></a>2019-09-27[类库]</h3><p>之前我写了一篇 <a href="https://github.com/azl397985856/frontend-test" target="_blank" rel="noopener">【前端测试】</a> 的草稿，一直搁置到现在，之前我做后端的时候，写测试尤其是单元测试是很普遍的。但是做前端这么久发现大家对这方面不是很重视， 其实前端也是非常需要做测试的。</p><p>今天给大家推荐的是一个非常流行的前端测试框架 jest 的 GUI 工具<a href="https://github.com/Raathigesh/majestic" target="_blank" rel="noopener">majestic</a> (⚡ Zero config GUI for Jest)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7d2hpkzxuj30ym0u0wg9.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7d2icroztj30cx0a33yn.jpg" alt></p><h3 id="2019-09-26-工具"><a href="#2019-09-26-工具" class="headerlink" title="2019-09-26[工具]"></a>2019-09-26[工具]</h3><p>你一定有想用某一个功能的快捷键，却想不出来的情况。也一定面临过多个软件快捷键不统一带来的烦恼，比如 A 软件<code>CMD + S</code>是保存， 另外一个软件 B 是<code>Shift + S</code>。</p><p>对于第一种问题，我们可以用一个叫 cheatsheet 的 mac 软件，有了它你就可以通过长按 command 键，从而查看当前应用的快捷键。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bja8uiysj31c20ohdkr.jpg" alt></p><p>cheatsheet 下载地址： <a href="https://cheatsheet-mac.en.softonic.com/mac" target="_blank" rel="noopener">https://cheatsheet-mac.en.softonic.com/mac</a></p><blockquote><p>顺便吐槽一下，cheatsheet 官网用户体验这块做的不怎么样</p></blockquote><p>对于按键不统一的问题，我们可以直接修改对应软件的快捷键即可，毕竟大多数软件都是支持快捷键定制的，还有一些<code>服务</code>快捷键我们可以去<code>系统偏好设置 - 键盘 - 服务</code>中修改。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7bjf9q87uj30ik0g1jry.jpg" alt></p><p>另外给大家安利一个软件<code>Karabiner-Elements</code>, 它是一个 mac 上好用的键盘定制工作，可以用来改键，定制超级键等，更多功能等你挖掘。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7bjhb8tfzj30rq0fvjrh.jpg" alt></p><blockquote><p>配合 HHKB 效果更佳</p></blockquote><p>Karabiner-Elements 下载地址： <a href="https://github.com/tekezo/Karabiner-Elements" target="_blank" rel="noopener">https://github.com/tekezo/Karabiner-Elements</a></p><h3 id="2019-09-25-技能"><a href="#2019-09-25-技能" class="headerlink" title="2019-09-25[技能]"></a>2019-09-25[技能]</h3><p>熟练使用命令行是一种常常被忽视，或者被认为难以掌握的技能，一旦掌握，会极大提高你工作的效率。当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。</p><p>今天介绍的这个仓库，首发于 Quora， 后面迁移到了 Github，并由众多高手做出了许多改进，现在已经有 6W+ Star 了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aupdnzicj30dc08040e.jpg" alt></p><p>仓库目录（目录是我用工具自己抓的，非官方提供）：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7aupokxczj30ed0bp74e.jpg" alt></p><p>仓库地址： <a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" rel="noopener">https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md</a></p><h3 id="2019-09-24-工具"><a href="#2019-09-24-工具" class="headerlink" title="2019-09-24[工具]"></a>2019-09-24[工具]</h3><p>今天给大家分享的是 VSCode 前一段时间推出的 SSH 扩展，实际使用效果非常棒，除了延迟，让你感觉不到你是在操作远程的文件。虽然有延迟，但是也仅仅限于你和服务器有 IO 交互的情况下才会有感知，结合我的使用体验来说，是“几乎”感觉不到差异（当然也有可能我的网比较快）。</p><p>VSCode SSH 扩展允许你连接到远程的主机，虚拟机或者是容器。而你所需要做的仅仅是点击 SSH 面板，然后配置一下就好了，配置也极其简单，对于经常使用 SSH 的你来说千万不要错过了。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g79mut0ml3j30d40ebjra.jpg" alt></p><p>下面是官方提供的原理架构图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g79mw5gg3mj30qw08q0tc.jpg" alt></p><p>地址： <a href="https://code.visualstudio.com/docs/remote/ssh" target="_blank" rel="noopener">https://code.visualstudio.com/docs/remote/ssh</a></p><h3 id="2019-09-23-好文"><a href="#2019-09-23-好文" class="headerlink" title="2019-09-23[好文]"></a>2019-09-23[好文]</h3><p>为什么一行 80 个字符是一个值得遵守的规范，即使你拥有 4k 显示器？</p><p>我个人一直是 80 字符的践行者，不仅仅是因为是这大家都普遍采用的标准，更重要的是我个人更习惯多窗口平铺的方式来展示我的窗口，这样效率更高一点，因此太大肯定会影响窗口平铺，太小又不方便阅读，80 对我来说其实刚刚好，其他比较常见的还有 100 字符等， 现在就让我们来看下为什么一行 80 个字符是一个值得遵守的规范吧。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn405nqj31hc0u0asd.jpg" alt></p><p>文章地址： <a href="https://nickjanetakis.com/blog/80-characters-per-line-is-a-standard-worth-sticking-to-even-today" target="_blank" rel="noopener">https://nickjanetakis.com/blog/80-characters-per-line-is-a-standard-worth-sticking-to-even-today</a></p><h3 id="2019-09-20-工具"><a href="#2019-09-20-工具" class="headerlink" title="2019-09-20[工具]"></a>2019-09-20[工具]</h3><p>我开启了<a href="https://lucifer.ren/blog/">个人博客</a>，增加了评论，分类，统计，RSS，歌单等功能， 之后的文章会在博客首发。 感兴趣的可以 RSS 订阅我的博客。订阅方法我画了个图。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn4kb9ej30pk0g03zx.jpg" alt="rss-feed"></p><p>RSS 是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS 文件包含全文或是节录的文字，再加上发布者所订阅之网摘数据和授权的元数据。</p><p>简单来说只要提供了符合 RSS 格式的数据源，你就可以订阅，然后在 RSS 阅读器上进行查看更新内容。</p><p>关于 RSS 订阅，今天我推荐的就是一个 RSS 的聚合器 feedly。<a href="https://feedly.com" target="_blank" rel="noopener">https://feedly.com</a></p><p>Feedly 是一个 RSS 聚合器应用程序，支持各种网页浏览器和运行 iOS 或 Android 的移动设备，也是一个基于云端的服务。其从各种在线资源聚合用户自定的新闻订阅源，并可与他人分享。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn51dupj313j0hjjtr.jpg" alt="feedly"></p><p>后续有机会我会向大家推荐我的 RSS 订阅源。</p><h3 id="2019-09-19-工具"><a href="#2019-09-19-工具" class="headerlink" title="2019-09-19[工具]"></a>2019-09-19[工具]</h3><p>今天给大家推荐一款 MarkDown 编辑器。 MarkDown 在程序员中的使用频率是非常高的，Github 是最早一批对 MarkDown 语法支持度比较好的平台之一。我日常写文档，记笔记等都采用 MarkDown 格式来书写。 它不仅书写方便，而且由于其格式比较规范，因此理论上可以通过一些“转换规则”将其转化为各种表现形式，市面上也有很多基于 Markdown 的渲染器，比如<a href="https://github.com/markdown-it/markdown-it" target="_blank" rel="noopener">markdown-it</a>，也有很多基于这些渲染器制作的产品，比如<a href="https://github.com/docsifyjs/docsify" target="_blank" rel="noopener">docsify</a>。</p><p>早些时候，我使用的比较多的是<a href="https://macdown.uranusjr.com" target="_blank" rel="noopener">MacDown</a>和 VSCode 自带的 Markdown 功能。这两个功能非常简单，但是却能满足我当时的需求，之后我开始经常用 Markdown 更新文章之类的，因此这些就显得不太够用了，现在我用的是 Yu Writer， 算是一个值得推荐的国人开发的 MarkDown 编辑器，功能非常强大而且免费。 你可能听过 MWeb，但是它是收费的，功能和这个比起来也并不占优势。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn5yydqj31hc0u0tep.jpg" alt="yu-writer"></p><p>下载地址：<a href="https://ivarptr.github.io/yu-writer.site/" target="_blank" rel="noopener">https://ivarptr.github.io/yu-writer.site/</a></p><h3 id="2019-09-18-工具"><a href="#2019-09-18-工具" class="headerlink" title="2019-09-18[工具]"></a>2019-09-18[工具]</h3><p>前天分享了我的 chrome 插件管理器，今天我们就来分享我的《娱乐插件》。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn6fnetj30fe04adg6.jpg" alt="extension-joy"></p><ol><li>listen1</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn70jguj301z021we9.jpg" alt="listen1-icon"></p><p>娱乐插件第一个要分享的是一个听歌的插件，各个平台都有一些独家的音乐，就像视频网站一样，这就可怜了我们这些消费者。<br>如果想要听所有的音乐就要办理各个 APP 的会员，或者在多个音乐 APP 中切换。</p><p>这个插件能让我们听到所有国内几个主流大平台的所有音乐，足不出户畅享所有的音乐，并且值得称赞的是它支持会员系统，你可以保存<br>你的歌单，甚至可以直接登陆你的 Github 账户同步多端的数据。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn7ialcj30pa0j3dyl.jpg" alt="listen1"></p><p>仓库地址：<a href="https://github.com/listen1/listen1" target="_blank" rel="noopener">https://github.com/listen1/listen1</a></p><ol start="2"><li>Video Downloader Professional</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn8f9wkj3022020jr5.jpg" alt="video-downloader-icon"></p><p>我主要用它来下载 Youtube 的视频，据说可以下载任何视频网站的视频，但是我亲测了几个网站不可以。</p><p>扩展下载地址：<a href="https://chrome.google.com/webstore/detail/jpaglkhbmbmhlnpnehlffkgaaapoicnk" target="_blank" rel="noopener">https://chrome.google.com/webstore/detail/jpaglkhbmbmhlnpnehlffkgaaapoicnk</a></p><ol start="3"><li>Bilibili 全家桶</li></ol><p>经常看番的朋友怎么能少的了几个好用的插件护体呢？</p><p>这几个插件的功能基本满足了我看番的所有需求，包括弹幕合并，查找弹幕，自动签到，一键直达，猜你喜欢等等，大家可以安装下自己体验。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn8wijhj301x01q0sj.jpg" alt="helper-icon"></p><p><a href="https://chrome.google.com/webstore/detail/kpbnombpnpcffllnianjibmpadjolanh" target="_blank" rel="noopener">bilibili 助手</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdn9c9r3j30250210sk.jpg" alt="pakku-icon"></p><p><a href="http://s.xmcp.ml/pakkujs/?src=wext_homepage" target="_blank" rel="noopener">pakku 哔哩哔哩弹幕过滤器</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdnades9j3022020742.jpg" alt="danmu-icon"></p><p><a href="https://chrome.google.com/webstore/detail/ngjddnobeppdekpmimhiamkoonoaccdf" target="_blank" rel="noopener">bilibili 猜你喜欢</a></p><h3 id="2019-09-17-学习方法"><a href="#2019-09-17-学习方法" class="headerlink" title="2019-09-17[学习方法]"></a>2019-09-17[学习方法]</h3><p>很多人想要问我“你的成长史是怎么样的？能不能分享一下你的菜鸡成长史”。 开始我是抵触的，这种东西写的不好大家会骂你，写的“太好”也会骂你。</p><p>今天我就来做个“lucifer”系列的开篇吧，用图来描述“lucifer 的一天”。</p><p>lucifer 的早晨：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdnas1atj30bl0de40e.jpg" alt="morning-lucifer"></p><p>lucifer 搬砖的一天开始了：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdnbsm32j30bl08c74r.jpg" alt="morning-lucifer"></p><p>lucifer 的晚上：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdnclwccj30bl05aq39.jpg" alt="morning-lucifer"></p><h3 id="2019-09-16-工具"><a href="#2019-09-16-工具" class="headerlink" title="2019-09-16[工具]"></a>2019-09-16[工具]</h3><p>经常有同学问我“你的这个扩展看着不错，叫什么”， “有什么好用的扩展程序推荐么？”。</p><p>因此我打算出一个《工具推荐》专题， 然后细分一个类别《工具推荐 - chrome 插件》。 这个算是这个系列的开篇之作，我默默翻开自己的 chrome 插件列表来看，<br>有什么好用的推荐给大家。突然灵机一动，干脆把这个“扩展插件管理器”安利给大家好了。之后我会向大家推荐更多好用好玩的插件，有“工具”，“效率”， “娱乐”，“前端”等等。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdnd1mbdj30fn0g1ab3.jpg" alt="chrome-extension-manager"></p><p>我的 chrome 插件差不多有 60 多个，插件多起来的时候，良好的分类，开启关闭，禁用，卸载等管理就变得非常重要了。<br>毕竟谁也不想在众多插件中寻寻觅觅的感觉，也不想因为开启太多插件吃我们宝贵的内存吧？<br>这个插件的名字是<a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco" target="_blank" rel="noopener">扩展管理器（Extension Manager)</a></p><blockquote><p>对于没有梯子的同学，我还贴心地给大家准备了我从官方下载的扩展文件。 <a href="./assets/2019-09/extension-manager.crx">链接</a></p></blockquote><h3 id="2019-09-12-类库"><a href="#2019-09-12-类库" class="headerlink" title="2019-09-12[类库]"></a>2019-09-12[类库]</h3><p>今天给大家推荐的是一个在给 Git 提交记录增加 emojis 的仓库。</p><p>或许你知道<a href="https://gist.github.com/stephenparish/9941e89d80e2bc58a153" target="_blank" rel="noopener">AngularJS Git Commit Message Conventions</a> , 现在很多开源项目和内部项目都在使用<br>，是一道非常流行的 git commit message 规范。 它的好处就是你可以很轻松地通过提交信息，看出<code>这次提交干的什么，影响范围等</code>，比如是新特性，修复 bug，增加文档， 重构代码等。</p><p>这个项目可以说更进一步，通过图的形式，让你更快地感知到这些信息，<code>可视化形式的沟通毫无疑问是最最有效的。因为人的大脑更擅长处理图像。</code> 项目提供了几十种 emoji，几乎覆盖了所有的场景。 仓库地址： <a href="https://gitmoji.carloscuesta.me/" target="_blank" rel="noopener">https://gitmoji.carloscuesta.me/</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7hdndga7qj30w20nedi8.jpg" alt="git-emoji"></p><h3 id="2019-09-11-技能"><a href="#2019-09-11-技能" class="headerlink" title="2019-09-11[技能]"></a>2019-09-11[技能]</h3><p>Google 内部有很多通用的最佳实践，在这我推荐一个项目，这是挂在 google group 下的一套通用的工程实战指南，被各个项目广泛使用，覆盖全部的编程语言。</p><p>这个仓库分成两部分：</p><ol><li><p>这部分是给 Code Reviewer（代码评审者）的指南</p></li><li><p>这部分是给 Change Author（CL 作者）的指南</p></li></ol><p>代码评审者指南本来是一个完整的文档，一共分为 6 部分，读者可根据需要阅读。</p><p>修改列表（Change List/CL）制定者指南包括一些浏览代码评审的最佳方式，开发者可以快速处理评审结果。</p><p>项目地址： <a href="https://github.com/google/eng-practices" target="_blank" rel="noopener">https://github.com/google/eng-practices</a></p><h3 id="2019-09-10-类库"><a href="#2019-09-10-类库" class="headerlink" title="2019-09-10[类库]"></a>2019-09-10[类库]</h3><p>今天给大家推荐的是一个打包平台，不知道大家有没有听说过“polyfill.io”，用法有点像。</p><p>这个仓库是 fork 自 packed，并进行了魔改，你可以将多个包打包成一个单独的 ESM，支持多种 options， 仓库地址： <a href="https://github.com/webcomponents-dev/packd-es" target="_blank" rel="noopener">https://github.com/webcomponents-dev/packd-es</a></p><h3 id="2019-09-09-类库"><a href="#2019-09-09-类库" class="headerlink" title="2019-09-09[类库]"></a>2019-09-09[类库]</h3><p>一个可以将草稿转化 HTML 的工具，利用了机器学习来生成页面。 你可以手画一些东西，然后将其直接生成静态页面。缺点也很明显，一方面是静态的，因此没有什么交互，对于交互强的应用没什么用。<br>其次就是生成的是 HTML，可维护性会比较差，如果生成类似 JSX 这样的中间产物可能会好一点。当然市面上其实已经有了生成 JSX 产物的开源框架了。 地址：<a href="https://github.com/ashnkumar/sketch-code" target="_blank" rel="noopener">https://github.com/ashnkumar/sketch-code</a></p><h3 id="2019-09-06-学习方法-好文"><a href="#2019-09-06-学习方法-好文" class="headerlink" title="2019-09-06[学习方法, 好文]"></a>2019-09-06[学习方法, 好文]</h3><p>如何培养自己的程序员思维。- Problem-solving is the meta-skill. 文章地址： <a href="https://learnworthy.net/how-to-think-like-a-programmer/?utm_source=quora&amp;utm_medium=referral" target="_blank" rel="noopener">https://learnworthy.net/how-to-think-like-a-programmer/?utm_source=quora&amp;utm_medium=referral</a></p><h3 id="2019-09-05-类库"><a href="#2019-09-05-类库" class="headerlink" title="2019-09-05[类库]"></a>2019-09-05[类库]</h3><p>这是微软开源的内部用来构建大型应用的工具库，包括接口管理，文档管理，代码仓库管理等。 地址： <a href="https://github.com/microsoft/web-build-tools" target="_blank" rel="noopener">https://github.com/microsoft/web-build-tools</a></p><h2 id="历史汇总"><a href="#历史汇总" class="headerlink" title="历史汇总"></a>历史汇总</h2><ul><li>暂无历史汇总</li></ul><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>我重新整理了下自己的公众号，并且我还给它换了一个名字<code>脑洞前端</code>，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>在这里我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解是我的目标。</p><p>之后我的文章会同步到微信公众号 <code>脑洞前端</code> ，你可以关注获取最新的文章，并和我进行交流。</p><p>另外你可以回复大前端进大前端微信交流群， 回复 leetcode 拉你进 leetcode 微信群，如果想加入 qq 群，请回复 qq。</p><img width="300" src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7he9xdtmyj30by0byaac.jpg"><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul><li>如果有想法和创意，请提<a href="https://github.com/azl397985856/daily-featured/issues" target="_blank" rel="noopener">issue</a>或者进群提</li><li>如果想贡献代码，请提<a href="https://github.com/azl397985856/daily-featured/pulls" target="_blank" rel="noopener">PR</a></li><li>如果需要修改项目中图片，<a href="https://github.com/azl397985856/daily-featured/tree/master/assets" target="_blank" rel="noopener">这里</a>存放了项目中绘制图的源代码， 大家可以用<a href="https://www.draw.io/" target="_blank" rel="noopener">draw.io</a>打开进行编辑。</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="./LICENSE">Apache-2.0</a></p>]]></content>
      
      
      <categories>
          
          <category> 每日一荐 </category>
          
          <category> 2019-09 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文看懂《最大子序列和问题》</title>
      <link href="/blog/2019/12/11/LSS/"/>
      <url>/blog/2019/12/11/LSS/</url>
      
        <content type="html"><![CDATA[<p>最大子序列和是一道经典的算法题， leetcode 也有原题《53.maximum-sum-subarray》，今天我们就来彻底攻克它。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求取数组中最大连续子序列和，例如给定数组为 A = [1， 3， -2， 4， -5]， 则最大连续子序列和为 6，即 1 + 3 +（-2）+ 4 = 6。<br>去</p><p>首先我们来明确一下题意。</p><ul><li>题目说的子数组是连续的</li><li>题目只需要求和，不需要返回子数组的具体位置。</li><li>数组中的元素是整数，但是可能是正数，负数和 0。</li><li>子序列的最小长度为 1。</li></ul><p>比如：</p><ul><li>对于数组 [1, -2, 3, 5, -3, 2], 应该返回 3 + 5 = 8</li><li>对于数组 [0, -2, 3, 5, -1, 2], 应该返回 3 + 5 + -1 + 2 = 9</li><li>对于数组 [-9, -2, -3, -5, -3], 应该返回 -2</li></ul><h2 id="解法一-暴力法（超时法）"><a href="#解法一-暴力法（超时法）" class="headerlink" title="解法一 - 暴力法（超时法）"></a>解法一 - 暴力法（超时法）</h2><p>一般情况下，先从暴力解分析，然后再进行一步步的优化。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们来试下最直接的方法，就是计算所有的子序列的和，然后取出最大值。<br>记 Sum[i,….,j]为数组 A 中第 i 个元素到第 j 个元素的和，其中 0 &lt;= i &lt;= j &lt; n，<br>遍历所有可能的 Sum[i,….,j] 即可。</p><p>我们去枚举以 0,1,2…n-1 开头的所有子序列即可，<br>对于每一个开头的子序列，我们都去枚举从当前开始到 n-1 的所有情况。</p><p>这种做法的时间复杂度为 O(N^2), 空间复杂度为 O(1)。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>JavaScript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LSS</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = list.length;</span><br><span class="line">  <span class="keyword">let</span> max = -<span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">      sum += list[j];</span><br><span class="line">      <span class="keyword">if</span> (sum &gt; max) &#123;</span><br><span class="line">        max = sum;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarrayPrefixSum</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> len = nums.length;</span><br><span class="line">      <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; len; j++) &#123;</span><br><span class="line">          sum += nums[j];</span><br><span class="line">          maxSum = Math.max(maxSum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxSum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        maxSum = -sys.maxsize</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i, n):</span><br><span class="line">                sum += nums[j]</span><br><span class="line">                maxSum = max(maxSum, sum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure><p>空间复杂度非常理想，但是时间复杂度有点高。怎么优化呢？我们来看下下一个解法。</p><h2 id="解法二-分治法"><a href="#解法二-分治法" class="headerlink" title="解法二 - 分治法"></a>解法二 - 分治法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们来分析一下这个问题， 我们先把数组平均分成左右两部分。</p><p>此时有三种情况：</p><ul><li>最大子序列全部在数组左部分</li><li>最大子序列全部在数组右部分</li><li>最大子序列横跨左右数组</li></ul><p>对于前两种情况，我们相当于将原问题转化为了规模更小的同样问题。</p><p>对于第三种情况，由于已知循环的起点（即中点），我们只需要进行一次循环，分别找出<br>左边和右边的最大子序列即可。</p><p>所以一个思路就是我们每次都对数组分成左右两部分，然后分别计算上面三种情况的最大子序列和，<br>取出最大的即可。</p><p>举例说明，如下图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds543yp2cj31400u0myf.jpg" alt><br>(by <a href="https://github.com/snowan" target="_blank" rel="noopener">snowan</a>)</p><p>这种做法的时间复杂度为 O(N*logN), 空间复杂度为 O(1)。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>JavaScript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">list, m, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (m === n) <span class="keyword">return</span> list[m];</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> lmax = -<span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">  <span class="keyword">let</span> rmax = -<span class="built_in">Number</span>.MAX_VALUE;</span><br><span class="line">  <span class="keyword">const</span> mid = ((n - m) &gt;&gt; <span class="number">1</span>) + m;</span><br><span class="line">  <span class="keyword">const</span> l = helper(list, m, mid);</span><br><span class="line">  <span class="keyword">const</span> r = helper(list, mid + <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = mid; i &gt;= m; i--) &#123;</span><br><span class="line">    sum += list[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; lmax) lmax = sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = mid + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum += list[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; rmax) rmax = sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(l, r, lmax + rmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LSS</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> helper(list, <span class="number">0</span>, list.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarrayDivideConquer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArrayDividConquer</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">      <span class="keyword">int</span> mid = (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> left = helper(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">int</span> right = helper(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">      <span class="keyword">int</span> leftMaxSum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// left surfix maxSum start from index mid - 1 to l</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= l; i--) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        leftMaxSum = Math.max(leftMaxSum, sum);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> rightMaxSum = <span class="number">0</span>;</span><br><span class="line">      sum = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// right prefix maxSum start from index mid + 1 to r</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        rightMaxSum = Math.max(sum, rightMaxSum);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// max(left, right, crossSum)</span></span><br><span class="line">      <span class="keyword">return</span> Math.max(leftMaxSum + rightMaxSum + nums[mid], Math.max(left, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 3 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> -sys.maxsize</span><br><span class="line">        mid = (l + r) // <span class="number">2</span></span><br><span class="line">        left = self.helper(nums, l, mid - <span class="number">1</span>)</span><br><span class="line">        right = self.helper(nums, mid + <span class="number">1</span>, r)</span><br><span class="line">        left_suffix_max_sum = right_prefix_max_sum = <span class="number">0</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(l, mid)):</span><br><span class="line">            sum += nums[i]</span><br><span class="line">            left_suffix_max_sum = max(left_suffix_max_sum, sum)</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(mid + <span class="number">1</span>, r + <span class="number">1</span>):</span><br><span class="line">            sum += nums[i]</span><br><span class="line">            right_prefix_max_sum = max(right_prefix_max_sum, sum)</span><br><span class="line">        cross_max_sum = left_suffix_max_sum + right_prefix_max_sum + nums[mid]</span><br><span class="line">        <span class="keyword">return</span> max(cross_max_sum, left, right)</span><br></pre></td></tr></table></figure><h2 id="解法三-动态规划"><a href="#解法三-动态规划" class="headerlink" title="解法三 - 动态规划"></a>解法三 - 动态规划</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>我们来思考一下这个问题， 看能不能将其拆解为规模更小的同样问题，并且能找出<br>递推关系。</p><p>我们不妨假设问题 Q(list, i) 表示 list 中以索引 i 结尾的情况下最大子序列和，<br>那么原问题就转化为 Q(list, i), 其中 i = 0,1,2…n-1 中的最大值。</p><p>我们继续来看下递归关系，即 Q(list, i)和 Q(list, i - 1)的关系，<br>即如何根据 Q(list, i - 1) 推导出 Q(list, i)。</p><p>如果已知 Q(list, i - 1)， 我们可以将问题分为两种情况，即以索引为 i 的元素终止，<br>或者只有一个索引为 i 的元素。</p><ul><li>如果以索引为 i 的元素终止， 那么就是 Q(list, i - 1) + list[i]</li><li>如果只有一个索引为 i 的元素，那么就是 list[i]</li></ul><p>分析到这里，递推关系就很明朗了，即<code>Q(list, i) = Math.max(0, Q(list, i - 1)) + list[i]</code></p><p>举例说明，如下图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds544xidoj30pj0h2wew.jpg" alt="53.maximum-sum-subarray-dp.png"><br>(by <a href="https://github.com/snowan" target="_blank" rel="noopener">snowan</a>)</p><p>这种算法的时间复杂度 O(N), 空间复杂度为 O(1)</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>JavaScript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LSS</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = list.length;</span><br><span class="line">  <span class="keyword">let</span> max = list[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    list[i] = <span class="built_in">Math</span>.max(<span class="number">0</span>, list[i - <span class="number">1</span>]) + list[i];</span><br><span class="line">    <span class="keyword">if</span> (list[i] &gt; max) max = list[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaximumSubarrayDP</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> currMaxSum = nums[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">       currMaxSum = Math.max(currMaxSum + nums[i], nums[i]);</span><br><span class="line">       maxSum = Math.max(maxSum, currMaxSum);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> maxSum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        max_sum_ending_curr_index = max_sum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            max_sum_ending_curr_index = max(max_sum_ending_curr_index + nums[i], nums[i])</span><br><span class="line">            max_sum = max(max_sum_ending_curr_index, max_sum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><h2 id="解法四-数学分析"><a href="#解法四-数学分析" class="headerlink" title="解法四 - 数学分析"></a>解法四 - 数学分析</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>我们来通过数学分析来看一下这个题目。</p><p>我们定义函数 S(i) ，它的功能是计算以 0（包括 0）开始加到 i（包括 i）的值。</p><p>那么 S(j) - S(i - 1) 就等于 从 i 开始（包括 i）加到 j（包括 j）的值。</p><p>我们进一步分析，实际上我们只需要遍历一次计算出所有的 S(i), 其中 i 等于 0,1,2….,n-1。<br>然后我们再减去之前的 S(k),其中 k 等于 0，1，i - 1，中的最小值即可。 因此我们需要<br>用一个变量来维护这个最小值，还需要一个变量维护最大值。</p><p>这种算法的时间复杂度 O(N), 空间复杂度为 O(1)。</p><p>其实很多题目，都有这样的思想， 比如之前的《每日一题 - 电梯问题》。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><p>JavaScript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LSS</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = list.length;</span><br><span class="line">  <span class="keyword">let</span> max = list[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    sum += list[i];</span><br><span class="line">    <span class="keyword">if</span> (sum - min &gt; max) max = sum - min;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; min) &#123;</span><br><span class="line">      min = sum;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxSumSubarray</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// prefix Sum</span></span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="comment">// update maxSum</span></span><br><span class="line">        maxSum = Math.max(maxSum, sum - minSum);</span><br><span class="line">        <span class="comment">// update minSum</span></span><br><span class="line">        minSum = Math.min(minSum, sum);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxSum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python 3:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        maxSum = nums[<span class="number">0</span>]</span><br><span class="line">        minSum = sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum += nums[i]</span><br><span class="line">            maxSum = max(maxSum, sum - minSum)</span><br><span class="line">            minSum = min(minSum, sum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSum</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们使用四种方法解决了<code>《最大子序列和问题》</code>,<br>并详细分析了各个解法的思路以及复杂度，相信下次你碰到相同或者类似的问题<br>的时候也能够发散思维，做到<code>一题多解，多题一解</code>。</p><p>实际上，我们只是求出了最大的和，如果题目进一步要求出最大子序列和的子序列呢？<br>如果要题目允许不连续呢？ 我们又该如何思考和变通？如何将数组改成二维，求解最大矩阵和怎么计算？<br>这些问题留给读者自己来思考。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
          <category> 数组 </category>
          
          <category> 子序列 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法之美》-为工程师量身打造的数据结构与算法私教课</title>
      <link href="/blog/2019/12/11/ad/"/>
      <url>/blog/2019/12/11/ad/</url>
      
        <content type="html"><![CDATA[<p>很多人问我如何系统地学习数据结构与算法，是看书，刷题还是看视频？</p><p>这个问题没有一个放之四海而皆准的答案，这是一个因人而异的东西，我之前给初学者推荐过邓俊辉老师免费的《数据结构与算法》课程，以及为《算法图解》这本书。 然而这些只是适合初学者，真正想要掌握数据结构与算法还是不够的，学习了基础之后如何进阶呢？像《算法导论》这些经典书籍，虽然很全面，但是过于缺乏重点。很多人学起来都非常困难。而市面很多在线课程或者线下课程，大多是为了“应试”，只讲一些看似通用，实则脱离真实开发场景的内容。因此这里给大家推荐一本书《数据结构与算法之美》。</p><a id="more"></a><h2 id="程序员必会的数据结构与算法"><a href="#程序员必会的数据结构与算法" class="headerlink" title="程序员必会的数据结构与算法"></a>程序员必会的数据结构与算法</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51dcng8j30u01spjwj.jpg" alt></p><h2 id="订阅量-TOP1"><a href="#订阅量-TOP1" class="headerlink" title="订阅量 TOP1"></a>订阅量 TOP1</h2><p>这本书是订阅量 Top1，50000+程序员的算法课堂，整个专栏会涵盖 100 多个算法真实项目场景案例，更难得的是它跟市面上晦涩的算法书籍不同的是，还手绘了一些清晰易懂的详解图（总共有 300 多张），市面上的大多数的算法教程都看过，走心的说，这个专栏是市面上唯一一门真正适用于工程师的专栏，作者是前 Google 工程师王争，相信会开启你的趣味学习算法之旅。</p><h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>本书作者王争，前 Google 工程师，从事 Google 翻译相关的开发工作，深入研究算法数十年。现任某金融公司资深系统架构师，核心业务接口平台负责人，负责公司核心业务的架构设计、开发，以及可用性、高性能等相关技术问题的解决。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51emu5oj30yi0emgmm.jpg" alt></p><h2 id="你能获得什么？"><a href="#你能获得什么？" class="headerlink" title="你能获得什么？"></a>你能获得什么？</h2><p>1、掌握数据结构与算法的核心知识</p><p>我根据自己研读数十本算法书籍和多年项目开发的经验，精选了 20 个最实用数据结构和算法结合具体的软件开发实例，由浅入深进行讲解背后的设计思想，并适时总结一些实用“宝典”，保证你印象深刻，并且能够迅速对应到实际工作场景中。</p><p>2、提升算法思维，训练解决实际开发工作难题的强能力</p><p>这部分我会讲一些不是那么常用的数据结构和算法。虽然不常用，但是并不是说他们没用。设置这一部分的目的，是为了让你开拓视野，强化训练算法思维、逻辑思维。如果说学完基础部分可以考 80 分，那掌握这一部分就能让你成为尖子生。再回过来说，不管是现在流行的区块链技术还是人工智能，核心代码实现中都会涉及到这些算法。</p><p>3、学习开源框架、底层系统的设计原理，提升工作实战技能</p><p>最后我会通过实战部分串讲一下前面讲到的数据结构和算法，并且结合 Redis、Disruptor 这样的开源项目，剖析它们背后的数据结构和算法，帮你提升读懂源码的能力（JDK 很多源码，不乏大量的数据结构，例如大家喜闻乐见的面试题 HashMap）。</p><p>我掰着指头数了下，整个专栏会涵盖 100 多个算法真实项目场景案例。我还手绘了一些清晰易懂的详解图，帮你理解核心概念和实现过程，展示每个知识点的框架逻辑，让晦涩难懂的算法变得轻松有趣。</p><h2 id="课程目录"><a href="#课程目录" class="headerlink" title="课程目录"></a>课程目录</h2><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51g47doj30ku2swqad.jpg" alt></p><h2 id="订阅福利"><a href="#订阅福利" class="headerlink" title="订阅福利"></a>订阅福利</h2><p>扫描下方二维码订阅即可，新人立减 30 元，另外我本人提供返现 11 元（到手 88 元），直接加我微信<code>DevelopeEngineer</code>即可。另外再送你 199 元限时学习礼包，你可以先领券再购买，领券地址：<a href="http://gk.link/a/108qc" target="_blank" rel="noopener">http://gk.link/a/108qc</a></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51hy79vj30u01hdgq9.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法在前端领域的应用 - 第四篇</title>
      <link href="/blog/2019/09/21/algorthimn-fe-4/"/>
      <url>/blog/2019/09/21/algorthimn-fe-4/</url>
      
        <content type="html"><![CDATA[<p>前一段时间我分享了几篇关于《数据结构与算法在前端领域的应用》的文章。</p><p>文章链接：</p><ul><li><a href="https://juejin.im/post/5d3dc8466fb9a07efc49d0a9" target="_blank" rel="noopener">数据结构和算法在前端领域的应用(前菜)</a></li><li><a href="https://juejin.im/post/5d4289046fb9a06ad229ad21" target="_blank" rel="noopener">数据结构和算法在前端领域的应用(进阶)</a></li></ul><p>这一次我们顺着前面的内容，讲一些经典的数据结构与算法，本期我们来讲一下时下比较火热的<code>React fiber</code>。</p><p>这部分内容相对比较硬核和难以消化，否则 React 团队也不会花费两年的时间来搞这一个东西。建议大家多读几遍。</p><a id="more"></a><h2 id="fiber-一个用于增量更新的数据结构"><a href="#fiber-一个用于增量更新的数据结构" class="headerlink" title="fiber - 一个用于增量更新的数据结构"></a>fiber - 一个用于增量更新的数据结构</h2><p>前面我的文章提到过 fiber 是一种数据结构，并且是一种链式的数据结构。</p><p>fiber 是为了下一代调和引擎而引入的一种新的数据结构，而下一代调和引擎最核心的部分就是<br>“增量渲染”。为了明白这个“增量渲染”，我们需要打一点小小的基础。</p><h3 id="分片执行"><a href="#分片执行" class="headerlink" title="分片执行"></a>分片执行</h3><p>为了做到上面我提到的“增量渲染”，我们首先要能够停下来。<br>之前 React 的更新 UI 的策略是自顶向下进行渲染，如果没有人工的干涉，React 实际上会更新到<br>所有的子组件，这在大多数情况下没有问题。</p><p>然而随着项目越来越复杂，这种弊端就非常明显了。单纯看这一点，Vue 在这方面做的更好，<br>Vue 提供了更加细粒度的更新组件的方式，甚至无需用户参与。 这是两者设计理念上的差异，不关乎<br>好坏，只是适用场景不一样罢了。</p><p>值得一提的是，Vue 的这种细粒度监听和更新的方式，实际上是内存层面和计算层面的权衡。<br>社区中一些新的优秀框架，也借鉴了 Vue 的这种模式，并且完成了进一步的进化，对不同的类型进行划分，<br>并采取不同的监听更新策略，实际上是一种更加“智能“的取舍罢了。</p><p>言归正传，我们如何才能做到”增量更新“呢？</p><ul><li>首先你要能够在进行到中途的时候停下来</li><li>你能够继续刚才的工作，换句话说可以重用之前的计算结果</li></ul><blockquote><p>实现这两点靠的正是我们今天的主角 fiber，稍后我们再讲。</p></blockquote><p>比如之前 React 执行了一个 100ms 的更新过程，对于新的调和算法，<br>会将这个过程划分为多个过程，当然每一份时间很可能是不同的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds527o2fmj30in07iaar.jpg" alt></p><p>由于总时间不会减少，我们设置还增加了调度（上面我提到的两条）的代码，<br>因此单纯从总时间上，甚至是一种倒退。但是为什么用户会感觉到更快了呢？<br>这就是下面我们要讲的调度器。</p><h3 id="三大核心组件-Scheduler，-Reconciliation，-Renderer"><a href="#三大核心组件-Scheduler，-Reconciliation，-Renderer" class="headerlink" title="三大核心组件 - Scheduler， Reconciliation， Renderer"></a>三大核心组件 - Scheduler， Reconciliation， Renderer</h3><p>事实上， React 核心的算法包含了三个核心部分，分别是<code>Scheduler，</code>， <code>Reconciliation</code>，<code>Renderer</code>。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds5284v44j30kn08rabb.jpg" alt></p><ul><li>scheduler 用于决定何时去执行。</li></ul><p>前面提到了，整个更新过程要比之前的做法要长。总时间变长的情况下，用户感觉性能更好的原因在于<br>scheduler。 对于用户而言，界面交互，动画，界面更新的优先级实际上是不一样的。</p><p>通过保证高优先级的事件的执行，比如用户输入，动画。 可以让用户有性能很好的感觉。</p><p>做到这一点实际上原理很简单，即使前面提到的 chunks，再加上我们给每一个任务分配一个优先级，<br>从而保证 chunks 的执行顺序中高优先级的在前面。</p><blockquote><p>浏览器实际上自己也会对一些事件区分优先级。</p></blockquote><ul><li>Reconciliation 决定哪部分需要更新，以及如何“相对最小化”完成更新过程。<br>这部分算法主要上衣基于<code>VDOM</code>这种数据结构来完成的。</li></ul><p>这部分的算法实际上就是一个“阉割版的最小编辑树算法”。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds528kezaj30ke09s75f.jpg" alt></p><ul><li>renderer 使用 Reconciliation 的计算结果，然后将这部分差异，最小化更新到视图。可以是 DOM，也可以是<br>native， 理论上可以是任何一种渲染容器。</li></ul><p>在 DOM 中，这部分的工作由 React-DOM 来完成。它会生成一些 DOM 操作的 API，从而去完成一些副作用，<br>这里指的是更新 DOM。</p><h2 id="fiber-一个虚拟调用栈"><a href="#fiber-一个虚拟调用栈" class="headerlink" title="fiber - 一个虚拟调用栈"></a>fiber - 一个虚拟调用栈</h2><p>实际上，fiber 做的事情就是将之前 react 更新策略进行了重构。</p><p>之前的更新策略是从顶向下，通过调用栈的形式保存已经更新的信息。<br>这本身没有问题， 但是这和我们刚才想要实现的效果是不匹配的，我们需要 chunks 的效果。<br>而之前的策略是从顶到下一口气执行完，不断 push stack，然后 pop stack，直到 stack 为空。</p><p>fiber 正是模拟了调用栈，并且通过链表来重新组织，一方面使得我们可以实现 chunks 的功能。<br>另一方面可以和 VDOM 进行很好的对应和映射。</p><h3 id="v-f-d"><a href="#v-f-d" class="headerlink" title="v = f(d)"></a>v = f(d)</h3><p>这是我从 React 官方介绍 fiber 的一个地方抄来的公式。</p><p>它想表达的是 react 是一个视图管理框架，并且是数据驱动的，唯一的数据会驱动产生唯一的视图。</p><p>我们可以把每一个组件都看成一个 view，然而我们的工作就是计算所有的组件的最新的 view。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds529530zj30h103y0t2.jpg" alt></p><p>那么 fiber 是如何完成“增量更新”呢？ 秘诀就是它相当于“重新实现了浏览器调用栈”。</p><p>我们来看一下，fiber 是如何实现传统调用栈的功能的。</p><h3 id="fiber-和-传统调用栈的区别"><a href="#fiber-和-传统调用栈的区别" class="headerlink" title="fiber 和 传统调用栈的区别"></a>fiber 和 传统调用栈的区别</h3><p>传统的调用栈，我们实际上将生成 view 的工作放到栈里面执行，浏览器的栈有一个特点就是<br>“你给它一个任务，它必须一口气执行完”。</p><p>而 fiber 由于是自己设计的，因此可以没有这个限制。 具体来说，两者的对应关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传统调用栈            fiber</span><br><span class="line"></span><br><span class="line">  子函数          component type</span><br><span class="line"> 函数嵌套              child</span><br><span class="line">  参数                props</span><br><span class="line"> 返回地址             parent</span><br><span class="line">  返回值          DOM elements</span><br></pre></td></tr></table></figure><p>用图来表示的话，大概是这样：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds52aevumj30ds08wwfk.jpg" alt></p><p>其中具体的算法，我预计会在我的<a href="https://github.com/azl397985856/mono-react" target="_blank" rel="noopener">从零开始开发一个 React</a> 中更新。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章介绍了fiber，fiber其实是一种用于增量更新的数据结构。<br>是为了下一代调和引擎而引入的一种新的数据结构，而下一代调和引擎最核心的部分就是<br>“增量渲染”。</p><p>我们介绍了几个基本概念和组件，包括分片执行， react三大核心组件 - Scheduler， Reconciliation， Renderer。</p><p>最后我们说了“fiber实际上就是一个虚拟调用栈”，并结合传统调用栈的特点和弊端，讲解了fiber是如何组织，<br>从而改进了传统调用栈带来的问题的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法在前端领域的应用 - 第三篇</title>
      <link href="/blog/2019/09/20/algorthimn-fe-3/"/>
      <url>/blog/2019/09/20/algorthimn-fe-3/</url>
      
        <content type="html"><![CDATA[<p>这是本系列文章的第三篇，这里我将带你从新的视角来看当前的前端应用，<br>虽然这其中涉及到的道理很简单，但是这部分知识很少被人看到，更不要说推广和应用了。</p><p>这里新的视角指的是我们从进程和线程的角度来思考我们前端应用的运行，从而从更高的层次去审视和优化我们的应用，甚至整个前端生态。</p><p>希望你看完之后从思维上也好，工作应用中也好能够有所收获。</p><p>前一段时间我分享了几篇关于《数据结构与算法在前端领域的应用》的文章。</p><p>文章链接：</p><ul><li><a href="https://juejin.im/post/5d3dc8466fb9a07efc49d0a9" target="_blank" rel="noopener">数据结构和算法在前端领域的应用(前菜)</a></li><li><a href="https://juejin.im/post/5d4289046fb9a06ad229ad21" target="_blank" rel="noopener">数据结构和算法在前端领域的应用(进阶)</a></li></ul><a id="more"></a><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是一个对技术充满兴趣的程序员, 擅长前端工程化，前端性能优化，前端标准化等。</p><p>做过.net， 搞过 Java，现在是一名前端工程师。</p><p>除了我的本职工作外，我会在开源社区进行一些输出和分享，GitHub 共计获得 1.5W star。比较受欢迎的项目有<a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">leetcode 题解</a> , <a href="https://github.com/azl397985856/fe-interview" target="_blank" rel="noopener">宇宙最强的前端面试指南</a> 和<br><a href="https://github.com/azl397985856/automate-everything" target="_blank" rel="noopener">我的第一本小书</a></p><h2 id="浏览器的进程模型"><a href="#浏览器的进程模型" class="headerlink" title="浏览器的进程模型"></a>浏览器的进程模型</h2><p>我们首先来看下浏览器的进程模型，我们以 chrome 为例。</p><p>Chrome 采用多进程架构，其顶层存在一个 Browser process 用以协调浏览器的其它进程。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds5220bt0j30k00bjdgl.jpg" alt><br>(图来自 <a href="https://zhuanlan.zhihu.com/p/47407398" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47407398</a>)</p><p>这也是为什么 chrome 明明只打开了一个 tab，却出现了 4 个进程的原因。</p><p>这部分不是我们本节的主要内容，大家了解这么多就够了，接下来我们看下今天的主角 - 渲染进程。</p><h2 id="浏览器的渲染进程"><a href="#浏览器的渲染进程" class="headerlink" title="浏览器的渲染进程"></a>浏览器的渲染进程</h2><p>渲染进程几乎负责 Tab 内的所有事情，渲染进程的核心目的在于转换 HTML CSS JS 为用户可交互的 web 页面。</p><p>渲染进程由以下四个线程组成：主线程 Main thread ， 工作线程 Worker thread，光栅线程 Raster thread<br>和排版线程 Compositor thread。</p><p>我们的今天的主角是主线程 Main thread 和 工作线程 Worker thread。</p><h3 id="主线程-Main-thread"><a href="#主线程-Main-thread" class="headerlink" title="主线程 Main thread"></a>主线程 Main thread</h3><p>主线程负责：</p><ul><li>构建 DOM</li><li>和网络进程（上文提到的）通信获取资源</li><li>对资源进行解析</li><li>JS 代码的执行</li><li>样式和布局的计算</li></ul><p>可以看出主线程非常繁忙，需要做很多事情。 主线程很容易成为应用的性能瓶颈。</p><p>当然除了主线程， 我们的其他进程和线程也可能成为我们的性能瓶颈，比如网络进程，解决网络进程瓶颈的方法有很多，可以使用浏览器本身缓存，也可以使用 ServiceWorker，还可以通过资源本身的优化等。这个不是我们本篇文章的讨论重点，这里只是让你有一个新的视角而已，因此不赘述。</p><h3 id="工作线程-Worker-thread"><a href="#工作线程-Worker-thread" class="headerlink" title="工作线程 Worker thread"></a>工作线程 Worker thread</h3><p>工作线程能够分担主线程的计算压力，进而主线程可以获得更多的空闲时间，从而更快地响应用户行为。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds522xxxtj31400u0gnl.jpg" alt></p><p>工作线程主要有 Web Woker 和 Service Worker 两种。</p><h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4><p>以下摘自<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">MDN</a></p><blockquote><p>Web Worker 为 Web 内容在后台线程中运行脚本提供了一种简单的方法。<br>线程可以执行任务而不干扰用户界面。此外，他们可以使用 XMLHttpRequest 执行 I/O<br>(尽管 responseXML 和 channel 属性总是为空)。<br>一旦创建， 一个 worker 可以将消息发送到创建它的 JavaScript 代码,</p></blockquote><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p>以下摘自<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">MDN</a></p><blockquote><p>Service workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，<br>也可以在网络可用时作为浏览器和网络间的代理。<br>它们旨在（除其他之外）使得能够创建有效的离线体验，<br>拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。<br>他们还允许访问推送通知和后台同步 API。</p></blockquote><h2 id="重新思考我们的前端应用"><a href="#重新思考我们的前端应用" class="headerlink" title="重新思考我们的前端应用"></a>重新思考我们的前端应用</h2><p>工作线程尤其是 Web Worker 的出现一部分原因就是为了分担主线程的压力。</p><p>整个过程就像主线程发布命令，然后工作线程执行，执行完毕将执行结果通过消息的形式传递给主线程。</p><p>我们以包工头包工程，然后将工作交给各个单位去做的角度来看的话，大概是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds523elypj30mt0cgq57.jpg" alt></p><p>实际上工作工作进程，尤其是 WebWorker 已经出现很长时间了。但是很多时候我们并没有充分使用，甚至连使用都没使用。</p><p>下面以 Web Worker 为例， 我们来深度挖掘一下工作线程的潜力。</p><p>前面的文章，我们谈了很多前端领域的算法，有框架层面的也有应用层面的。</p><p>前面提到了 React 的调和算法，这部分代码耗时其实还是蛮大的，React16 重构了<br>整个调和算法，但是总体的计算成本还是没有减少，甚至是增加的。</p><blockquote><p>关于调和算法可以参考我的另外一篇文章<a href="https://juejin.im/post/5d479ae551882505de0f1525" target="_blank" rel="noopener">前端领域的数据结构与算法解读 - fiber</a></p></blockquote><p>我们有没有可能将这部分内容抽离出主线程，交给工作进程，就像上面的图展示的那样呢？<br>我觉得可以， 另外我前面系列文章提到的所有东西，都可以放到工作线程中执行。<br>比如状态机，时光机，自动完成，差异比对算法等等。</p><p>如果将这些抽离出我们主线程的话，我们的应用大概会是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds524dw4nj30hb0d940f.jpg" alt></p><p>这样做主线程只负责 UI 展示，以及事件分发处理等工作，这样就大大减轻了主线程的负担，我们就可以更快速地响应用户了。<br>然后在计算结果完成之后，我们只需要通知主线程，主线程做出响应即可。<br>可以看出，在项目复杂到一定程度，这种优化带来的效果是非常大的。</p><p>我们来开一下脑洞， 假如流行的前端框架比如 React 内置了这种线程分离的功能，<br>即将调和算法交给 WebWorker 来处理，会给前端带来怎么样的变化？</p><p>假如我们可以涉及一个算法，智能地根据当前系统的硬件条件和网络状态，<br>自动判断应该将哪部分交给工作线程，哪部分代码交给主线程，会是怎么样的场景？</p><blockquote><p>这其实就是传说中的启发式算法， 大家有兴趣可以研究一下</p></blockquote><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>上述描述的场景非常美好，但是同样地也会有一些挑战。</p><p>第一个挑战就是操作繁琐，比如 webworker 只支持单独文件引入，再比如不支持函数序列化,以及反复序列化带来的性能问题， 还有和 webworker 通信是异步的等等。</p><p>但是这些问题都有很成熟的解决方案，比如对于操作比较繁琐这个问题我们就可以通过使用一些封装好 web worker 操作的库。<a href="https://github.com/GoogleChromeLabs/comlink" target="_blank" rel="noopener">comlink</a> 就是一个非常不错的 web worker 的封装工具库。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds525clcbj31kw0ntjt5.jpg" alt></p><p>对于不支持单文件引入，我们其实可以用<code>Blob</code>, <code>createObjectURL</code>的方式模拟，<br>当然社区中其实也有了成熟的解决方案，如果你使用 webpack 构建的话，有一个<code>worker-loader</code>可以直接用。</p><p>对于函数序列化这个问题，我们无法传递函数给工作线程，其实上面提到的<br>Comlink， 就很好地解决了这个问题，即使用 Comlink 提供的<code>proxy</code>,<br>你可以将一个代理传递到工作线程。</p><p>对于反复序列化带来的性能问题，我们其实可以使用一种叫<code>对象转移（Transferable Objects）</code>的技术，幸运的是这个特性的浏览器兼容性也不错。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds526p8ufj312h0a2dhn.jpg" alt></p><p>对于异步的问题，我们可以采取一定的取舍。 即我们<br>本地每次保存一份最近一份的结果拷贝，我们只需要每次返回这个拷贝，<br>然后在 webworker 计算结果返回的时候更新拷贝即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章的主要目的是让大家以新的视角来思考当前的前端应用，我们站在进程和线程的角度来看现在的前端应用，或许会有更多的不一样的理解和思考。</p><p>本文先是讲了浏览器的进程模型，然后讲了浏览器的渲染进程中的<br>线程模型。 我们知道了渲染进程主要有四个线程组成，<br>分别是主线程 Main thread ， 工作线程 Worker thread，光栅线程 Raster thread<br>和排版线程 Compositor thread。</p><p>然后详细介绍了主线程和工作线程，并以 webworker 为例，讲述了如何利用工作线程为我们的主线程分担负担。为了消化这部分知识，建议你自己动手实践一下。</p><p>虽然我们的愿望很好，但是这其中在应用的过程之中还是有一些坑的，我这里列觉了一些常见的坑，并给出了解决方案。</p><p>我相信工作线程的潜力还没有被充分发挥出来，希望可以看到前端应用真正的挖掘各个进程和线程潜力的时候吧，这不但需要前端工程师的努力，也需要浏览器的配合支持，甚至需要标准化组织去推送一些东西。</p><h2 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h2><p>最近我重新整理了下自己的公众号，并且我还给他换了一个名字《脑洞前端》，它是一个帮助你打开大前端新世界大门的钥匙 🔑，在这里你可以听到新奇的观点，看到一些技术尝新，还会收到系统性总结和思考。</p><p>我会尽量通过图的形式来阐述一些概念和逻辑，帮助大家快速理解，图解前端是我的目标。</p><p>之后我的文章同步到微信公众号 脑洞前端 ，您可以关注获取最新的文章，或者和我进行交流。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds4sh51a6j30km0komyv.jpg" width="50%" height="50%" alt="gongzhonghao" align="center">]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法在前端领域的应用 - 第二篇</title>
      <link href="/blog/2019/09/19/algorthimn-fe-2/"/>
      <url>/blog/2019/09/19/algorthimn-fe-2/</url>
      
        <content type="html"><![CDATA[<p>这是一个我即将做的一个《数据结构与算法在前端领域的应用》主题演讲的一个主菜。<br>如果你对这部分内容比较生疏，可以看我的<a href="https://juejin.im/post/5d3dc8466fb9a07efc49d0a9" target="_blank" rel="noopener">数据结构和算法在前端领域的应用(前菜)</a></p><p>这里我会深入帮助大家如何根据业务抽离出纯粹的模型，从而转化为算法问题，</p><a id="more"></a><h2 id="以上帝角度来看前端"><a href="#以上帝角度来看前端" class="headerlink" title="以上帝角度来看前端"></a>以上帝角度来看前端</h2><p>让我们以更高的层次来看一下，从大的范围上前端领域都在做什么？</p><p>从业务上来说，我们会去做各个端的开发、网关、接口、工程化。<br>从技术上说，则是基于 WEB、Node 的通用技术，以及各平台（最常见的就是安卓和 IOS）的专有技术。</p><p>在这里我以自己的标准总结了以下三点：</p><ol><li>架构和平台</li></ol><p>其实平台建设也是架构中的一环，之所以列出来单独讲是因为这块内容相对比较大。<br>每个公司，部门，项目都有自己的架构设计和规范。它们环环相套组成了整个公司的架构体系。</p><p>很多公司在做工具链，在做跨端方案，在做底层融合等，这些都属于这个范畴。<br>比如最近比较火的 Serverless 也是属于这个范畴。</p><ol start="2"><li>规范和标准化</li></ol><p>前端行业规范目前来看的话就两个，一个是 ECMA 的规范，一个是 W3C 的规范。<br>前端行业规范是非常重要的，不然前端会非常混乱，想一下前端刚刚诞生出来的时候就知道了。</p><p>公司内部也会有一些规范，但是很难上升到标准层次。 目前国内没有一个行业认可的标准化组织，<br>这算是一个遗憾吧。 好消息是国人在标准化组织的参与感越来越强，做了更多的事情。</p><p>其实这部分我们的感知是比较弱的，一个原因就是我们一直在努力对接行业的标准，很少去自己创造一些标准。<br>原因有几点，一方面自己做标准，维护更新标准很难，另一方面自己做标准需要学习成本和转换成本。</p><p>但是这并不意味这做公司标准或者行业领域规范就没有用，相反非常有用。我之前做过一个《标准化能给我们带来什么》的<br>分享，详细介绍了标准化对于我们的重要性。</p><ol start="3"><li>生态体系</li></ol><p>其实前端的工作就是人机交互，这其中涉及的东西很多，相关领域非常广泛。</p><p>比如智能手表、智能 TV、智能眼镜、头戴 AR，VR 等新的交互模式我们如何去融入现有开发体系中 ？<br>人工智能在前端开发可以发挥怎么样的作用 ？ 这些其实很多公司已经在尝试，并且取得了非常不错的效果。</p><p>比如 IDE 是开发过程非常重要的工具，我们是否可以去做标准化的 IDE，甚至放到云端。</p><h2 id="无处不在的算法"><a href="#无处不在的算法" class="headerlink" title="无处不在的算法"></a>无处不在的算法</h2><p>上面我们从多个方面重新审视了一下前端，除了人工智能部分，其他部分根本没有提到算法。<br>是不是算法在前端领域应用很少呢？ 不是的。</p><p>一方面就像上一节介绍的，我们日常开发中使用的很多东西都是经过数据结构和算法的精心封装，<br>比如 DOM 和 VDOM，以及 JSON。 JSON的序列化和反序列化是我们无时无刻使用的方法，<br>比如我们需要和后端进行数据交互，需要和其他线程（比如webworker）进行数据交互都要经过<br>序列化和反序列化，如何减少数据传输，如何提高序列化和反序列化的效率，如何在两者<br>之间寻求一种平衡都是我们需要研究的。</p><blockquote><p>JSON 也是一种树结构</p></blockquote><p>甚至还有很多框架以数据结构直接命名，比如 GraphQL，就是<br>用图这种数据结构来命名，从而体现其强大的关联查询能力。 比如 tensorflow 以张量（tensor）来加深大家对上面两点的印象命名，</p><p>TensorFlow™ 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。</p><p>上面提到的各个环节都或多或少会用到算法。首先网络部分就涉及到很多算法，<br>比如有限状态机，滑动窗口，各种压缩算法，保障我们信息不泄漏的各种加密算法等等，简直不要太多。<br>虽然这些网络部分很多都是现成的，但是也不排除有一些需要我们自己根据当前实际场景自己去搭建一套的可能。<br>这在大公司之中是非常常见的。</p><p>我们再来看下执行我们代码的引擎，以 V8 为例，其本身涉及的算法不算在内。<br>但是当我们基于 V8 去做一些事情，我们就需要了解一些编译相关的原理。<br>这里我举个例子，下图是支付宝的小程序架构。 如果我们不懂一些算法的话，<br>是很难像支付宝一样结合自己的业务去做一些突破的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51u5ayhj315i0cm0vu.jpg" alt="支付宝小程序架构"><br>(图片来自 <a href="https://www.infoq.cn/article/ullETz7q_Ue4dUptKgKC" target="_blank" rel="noopener">https://www.infoq.cn/article/ullETz7q_Ue4dUptKgKC</a>)</p><p>另外一些高层的架构中也会有很多算法方面的东西，比如我需要在前端做增量更新的功能。<br>增量更新在APP中早已不是新鲜的东西了，但是真正做JS等静态资源的实时增量更新还比较少，<br>这里面会涉及非常复杂的交互和算法。</p><p>上面提到的更多的是高层面上，事实上即使是业务层面也有很多值得挖掘的算法模型。<br>我们需要从复杂的业务中提炼出算法模型，才能得到实际应用。可惜的是很多时候我们缺乏这种抽象能力和意志。</p><p>除了上一节我讲述的常见场景之外，我还会在下一节介绍几个实际业务场景，从而加深大家的理解。<br>希望大家看了之后，能够在自己的实际业务中有所帮助。</p><h2 id="性能和优雅，我全都要"><a href="#性能和优雅，我全都要" class="headerlink" title="性能和优雅，我全都要"></a>性能和优雅，我全都要</h2><p>从表象上看，使用合适的数据结构和算法有两方面的好处。</p><p>第一个是性能，这个比较好理解一点，我们追求更好的时间复杂度和空间复杂度，<br>并且我们需要不断地在两者之间做合理的取舍。</p><p>第二点是优雅，使用合适的数据结构和算法。能让我们处理问题更加简洁优雅。</p><p>下面我会举几个我在实际业务场景中的例子，来加深大家对上面两点的印象。</p><h3 id="权限系统"><a href="#权限系统" class="headerlink" title="权限系统"></a>权限系统</h3><p>假如你现在开发一款类似石墨文档的多人在线协作编辑文档系统。</p><p>这里面有一个小功能是权限系统。 用户可以在我们的系统中创建文件夹和文件，<br>并且管理角色，不同的角色可以分配不同的文件权限。 比如查看，下载，编辑，审批等。</p><p>我们既可以给文件夹分配权限，又可以给文件分配权限，如果对应文件该角色没有权限，<br>我们需要递归往上搜索，看有没有相应权限，如果有，则这个角色有文件的该操作权限。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51uym8gj30kn0eedhp.jpg" alt></p><p>如图，fileA 的权限就需要从 fileA 开始看有没有对应权限，如果有，则返回有权限。<br>如果没有，则查找 app 文件夹的权限，重复这个过程，直到根节点。</p><p>如果你是这个系统的前端负责人，你会如何设计这个系统呢？</p><p>其实做这个功能的方案有很多，我这里参考了 linux 的设计。<br>我们使用一个二进制来标示一个权限有还是没有。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51vgy83j30f70d7wfv.jpg" alt></p><p>这样的话，一方面我们只需要 4 个 bit 就可以存储权限信息，存储已经是极限了。<br>另一方面我们通过位运算即可算出有没有权限，二进制运算在计算性能上也是极限了。</p><p>另外代码写起来，也会非常简洁，感兴趣的可以自己试试。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51xb3fij30hi0d1abh.jpg" alt></p><blockquote><p>扩展： 假如文件权限不是只有两种可能，比如有三个取值怎么办？</p></blockquote><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><h4 id="什么是状态机"><a href="#什么是状态机" class="headerlink" title="什么是状态机"></a>什么是状态机</h4><p>状态机表示若干个状态以及在这些状态之间的转移和动作等行为的数学模型。<br>通俗的描述状态机就是定义了一套状态変更的流程：状态机包含一个状态集合，<br>定义当状态机处于某一个状态的时候它所能接收的事件以及可执行的行为，执行完成后，状态机所处的状态。</p><p>我们以现实中广泛使用的有限状态机（以下简称 FSM）为例进行讲解</p><p>FSM 应用非常广泛， 比如正则表达式的引擎，编译器的词法和语法分析，网络协议，企业应用等很多领域都会用到。</p><p>其中正则中使用的是一种特殊的 FSM， 叫 DFA（Deterministic Finite Automaton）， 通过分裂树形式来运行。</p><h4 id="为什么要使用状态机"><a href="#为什么要使用状态机" class="headerlink" title="为什么要使用状态机"></a>为什么要使用状态机</h4><p>第一个原因，也是大家感触最深的一个原因就是通过状态机去控制系统内部的状态以及状态流转，逻辑会<br>比较清晰，尤其在逻辑比较复杂的时候，这种作用越发明显。</p><p>第二个原因是通过状态机，我们可以实现数据以及系统的可视化。刚才我提到了正则表达式用到了状态机，<br>那么正则是否可以可视化呢？ 答案是肯定的，这里我介绍一个可视化正则表达式的一个网站。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51yqptbj313h05wgmb.jpg" alt></p><p>实际业务中如果使用状态机来设计系统也可以进行可视化。类似这样子：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51z6k2gj31390h9tah.jpg" alt></p><p>(图来自 <a href="https://statecharts.github.io/xstate-viz/" target="_blank" rel="noopener">https://statecharts.github.io/xstate-viz/</a>)</p><p>可以看出，逻辑流转非常清晰，我们甚至可以基于此进行调试。<br>当然，将它作为文档的一部分也是极好的，关于状态机的实际意义还有很多，我们接下来举几个例子说明。</p><h4 id="状态机的实际应用场景"><a href="#状态机的实际应用场景" class="headerlink" title="状态机的实际应用场景"></a>状态机的实际应用场景</h4><h5 id="匹配三的倍数"><a href="#匹配三的倍数" class="headerlink" title="匹配三的倍数"></a>匹配三的倍数</h5><p>实现一个功能，判断一个数字是否是三的倍数。 数字可以非常大，以至于超过 Number 的表示范围，<br>因此我们需要用 string 来存储。</p><p>一个简单直观的做法是直接将每一位都加起来，然后看加起来的数字是否是三的倍数。<br>但是如果数字大到一定程度，导致加起来的数字也超过了 Number 的表示范围呢？</p><p>一个方法是使用状态机来解决。</p><p>我们发现一个数字除以 3 的余数一共有三种状态，即 0，1，2。 基于此我们可以构建一个 FSM。<br>0，1，2 之间的状态流转也不难得出。</p><p>举个例子，假设当前我们是余数为 0 的状态，这时候再来一个字符。</p><ul><li>如果这个字符是 0,3 或者 9，那么我们的余数还是 0</li><li>如果这个字符是 1,4 或者 7，那么我们的余数是 1</li><li>如果这个字符是 2,5 或者 8，那么我们的余数还是 2</li></ul><p>用图大概是这个样子：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds5204zw8j30eq0bfwfw.jpg" alt></p><p>如果用代码大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFSM</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    initial: <span class="number">0</span>,</span><br><span class="line">    states: &#123;</span><br><span class="line">      <span class="number">0</span>: &#123;</span><br><span class="line">        on: &#123;</span><br><span class="line">          read(ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              <span class="number">0</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">3</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">9</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">4</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">7</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">2</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">5</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">8</span>: <span class="number">2</span></span><br><span class="line">            &#125;[ch];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="number">1</span>: &#123;</span><br><span class="line">        on: &#123;</span><br><span class="line">          read(ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">3</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">9</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">4</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">7</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">2</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">5</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">            &#125;[ch];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="number">2</span>: &#123;</span><br><span class="line">        on: &#123;</span><br><span class="line">          read(ch) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              <span class="number">0</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">3</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">9</span>: <span class="number">2</span>,</span><br><span class="line">              <span class="number">1</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">4</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">7</span>: <span class="number">0</span>,</span><br><span class="line">              <span class="number">2</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">5</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="number">8</span>: <span class="number">1</span></span><br><span class="line">            &#125;[ch];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fsm = createFSM();</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">"281902812894839483047309573843389230298329038293829329"</span>;</span><br><span class="line"><span class="keyword">let</span> cur = fsm.initial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (![<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>].includes(str[i])) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"非法数字"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  cur = fsm.states[cur].on.read(str[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"可以被3整除"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"不可以被3整除"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实代码还可以简化，读者可以下去尝试一下。</p><p>可以看出，我们这种方式逻辑清晰，且内存占用很少，不会出现溢出的情况。</p><blockquote><p>正则是基于自动机实现的，那么使用正则匹配会是怎么样的呢？大家可以自己试一下。</p></blockquote><h5 id="答题活动"><a href="#答题活动" class="headerlink" title="答题活动"></a>答题活动</h5><p>经过上面的热身，我们来一个真实的项目来练练手。</p><p>有这样一个业务场景，我们需要设计一款答题活动，让用户过来进行答题，<br>我们预先设置 N 道题目。 规则如下：</p><ul><li>初始状态用户会进入欢迎页面</li><li>答对之后可以直接进入下一个题目</li><li>答错了可以使用复活卡重新答，也可以使用过关卡，直接进入下一题</li><li>用户可以通过其他途径获取复活卡和过关卡</li><li>答对全部 N 道题之后用户过关，否则失败</li><li>不管是过关还是失败都展示结果页面，只不过展示不同的文字和图片</li></ul><p>这其实是一个简化版本的真实项目。 如果要你设计这样的一个系统，你会如何设计？</p><p>相信你肯定能想出很多种方法来完成这样的需求，接下来我会用 FSM 来实现。</p><p>我们很容易画出整理的流程图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds520kx1pj30lr06p0tw.jpg" alt></p><p>对于答题部分则稍微有一点麻烦，但是如果你用状态机的思维去思考就很容易,<br>我们不难画出这样的图：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds52123yij30m008vdht.jpg" alt></p><p>JS 中有很多 FSM 的框架， 大家都可以直接拿过来使用。 笔者之前所在的项目<br>也用到了这样的技术，但是笔者是自己手写的简化版本 FSM，基本思想是一致的。</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>事实上，还有很多例子可以举。</p><p>假设我们后端服务器是一主一备，我们将所有的数据都同时存储在两个服务器上。<br>假如某一天，有一份数据丢失了，我们如何快速找到有问题的服务器。</p><p>这其实可以抽象成【Signle Number问题】。 因此很多时候，不是缺乏应用算法的场景，<br>而是缺乏这种将现实业务进行抽象为纯算法问题的能力。<br>我们会被各种细枝末节的问题遮蔽双眼，无法洞察隐藏在背后的深层次的规律。</p><p>编程最难是抽象能力，前几年我写了一篇文章《为什么我们的代码难以维护》，<br>其中一个非常重要的原因就是缺乏抽象。</p><p>从现在开始，让我们来锻炼抽象能力吧。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法在前端领域的应用 - 第一篇</title>
      <link href="/blog/2019/09/18/algorthimn-fe-1/"/>
      <url>/blog/2019/09/18/algorthimn-fe-1/</url>
      
        <content type="html"><![CDATA[<p>这是一个我在公司内部做的一个《数据结构与算法在前端领域的应用》主题演讲的一个前菜。<br>希望通过这个分享让大家认识到其实前端领域也有很多算法的，从而加深前端同学对算法的认识。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51jlf4ij30kv11375x.jpg" alt></p><a id="more"></a><h2 id="为什么大家觉得算法没用"><a href="#为什么大家觉得算法没用" class="headerlink" title="为什么大家觉得算法没用"></a>为什么大家觉得算法没用</h2><p>在我的职业生涯中，碰到很多非算法岗的研发同学吐槽“算法在实际业务中没什么用”，<br>甚至在面试官也问过我这个问题。我们姑且不来判断这句话正确与否，我们先来看下为什么大家会有这样的想法。</p><p>我发现很多人喜欢用冰山这个图来表示这种只看到总体的一小部分的情况。<br>我也来借用一下这个创意。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51k9cocj30lk09x75c.jpg" alt></p><p>根据我的经验，我们写的业务代码通常不到总包体的 5%， 下面是我以前做过的一个实际项目的代码分布。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ du -sh node_modules <span class="comment"># 429M</span></span><br><span class="line">$ du -sh src <span class="comment"># 7.7M</span></span><br></pre></td></tr></table></figure><p>大家可以拿自己的实际项目看一下，看是不是这样的。</p><p>其实不难看出业务代码在整个应用的比例是很小的，软件工程有一个至理名言，“软件开发的 90%的工作是由 10%的人完成的”，<br>这句话很对，那么剩下的 10 的工作却由剩下的 90%来完成。</p><p>因此我们感觉算法没用，是因为我们没用深入剩下的“90%”<br>很多场景我们接触不到，并且没有思考过，就很容易“井底之蛙”，到头来就变成“只会用别人造好的轮子组装代码”的“前端打字员”。</p><p>那剩下的 90% 究竟有哪些涉及到算法呢？是否可以举例说明呢？<br>那接下来让我们来继续看一下。</p><h2 id="前端中算法的应用场景都有哪些"><a href="#前端中算法的应用场景都有哪些" class="headerlink" title="前端中算法的应用场景都有哪些"></a>前端中算法的应用场景都有哪些</h2><p>说实话，这部分内容实在太多啦，为了让大家有一个直观的感受，我画了一个图。</p><blockquote><p>图中黄色的代表我自己实现过。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51kp9q4j30ic0cxwfd.jpg" alt></p><p>这些都是前端开发过程的一些东西， 他们多多少少涉及到了数据结构和算法的知识</p><p>下面我们来简单分析一下。</p><h3 id="VDOM"><a href="#VDOM" class="headerlink" title="VDOM"></a>VDOM</h3><p>事实上 VDOM 就是一种数据结构，但是它并不是我们在《数据结构与算法》课程中学习到的一些现成的数据结构。</p><p>逻辑上 VDOM 就是用来抽象 DOM 的，底层上 VDOM 普遍实现是基于 hash table 这种数据结构的。</p><p>一个典型的 VDOM 可以是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: <span class="string">'lucifer'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [&#123;</span><br><span class="line">    type: <span class="string">'span'</span>,</span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    children: []</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出，VDOM 是一种递归的数据结构，因此使用递归的方式来处理是非常直观和容易的。</p><p>我上面提到了 VDOM 是 DOM 的抽象（ye, a new level of abstraction）。<br>根据 VDOM 我们可以创建一个对应的真实 DOM。</p><p>如果我们只是做了这一层抽象的话，我们相当于引入了一种编程模式，即从<br>面向 DOM 编程，切换到面向 VDOM 编程，而现在 VDOM 又是由数据驱动的，因此<br>我们的编程模式切换到了“数据驱动”。</p><p>事实上，VDOM 部分还有一个 VDOM diff 算法，相信大家都听说过。关于<br>DOM diff 的算法，以及它是如何取舍和创新的，我之前在一个地方回答过，这里给一个链接地址:<br><a href="https://juejin.im/post/5d3d8cf15188256ac355a9f0" target="_blank" rel="noopener">https://juejin.im/post/5d3d8cf15188256ac355a9f0</a></p><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p>Hooks 是 React16 添加的一个新功能， 它要解决的问题是状态逻辑复用。</p><p>Hooks 逻辑上解决了纯函数无法持久化状态的“问题”，从而拓宽了纯函数组件的<br>适用范围。</p><p>底层上 Hooks 使用数据来实现状态的对应关系，关于这部分可以参考我的<br><a href="https://github.com/azl397985856/over-fancy-30s/blob/master/problems/create-useState-from-scratch.md" target="_blank" rel="noopener">[第一期]实现一个简化版的 React Hook - useState</a></p><h3 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h3><p>Fiber 也是 React16 添加的一个新功能。</p><p>事实上 Fiber 类似 VDOM，也是一个数据结构，而且同样也是一个递归的数据结构。</p><p>为了解决 React 之前一次全量更新的”问题”, React 引入了 fiber 这种数据结构，<br>并重写了整个调和算法，并且划分了多个阶段。 关于这部分内容，我只推荐一篇文章,<br><a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e" target="_blank" rel="noopener">Inside Fiber: in-depth overview of the new reconciliation algorithm in React</a></p><blockquote><p>其实之前我的<a href="https://github.com/azl397985856/mono-react" target="_blank" rel="noopener">从零开始实现 React 系列教程</a> 也欠了 fiber 😄, 等我开心的时候补充上去哈。</p></blockquote><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>我之前写过一个 Git 终端（代码被我 rm -rf 啦）。 这过程还是用到了很多数据结构和算法的，<br>我也学到了很多东西， 甚至 React16 新的调和算法也有 Git 思想。</p><p>很直观的，Git 在推送本地仓库到远程的时候会进行压缩，其实这里就用到了最小编辑距离算法。<br>Leetcode 有一个题目<a href="https://leetcode.com/problems/edit-distance/description/" target="_blank" rel="noopener">72. Edit Distance</a>,<br>官方难度<code>hard</code>, Git 的算法要是这个算法的复杂版本。</p><p>另外 Git 其实很多存储文件，数据的时候也用到了特殊的数据结构，我在<a href="https://github.com/azl397985856/git" target="_blank" rel="noopener">这里</a><br>进行了详细的描述，感兴趣的可以去看看。</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>Webpack 是众所周知的一个前端构建工具，我们可以用它做很多事情。<br>至今在前端构建领域还是龙头老大 🐲 的位置。</p><p>Webpack 中最核心的 tapable 是什么，是如何配合插件系统的？ webpack 是如何对资源进行抽象的，<br>webpack 是如何对依赖进行处理的？更复杂一点 Tree Shaking 如何做，分包怎么做，<br>加速打包怎么做。</p><p>其实 webpack 的执行过程是基于事件驱动的，tapable 提供了一系列钩子，<br>让 plugin 深入到这些过程之中去。听起来有点像事件总线，其实其中的设计思想和算法<br>细节要复杂和精妙很多。</p><p>关于这部分细节，我在我的<a href="https://github.com/azl397985856/mono-webpack" target="_blank" rel="noopener">从零实现一个 Webpack</a></p><blockquote><p>之后会加入更多特性，比如 tapable</p></blockquote><h3 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h3><p>AST（抽象语法树）是前端 编译（严格意义上是转义）的理论基础，<br>你如果想深入前端编译，就一定不能不会这个知识点。</p><blockquote><p>和 AST 相似的，其实还有 CST，prettier 等格式化工具会用到， 有兴趣可以搜一下。</p></blockquote><p><a href="https://astexplorer.net/" target="_blank" rel="noopener">这个网站</a> 可以让你对 AST 有一个直观的认识。</p><p>AST 厉害就厉害在它本身不涉及到任何语法，因此你只要编写相应的转义规则，就可以将任何语法转义到任何语法。<br>这就是<code>babel</code>， <code>PostCSS</code>, <code>prettier</code>， <code>typescript</code> 等的原理，<br>除此之外，还有很多应用场景，比如编辑器。</p><blockquote><p>之前自己写过一个小型的生成 AST 的程序，源代码忘记放哪了。😅</p></blockquote><h3 id="Browser-History"><a href="#Browser-History" class="headerlink" title="Browser History"></a>Browser History</h3><p>像浏览器中的历史页面，移动端 webview 的 <code>view stack</code>, 都用到了<code>栈</code>这种数据结构。</p><p>剩下的我就不一一说了。其实都是有很多数据结构和算法的影子的。</p><p>OK，说了那么多。 这些都是“大牛”们做的事情，好像和我日常开发没关系啊。<br>我只要用他们做好的东西，调用一下，一样可以完成我的日常工作啊。<br>让我们带着这个问题继续往下看。</p><h2 id="算法在日常开发中的应用都有哪些"><a href="#算法在日常开发中的应用都有哪些" class="headerlink" title="算法在日常开发中的应用都有哪些"></a>算法在日常开发中的应用都有哪些</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大神： “你可以先这样，再这样，然后就会抽象为纯算法问题了。”</span><br><span class="line"></span><br><span class="line">我： “哇，好厉害。”</span><br></pre></td></tr></table></figure><p>其实就是你没有掌握，或者“再思考”，以至于不能融汇贯通。</p><p>比如你可以用 vue 组件写一个递归，实现一些递归的功能，也是可以的，<br>但是大多数人都想不到。</p><p>接下来，我会举几个例子来说明“算法在日常开发中的应用”。<br>注意，以下所有的例子均来自我的实际业务需求。</p><h3 id="第一个例子-撤销与重做"><a href="#第一个例子-撤销与重做" class="headerlink" title="第一个例子 - 撤销与重做"></a>第一个例子 - 撤销与重做</h3><h4 id="业务描述"><a href="#业务描述" class="headerlink" title="业务描述"></a>业务描述</h4><p>某一天，可(gai)爱(si)的产品提了一个需求，”我们的系统需要支持用户撤销和重做最近十次的操作。“</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51lnlu0j306v06nglv.jpg" alt></p><p>让我们来回忆一下纯函数。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51mlsw9j30hn0argma.jpg" alt></p><p>纯函数有一个特性是给定输入，输出总是一样的。</p><blockquote><p>关于函数式编程可以参考我之前的<a href="https://github.com/azl397985856/functional-programming" target="_blank" rel="noopener">几篇文章</a><br>和<a href="https://slides.com/azl397985856/functional-programming-4" target="_blank" rel="noopener">一个分享</a></p></blockquote><p>我们对问题进行一些简化，假设我们的应用是纯粹的数据驱动，也就是说满足<code>纯</code>的特性。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51n37b0j30fu0903yy.jpg" alt></p><p>我们继续引入第二个知识点 - <code>reducer</code>.</p><p>reducer 是一个纯函数，函数签名为<code>(store1, action1) =&gt; store2</code>。<br>即给定 state 和 action，一定会返回确定的新的 state。</p><blockquote><p>本质上 reducer 是 reduce 的空间版本。</p></blockquote><p>假设我们的应用初始 state 为 state1， 我们按照时间先后顺序分别发送了三个 action，<br>action1, action2, action3。</p><p>我们用一个图来表示就是这样的：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51o27clj30mi06n3z4.jpg" alt></p><p>运用简单的数据知识，我们不难推导出如下关系：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51ov68aj30l806ngm6.jpg" alt></p><blockquote><p>如果对这部分知识点还比较迷茫，可以看下我之前的一篇文章，<a href="https://juejin.im/post/5a9e6a61f265da239866c7a3" target="_blank" rel="noopener">从零实现一个 Redux</a></p></blockquote><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>基础知识铺垫完了，我们来看一下怎么解决这个问题。</p><p>第一种方案，我们可以将每次的store，即store1, store2, store3都存起来。<br>比如我想回退到第二步，我们只需要将store2取出来，覆盖当前store，然后重新渲染即可。<br>这种方案很直观，可以满足我们的业务需求。<br>但是缺点也很明显，store在这里被存储了很多。 每次发送一个action都会有一个新的store被存起来。<br>当我们应用比较大的时候，或者用户触发了很多action的时候，会占据大量内存。<br>实际场景中性能上我们很难接受。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51pe9v8j30fz06hwes.jpg" alt></p><p>第二种方案，有了上面的铺垫，我们发现， 事实上我们没必要存储所有的store。<br>因为store可以被计算出来。因此我们只要存储action即可。<br>比如我们要回退到第二步，我们拿出来store1，然后和action运算一次，得到store2，<br>然后将store2覆盖到当前的store即可。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51pvzp9j30g8073jrr.jpg" alt></p><p>这种做法，只需要存储一个store1， 以及若干个action。 action相对于store来说要小很多。<br>这是这种做法相比与上一种的优势。同时由于每次都需要从头（store1）开始计算，<br>因此是一种典型的“时间换空间”的优化手段。</p><p>实际上这种做法，我们可以进行小小的优化。比如我们设置多个snapshot，<br>然后我们就不必每次从头开始计算，而是算出最近的一个snapshot，<br>然后计算即可。 无疑这种做法可以减少很多计算量，但是会增加空间占用。<br>这是典型的“空间换时间”， 如果根据实际业务进行取舍是关键。</p><p>第三种方案，我们可以用树来表示我们的store。每次修改store，我们不是将整个store<br>销毁然后创建一个新的，而是重用可以重用的部分。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51qsh7fj30kp0ajab6.jpg" alt></p><p>如图我要修改 <code>store.user.age</code>。我们只需要将root和user的引用进行修改，同时替换age节点即可。</p><p>如果大家对immutable研究比较深的话应该能发现，这其实就是immutable的原理</p><h3 id="第二个例子-巨型Mapper的优化"><a href="#第二个例子-巨型Mapper的优化" class="headerlink" title="第二个例子 - 巨型Mapper的优化"></a>第二个例子 - 巨型Mapper的优化</h3><h4 id="业务描述-1"><a href="#业务描述-1" class="headerlink" title="业务描述"></a>业务描述</h4><p>由于业务需要，我们需要在前端缓存一些HTTP请求。<br>我们设计了如下的数据结构，其中key表示资源的URL，<br>value会上次服务端的返回值。</p><p>现在我们的项目中已经有上千个接口，当接口多起来之后，缓存占用会比较大，我们如何对此进行优化？</p><p>注： 我们的key中的前缀是有规律的，即有很多重复的数据在。 返回值也有可能是有很多重复的。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51rq707j309h087js1.jpg" alt></p><p>这是一个典型的数据压缩算法。数据压缩算法有很多，我这里就不介绍了，大家可以自行了解一下。</p><p>对数据压缩算法感兴趣的，可以看下我之前写的<a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/run-length-encode-and-huffman-encode.md" target="_blank" rel="noopener">游程编码和哈夫曼编码</a></p><h3 id="第三个例子-实现自动联想功能"><a href="#第三个例子-实现自动联想功能" class="headerlink" title="第三个例子 - 实现自动联想功能"></a>第三个例子 - 实现自动联想功能</h3><h4 id="业务描述-2"><a href="#业务描述-2" class="headerlink" title="业务描述"></a>业务描述</h4><p>现在很多输入框都带了自动联想的功能， 很多组件库也实现了自动填充组件。</p><p>现在需要你完成这个功能，你会怎么做？</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51s6v4vj309w030aa3.jpg" alt></p><p>我们可以用前缀树，很高效的完成这个工作。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51sr2ivj30mz0gq406.jpg" alt="prefix-tree"></p><p>对这部分原理感兴趣的可以看下我的<a href="https://github.com/azl397985856/leetcode/blob/master/problems/208.implement-trie-prefix-tree.md" target="_blank" rel="noopener">这个题解</a></p><h3 id="第四个例子-相似度检测"><a href="#第四个例子-相似度检测" class="headerlink" title="第四个例子 - 相似度检测"></a>第四个例子 - 相似度检测</h3><h4 id="业务描述-3"><a href="#业务描述-3" class="headerlink" title="业务描述"></a>业务描述</h4><p>由于业务需要，我们需要对字符串进行相似度检测。<br>对于相似度超过一定阀值的数据，我们认为它是同一个数据。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gds51tk5bxj30it07s403.jpg" alt></p><p>关于相似度检测，我们其实可以借助“最小编辑距离”算法。<br>对于两个字符串a和b，如果a和b的编辑距离越小，我们认为越相似，<br>反之越不相似。 特殊情况，如果编辑距离为0表示是相同的字符串，<br>相似度为100%。  我们可以加入自己的计算因子，将相似度<br>离散在0 - 100%之间。</p><p>这部分的内容，我在介绍Git的时候介绍过了，这里不再重复。</p><p>其实我们可以进一步扩展一下，比如<code>对于一些无意义的词不计入统计范围</code>，我们可以怎么做？</p><h2 id="算法不好会怎么样"><a href="#算法不好会怎么样" class="headerlink" title="算法不好会怎么样"></a>算法不好会怎么样</h2><p>这恐怕是很多人最关心的问题。</p><p>我虽然知道了算法有用，但是我不会怎么办？会有什么样的影响呢？</p><p>这就回到了我们开头的问题，“为什么很多人觉得算法没用”。<br>事实上，我们日常开发中真正用到算法的场景很少，大部分都被别人封装好了。<br>即使真正需要用到一些算法，我们也可以通过一些“低劣”的手段完成，在很多对性能和质量要求<br>不高的业务场景都是没有问题的。 这就是为什么“前端同学更加觉得算法没用”的原因之一。</p><p>那既然这么说，是不是真的算法就没用呢？ 或者说算法不好也不会怎么样了么？<br>当然不是， 如果算法不好，会<code>很难创新和突破</code>。 想想如今前端框架，工具的演进，哪一个不是建立在<br>无数的算法之上。  将视角聚焦到我们当下的业务上，如果算法不好，我们也同样很难让业务不断精进，<br>不断赋能业务。</p><p>React框架就是一个非常典型的例子，它的出现改变了传统的编程模式。<br>Redux的作者，React团队现任领导者 dan 最近发表了一篇个人博客 <a href="https://overreacted.io/algebraic-effects-for-the-rest-of-us/" target="_blank" rel="noopener">Algebraic Effects for the Rest of Us</a><br>这里面也有很多算法相关的东西，大家有兴趣的可以读读看。</p><p>另外我最近在做的一个 stack-visualizer，一个用于跟踪浏览器堆栈信息，以便更好地调试地工具， 这个也是和算法有关系的。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
